( () => {
    var e, t = {
        77: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_x_positive.svg"
        }
        ,
        202: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => h
            });
            var i, r, a, s, o, l = n(1635);
            class c extends HTMLButtonElement {
                constructor(e, t, n) {
                    super(),
                    i.add(this),
                    r.set(this, void 0),
                    a.set(this, void 0),
                    s.set(this, null),
                    (0,
                    l.GG)(this, r, t, "f"),
                    this.className = "button",
                    this.innerHTML = '<img class="button-icon" src="images/copy.svg"> ',
                    (0,
                    l.GG)(this, a, document.createTextNode(t.get("Copy")), "f"),
                    this.append((0,
                    l.gn)(this, a, "f")),
                    this.addEventListener("click", ( () => {
                        e.playUIClick();
                        const t = n();
                        (async () => {
                            try {
                                await navigator.clipboard.writeText(t),
                                (0,
                                l.gn)(this, i, "m", o).call(this, (0,
                                l.gn)(this, r, "f").get("Copied!"))
                            } catch (e) {
                                console.error(e);
                                const n = document.createElement("textarea");
                                n.value = t,
                                n.style.position = "fixed",
                                document.body.appendChild(n);
                                try {
                                    n.select(),
                                    document.execCommand("copy"),
                                    (0,
                                    l.gn)(this, i, "m", o).call(this, (0,
                                    l.gn)(this, r, "f").get("Copied!"))
                                } catch (e) {
                                    console.error(e),
                                    (0,
                                    l.gn)(this, i, "m", o).call(this, (0,
                                    l.gn)(this, r, "f").get("Error!"))
                                } finally {
                                    document.body.removeChild(n)
                                }
                            }
                        }
                        )()
                    }
                    ))
                }
            }
            r = new WeakMap,
            a = new WeakMap,
            s = new WeakMap,
            i = new WeakSet,
            o = function(e) {
                (0,
                l.gn)(this, a, "f").textContent = e,
                null != (0,
                l.gn)(this, s, "f") && clearTimeout((0,
                l.gn)(this, s, "f")),
                (0,
                l.GG)(this, s, setTimeout(( () => {
                    (0,
                    l.gn)(this, a, "f").textContent = (0,
                    l.gn)(this, r, "f").get("Copy"),
                    (0,
                    l.GG)(this, s, null, "f")
                }
                ), 2e3), "f")
            }
            ,
            window.customElements.define("copy-button-ui", c, {
                extends: "button"
            });
            const h = c
        }
        ,
        228: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_diamonds.svg"
        }
        ,
        243: (e, t, n) => {
            "use strict";
            n.d(t, {
                $L: () => y,
                PM: () => g,
                RN: () => A,
                R_: () => m,
                XZ: () => v,
                Xx: () => w,
                bQ: () => p,
                g_: () => x,
                ip: () => b,
                n_: () => d,
                pS: () => f,
                tU: () => u
            });
            var i, r = n(4865);
            !function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Error = 1] = "Error",
                e[e.Ready = 2] = "Ready"
            }(i || (i = {}));
            let a = i.Loading
              , s = !1
              , o = !1
              , l = !1
              , c = !1;
            async function h(e, t=[]) {
                return new Promise(( (n, i) => {
                    const r = document.createElement("script");
                    r.addEventListener("load", ( () => {
                        n()
                    }
                    )),
                    r.addEventListener("error", (e => {
                        i(new Error(e.error))
                    }
                    ));
                    for (const [e,n] of t)
                        r.setAttribute(e, n);
                    r.src = e,
                    document.body.appendChild(r)
                }
                ))
            }
            async function d() {
                try {
                    if ("crazygames" == r.aC) {
                        if (await h("../../sdk.crazygames.com/crazygames-sdk-v3.js"),
                        !window.CrazyGames)
                            throw new Error("CrazyGames SDK not loaded");
                        await window.CrazyGames.SDK.init(),
                        a = i.Ready
                    } else if ("poki" == r.aC) {
                        if (await h("../../game-cdn.poki.com/scripts/v2/poki-sdk.js"),
                        !window.PokiSDK)
                            throw new Error("Poki SDK not loaded");
                        await window.PokiSDK.init(),
                        a = i.Ready
                    } else
                        a = i.Ready
                } catch (e) {
                    a = i.Error,
                    console.error(e)
                }
            }
            function u() {
                if (a == i.Ready && !s)
                    try {
                        window.CrazyGames ? window.CrazyGames.SDK.game.gameplayStart() : window.PokiSDK && window.PokiSDK.gameplayStart(),
                        s = !0
                    } catch (e) {
                        console.error(e)
                    }
            }
            function p() {
                if (a == i.Ready && s)
                    try {
                        window.CrazyGames ? window.CrazyGames.SDK.game.gameplayStop() : window.PokiSDK && window.PokiSDK.gameplayStop(),
                        s = !1
                    } catch (e) {
                        console.error(e)
                    }
            }
            function f() {
                if (a == i.Ready && !o)
                    try {
                        window.CrazyGames ? window.CrazyGames.SDK.game.loadingStart() : window.PokiSDK,
                        o = !0
                    } catch (e) {
                        console.error(e)
                    }
            }
            function g() {
                if (a == i.Ready && o)
                    try {
                        window.CrazyGames ? window.CrazyGames.SDK.game.loadingStop() : window.PokiSDK,
                        o = !1
                    } catch (e) {
                        console.error(e)
                    }
            }
            function m() {
                if (a == i.Ready)
                    try {
                        window.CrazyGames ? window.CrazyGames.SDK.game.loadingStop() : window.PokiSDK && window.PokiSDK.gameLoadingFinished()
                    } catch (e) {
                        console.error(e)
                    }
            }
            async function A(e) {
                if (a == i.Ready)
                    try {
                        if (window.CrazyGames) {
                            l = !0;
                            const t = window.CrazyGames;
                            await new Promise(( (n, i) => {
                                t.SDK.ad.requestAd("midgame", {
                                    adFinished: n,
                                    adError: i,
                                    adStarted: () => {
                                        l = !1,
                                        c = !0,
                                        null != e && e()
                                    }
                                })
                            }
                            )).finally(( () => {
                                l = !1,
                                c = !1
                            }
                            ))
                        } else
                            window.PokiSDK && (l = !0,
                            await window.PokiSDK.commercialBreak(( () => {
                                l = !1,
                                c = !0,
                                null != e && e()
                            }
                            )).finally(( () => {
                                l = !1,
                                c = !1
                            }
                            )))
                    } catch (e) {
                        console.error(e)
                    }
            }
            function v() {
                if (a == i.Ready) {
                    if (window.CrazyGames)
                        return !0;
                    if (window.PokiSDK)
                        return !0
                }
                return !1
            }
            async function y(e) {
                if (a != i.Ready)
                    return !1;
                try {
                    if (window.CrazyGames) {
                        l = !0;
                        const t = window.CrazyGames;
                        return await new Promise(( (n, i) => {
                            t.SDK.ad.requestAd("rewarded", {
                                adFinished: n,
                                adError: i,
                                adStarted: () => {
                                    l = !1,
                                    c = !0,
                                    null != e && e()
                                }
                            })
                        }
                        )).finally(( () => {
                            l = !1,
                            c = !1
                        }
                        )),
                        !0
                    }
                    if (window.PokiSDK) {
                        l = !0;
                        return await window.PokiSDK.rewardedBreak(( () => {
                            l = !1,
                            c = !0,
                            null != e && e()
                        }
                        )).finally(( () => {
                            l = !1,
                            c = !1
                        }
                        ))
                    }
                    throw new Error("Called requestRewardedAd on unsupported platform")
                } catch (e) {
                    return console.error(e),
                    !1
                }
            }
            function w() {
                return l || c
            }
            function b() {
                return c
            }
            function x() {
                return !(a != i.Ready || !window.CrazyGames) && window.CrazyGames.SDK.game.settings.muteAudio
            }
        }
        ,
        405: (e, t, n) => {
            "use strict";
            n.d(t, {
                Hw: () => f,
                bK: () => g,
                l1: () => m,
                yD: () => u
            });
            var i = n(4922)
              , r = n(1882)
              , a = n(4183)
              , s = n(2203)
              , o = n(2247)
              , l = n(7129);
            const c = [{
                id: a.A.Summer,
                colors: {}
            }, {
                id: a.A.Winter,
                colors: {
                    Road: "#5077b2",
                    RoadBarrier: "#898989",
                    RoadEdgeWhite: "#ffffff",
                    RoadEdgeRed: "#1f3d6b",
                    BlockSurface: "#878787",
                    Pillar: "#2b4d7f",
                    PillarEdge: "#071428",
                    WallTrack: "#5077b2",
                    WallTrackBottom: "#878787",
                    WallTrackSides: "#ffffff",
                    PlaneWall: "#1f3d6b",
                    PlaneWallDetail: "#878787",
                    SignYellow: "#1b2a89",
                    SignRed: "#841901",
                    SignBlack: "#5077b2"
                }
            }, {
                id: a.A.Desert,
                colors: {
                    Road: "#997240",
                    RoadBarrier: "#211001",
                    RoadEdgeRed: "#5b2424",
                    RoadEdgeWhite: "#510808",
                    BlockSurface: "#b78f5b",
                    Pillar: "#99713d",
                    PillarEdge: "#1c1105",
                    WallTrack: "#260b0b",
                    WallTrackBottom: "#160606",
                    WallTrackSides: "#75562e",
                    PlaneWall: "#633030",
                    PlaneWallDetail: "#aa8a53",
                    SignYellow: "#997240",
                    SignRed: "#d80202",
                    SignBlack: "#601d1d"
                }
            }]
              , h = c.concat([{
                id: a.A.Custom0,
                colors: {
                    BlockSurface: "#131313"
                }
            }, {
                id: a.A.Custom1,
                colors: {
                    BlockSurface: "#501b1b"
                }
            }, {
                id: a.A.Custom2,
                colors: {
                    BlockSurface: "#7f4d2b"
                }
            }, {
                id: a.A.Custom3,
                colors: {
                    BlockSurface: "#93862d"
                }
            }, {
                id: a.A.Custom4,
                colors: {
                    BlockSurface: "#2a5e30"
                }
            }, {
                id: a.A.Custom5,
                colors: {
                    BlockSurface: "#236363"
                }
            }, {
                id: a.A.Custom6,
                colors: {
                    BlockSurface: "#20244b"
                }
            }, {
                id: a.A.Custom7,
                colors: {
                    BlockSurface: "#592759"
                }
            }, {
                id: a.A.Custom8,
                colors: {
                    BlockSurface: "#302318"
                }
            }]);
            class d {
                constructor(e, t, n, i, r, a, s=null, o=null) {
                    const c = [];
                    for (const [e,t] of a)
                        for (let n = e[0]; n <= t[0]; n++)
                            for (let i = e[1]; i <= t[1]; i++)
                                for (let r = e[2]; r <= t[2]; r++) {
                                    if (null != c.find(( ([e,t,a]) => e == n && t == i && a == r)))
                                        throw new Error("Duplicate tile in track part");
                                    c.push([n, i, r])
                                }
                    this.checksum = e,
                    this.category = t,
                    this.id = n,
                    this.models = i,
                    this.colors = r,
                    this.tiles = new l.A(c),
                    this.detector = s,
                    this.startOffset = o,
                    Object.freeze(this)
                }
            }
            const u = [new d("6d94d798abd14dc3bce4e99c180309d993ad43adb5f2c90eef8e350eedafe7cf",r.A.Special,s.A.Start,[["Road", "Start"]],c,[[[-2, 0, -2], [1, 0, 1]]],null,new i.Pq0(0,.35,1.35)), new d("f29e34b2e05e0a4751109ae564b03fe8878a79cc6b26288f1117ed296d09c5bb",r.A.Special,s.A.StartWide,[["RoadWide", "StartWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],null,new i.Pq0(-10,.35,1.35)), new d("3c304054f415fbede4f73a43517db04302f38b16fa2cd4e587082b37b75e20e5",r.A.Special,s.A.PlaneStart,[["Planes", "PlaneStart"]],c,[[[-2, 0, -2], [1, 0, 1]]],null,new i.Pq0(0,.35,1.35)), new d("f08710416bdaa3d91d0d43f014e45d421fdb4587a334993bad0056f3dbbcb6bb",r.A.Special,s.A.PlaneStartWide,[["Planes", "PlaneStartWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],null,new i.Pq0(-10,.35,1.35)), new d("223fc87c72bb64b58677062ffa08ab7eafd78071bced7c53233606763cd5316b",r.A.Special,s.A.Checkpoint,[["Road", "Checkpoint"]],c,[[[-2, 0, -2], [1, 0, 1]]],{
                type: o.A.Checkpoint,
                center: [0, 2.2, 0],
                size: [10.5, 3.8, 1]
            }), new d("82d9a9879cee92c04c8d4ba2e16fc31bb1917a31f5802a3bb5177ca9a5cfee01",r.A.Special,s.A.CheckpointWide,[["RoadWide", "CheckpointWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],{
                type: o.A.Checkpoint,
                center: [10, 2.2, 0],
                size: [30.6, 3.8, 1]
            }), new d("fe8946d7f09724b5e11f493eb5c2a5b5e3d502b15beaad003f8134ac63558948",r.A.Special,s.A.PlaneCheckpoint,[["Planes", "PlaneCheckpoint"]],c,[[[-2, 0, -2], [1, 0, 1]]],{
                type: o.A.Checkpoint,
                center: [0, 2.2, 0],
                size: [18.25, 3.8, 1]
            }), new d("d486d9b851db35dd44c15f9e0bb3bf582118daf7be514598a19307f61cf46678",r.A.Special,s.A.PlaneCheckpointWide,[["Planes", "PlaneCheckpointWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],{
                type: o.A.Checkpoint,
                center: [10, 2.2, 0],
                size: [38.25, 3.8, 1]
            }), new d("c01200d573a3594a6a4cb73ebb600964d653e4a89267d3297f3969220742aa79",r.A.Special,s.A.Finish,[["Road", "Finish"]],c,[[[-2, 0, -2], [1, 0, 1]]],{
                type: o.A.Finish,
                center: [0, 2.2, 0],
                size: [10.5, 3.8, 2]
            }), new d("a9cefdff816e94a643210c58582c2809de0e3e0e0478b8d5baabd7fe81f13e73",r.A.Special,s.A.FinishWide,[["RoadWide", "FinishWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],{
                type: o.A.Finish,
                center: [10, 2.2, 0],
                size: [30.6, 3.8, 2]
            }), new d("75e5f09fe8a18ecafaf1fb80929173ef0a7dc0b785596bbe0ccd85a934d79578",r.A.Special,s.A.PlaneFinish,[["Planes", "PlaneFinish"]],c,[[[-2, 0, -2], [1, 0, 1]]],{
                type: o.A.Finish,
                center: [0, 2.2, 0],
                size: [18.25, 3.8, 2]
            }), new d("5801b3268c75809728c63450d06000c5f6fcfd5d72691902f99d7d19d25e1d78",r.A.Special,s.A.PlaneFinishWide,[["Planes", "PlaneFinishWide"]],c,[[[-2, 0, -2], [5, 0, 1]]],{
                type: o.A.Finish,
                center: [10, 2.2, 0],
                size: [38.25, 3.8, 2]
            }), new d("3421096c1986d008da88b5fac64cd4c475603138c9bf8a98ab6d581dda6befa7",r.A.Road,s.A.Straight,[["Road", "Straight"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("bdc3bcdafec9bc26835dc76159f7223da7da5babb3a5770129fa11046c748b69",r.A.Road,s.A.StraightPillarBottom,[["Road", "Straight"], ["Pillar", "SurfacePillarBottom"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("2758e984d87b3170f6618c9c689554ef169fd5f80ea7f0df292ffd69792d414e",r.A.Road,s.A.StraightPillarShort,[["Road", "Straight"], ["Pillar", "SurfacePillarShort"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("fb5a81784022cfc2d3d0007a032976c8dfd066e72a3bc92f671c98c5cca36aaa",r.A.Road,s.A.TurnSharp,[["Road", "TurnSharp"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("3da2e9a93da06b1376c33486f30a5f02d8c2f125f5b7d8b41166049ecd95f269",r.A.Road,s.A.TurnSharpPillarBottom,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarBottom"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("c642122276547382e37dcb857b130088f4dc0d208dc7fdb6055b2a93080a3ffe",r.A.Road,s.A.TurnSharpPillarShort,[["Road", "TurnSharp"], ["Pillar", "SurfacePillarShort"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("7d8d1eed719515ba7e48b5ef4a53b6b4bb2bef42496b6b40d2551230435ecb66",r.A.Road,s.A.SlopeUp,[["Road", "SlopeUp"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new d("d6d54dbf283f7209032541fc6b924dc879d914f253e391cf8b34dde8354661be",r.A.Road,s.A.SlopeUpLong,[["Road", "SlopeUpLong"]],c,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new d("435e8cf33d28e52f75890cba1cb6529991148afd701f9b40e9ab876c11b2c448",r.A.Road,s.A.SlopeDown,[["Road", "SlopeDown"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new d("01990158f65e5d499030d8c6d0ce80d34c136189ae1a9430d4260ea7a85e91a9",r.A.Road,s.A.SlopeDownLong,[["Road", "SlopeDownLong"]],c,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new d("f4fe25138e88fc36b796c9251c696f1e44bf77502ee8e4e7d9ed2d8c8be2fd98",r.A.Road,s.A.Slope,[["Road", "Slope"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new d("2cfd3548dbd3dcf793f1597a1350864b5f14ed46e907d163977b73363896c3d4",r.A.Road,s.A.SlopeUpVertical,[["Road", "SlopeUpVertical"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new d("3de87fd1ea3a4ffbf353a03e3c90da97e62b03f85d07ad4bc947e9ceed20b7d8",r.A.Road,s.A.SlopeToVertical,[["Road", "SlopeToVertical"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]], [[-2, 2, -1], [-2, 2, -1]], [[1, 2, -1], [1, 2, -1]]]), new d("63628b23e104a3eb3c2ba8189cd408a10fbb6ebcd6fa4359d981e3c3804c13d8",r.A.Road,s.A.IntersectionT,[["Road", "IntersectionT"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("400dc4643653001d283bb13f740593fc2300c547bb4d2a962054ba6aabf3721c",r.A.Road,s.A.IntersectionTPillarBottom,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarBottom"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("60355388650d35fcbddaaac29e0d03bc2ae46db1a05cd23ddd3f2722ec2d409e",r.A.Road,s.A.IntersectionTPillarShort,[["Road", "IntersectionT"], ["Pillar", "SurfacePillarShort"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("74197b3731c2befd03498bf5172859f0b3652f1972c19e43a99bb938769573df",r.A.Road,s.A.IntersectionCross,[["Road", "IntersectionCross"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("464e69b5c4f2667c246ade9ed33fd3e50b49438ed0ab787a086dfe74c217ff6c",r.A.Road,s.A.IntersectionCrossPillarBottom,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarBottom"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("90004caf354627289265314966f11b5656e6879ca7de10507e6c50cd95254b75",r.A.Road,s.A.IntersectionCrossPillarShort,[["Road", "IntersectionCross"], ["Pillar", "SurfacePillarShort"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("6259b51229152128dc859e1bffc614b60464799c401182dccae58131ee155b1c",r.A.Road,s.A.IntersectionY,[["Road", "IntersectionY"]],c,[[[-6, 0, -10], [-3, 0, -8]], [[-5, 0, -7], [-2, 0, -5]], [[-4, 0, -4], [3, 0, -4]], [[-3, 0, -3], [2, 0, -2]], [[-2, 0, -1], [1, 0, 1]], [[-1, 0, -5], [4, 0, -5]], [[1, 0, -7], [4, 0, -6]], [[2, 0, -10], [5, 0, -8]]]), new d("846db907fcc382dd462283874fcbceab9c8c06fab6e7654a5cf6811dffcf086e",r.A.Road,s.A.IntersectionYLong,[["Road", "IntersectionYLong"]],c,[[[-6, 0, -14], [-3, 0, -11]], [[-5, 0, -10], [-2, 0, -8]], [[-4, 0, -7], [3, 0, -5]], [[-3, 0, -4], [2, 0, -3]], [[-2, 0, -2], [1, 0, 1]], [[-1, 0, -8], [4, 0, -8]], [[1, 0, -10], [4, 0, -9]], [[2, 0, -14], [5, 0, -11]]]), new d("48992a178b504f5205eb7613e273f61a2916b16b9b3d402208dcf711b29d20d3",r.A.Road,s.A.StraightTilted,[["Road", "Straight", {
                offset: new i.Pq0(0,5,0),
                scale: new i.Pq0(1,.894425810573391,1),
                quaternion: (new i.PTz).setFromEuler(new i.O9p(0,0,-.46364760900081))
            }]],c,[[[-2, 1, -2], [0, 1, 1]], [[0, 0, -2], [1, 0, 1]]]), new d("d06cc41bda0172e626ad85fca987f426c60b86c3fabd3635d8ddc17f0b38afcd",r.A.Road,s.A.ToTiltedLeft,[["Road", "ToTilted", {
                flipX: !0,
                offset: new i.Pq0(0,5,0)
            }]],c,[[[-2, 0, -10], [-1, 0, 1]], [[-2, 1, -3], [1, 1, 1]], [[-1, 1, -10], [1, 1, -4]]]), new d("36bbe97fc3c199f694f3aefc0ba5ee6e6b3859cf8adeaabab77d53eb921d8979",r.A.Road,s.A.ToTiltedRight,[["Road", "ToTilted", {
                offset: new i.Pq0(0,5,0)
            }]],c,[[[-2, 1, -10], [0, 1, 1]], [[0, 0, -10], [1, 0, 1]], [[1, 1, -3], [1, 1, 1]]]), new d("fd261825d8261ce05c214e0f12e3640a38f448866ee662136fbdee4f2e0bae22",r.A.RoadTurns,s.A.TurnShort,[["Road", "TurnShort"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-1, 0, -2], [3, 0, -2]], [[-1, 0, -3], [5, 0, -3]], [[0, 0, -4], [5, 0, -4]], [[1, 0, -5], [5, 0, -5]], [[3, 0, -6], [5, 0, -6]]]), new d("830000386e11f915cc7be618600256c438ace73ed2b6f0f3ec2990d8c25760fd",r.A.RoadTurns,s.A.TurnLong,[["Road", "TurnLong"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [2, 0, -2]], [[-1, 0, -3], [2, 0, -3]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -6], [6, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new d("a02b464ce6f6348e13dc90199882e91be6f2220e7e13c79ad46ca9b2032adb01",r.A.RoadTurns,s.A.TurnLong2,[["Road", "TurnLong2"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [3, 0, -5]], [[0, 0, -6], [4, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [6, 0, -8]], [[2, 0, -9], [7, 0, -9]], [[3, 0, -10], [9, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new d("a9e794783cdb96e81c95a476f9cbe9e43a5f0357e34d7d278e449a701e44afc3",r.A.RoadTurns,s.A.TurnLong3,[["Road", "TurnLong3"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -4], [2, 0, -3]], [[-1, 0, -5], [2, 0, -5]], [[0, 0, -6], [3, 0, -6]], [[0, 0, -7], [3, 0, -7]], [[0, 0, -8], [4, 0, -8]], [[1, 0, -9], [5, 0, -9]], [[2, 0, -10], [6, 0, -10]], [[2, 0, -11], [7, 0, -11]], [[3, 0, -12], [8, 0, -12]], [[4, 0, -13], [10, 0, -13]], [[5, 0, -14], [13, 0, -14]], [[7, 0, -15], [17, 0, -15]], [[8, 0, -16], [17, 0, -16]], [[11, 0, -17], [17, 0, -17]], [[14, 0, -18], [17, 0, -18]]]), new d("285f8b84f4dcbb2cbf59be0a54038a01d7cd672cbce96fa0427b589562ebf45e",r.A.RoadTurns,s.A.TurnSLeft,[["Road", "TurnS", {
                flipX: !0
            }]],c,[[[-2, 0, -1], [1, 0, 1]], [[-3, 0, -3], [0, 0, -2]], [[-4, 0, -4], [0, 0, -4]], [[-5, 0, -5], [-1, 0, -5]], [[-5, 0, -7], [-2, 0, -6]], [[-6, 0, -10], [-3, 0, -8]]]), new d("fd7fea58c90ec42781be6192ac4f1086945d48986bc2f0f0702c1ede2c7bd6be",r.A.RoadTurns,s.A.TurnSRight,[["Road", "TurnS"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -3], [2, 0, -2]], [[-1, 0, -4], [3, 0, -4]], [[0, 0, -5], [4, 0, -5]], [[1, 0, -7], [4, 0, -6]], [[2, 0, -10], [5, 0, -8]]]), new d("190ba45df20d893be69c2f9e92d420e3aca4070340a836bb2062ea3ffdeb83e8",r.A.RoadTurns,s.A.TurnSLongLeft,[["Road", "TurnSLong", {
                flipX: !0
            }]],c,[[[-6, 0, -14], [-3, 0, -11]], [[-5, 0, -10], [-2, 0, -8]], [[-4, 0, -7], [-1, 0, -5]], [[-3, 0, -4], [0, 0, -3]], [[-2, 0, -2], [1, 0, 1]], [[-1, 0, -8], [-1, 0, -8]], [[0, 0, -5], [0, 0, -5]]]), new d("372b17815889b51da18fbcb77434f1a7ea0b93d2d62cd7c1ca9ec2a1854effe5",r.A.RoadTurns,s.A.TurnSLongRight,[["Road", "TurnSLong"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -5], [2, 0, -3]], [[0, 0, -8], [3, 0, -6]], [[1, 0, -10], [4, 0, -9]], [[2, 0, -14], [5, 0, -11]], [[3, 0, -5], [3, 0, -5]], [[4, 0, -8], [4, 0, -8]]]), new d("26bca19e63867bc0b755ff6fcca65de296c9d1f109f87540103565eb88a0e03d",r.A.RoadTurns,s.A.TurnShortLeftWide,[["RoadWide", "TurnShortLeftWide"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-1, 0, -4], [5, 0, -3]], [[0, 0, -5], [5, 0, -5]], [[1, 0, -6], [5, 0, -6]], [[2, 0, -7], [9, 0, -7]], [[3, 0, -8], [9, 0, -8]], [[4, 0, -9], [9, 0, -9]], [[7, 0, -10], [9, 0, -10]]]), new d("e3845854f85dafd8cec193bcbecdac6cb79f625066de29524d5c10c5580611c5",r.A.RoadTurns,s.A.TurnShortRightWide,[["RoadWide", "TurnShortRightWide"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 0, -1], [2, 0, -1]], [[-2, 0, -2], [3, 0, -2]], [[2, 0, -6], [5, 0, -3]]]), new d("dc6088960a65a55c74353a1e7c8a1ca8ec99e683f6273bf666d6909b288bb84b",r.A.RoadTurns,s.A.TurnLongLeftWide,[["RoadWide", "TurnLongLeftWide"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-1, 0, -5], [1, 0, -3]], [[0, 0, -6], [1, 0, -6]], [[0, 0, -7], [5, 0, -7]], [[1, 0, -8], [5, 0, -8]], [[2, 0, -9], [5, 0, -9]], [[3, 0, -10], [5, 0, -10]], [[4, 0, -11], [13, 0, -11]], [[5, 0, -12], [13, 0, -12]], [[7, 0, -13], [13, 0, -13]], [[10, 0, -14], [13, 0, -14]]]), new d("0bbb8d6c1e4a325e10643cf45546da725c1ea18e92a3a95f753339629a06ef6c",r.A.RoadTurns,s.A.TurnLongRightWide,[["RoadWide", "TurnLongRightWide"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 0, -3], [2, 0, -2]], [[-2, 0, -4], [3, 0, -4]], [[-2, 0, -5], [4, 0, -5]], [[-2, 0, -6], [6, 0, -6]], [[2, 0, -10], [9, 0, -7]]]), new d("3d4972c41e0e1c39b31b98c8b4ba3377477c4370fbd32cbf5a92c88b46fb7614",r.A.RoadTurns,s.A.TurnShortTilted,[["Road", "TurnShortTilted"]],c,[[[-2, 1, 0], [0, 1, 1]], [[-1, 1, -2], [0, 1, -1]], [[0, 0, -2], [2, 0, -1]], [[0, 0, 0], [1, 0, 1]], [[0, 1, -4], [2, 1, -3]], [[1, 0, -3], [5, 0, -3]], [[1, 1, -2], [1, 1, -2]], [[2, 0, -4], [5, 0, -4]], [[2, 1, -5], [5, 1, -5]], [[3, 0, -2], [3, 0, -2]], [[3, 1, -4], [5, 1, -4]], [[4, 1, -6], [5, 1, -6]]]), new d("5d48577ff2562e2abfe287bc0519dd0de692f3665e5596b3ef629069a59a21ab",r.A.RoadTurns,s.A.TurnLongTilted,[["Road", "TurnLongTilted"]],c,[[[-2, 1, 0], [0, 1, 1]], [[-1, 1, -3], [0, 1, -1]], [[0, 0, -3], [2, 0, -2]], [[0, 0, -1], [1, 0, 1]], [[0, 1, -5], [2, 1, -4]], [[1, 0, -4], [3, 0, -4]], [[1, 1, -6], [4, 1, -6]], [[1, 1, -3], [1, 1, -3]], [[2, 0, -5], [4, 0, -5]], [[2, 1, -7], [5, 1, -7]], [[3, 0, -6], [6, 0, -6]], [[3, 1, -8], [9, 1, -8]], [[4, 0, -7], [9, 0, -7]], [[5, 0, -8], [9, 0, -8]], [[5, 1, -9], [9, 1, -9]], [[8, 1, -10], [9, 1, -10]]]), new d("abf9d95b8b0bf58bf4fe8df599e4ccee1b527c7c63f15636374742c1ebc2b93a",r.A.RoadTurns,s.A.TurnLong2Tilted,[["Road", "TurnLong2Tilted"]],c,[[[-2, 1, -1], [0, 1, 1]], [[-1, 1, -4], [0, 1, -2]], [[0, 0, -3], [1, 0, 1]], [[0, 1, -6], [1, 1, -5]], [[1, 0, -5], [2, 0, -4]], [[1, 1, -8], [3, 1, -7]], [[1, 1, -4], [1, 1, -4]], [[2, 0, -7], [4, 0, -6]], [[2, 0, -3], [2, 0, -3]], [[2, 1, -9], [5, 1, -9]], [[2, 1, -6], [2, 1, -6]], [[3, 0, -8], [6, 0, -8]], [[3, 0, -5], [3, 0, -5]], [[3, 1, -10], [6, 1, -10]], [[4, 0, -9], [7, 0, -9]], [[4, 1, -11], [8, 1, -11]], [[4, 1, -8], [4, 1, -8]], [[5, 0, -10], [9, 0, -10]], [[6, 1, -12], [13, 1, -12]], [[7, 0, -11], [13, 0, -11]], [[8, 1, -13], [13, 1, -13]], [[9, 0, -12], [13, 0, -12]], [[11, 1, -14], [13, 1, -14]]]), new d("f64a25f9f9306a760e247f68ce37404d175462993e146853ce1f1b7ac7353bef",r.A.RoadTurns,s.A.TurnLong3Tilted,[["Road", "TurnLong3Tilted"]],c,[[[-2, 1, -1], [0, 1, 1]], [[-1, 1, -5], [1, 1, -4]], [[-1, 1, -3], [0, 1, -2]], [[0, 0, -4], [1, 0, 1]], [[0, 1, -7], [1, 1, -6]], [[1, 0, -7], [3, 0, -6]], [[1, 0, -5], [2, 0, -5]], [[1, 1, -9], [3, 1, -8]], [[2, 0, -8], [4, 0, -8]], [[2, 0, -4], [2, 0, -4]], [[2, 1, -10], [4, 1, -10]], [[2, 1, -7], [2, 1, -7]], [[3, 0, -10], [5, 0, -9]], [[3, 1, -12], [5, 1, -11]], [[4, 0, -11], [7, 0, -11]], [[4, 1, -13], [8, 1, -13]], [[5, 0, -12], [8, 0, -12]], [[6, 0, -13], [10, 0, -13]], [[6, 0, -10], [6, 0, -10]], [[6, 1, -14], [9, 1, -14]], [[6, 1, -12], [6, 1, -12]], [[7, 1, -15], [11, 1, -15]], [[8, 0, -14], [12, 0, -14]], [[9, 0, -15], [17, 0, -15]], [[9, 1, -16], [17, 1, -16]], [[11, 1, -17], [17, 1, -17]], [[12, 0, -16], [17, 0, -16]], [[15, 1, -18], [17, 1, -18]]]), new d("2af8aa6050028dd6ee69b7150e83a6d8819e1848a7b1c782848d3f6448c5091a",r.A.RoadWide,s.A.ToWideMiddle,[["RoadWide", "ToWideMiddle"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("26341cfe6bec34f46b10ffcd9a7706a8156b9ac41ed2cdfd166f9f8d3e9bc8f3",r.A.RoadWide,s.A.ToWideLeft,[["RoadWide", "ToWideSide", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("3f82ebd6c72110b532a20673f8b54c7b25ae5988a51d3793bf383fea8ffcffc3",r.A.RoadWide,s.A.ToWideRight,[["RoadWide", "ToWideSide"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("f5cecce9870f41f8cba7a9fbe631c315370a7a82824d04977ec857dbb1dfed29",r.A.RoadWide,s.A.ToWideDouble,[["RoadWide", "ToWideDouble"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("99dc726611397f81b47459d32c7bfb8232322d1ca976ba9a3e71cc15451d8cfb",r.A.RoadWide,s.A.ToWideDiagonal,[["RoadWide", "ToWideDiagonal"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("47d7e3fb334681911e122babef127881a36a763fb22176854114495802d5ce84",r.A.RoadWide,s.A.StraightWide,[["RoadWide", "StraightWide"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("521adc95ed5a4809eeff7eec872c3d6449e4d6a7e4941d672f1e06a50a6615de",r.A.RoadWide,s.A.InnerCornerWide,[["RoadWide", "InnerCornerWide"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("d82274b362794e3c1772510002d5015dde345f1e72dd675c8bac41cf2331398b",r.A.RoadWide,s.A.OuterCornerWide,[["RoadWide", "OuterCornerWide"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("8c2541fab7e5e930b9280b3ef1e5bfc3092c17901c87457515df577f625c4303",r.A.RoadWide,s.A.SlopeUpLeftWide,[["RoadWide", "SlopeUpWide", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new d("6c908d749b8150b47d96c2d0c493ed8bf125035a250025fbe94b6078503bcfce",r.A.RoadWide,s.A.SlopeUpRightWide,[["RoadWide", "SlopeUpWide"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new d("676c22b45763bd86c8bb8d34a2fa7a38abde40618892742de598d866b4925b42",r.A.RoadWide,s.A.SlopeUpLongLeftWide,[["RoadWide", "SlopeUpLongWide", {
                flipX: !0
            }]],c,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new d("e783f085e8ec313dcd1bbb0849fe5e669ccbb075baac4d289fd442a9cd4ba562",r.A.RoadWide,s.A.SlopeUpLongRightWide,[["RoadWide", "SlopeUpLongWide"]],c,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new d("4229bf84ab08f86a24d24b610a8225885f3cb68726ef74f4b314d7705c9eb2da",r.A.RoadWide,s.A.SlopeDownLeftWide,[["RoadWide", "SlopeDownWide", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new d("a141744b0ffb4df202f230f1f97443f4198032aacf94e7259b7b0127df6bd838",r.A.RoadWide,s.A.SlopeDownRightWide,[["RoadWide", "SlopeDownWide"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new d("0fd78ec94545d4f7c41515ab7dafafb331b146118e3a14835fb6e6c9cb12e4af",r.A.RoadWide,s.A.SlopeDownLongLeftWide,[["RoadWide", "SlopeDownLongWide", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new d("997f1fd3e53bc438066f32e6ea33300a8371b297c7d74f4c25f48f3370fd5752",r.A.RoadWide,s.A.SlopeDownLongRightWide,[["RoadWide", "SlopeDownLongWide"]],c,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new d("bde16df3b12aab766167803dc302428bc8d3a4f95efcdeb8660b773e00e6ecb0",r.A.RoadWide,s.A.SlopeLeftWide,[["RoadWide", "SlopeWide", {
                flipX: !0
            }]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new d("1524c4b16a08292aa84fbe0f0369d09453e75061fc39a9a0503e6caf4843a301",r.A.RoadWide,s.A.SlopeRightWide,[["RoadWide", "SlopeWide"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new d("b598ff14bda99600434b24a619132fec4bffcc535483b9b57b0c8c09c1be1f1b",r.A.RoadWide,s.A.SlopeUpVerticalLeftWide,[["RoadWide", "SlopeUpVerticalWide"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new d("4e0275d3a01eaca6ec5118b8b816ed292cb7172710cf9b7801068424ab684b22",r.A.RoadWide,s.A.SlopeUpVerticalRightWide,[["RoadWide", "SlopeUpVerticalWide", {
                flipX: !0
            }]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new d("feff879bfa80db0dc58d93fe8e34ca793aa508002df55a27cba2d99cfefa4691",r.A.RoadWide,s.A.SlopeToVerticalLeftWide,[["RoadWide", "SlopeToVerticalWide", {
                flipX: !0
            }]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]], [[-2, 2, -1], [-2, 2, -1]]]), new d("88a9c7425f1e5b287ce571f744348a4a330409fced83f13b5a1c7e8e51e9ead4",r.A.RoadWide,s.A.SlopeToVerticalRightWide,[["RoadWide", "SlopeToVerticalWide"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]], [[1, 2, -1], [1, 2, -1]]]), new d("896b47675cc2ff58494979168f6fd36c27c43da29aed6a52fdf80f054630166a",r.A.Plane,s.A.Plane,[["Planes", "Plane"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("dc9afb98a8bb998d3b76c3563385e58c1749e56ff43fbc7577b1f57ba8360702",r.A.Plane,s.A.PlanePillarBottom,[["Planes", "Plane"], ["Pillar", "SurfacePillarBottom"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("f59ad95edd26814236ab30b73f6f4f68003885ef150201a4ace14b832abcf438",r.A.Plane,s.A.PlanePillarShort,[["Planes", "Plane"], ["Pillar", "SurfacePillarShort"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("48247a66b232461083fa2aa36644e7e8779f5b426d474efd375ee7d21d009c9a",r.A.Plane,s.A.HalfPlane,[["Planes", "HalfPlane"]],c,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new d("eac8530d1a025291674bf34b206f75700dc8626012d8d33ed398f7aed746dac8",r.A.Plane,s.A.QuarterPlane,[["Planes", "QuarterPlane"]],c,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new d("2dda4d3801c9cd4c117dc3c8239bea28cafe70ef2127986c2d6b455744fc8019",r.A.Plane,s.A.PlaneSlopeUp,[["Planes", "PlaneSlopeUp"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -2]]]), new d("ff295081bdf76f76ad286007c813d37b5af22b06f337ad8fe43cddbd221255b4",r.A.Plane,s.A.PlaneSlopeUpLong,[["Planes", "PlaneSlopeUpLong"]],c,[[[-2, 0, -4], [1, 0, 1]], [[-2, 1, -5], [1, 1, -4]], [[-2, 1, -6], [1, 2, -6]]]), new d("f1ac897525aa3fcae4fb678ca681bf559d993517b5f4f323b25789b64fe3f477",r.A.Plane,s.A.PlaneSlopeDown,[["Planes", "PlaneSlopeDown"]],c,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, 0], [1, 1, 1]]]), new d("549dbef42b80ca6cfa7eecb1397918b2fc9ccd15ceb1c494c41944b8a0d50d7b",r.A.Plane,s.A.PlaneSlopeDownLong,[["Planes", "PlaneSlopeDownLong"]],c,[[[-2, 0, -2], [1, 0, 0]], [[-2, 1, -1], [1, 1, 5]], [[-2, 2, 3], [1, 2, 5]]]), new d("2e9a2af92aea4a70361adba95230f3126911aa357299c0fe6c1e0611945961c0",r.A.Plane,s.A.PlaneSlope,[["Planes", "PlaneSlope"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 2, -2]]]), new d("76408f7250687477995d65c39e60554466c6b96376d2ff0c9c9c497e1ee823bf",r.A.Plane,s.A.HalfPlaneSlopeBottomLeft,[["Planes", "HalfPlaneSlopeBottom"]],c,[[[-2, 0, 0], [0, 0, 1]], [[-2, 1, -2], [-2, 1, 0]], [[-2, 2, -2], [-2, 2, -2]], [[-1, 1, -1], [-1, 1, 0]], [[0, 1, 0], [0, 1, 0]], [[1, 0, 1], [1, 0, 1]]]), new d("bb77b8de31e4d193112947bb0c3d9d62985b10d8982acaaf58df54d483863873",r.A.Plane,s.A.HalfPlaneSlopeBottomRight,[["Planes", "HalfPlaneSlopeBottom", {
                flipX: !0
            }]],c,[[[-2, 0, 1], [1, 0, 1]], [[-1, 0, 0], [1, 1, 0]], [[0, 1, -1], [1, 1, -1]], [[1, 1, -2], [1, 2, -2]]]), new d("6984589cd1276691a8c2161fec8205194ea7545c8962b3f61f672ec02cf534f9",r.A.Plane,s.A.HalfPlaneSlopeTopLeft,[["Planes", "HalfPlaneSlopeTop", {
                flipX: !0
            }]],c,[[[-2, 0, 0], [-1, 1, 0]], [[-2, 0, 1], [-2, 0, 1]], [[-2, 1, -2], [0, 1, -1]], [[-2, 2, -2], [1, 2, -2]], [[1, 1, -2], [1, 1, -2]]]), new d("992d36738e4882dd1da1ca3c2a396c79ae7fcb2ba47649de7cb0f888f18e04b3",r.A.Plane,s.A.HalfPlaneSlopeTopRight,[["Planes", "HalfPlaneSlopeTop"]],c,[[[-2, 1, -2], [1, 2, -2]], [[-1, 1, -1], [1, 1, -1]], [[0, 0, 0], [1, 1, 0]], [[1, 0, 1], [1, 0, 1]]]), new d("ba0d6ec33647740bf4c60e542d1758095afa3ef451bdaec76c783dd32116e4cb",r.A.Plane,s.A.PlaneSlopeVerticalBottom,[["Planes", "PlaneSlopeVertical"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new d("6f750b74664474a57a22f22b4f8b7f2fef330eb00f9041385ec0acfbc2b09302",r.A.Plane,s.A.PlaneSlopeToVertical,[["Planes", "PlaneSlopeToVertical"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new d("5f6d1ece085d450643f1399af53673dcc6bbbf413094d8dd5ee6816d80e1c8ae",r.A.Plane,s.A.PlaneBridge,[["Planes", "PlaneBridge"]],c,[[[-1, 0, -2], [0, 0, 1]]]), new d("32b91fc4cdf95f5b7a490d81058522bae14741601dd44c73cc110121aa1dd6e6",r.A.Plane,s.A.PlaneBridgeCorner,[["Planes", "PlaneBridgeCorner"]],c,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new d("2db870b1821fb655437bd0527569d5a6843718fa0775682701437432265a1a88",r.A.Plane,s.A.PlaneBridgeIntersectionT,[["Planes", "PlaneBridgeIntersectionT"]],c,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("33aa0e7524b74dcdae4aed89856c09d25248c4cab8f70dcc31b347f0a00fcb52",r.A.Plane,s.A.PlaneBridgeIntersectionCross,[["Planes", "PlaneBridgeIntersectionCross"]],c,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new d("bd7cc4ab180fc0a6936fef828ae3a91566b3dd621b888fbcc57c9ac11dcb713b",r.A.Plane,s.A.PlaneWall,[["Planes", "PlaneWall"]],c,[[[-2, 0, 1], [1, 0, 1]]]), new d("d92568164028bb2e65799abd9dc6ba66cfe8a28515c09fbe5ac175f5966af66a",r.A.Plane,s.A.PlaneWallCorner,[["Planes", "PlaneWallCorner"]],c,[[[-2, 0, 1], [1, 0, 1]], [[1, 0, -2], [1, 0, 0]]]), new d("792ab5a6f0e2bf8e556575ef12731ec30755855d4394f98eb4ca7ec8b713933c",r.A.Plane,s.A.PlaneWallInnerCorner,[["Planes", "PlaneWallInnerCorner"]],c,[[[1, 0, 1], [1, 0, 1]]]), new d("9f1a6ce37a3b0601346f4d30d8a81075c8eefd3d873cbb24fbe5cf6d5da3093f",r.A.Plane,s.A.PlaneWallSlopeLeft,[["Planes", "PlaneWallSlope"]],c,[[[1, 0, 0], [1, 1, 1]], [[1, 1, -2], [1, 2, -1]]]), new d("0a28443c2fc0e51527b4d3a5a0d98302fc368839b614db5c7d90f151a97c7542",r.A.Plane,s.A.PlaneWallSlopeRight,[["Planes", "PlaneWallSlope", {
                flipX: !0
            }]],c,[[[-2, 0, 0], [-2, 1, 1]], [[-2, 1, -2], [-2, 2, -1]]]), new d("b55dca4b19a0f61db43849e444eaa1d9289519ef7e5a4b6e02c7c02ba80f84f4",r.A.Plane,s.A.PlaneWallSlopeUpLeft,[["Planes", "PlaneWallSlopeUp"]],c,[[[1, 0, -2], [1, 1, 1]]]), new d("70c5288fe8e74957d820cc34995566ad26478e00e5314e36e836e0f803b38061",r.A.Plane,s.A.PlaneWallSlopeUpRight,[["Planes", "PlaneWallSlopeUp", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [-2, 1, 1]]]), new d("9b16670e084f2e054c61f253abb7b24e29e0b11800de23b9a2877f17c33dd4a9",r.A.Plane,s.A.PlaneWallSlopeDownLeft,[["Planes", "PlaneWallSlopeDown"]],c,[[[1, 0, -2], [1, 1, 1]]]), new d("bf441ad2d47b48000b7535e2dd39c209257f2614363494827200330dfea97e11",r.A.Plane,s.A.PlaneWallSlopeDownRight,[["Planes", "PlaneWallSlopeDown", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [-2, 1, 1]]]), new d("8d561c6d1e116c92c5f9ecb9715e57b510dfd38d8e4ba2183429d28238c6ac83",r.A.Plane,s.A.PlaneWallSlopeUpLongLeft,[["Planes", "PlaneWallSlopeUpLong"]],c,[[[1, 0, -4], [1, 1, 1]], [[1, 1, -6], [1, 2, -5]], [[1, 2, -4], [1, 2, -4]]]), new d("ab013301c7b3b91cf48ae1a8d47842f85ac688677cc14e0baa3b3a5a3ce0bb3b",r.A.Plane,s.A.PlaneWallSlopeUpLongRight,[["Planes", "PlaneWallSlopeUpLong", {
                flipX: !0
            }]],c,[[[-2, 0, -4], [-2, 1, 1]], [[-2, 1, -6], [-2, 2, -5]], [[-2, 2, -4], [-2, 2, -4]]]), new d("79fc30fd9032052b23a30f03fde4e4932b4a3a6a57c1e2b64631fb5d6c5f1052",r.A.Plane,s.A.PlaneWallSlopeDownLongLeft,[["Planes", "PlaneWallSlopeDownLong"]],c,[[[1, 0, -2], [1, 1, 0]], [[1, 1, 1], [1, 2, 5]], [[1, 2, 0], [1, 2, 0]]]), new d("5aeda192c725700634faf36a401b9bf0b4df869b311da546080569f66c741a66",r.A.Plane,s.A.PlaneWallSlopeDownLongRight,[["Planes", "PlaneWallSlopeDownLong", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [-2, 1, 0]], [[-2, 1, 1], [-2, 2, 5]], [[-2, 2, 0], [-2, 2, 0]]]), new d("de0d588c4b2fe6b32d72a7e0e2984285955f805ccb86d3c269f7155401cd6b20",r.A.Block,s.A.Block,[["Blocks", "Block"]],h,[[[-2, 0, -2], [1, 0, 1]]]), new d("1ce6b585c0e99d71877fefe015ff16336ae62eb0caebeca62dd09d836092d7b6",r.A.Block,s.A.HalfBlock,[["Blocks", "HalfBlock"]],h,[[[-2, 0, 1], [1, 0, 1]], [[-2, 0, 0], [0, 0, 0]], [[-2, 0, -1], [-1, 0, -1]], [[-2, 0, -2], [-2, 0, -2]]]), new d("0d5f0609c3c98f687d55d3a73313225c1642f6285ddaca3ed536db742c85958d",r.A.Block,s.A.QuarterBlock,[["Blocks", "QuarterBlock"]],h,[[[-2, 0, 1], [-2, 0, 1]], [[-2, 0, -1], [-1, 0, 0]], [[-2, 0, -2], [-2, 0, -2]]]), new d("18fc1c569c6fc04f95f10174143d19e7a9ea4e387302363f4ae60883c1acd3f0",r.A.Block,s.A.BlockSlopedDown,[["Blocks", "BlockSlopedDown"]],h,[[[-2, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new d("22dd5b2804c88994a4d283cb822f47de3c72f82376e4c9332d39feae85206c0f",r.A.Block,s.A.BlockSlopedDownInnerCorner,[["Blocks", "BlockSlopedDownInnerCorner"]],h,[[[-2, 0, -2], [-1, 0, 1]], [[0, 0, -2], [1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new d("81a71b4cc6ef8520f20fd738457abc31b04258c97f9862f70190fd2a0ba91382",r.A.Block,s.A.BlockSlopedDownOuterCorner,[["Blocks", "BlockSlopedDownOuterCorner"]],h,[[[-2, 0, -2], [-1, 0, -1]], [[-2, 1, -2], [1, 1, 1]]]), new d("f4e19d3bc49994a85fecd187b76c21d258e7f30f0506d90bc6f173336e11627d",r.A.Block,s.A.BlockSlopedUp,[["Blocks", "BlockSlopedUp"]],h,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]]]), new d("fd9309468e97131bbbd1404fac34a7137cb176327789b955c1aea30267e1cded",r.A.Block,s.A.BlockSlopedUpInnerCorner,[["Blocks", "BlockSlopedUpInnerCorner"]],h,[[[-2, 1, -2], [-1, 1, 1]], [[0, 1, -2], [1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new d("1321fb07ece1b80b99dc4671b52673ac028fbf43322e9e652ad633ff6afac21b",r.A.Block,s.A.BlockSlopedUpOuterCorner,[["Blocks", "BlockSlopedUpOuterCorner"]],h,[[[-2, 1, -2], [-1, 1, -1]], [[-2, 0, -2], [1, 0, 1]]]), new d("84d11f91b9410afafd2801d85bcfd87f9390272180e3f49ab77d108e328dbd1d",r.A.Block,s.A.HalfBlockSlopeBottomLeft,[["Blocks", "HalfBlockSlopeBottom"]],c,[[[-2, 0, -2], [-2, 0, 1]], [[-2, 1, -2], [-2, 1, -1]], [[-1, 0, -1], [-1, 0, 1]], [[-1, 1, -1], [-1, 1, -1]], [[0, 0, 0], [0, 0, 1]], [[1, 0, 1], [1, 0, 1]]]), new d("84d77134750b28ec4d4e66d37052a5d83cd97e18144e1b849155976d35418d3b",r.A.Block,s.A.HalfBlockSlopeBottomRight,[["Blocks", "HalfBlockSlopeBottom", {
                flipX: !0
            }]],c,[[[-2, 0, 1], [1, 0, 1]], [[-1, 0, 0], [1, 0, 0]], [[0, 0, -1], [1, 1, -1]], [[1, 0, -2], [1, 1, -2]]]), new d("185b3f1a8ed7f7b1eb8da5e6911a181560a3dab738e59f01cb54af58391eb223",r.A.Block,s.A.HalfBlockSlopeTopLeft,[["Blocks", "HalfBlockSlopeTop", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [0, 1, -1]], [[-2, 0, 0], [-1, 0, 0]], [[-2, 0, 1], [-2, 0, 1]], [[1, 0, -2], [1, 1, -2]]]), new d("813b1bbe0eebb47629848d50e815cd28760b3e6c56e549a4a53faea4b33726ab",r.A.Block,s.A.HalfBlockSlopeTopRight,[["Blocks", "HalfBlockSlopeTop"]],c,[[[-2, 0, -2], [1, 1, -2]], [[-1, 0, -1], [1, 1, -1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, 1], [1, 0, 1]]]), new d("b97c17388fc38139f2f5a98a36d94831095f79db709dd97748ad2904bc54d689",r.A.Block,s.A.BlockSlopeDown,[["Blocks", "BlockSlopeDown"]],h,[[[-2, 0, -2], [1, 0, 1]]]), new d("50276826bbfb9fcb11a8519b8dae8a2b1cf82817d5431418d9a376664261be82",r.A.Block,s.A.BlockSlopeUp,[["Blocks", "BlockSlopeUp"]],h,[[[-2, 0, -2], [1, 0, 1]]]), new d("63fd3032796397f8e25669c1c1d3fc97b8ec0e5fc88bfcb5c00a2a2c2b517888",r.A.Block,s.A.BlockSlopeDownLong,[["Blocks", "BlockSlopeDownLong"]],h,[[[-2, 0, -2], [1, 0, 5]], [[-2, 1, 0], [1, 1, 5]]]), new d("2d29131222a8d891b4350e6a2f335b114e001cf22e4e2f170dc9b86c4b2fd325",r.A.Block,s.A.BlockSlopeUpLong,[["Blocks", "BlockSlopeUpLong"]],h,[[[-2, 0, -6], [1, 0, 1]], [[-2, 1, -6], [1, 1, -4]]]), new d("0bbcd96c91b69e6e8005bfae5b64455b0d6510cb1595f3fca7f77c86ddda4560",r.A.Block,s.A.BlockSlopeVerticalTop,[["Blocks", "BlockSlopeVertical", {
                flipY: !0
            }]],h,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [1, 2, -1]], [[-2, 0, -2], [1, 1, -2]]]), new d("e81a123c0be3f8f168fb584d53e8aa038785569bbf2cd1c1cead2272889591e0",r.A.Block,s.A.BlockSlopeVerticalBottom,[["Blocks", "BlockSlopeVertical"]],h,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new d("39c8bfd9a12ba536f34db14b3ac24afd133f3dd67ecc30f8ab90138a5a545520",r.A.Block,s.A.BlockSlopeToVertical,[["Blocks", "BlockSlopeToVertical"]],h,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [1, 1, -1]], [[-2, 2, -2], [1, 3, -2]]]), new d("3a2f05b1c2c2fd976997fa473f1adb3ba14495701dc5a998f8697798384c6946",r.A.Block,s.A.BlockSlopeVerticalCornerTop,[["Blocks", "BlockSlopeVerticalCornerBottom", {
                flipY: !0
            }]],h,[[[-2, 3, -2], [1, 3, 1]], [[-2, 2, -2], [0, 2, 0]], [[1, 2, -2], [1, 2, -1]], [[-2, 2, 1], [-1, 2, 1]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 1, 0], [-1, 1, 0]], [[0, 1, -2], [0, 1, -1]], [[1, 1, -2], [1, 1, -2]], [[-2, 1, 1], [-2, 1, 1]], [[-2, 0, -2], [-1, 0, -1]], [[-2, 0, 0], [-2, 0, 1]], [[0, 0, -2], [1, 0, -2]]]), new d("3e4fa43e69aa1dbee584e16451a95a16229bba8d638df2bf6f6c9ffb3a9629c9",r.A.Block,s.A.BlockInnerCorner,[["Blocks", "BlockInnerCorner"]],h,[[[-2, 0, 0], [-2, 0, 1]], [[-2, 0, -2], [-1, 0, -1]], [[0, 0, -2], [1, 0, -2]]]), new d("cc9c95eef56def4cf013e4ac85b8013a2b4f4b4346f1f5dd41fa017de763ef17",r.A.Block,s.A.BlockSlopeVerticalCornerBottom,[["Blocks", "BlockSlopeVerticalCornerBottom"]],h,[[[-2, 0, -2], [1, 0, 1]], [[-2, 1, -2], [0, 1, 0]], [[1, 1, -2], [1, 1, -1]], [[-2, 1, 1], [-1, 1, 1]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 2, 0], [-1, 2, 0]], [[0, 2, -2], [0, 2, -1]], [[1, 2, -2], [1, 2, -2]], [[-2, 2, 1], [-2, 2, 1]], [[-2, 3, -2], [-1, 3, -1]], [[-2, 3, 0], [-2, 3, 1]], [[0, 3, -2], [1, 3, -2]]]), new d("e4c82c8e512d52269cb6588fa34b06c179340ea40e71f74cbadadc7e8353f5a2",r.A.Block,s.A.BlockSlopeVerticalInnerCornerTop,[["Blocks", "BlockSlopeVerticalInnerCorner", {
                flipY: !0
            }]],h,[[[-2, 3, -2], [0, 3, 1]], [[1, 3, -2], [1, 3, 0]], [[-2, 2, -2], [-2, 2, -1]], [[-1, 2, -2], [-1, 2, -2]], [[-2, 0, -2], [-2, 1, -2]]]), new d("926fdc6e82ecd709cc535faea6bb8778c6e2e91edb39eb6ae6308076dca2ed18",r.A.Block,s.A.BlockSlopeVerticalInnerCornerBottom,[["Blocks", "BlockSlopeVerticalInnerCorner"]],h,[[[-2, 0, -2], [0, 0, 1]], [[1, 0, -2], [1, 0, 0]], [[-2, 1, -2], [-2, 1, -1]], [[-1, 1, -2], [-1, 1, -2]], [[-2, 2, -2], [-2, 3, -2]]]), new d("1086515ba3c1d8e5ec76b378f0bdbc77fc5a57fc8eba8972f0d5e611be945235",r.A.Block,s.A.BlockBridge,[["Blocks", "BlockBridge"]],h,[[[-1, 0, -2], [0, 0, 1]]]), new d("5426ad4ff64af3f1a0f0794ad30cfc20434dfffdf44d93010f5f98671c246ff3",r.A.Block,s.A.BlockBridgeCorner,[["Blocks", "BlockBridgeCorner"]],h,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]]]), new d("784b9b4459e838e5b8f74f6250769ffa52ec5cc3608abc24c380a2e792c3d338",r.A.Block,s.A.BlockBridgeIntersectionT,[["Blocks", "BlockBridgeIntersectionT"]],h,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("dfbcbc107a3c12217bfa3b224a5757d08e995705d1c122bb2c2665bbb8447b1c",r.A.Block,s.A.BlockBridgeIntersectionCross,[["Blocks", "BlockBridgeIntersectionCross"]],h,[[[-1, 0, -1], [0, 0, 1]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, -2], [0, 0, -2]]]), new d("a00d7077d07af7f2125d4db731b5b76ca182b65eb90fbe76061e196a7c0b1652",r.A.WallTrack,s.A.WallTrackTop,[["WallTrack", "WallTrackBottom", {
                flipY: !0
            }]],c,[[[-2, 3, -1], [1, 3, 1]], [[-2, 2, -1], [1, 2, -1]], [[-2, 0, -2], [1, 2, -2]]]), new d("010d187fbfbd399bfe880bbea1b548678c239eba0be2913e5cb8a69fbd17adf7",r.A.WallTrack,s.A.WallTrackMiddle,[["WallTrack", "WallTrackMiddle"]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("72934b2ee76e187eee519baf97df49128dc32e3583795f98645774ae5639f443",r.A.WallTrack,s.A.WallTrackBottom,[["WallTrack", "WallTrackBottom"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-2, 1, -1], [1, 1, -1]], [[-2, 1, -2], [1, 3, -2]]]), new d("1ff36280441e023bd066dc3c5cdf136bd9a3a0beb9eee0aad048c9a2dfd5eafb",r.A.WallTrack,s.A.WallTrackSlopeToVertical,[["WallTrack", "WallTrackSlopeToVertical"]],c,[[[-2, 0, 0], [1, 0, 1]], [[-2, 1, -2], [1, 1, 0]], [[-2, 2, -2], [1, 3, -2]]]), new d("9c7c099734168051032425b6e228665caa581282ef23db6d1ae8c958f8675531",r.A.WallTrack,s.A.WallTrackTopCorner,[["WallTrack", "WallTrackBottomCorner", {
                flipY: !0
            }]],c,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -1], [-2, 1, 1]], [[-1, 1, -1], [-1, 1, 0]], [[0, 1, -1], [0, 1, -1]], [[-1, 1, -2], [1, 1, -2]], [[-2, 2, 0], [-2, 2, 1]], [[-1, 2, 1], [-1, 2, 1]], [[-1, 2, -1], [0, 2, 0]], [[1, 2, -1], [1, 2, -1]], [[0, 2, -2], [1, 2, -2]], [[0, 3, -1], [1, 3, 1]], [[-1, 3, 0], [-1, 3, 1]]]), new d("4027a2439cc3e42ceda50ff3d427a31e127b25a6457b55edc2d498b474a296a7",r.A.WallTrack,s.A.WallTrackMiddleCorner,[["WallTrack", "WallTrackMiddleCorner"]],c,[[[-2, 0, -1], [-2, 0, 1]], [[-1, 0, -1], [-1, 0, -1]], [[-1, 0, -2], [1, 0, -2]]]), new d("32c0ec55a47f619e277cb9efec3dd1b54792e7ea78c370f1e3102b7ba4ed2928",r.A.WallTrack,s.A.WallTrackBottomCorner,[["WallTrack", "WallTrackBottomCorner"]],c,[[[-2, 3, -1], [-2, 3, 1]], [[-1, 3, -1], [-1, 3, -1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -1], [-2, 2, 1]], [[-1, 2, -1], [-1, 2, 0]], [[0, 2, -1], [0, 2, -1]], [[-1, 2, -2], [1, 2, -2]], [[-2, 1, 0], [-2, 1, 1]], [[-1, 1, 1], [-1, 1, 1]], [[-1, 1, -1], [0, 1, 0]], [[1, 1, -1], [1, 1, -1]], [[0, 1, -2], [1, 1, -2]], [[0, 0, -1], [1, 0, 1]], [[-1, 0, 0], [-1, 0, 1]]]), new d("786b8ff7fcb72c67e7b887a78fa7b823c48575ae1e4d3b48ae13620646ac34a7",r.A.WallTrack,s.A.WallTrackTopInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner", {
                flipY: !0
            }]],c,[[[-2, 3, -1], [1, 3, 1]], [[-1, 3, -2], [1, 3, -2]], [[-2, 2, -2], [-1, 2, -1]], [[-2, 0, -2], [-2, 1, -2]]]), new d("16c9c8ece47c097f60cfc7f8a2daa2f0e7ad0befb0ebfd185402013fd1ec8e0f",r.A.WallTrack,s.A.WallTrackInnerCorner,[["WallTrack", "WallTrackInnerCorner"]],c,[[[-2, 0, -2], [-2, 0, -2]]]), new d("413dcb45de9fdaf4fe8b78804feaa80891053063a5c432c09b50c24201166572",r.A.WallTrack,s.A.WallTrackBottomInnerCorner,[["WallTrack", "WallTrackBottomInnerCorner"]],c,[[[-2, 0, -1], [1, 0, 1]], [[-1, 0, -2], [1, 0, -2]], [[-2, 1, -2], [-1, 1, -1]], [[-2, 2, -2], [-2, 3, -2]]]), new d("8b7023471502607ef19109760bee3b954ea3b3883c32f3960f75c6651c912ffd",r.A.WallTrack,s.A.WallTrackFloor,[["WallTrack", "WallTrackFloor"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("59e7f31827236c71db8b16f3f1f259c4c82c87a37e4d57a5a097c0d527d128f3",r.A.WallTrack,s.A.WallTrackFloorCorner,[["WallTrack", "WallTrackFloorCorner"]],c,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new d("d58e3805b550b70940c845a807086865b21a4c36da74ffddedcfe5ce2d08e093",r.A.WallTrack,s.A.WallTrackFloorPlaneCorner,[["WallTrack", "WallTrackFloorPlaneCorner"]],c,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new d("a56b0c1cf964b213a38167cbbac6f33acd403978ad75746eb51bcfd8c6a36148",r.A.WallTrack,s.A.WallTrackCeiling,[["WallTrack", "WallTrackCeiling"]],c,[[[-2, 0, -2], [1, 0, 1]]]), new d("f87b592d02120312e8e93d8a27c02dcda1095ac2f09879c6efafb2ca2b49d127",r.A.WallTrack,s.A.WallTrackCeilingCorner,[["WallTrack", "WallTrackCeilingCorner"]],c,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new d("cfce1fe50f8cd26393eadd475783830e02f0b39bad4c0e00f7aa69614b22decc",r.A.WallTrack,s.A.WallTrackCeilingPlaneCorner,[["WallTrack", "WallTrackCeilingPlaneCorner"]],c,[[[-2, 0, 1], [1, 0, 1]], [[0, 0, 0], [1, 0, 0]], [[1, 0, -2], [1, 0, -1]]]), new d("19656d02145f1a4ba07dbf2f236f865d34c86f823741b247b5d444a36d61c316",r.A.Pillar,s.A.PillarTop,[["Pillar", "PillarTop"]],c,[[[-1, 0, -1], [0, 0, 0]]]), new d("dde596d55ffc00f0f00d361667239d9f71c414f03304fecb6a7d11f6f5e702f1",r.A.Pillar,s.A.PillarMiddle,[["Pillar", "PillarMiddle"]],c,[[[-1, 0, -1], [0, 0, 0]]]), new d("dced5202d9373f9dd81a39530a87a1a7036c93ae71604a4e26c3a191abf3c197",r.A.Pillar,s.A.PillarBottom,[["Pillar", "PillarBottom"]],c,[[[-1, 0, -1], [0, 0, 0]]]), new d("af83eebf50c302880377e4f8c1fb3b2ef96ae193e8d03c17e1fd77c73a847e63",r.A.Pillar,s.A.PillarShort,[["Pillar", "PillarShort"]],c,[[[-1, 0, -1], [0, 0, 0]]]), new d("bad7c003302fe84912a2f36551fc9751220ebe6e747791a8df205dca9ae31cc0",r.A.Pillar,s.A.PillarTopSlope,[["Pillar", "PillarTopSlope"]],c,[[[-1, 0, -1], [0, 0, 0]], [[-1, 1, -1], [0, 1, -1]]]), new d("9f34b2cd553c88364c36923d7ae5e606253865e0684f575e0538670b6116ac5a",r.A.Pillar,s.A.PillarShortSlope,[["Pillar", "PillarShortSlope"]],c,[[[-1, 0, -1], [0, 0, 0]], [[-1, 1, -1], [0, 1, -1]]]), new d("25b41116fb04b1f3cdd3119f57e0000a6ea8cb12d435718ffd6bb765866c272f",r.A.Pillar,s.A.PillarBranch1,[["Pillar", "PillarBranch1"]],c,[[[-1, 0, -2], [0, 0, 0]]]), new d("05ae39aea4f1ddd818fa57860e688c9cb875544f9b82eafe58a2eb9c19d8d91d",r.A.Pillar,s.A.PillarBranch1Top,[["Pillar", "PillarBranch1Top"]],c,[[[-1, 0, -2], [0, 0, 0]]]), new d("06c29d92e42e0c32050af98d69eecc94ce15adf8ac81dbe53dfb577a83265f4e",r.A.Pillar,s.A.PillarBranch1Middle,[["Pillar", "PillarBranch1Middle"]],c,[[[-1, 0, -2], [0, 0, 0]]]), new d("4a989027e0bd6db264f092bac729d9d450e012a710ea28d199f7ff52efd70fbd",r.A.Pillar,s.A.PillarBranch1Bottom,[["Pillar", "PillarBranch1Bottom"]],c,[[[-1, 0, -2], [0, 0, 0]]]), new d("78b2ff83ad71e7f3d692abc35923fa20c2ae14c01e37d44ec430746ca1bac992",r.A.Pillar,s.A.PillarBranch2,[["Pillar", "PillarBranch2"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new d("b22c93bc73ec2da9dbff218da1676d7436527ed284e264f37294e48ef1307301",r.A.Pillar,s.A.PillarBranch2Top,[["Pillar", "PillarBranch2Top"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new d("79a456a8fa3da24bec6c033f6c736fa1c728745f9624ae78ca20b6a4a76afae8",r.A.Pillar,s.A.PillarBranch2Middle,[["Pillar", "PillarBranch2Middle"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new d("3b81b3f965cbc9fda4fe09e830ba25f1b96ce512d87b0146a1192a6cd0d07335",r.A.Pillar,s.A.PillarBranch2Bottom,[["Pillar", "PillarBranch2Bottom"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]]]), new d("27727678bbcac9d3b0172b165ca5c92b10f4b4584a3a18fef4c542f3e791f26f",r.A.Pillar,s.A.PillarBranch3,[["Pillar", "PillarBranch3"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("50c7ac511d30ab9e065c928b776652f038be7683d948082bbefc419ee049e505",r.A.Pillar,s.A.PillarBranch3Top,[["Pillar", "PillarBranch3Top"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("98b3bfe99e7132825f5aa93122e4e5fdec46eb2877c8eb91fa2648f709527b60",r.A.Pillar,s.A.PillarBranch3Middle,[["Pillar", "PillarBranch3Middle"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("7326bbb558f8bcc28d5875c43b1b8e3646caadb873a14fde3ab517f779aea345",r.A.Pillar,s.A.PillarBranch3Bottom,[["Pillar", "PillarBranch3Bottom"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]]]), new d("0e23c2615cfdb350bb3a700b6169589265a1d1079f61294fb497b8f80191d523",r.A.Pillar,s.A.PillarBranch4,[["Pillar", "PillarBranch4"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new d("e62b55e111dbcb3faefed0a203eac5b55051a2b11911946660310e3df3588da3",r.A.Pillar,s.A.PillarBranch4Top,[["Pillar", "PillarBranch4Top"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new d("4e2cfb89c1c591803a1440532a74c3ace37ec7fe78a526c1b57f6679c620df2e",r.A.Pillar,s.A.PillarBranch4Middle,[["Pillar", "PillarBranch4Middle"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new d("e7807350788e4570c8bb74d4a635639ef731d83e52922fac5bc10f415f73f794",r.A.Pillar,s.A.PillarBranch4Bottom,[["Pillar", "PillarBranch4Bottom"]],c,[[[-1, 0, -2], [0, 0, 0]], [[1, 0, -1], [1, 0, 0]], [[-2, 0, -1], [-2, 0, 0]], [[-1, 0, 1], [0, 0, 1]]]), new d("836bfd12791bfebd99aba70531da4c9bd6e332d16c1e120a8888ea54f59456f9",r.A.Pillar,s.A.PillarBranch5,[["Pillar", "PillarBranch5"]],c,[[[-2, 0, -1], [1, 0, 0]]]), new d("ab85228116faf9ae7b1e6cb4a03530cbec808df3d3c1d7883eb41eb7cfe231d7",r.A.Pillar,s.A.PillarBranch5Top,[["Pillar", "PillarBranch5Top"]],c,[[[-2, 0, -1], [1, 0, 0]]]), new d("db93d5cea4e523fd67a56f8d928084ab6355331a8e5d1899115c1841866006bb",r.A.Pillar,s.A.PillarBranch5Middle,[["Pillar", "PillarBranch5Middle"]],c,[[[-2, 0, -1], [1, 0, 0]]]), new d("dd793efa234159e3a0ff28b064ecb715e6c8bb76e06acfe4bd0d9a2f2b9bba88",r.A.Pillar,s.A.PillarBranch5Bottom,[["Pillar", "PillarBranch5Bottom"]],c,[[[-2, 0, -1], [1, 0, 0]]]), new d("350f7d3591ffd0b2cfb8204d1c6cd0022fd3bda81ea7e950fce3abea7ec89e1a",r.A.Sign,s.A.SignArrowLeft,[["Signs", "SignArrowRight", {
                flipX: !0
            }]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("22e104e58bba0a609d379578e391ce50ca523c9eee1c3fddebb6d1bb2246a0b9",r.A.Sign,s.A.SignArrowRight,[["Signs", "SignArrowRight"]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("acba0cfe380e625285b973e09344e61740e77d6f8cac8691ef3e0a0b0878040e",r.A.Sign,s.A.SignArrowUp,[["Signs", "SignArrowUp"]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("8d0dbea0a26bdf3addd372f5d9a2fdecfd776a48f31218acdeb036129b248ca5",r.A.Sign,s.A.SignArrowDown,[["Signs", "SignArrowUp", {
                flipY: !0
            }]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("e5e1b1ca69d7b230331171be07876c4b1bdebba557c19b18ab17d91eee2771d5",r.A.Sign,s.A.SignWarning,[["Signs", "SignWarning"]],c,[[[-2, 0, -2], [1, 0, -2]]]), new d("64ed1fba4990a25bc774575ff8835117638d2c3e7c8f41bf0032d219e1083e4c",r.A.Sign,s.A.SignWrongWay,[["Signs", "SignWrongWay"]],c,[[[-2, 0, -2], [1, 0, -2]]])]
              , p = new Map;
            for (const e of u) {
                if (p.has(e.id))
                    throw new Error("Duplicate track part id " + e.id.toString());
                p.set(e.id, e)
            }
            function f(e) {
                const t = p.get(e);
                if (null == t)
                    throw new Error("Unknown track part id " + e.toString());
                return t
            }
            const g = u.filter((e => e.detector?.type == o.A.Checkpoint)).map((e => e.id))
              , m = u.filter((e => null != e.startOffset)).map((e => e.id))
        }
        ,
        493: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/empty.svg"
        }
        ,
        516: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/arrow_down.svg"
        }
        ,
        540: e => {
            "use strict";
            e.exports = function(e) {
                var t = document.createElement("style");
                return e.setAttributes(t, e.attributes),
                e.insert(t, e.options),
                t
            }
        }
        ,
        542: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/step_back.svg"
        }
        ,
        560: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern.svg"
        }
        ,
        579: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => M
            });
            var i = n(1635)
              , r = n(5072)
              , a = n.n(r)
              , s = n(7825)
              , o = n.n(s)
              , l = n(7659)
              , c = n.n(l)
              , h = n(5056)
              , d = n.n(h)
              , u = n(540)
              , p = n.n(u)
              , f = n(1113)
              , g = n.n(f)
              , m = n(7687)
              , A = {};
            A.styleTagTransform = g(),
            A.setAttributes = d(),
            A.insert = c().bind(null, "head"),
            A.domAPI = o(),
            A.insertStyleElement = p();
            a()(m.A, A);
            m.A && m.A.locals && m.A.locals;
            var v, y, w, b, x, S, E, T = n(8438), k = n(202);
            v = new WeakMap,
            y = new WeakMap,
            w = new WeakMap,
            b = new WeakMap,
            x = new WeakMap,
            S = new WeakMap,
            E = new WeakMap;
            const M = class {
                constructor(e, t, n, r, a, s, o) {
                    v.set(this, void 0),
                    y.set(this, void 0),
                    w.set(this, void 0),
                    b.set(this, void 0),
                    x.set(this, void 0),
                    S.set(this, void 0),
                    E.set(this, void 0),
                    (0,
                    i.GG)(this, v, r, "f");
                    const l = document.getElementById("ui");
                    if (null == l)
                        throw new Error("UI element not found");
                    (0,
                    i.GG)(this, y, l, "f"),
                    (0,
                    i.GG)(this, w, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, w, "f").className = "track-export-ui",
                    (0,
                    i.gn)(this, y, "f").appendChild((0,
                    i.gn)(this, w, "f"));
                    const c = document.createElement("div");
                    c.className = "background",
                    (0,
                    i.gn)(this, w, "f").appendChild(c);
                    const h = document.createElement("div");
                    h.className = "box",
                    (0,
                    i.gn)(this, w, "f").appendChild(h);
                    const d = document.createElement("div");
                    d.className = "bar",
                    h.appendChild(d);
                    const u = document.createElement("button");
                    u.className = "button",
                    u.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                    u.append(document.createTextNode(r.get("Back"))),
                    u.addEventListener("click", ( () => {
                        a.playUIClick(),
                        t()
                    }
                    )),
                    d.appendChild(u),
                    null == n ? ((0,
                    i.GG)(this, x, new k.A(a,r,( () => (0,
                    i.gn)(this, b, "f").value)), "f"),
                    (0,
                    i.gn)(this, x, "f").classList.add("right"),
                    d.appendChild((0,
                    i.gn)(this, x, "f")),
                    (0,
                    i.GG)(this, S, null, "f")) : ((0,
                    i.GG)(this, x, null, "f"),
                    (0,
                    i.GG)(this, S, document.createElement("button"), "f"),
                    (0,
                    i.gn)(this, S, "f").className = "button right",
                    (0,
                    i.gn)(this, S, "f").innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                    (0,
                    i.gn)(this, S, "f").append(document.createTextNode(r.get("Import"))),
                    (0,
                    i.gn)(this, S, "f").addEventListener("click", ( () => {
                        a.playUIClick();
                        const e = (0,
                        i.gn)(this, b, "f").value.split(/(\s|,)+/).map((e => e.replace(/,/g, "").trim())).filter((e => e.length > 0))
                          , t = e.length > 1
                          , l = e => {
                            const t = (0,
                            i.gn)(this, w, "f").className;
                            (0,
                            i.gn)(this, w, "f").className = "hidden",
                            o.show(e, r.get("Ok"), ( () => {
                                (0,
                                i.gn)(this, w, "f").className = t
                            }
                            ))
                        }
                          , c = t => {
                            1 == e.length ? l(r.get("Failed to save track")) : l(r.get("Failed to save track {0}", [(t + 1).toString()]))
                        }
                        ;
                        (async () => {
                            const a = [];
                            for (let t = 0; t < e.length; t++)
                                await new Promise((n => {
                                    const h = e[t]
                                      , d = T.A.fromExportString(h);
                                    if (null == d)
                                        u = t,
                                        1 == e.length ? l(r.get("Invalid track code")) : l(r.get("Invalid track code for track {0}", [(u + 1).toString()])),
                                        n();
                                    else {
                                        const {trackMetadata: e, trackData: l} = d
                                          , h = l.getId()
                                          , u = l.createThumbnail();
                                        if (s.checkCustomTrackNameExists(e.name)) {
                                            const d = (0,
                                            i.gn)(this, w, "f").className;
                                            (0,
                                            i.gn)(this, w, "f").className = "hidden",
                                            o.showConfirm(r.get('The track "{0}" already exists. Do you wish to overwrite it?', [e.name]), r.get("Cancel"), r.get("Overwrite"), ( () => {
                                                (0,
                                                i.gn)(this, w, "f").className = d,
                                                n()
                                            }
                                            ), ( () => {
                                                (0,
                                                i.gn)(this, w, "f").className = d,
                                                s.saveCustomTrack(e, l) ? a.push({
                                                    trackMetadata: e,
                                                    trackData: l,
                                                    trackId: h,
                                                    trackThumbnail: u
                                                }) : c(t),
                                                n()
                                            }
                                            ))
                                        } else
                                            s.saveCustomTrack(e, l) ? a.push({
                                                trackMetadata: e,
                                                trackData: l,
                                                trackId: h,
                                                trackThumbnail: u
                                            }) : c(t),
                                            n()
                                    }
                                    var u
                                }
                                ));
                            a.length > 0 && n(a, t)
                        }
                        )()
                    }
                    )),
                    d.appendChild((0,
                    i.gn)(this, S, "f"))),
                    (0,
                    i.GG)(this, b, document.createElement("textarea"), "f"),
                    (0,
                    i.gn)(this, b, "f").spellcheck = !1,
                    h.appendChild((0,
                    i.gn)(this, b, "f")),
                    null != n && ((0,
                    i.gn)(this, b, "f").placeholder = (0,
                    i.gn)(this, v, "f").get("Paste track data here...")),
                    (0,
                    i.gn)(this, b, "f").value = e,
                    (0,
                    i.gn)(this, b, "f").readOnly = null == n,
                    window.addEventListener("keydown", (0,
                    i.GG)(this, E, (e => {
                        "Escape" == e.code && (t(),
                        e.preventDefault())
                    }
                    ), "f"))
                }
                dispose() {
                    (0,
                    i.gn)(this, y, "f").removeChild((0,
                    i.gn)(this, w, "f")),
                    window.removeEventListener("keydown", (0,
                    i.gn)(this, E, "f"))
                }
            }
        }
        ,
        666: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => u,
                _: () => d
            });
            var i = n(2244)
              , r = n(7680)
              , a = n(8438)
              , s = n(5169)
              , o = n(4183)
              , l = n(2203)
              , c = n(8566)
              , h = n(405);
            function d(e) {
                const t = i.D(e);
                if (null == t)
                    return null;
                const n = new a.A(s.A.Summer,new r.A);
                let d = 0;
                for (; d < t.length; ) {
                    if (t.length - d < 2)
                        return null;
                    let e = t[d + 0] | t[d + 1] << 8;
                    d += 2;
                    let i = null;
                    if (40 == e && (e = l.A.Slope,
                    i = l.A.PillarTopSlope),
                    !(e in l.A))
                        return null;
                    if (t.length - d < 4)
                        return null;
                    const r = t[d + 0] | t[d + 1] << 8 | t[d + 2] << 16 | t[d + 3] << 24;
                    d += 4;
                    for (let a = 0; a < r; ++a) {
                        if (t.length - d < 3)
                            return null;
                        const r = (t[d + 0] | t[d + 1] << 8 | t[d + 2] << 16) - 2 ** 23;
                        if (d += 3,
                        t.length - d < 3)
                            return null;
                        const a = t[d + 0] | t[d + 1] << 8 | t[d + 2] << 16;
                        if (d += 3,
                        t.length - d < 3)
                            return null;
                        const s = (t[d + 0] | t[d + 1] << 8 | t[d + 2] << 16) - 2 ** 23;
                        if (d += 3,
                        t.length - d < 1)
                            return null;
                        const l = 3 & t[d + 0];
                        if (d += 1,
                        l < 0 || l > 3)
                            return null;
                        if (h.bK.includes(e))
                            return null;
                        let u = null;
                        h.l1.includes(e) && (u = 0),
                        null != i && n.addPart(4 * r, a, 4 * s, i, l, c.A.YPositive, o.A.Default, null, null),
                        n.addPart(4 * r, a, 4 * s, e, l, c.A.YPositive, o.A.Default, null, u)
                    }
                }
                return n
            }
            function u(e) {
                if (!e.startsWith("v1n"))
                    return null;
                const t = e.substring(3, 5)
                  , n = i.D(t);
                if (null == n)
                    return null;
                if (1 != n.length)
                    return null;
                const r = n[0]
                  , a = e.substring(5, 5 + r);
                let s;
                try {
                    s = decodeURIComponent(a)
                } catch (e) {
                    return console.warn(e),
                    null
                }
                const o = d(e.substring(5 + r));
                return null == o ? null : {
                    trackMetadata: {
                        name: s,
                        author: null,
                        lastModified: null
                    },
                    trackData: o
                }
            }
        }
        ,
        732: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".invite-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 30%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 500px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n}\n\n.invite-ui > h2 {\n\tmargin: 0;\n\tpadding: 10px 20px;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.invite-ui > .content {\n\tmargin: 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\theight: 290px;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.invite-ui > .content > .loading-container {\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.invite-ui > .content > .loading-container > .loading-text {\n\tmargin: 0 0 20px 0;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.invite-ui > .content > .invite-code-container {\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n.invite-ui > .content > .invite-code-container > .title {\n\tmargin: 0 10px;\n\tfont-size: 26px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.invite-ui > .content > .invite-code-container > input {\n\tmargin: 20px 20px 0 20px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 2 * 20px);\n\tfont-size: 46px;\n\ttext-align: center;\n}\n\n.invite-ui > .content > .invite-code-container > .timeout-timer {\n\tmargin: 10px 0 0 0;\n\tfont-size: 32px;\n\tcolor: var(--text-color);\n}\n\n.invite-ui > .content > .invite-code-container > .timeout-timer.expired {\n\tcolor: #f55;\n}\n\n.invite-ui > .content > .error-container {\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\talign-items: center;\n\tjustify-content: center;\n\ttext-align: center;\n\tfont-size: 38px;\n\tcolor: #ff9696;\n}\n\n.invite-ui > .content > .error-container > .error-reason {\n\tfont-size: 22px;\n}\n\n.invite-ui > .content > .new-code-container {\n\tpadding: 10px 0;\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-self: center;\n}\n\n.invite-ui > .buttons-container {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tpadding: 10px;\n}\n", ""]);
            const o = s
        }
        ,
        765: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => p
            });
            var i, r, a, s, o, l, c = n(1635), h = n(4922), d = n(2244);
            class u {
                constructor(e, t, n, i, l, h, d) {
                    r.set(this, void 0),
                    a.set(this, void 0),
                    s.set(this, void 0),
                    o.set(this, void 0),
                    this.pattern = e,
                    this.rims = t,
                    this.exhaust = n,
                    (0,
                    c.GG)(this, r, i, "f"),
                    (0,
                    c.GG)(this, a, l, "f"),
                    (0,
                    c.GG)(this, s, h, "f"),
                    (0,
                    c.GG)(this, o, d, "f")
                }
                static default() {
                    const e = 360 * Math.random()
                      , t = 100 * (1 - Math.pow(Math.random(), 2))
                      , n = 100 * (.05 + .25 * (1 - Math.pow(Math.random(), 2)));
                    return new i(i.defaultPattern,i.defaultRims,i.defaultExhaust,new h.Q1f("hsl(" + e.toString() + "," + t.toString() + "%," + n.toString() + "%)").getHex(),16777215,1250067,6710886)
                }
                get primaryHex() {
                    return (0,
                    c.gn)(this, r, "f")
                }
                set primaryHex(e) {
                    if (e < 0 || e > 16777215 || !Number.isSafeInteger(e))
                        throw new Error("Invalid primary color hex value");
                    (0,
                    c.GG)(this, r, e, "f")
                }
                get secondaryHex() {
                    return (0,
                    c.gn)(this, a, "f")
                }
                set secondaryHex(e) {
                    if (e < 0 || e > 16777215 || !Number.isSafeInteger(e))
                        throw new Error("Invalid secondary color hex value");
                    (0,
                    c.GG)(this, a, e, "f")
                }
                get frameHex() {
                    return (0,
                    c.gn)(this, s, "f")
                }
                set frameHex(e) {
                    if (e < 0 || e > 16777215 || !Number.isSafeInteger(e))
                        throw new Error("Invalid frame color hex value");
                    (0,
                    c.GG)(this, s, e, "f")
                }
                get rimsHex() {
                    return (0,
                    c.gn)(this, o, "f")
                }
                set rimsHex(e) {
                    if (e < 0 || e > 16777215 || !Number.isSafeInteger(e))
                        throw new Error("Invalid rims color hex value");
                    (0,
                    c.GG)(this, o, e, "f")
                }
                get primaryColor() {
                    return new h.Q1f((0,
                    c.gn)(this, r, "f"))
                }
                get secondaryColor() {
                    return new h.Q1f((0,
                    c.gn)(this, a, "f"))
                }
                get frameColor() {
                    return new h.Q1f((0,
                    c.gn)(this, s, "f"))
                }
                get rimsColor() {
                    return new h.Q1f((0,
                    c.gn)(this, o, "f"))
                }
                equals(e) {
                    return this.pattern == e.pattern && this.rims == e.rims && this.exhaust == e.exhaust && this.primaryHex == e.primaryHex && this.secondaryHex == e.secondaryHex && this.frameHex == e.frameHex && this.rimsHex == e.rimsHex
                }
                clone() {
                    return new i(this.pattern,this.rims,this.exhaust,(0,
                    c.gn)(this, r, "f"),(0,
                    c.gn)(this, a, "f"),(0,
                    c.gn)(this, s, "f"),(0,
                    c.gn)(this, o, "f"))
                }
                serialize() {
                    return d.l(this.serializeBinary())
                }
                static deserializeSafe(e) {
                    const t = d.D(e);
                    if (null == t)
                        return (0,
                        c.gn)(i, i, "m", l).call(i);
                    try {
                        return i.deserializeBinary(t)
                    } catch {
                        return (0,
                        c.gn)(i, i, "m", l).call(i)
                    }
                }
                serializeBinary() {
                    const e = new Uint8Array(i.binaryLength);
                    return e[0] = 0,
                    e[1] = this.pattern,
                    e[2] = this.rims,
                    e[3] = this.exhaust,
                    e.set([255 & (0,
                    c.gn)(this, r, "f"), (0,
                    c.gn)(this, r, "f") >> 8 & 255, (0,
                    c.gn)(this, r, "f") >> 16 & 255], 4),
                    e.set([255 & (0,
                    c.gn)(this, a, "f"), (0,
                    c.gn)(this, a, "f") >> 8 & 255, (0,
                    c.gn)(this, a, "f") >> 16 & 255], 7),
                    e.set([255 & (0,
                    c.gn)(this, s, "f"), (0,
                    c.gn)(this, s, "f") >> 8 & 255, (0,
                    c.gn)(this, s, "f") >> 16 & 255], 10),
                    e.set([255 & (0,
                    c.gn)(this, o, "f"), (0,
                    c.gn)(this, o, "f") >> 8 & 255, (0,
                    c.gn)(this, o, "f") >> 16 & 255], 13),
                    e
                }
                static deserializeBinary(e) {
                    if (e.length < i.binaryLength)
                        throw new Error("Data length is too short");
                    if (0 != e[0])
                        throw new Error("Unsupported car style version");
                    const t = e[1];
                    if (!i.isValidPattern(t))
                        throw new Error("Invalid car style pattern");
                    const n = e[2];
                    if (!i.isValidRims(n))
                        throw new Error("Invalid car style rims");
                    const r = e[3];
                    if (!i.isValidExhaust(r))
                        throw new Error("Invalid car style exhaust");
                    const a = e[4] | e[5] << 8 | e[6] << 16
                      , s = e[7] | e[8] << 8 | e[9] << 16
                      , o = e[10] | e[11] << 8 | e[12] << 16
                      , l = e[13] | e[14] << 8 | e[15] << 16;
                    return new i(t,n,r,a,s,o,l)
                }
                static get defaultPattern() {
                    return 0
                }
                static get defaultRims() {
                    return 0
                }
                static get defaultExhaust() {
                    return 0
                }
                static isValidPattern(e) {
                    return Number.isSafeInteger(e) && e >= 0 && e < i.patterns.length
                }
                static isValidRims(e) {
                    return Number.isSafeInteger(e) && e >= 0 && e < i.rims.length
                }
                static isValidExhaust(e) {
                    return Number.isSafeInteger(e) && e >= 0 && e < i.exhausts.length
                }
            }
            i = u,
            r = new WeakMap,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            l = function() {
                return new i(i.defaultPattern,i.defaultRims,i.defaultExhaust,5592405,5592405,5592405,5592405)
            }
            ,
            u.binaryLength = 16,
            u.patterns = Object.freeze(( () => {
                const e = [];
                return e[0] = {
                    url: "images/pattern_stripe.svg"
                },
                e[1] = {
                    url: "images/pattern_stripe2.svg"
                },
                e[2] = {
                    url: "images/pattern_stripe3.svg"
                },
                e[3] = {
                    url: "images/pattern_double_stripe.svg"
                },
                e[4] = {
                    url: "images/pattern_edge.svg"
                },
                e[5] = {
                    url: "images/pattern_half.svg"
                },
                e[6] = {
                    url: "images/pattern_arrow.svg"
                },
                e[7] = {
                    url: "images/pattern_circle.svg"
                },
                e[8] = {
                    url: "images/pattern_horseshoe.svg"
                },
                e[9] = {
                    url: "images/pattern_needle.svg"
                },
                e[10] = {
                    url: "images/pattern_triangle.svg"
                },
                e[11] = {
                    url: "images/pattern_diamonds.svg"
                },
                e[12] = {
                    url: "images/pattern_zigzag.svg"
                },
                e[13] = {
                    url: "images/pattern_circles.svg"
                },
                e[14] = {
                    url: "images/pattern_gradient.svg"
                },
                e[15] = {
                    url: "images/pattern_outline.svg"
                },
                e.map((e => Object.freeze(e)))
            }
            )()),
            u.rims = Object.freeze(( () => {
                const e = [];
                return e[0] = {
                    model: "Wheel0"
                },
                e[1] = {
                    model: "Wheel1"
                },
                e[2] = {
                    model: "Wheel2"
                },
                e[3] = {
                    model: "Wheel3"
                },
                e[4] = {
                    model: "Wheel4"
                },
                e[5] = {
                    model: "Wheel5"
                },
                e[6] = {
                    model: "Wheel6"
                },
                e[7] = {
                    model: "Wheel7"
                },
                e[8] = {
                    model: "Wheel8"
                },
                e[9] = {
                    model: "Wheel9"
                },
                e[10] = {
                    model: "Wheel10"
                },
                e[11] = {
                    model: "Wheel11"
                },
                e.map((e => Object.freeze(e)))
            }
            )()),
            u.exhausts = Object.freeze(( () => {
                const e = [];
                return e[0] = {
                    model: "Exhaust0"
                },
                e[1] = {
                    model: "Exhaust1"
                },
                e[2] = {
                    model: "Exhaust2"
                },
                e[3] = {
                    model: "Exhaust3"
                },
                e[4] = {
                    model: "Exhaust4"
                },
                e[5] = {
                    model: "Exhaust5"
                },
                e[6] = {
                    model: "Exhaust6"
                },
                e[7] = {
                    model: "Exhaust7"
                },
                e.map((e => Object.freeze(e)))
            }
            )());
            const p = u
        }
        ,
        798: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_stripe2.svg"
        }
        ,
        813: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/winter.svg"
        }
        ,
        820: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/exhaust.svg"
        }
        ,
        832: (e, t, n) => {
            "use strict";
            n.d(t, {
                F: () => u
            });
            var i = n(4922)
              , r = n(4078)
              , a = n(2825)
              , s = n(7680);
            let o = null
              , l = null
              , c = null
              , h = null
              , d = null;
            async function u(e, t, n) {
                for (; null != d; )
                    await d;
                const u = function(e, t, n) {
                    return new Promise((d => {
                        const u = setTimeout(( () => {
                            null != o && null != l && null != c && null != h || (l = document.createElement("canvas"),
                            l.width = 200,
                            l.height = 200,
                            c = new a.A(l,null,!1,!0),
                            h = new i.qUd(-1,1,1,-1,.1,1e4),
                            c.scene.add(h),
                            c.setCamera(h),
                            o = new r.A(null,{
                                position: new i.Pq0,
                                quaternion: new i.PTz
                            },null,null,c,null,null,null,null,null,null),
                            o.update(0)),
                            h.position.copy(n?.position ?? new i.Pq0(1000.1,1000.3,1e3)),
                            h.lookAt(n?.look ?? new i.Pq0(.1,.3,0)),
                            h.zoom = n?.zoom ?? .5,
                            h.updateProjectionMatrix(),
                            o.setCarStyle(e),
                            c.update(new s.A),
                            d(l.toDataURL())
                        }
                        ), 25);
                        t.addCancelCallback(( () => {
                            clearTimeout(u),
                            d("")
                        }
                        ))
                    }
                    ))
                }(e, t, n);
                let p;
                d = u;
                try {
                    p = await u
                } finally {
                    d = null
                }
                return p
            }
        }
        ,
        853: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/icon.svg"
        }
        ,
        858: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/discord.svg"
        }
        ,
        927: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => v
            });
            var i, r, a, s, o, l, c, h, d, u, p, f = n(1635), g = n(3075), m = n(2244);
            class A {
                constructor(e) {
                    i.add(this),
                    a.set(this, []),
                    s.set(this, []),
                    o.set(this, []),
                    l.set(this, []),
                    c.set(this, []),
                    h.set(this, null),
                    null != e && ((0,
                    f.GG)(this, a, e.up, "f"),
                    (0,
                    f.GG)(this, s, e.right, "f"),
                    (0,
                    f.GG)(this, o, e.down, "f"),
                    (0,
                    f.GG)(this, l, e.left, "f"),
                    (0,
                    f.GG)(this, c, e.reset, "f"))
                }
                recordFrame(e, t) {
                    if (e > r.maxFrames)
                        throw new Error("Frame number exceeds maximum frame count.");
                    if (null != (0,
                    f.gn)(this, h, "f") && e <= (0,
                    f.gn)(this, h, "f"))
                        throw new Error("Frame number must be greater than the previous recorded frame.");
                    (0,
                    f.GG)(this, h, e, "f");
                    const n = (0,
                    f.gn)(this, a, "f").length % 2 != 0
                      , i = (0,
                    f.gn)(this, s, "f").length % 2 != 0
                      , d = (0,
                    f.gn)(this, o, "f").length % 2 != 0
                      , u = (0,
                    f.gn)(this, l, "f").length % 2 != 0
                      , p = (0,
                    f.gn)(this, c, "f").length % 2 != 0;
                    t.up != n && (0,
                    f.gn)(this, a, "f").push(e),
                    t.right != i && (0,
                    f.gn)(this, s, "f").push(e),
                    t.down != d && (0,
                    f.gn)(this, o, "f").push(e),
                    t.left != u && (0,
                    f.gn)(this, l, "f").push(e),
                    t.reset != p && (0,
                    f.gn)(this, c, "f").push(e)
                }
                getFrame(e) {
                    return {
                        up: ((0,
                        f.gn)(this, i, "m", d).call(this, e, (0,
                        f.gn)(this, a, "f")) + 1) % 2 != 0,
                        right: ((0,
                        f.gn)(this, i, "m", d).call(this, e, (0,
                        f.gn)(this, s, "f")) + 1) % 2 != 0,
                        down: ((0,
                        f.gn)(this, i, "m", d).call(this, e, (0,
                        f.gn)(this, o, "f")) + 1) % 2 != 0,
                        left: ((0,
                        f.gn)(this, i, "m", d).call(this, e, (0,
                        f.gn)(this, l, "f")) + 1) % 2 != 0,
                        reset: ((0,
                        f.gn)(this, i, "m", d).call(this, e, (0,
                        f.gn)(this, c, "f")) + 1) % 2 != 0
                    }
                }
                serialize() {
                    const e = new Uint8Array(3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length + 3 + 3 * (0,
                    f.gn)(this, l, "f").length + 3 + 3 * (0,
                    f.gn)(this, c, "f").length);
                    (0,
                    f.gn)(this, i, "m", u).call(this, (0,
                    f.gn)(this, a, "f"), e.subarray(0, 3 + 3 * (0,
                    f.gn)(this, a, "f").length)),
                    (0,
                    f.gn)(this, i, "m", u).call(this, (0,
                    f.gn)(this, s, "f"), e.subarray(3 + 3 * (0,
                    f.gn)(this, a, "f").length, 3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length)),
                    (0,
                    f.gn)(this, i, "m", u).call(this, (0,
                    f.gn)(this, o, "f"), e.subarray(3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length, 3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length)),
                    (0,
                    f.gn)(this, i, "m", u).call(this, (0,
                    f.gn)(this, l, "f"), e.subarray(3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length, 3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length + 3 + 3 * (0,
                    f.gn)(this, l, "f").length)),
                    (0,
                    f.gn)(this, i, "m", u).call(this, (0,
                    f.gn)(this, c, "f"), e.subarray(3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length + 3 + 3 * (0,
                    f.gn)(this, l, "f").length, 3 + 3 * (0,
                    f.gn)(this, a, "f").length + 3 + 3 * (0,
                    f.gn)(this, s, "f").length + 3 + 3 * (0,
                    f.gn)(this, o, "f").length + 3 + 3 * (0,
                    f.gn)(this, l, "f").length + 3 + 3 * (0,
                    f.gn)(this, c, "f").length));
                    const t = new g.Ay.Deflate({
                        level: 9
                    });
                    return t.push(new Uint8Array(e), !0),
                    m.l(t.result)
                }
                static deserialize(e) {
                    const t = m.D(e);
                    if (null == t)
                        return null;
                    const n = new g.Ay.Inflate;
                    if (n.push(t, !0),
                    n.err)
                        return null;
                    const i = n.result;
                    if (!(i instanceof Uint8Array))
                        return null;
                    const a = (0,
                    f.gn)(r, r, "m", p).call(r, i);
                    if (null == a)
                        return null;
                    const s = (0,
                    f.gn)(r, r, "m", p).call(r, i.subarray(3 + 3 * a.length));
                    if (null == s)
                        return null;
                    const o = (0,
                    f.gn)(r, r, "m", p).call(r, i.subarray(3 + 3 * a.length + 3 + 3 * s.length));
                    if (null == o)
                        return null;
                    const l = (0,
                    f.gn)(r, r, "m", p).call(r, i.subarray(3 + 3 * a.length + 3 + 3 * s.length + 3 + 3 * o.length));
                    if (null == l)
                        return null;
                    const c = (0,
                    f.gn)(r, r, "m", p).call(r, i.subarray(3 + 3 * a.length + 3 + 3 * s.length + 3 + 3 * o.length + 3 + 3 * l.length));
                    return null == c ? null : new r({
                        up: a,
                        right: s,
                        down: o,
                        left: l,
                        reset: c
                    })
                }
            }
            r = A,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            l = new WeakMap,
            c = new WeakMap,
            h = new WeakMap,
            i = new WeakSet,
            d = function(e, t) {
                let n = -1;
                for (let i = 0; i < t.length; ++i) {
                    const r = t[i];
                    if (r == e) {
                        n = i;
                        break
                    }
                    if (r > e)
                        break;
                    n = i
                }
                return n
            }
            ,
            u = function(e, t) {
                t[0] = 255 & e.length,
                t[1] = e.length >>> 8 & 255,
                t[2] = e.length >>> 16 & 255;
                for (let n = 0; n < e.length; ++n) {
                    let i;
                    i = 0 == n ? e[n] : e[n] - e[n - 1],
                    t[3 + 3 * n] = 255 & i,
                    t[3 + 3 * n + 1] = i >>> 8 & 255,
                    t[3 + 3 * n + 2] = i >>> 16 & 255
                }
            }
            ,
            p = function(e) {
                if (e.length < 3)
                    return null;
                const t = e[0] | e[1] << 8 | e[2] << 16;
                if (e.length < 3 + 3 * t)
                    return null;
                const n = [];
                for (let i = 0; i < t; ++i) {
                    const t = e[3 + 3 * i] | e[3 + 3 * i + 1] << 8 | e[3 + 3 * i + 2] << 16;
                    0 == i ? n.push(t) : n.push(n[i - 1] + t)
                }
                return n
            }
            ,
            A.maxFrames = 5999999;
            const v = A
        }
        ,
        964: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".input-visualizer-ui {\n    position: absolute;\n    left: var(--safe-area-horizontal);\n    bottom: 106px;\n    margin: 20px;\n    padding: 0;\n    --size: 96px;\n    width: calc(var(--size) * 3);\n    height: calc(var(--size) * 2);\n    opacity: 0.9;\n}\n\n.input-visualizer-ui > div {\n    position: absolute;\n    margin: 0;\n    padding: 0;\n    width: var(--size);\n    height: var(--size);\n    background-color: var(--surface-color);\n}\n\n.input-visualizer-ui > .arrow-up {\n    left: var(--size);\n    top: 0;\n}\n\n.input-visualizer-ui > .arrow-right {\n    left: calc(var(--size) * 2);\n    top: var(--size);\n}\n\n.input-visualizer-ui > .arrow-down {\n    left: var(--size);\n    top: var(--size);\n}\n\n.input-visualizer-ui > .arrow-left {\n    left: 0;\n    top: var(--size);\n}\n\n.input-visualizer-ui > div.active {\n    background-color: var(--surface-tertiary-color);\n}\n\n.input-visualizer-ui > div > img {\n    margin: 0;\n    padding: 20px;\n    width: 100%;\n    height: 100%;\n    box-sizing: border-box;\n}\n.input-visualizer-ui > div.active > img {\n    padding: 25px;\n}", ""]);
            const o = s
        }
        ,
        1014: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/step_forward.svg"
        }
        ,
        1055: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => s
            });
            var i, r, a = n(1635);
            i = new WeakMap,
            r = new WeakMap;
            const s = class {
                constructor() {
                    i.set(this, !1),
                    r.set(this, [])
                }
                cancel() {
                    if (!(0,
                    a.gn)(this, i, "f")) {
                        (0,
                        a.GG)(this, i, !0, "f");
                        for (const e of (0,
                        a.gn)(this, r, "f"))
                            e()
                    }
                }
                get isCancelled() {
                    return (0,
                    a.gn)(this, i, "f")
                }
                addCancelCallback(e) {
                    (0,
                    a.gn)(this, r, "f").push(e),
                    (0,
                    a.gn)(this, i, "f") && e()
                }
            }
        }
        ,
        1066: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => f
            });
            var i, r, a, s, o, l, c, h, d = n(1635), u = n(4922);
            class p {
                constructor(e) {
                    r.set(this, void 0),
                    a.set(this, void 0),
                    s.set(this, []),
                    o.set(this, 256),
                    l.set(this, new u.Pq0(0,1,0)),
                    (0,
                    d.GG)(this, r, e, "f"),
                    (0,
                    d.GG)(this, a, new u.ZLX((0,
                    d.gn)(i, i, "f", c),(0,
                    d.gn)(i, i, "f", h),(0,
                    d.gn)(this, o, "f")), "f"),
                    (0,
                    d.gn)(this, a, "f").frustumCulled = !1,
                    e.scene.add((0,
                    d.gn)(this, a, "f")),
                    this.clear()
                }
                dispose() {
                    (0,
                    d.gn)(this, a, "f").dispose(),
                    (0,
                    d.gn)(this, r, "f").scene.remove((0,
                    d.gn)(this, a, "f"))
                }
                clear() {
                    (0,
                    d.gn)(this, s, "f").length = 0,
                    (0,
                    d.gn)(this, a, "f").count = 0,
                    (0,
                    d.gn)(this, a, "f").instanceMatrix.needsUpdate = !0
                }
                spawn(e, t, n) {
                    (0,
                    d.gn)(this, s, "f").push({
                        x: e + .25 * (Math.random() - .5),
                        y: t + .25 * (Math.random() - .5),
                        z: n + .25 * (Math.random() - .5),
                        vx: .5 * (Math.random() - .5),
                        vy: .5 * (Math.random() - .5),
                        vz: .5 * (Math.random() - .5),
                        rotation: Math.random() * Math.PI * 2,
                        lifetime: .5
                    })
                }
                update(e) {
                    for (let t = (0,
                    d.gn)(this, s, "f").length - 1; t >= 0; --t) {
                        const n = (0,
                        d.gn)(this, s, "f")[t];
                        n.vy += 15 * e,
                        n.x += n.vx * e,
                        n.y += n.vy * e,
                        n.z += n.vz * e,
                        n.lifetime -= e,
                        n.lifetime <= 0 && (0,
                        d.gn)(this, s, "f").splice(t, 1)
                    }
                    let t = !1;
                    (0,
                    d.gn)(this, a, "f").count != (0,
                    d.gn)(this, s, "f").length && ((0,
                    d.gn)(this, a, "f").count = Math.min((0,
                    d.gn)(this, s, "f").length, (0,
                    d.gn)(this, o, "f")),
                    t = !0);
                    for (let e = 0; e < (0,
                    d.gn)(this, a, "f").count; ++e) {
                        const t = (0,
                        d.gn)(this, s, "f")[(0,
                        d.gn)(this, s, "f").length - 1 - e]
                          , n = new u.kn4;
                        n.lookAt(new u.Pq0(t.x,t.y,t.z), (0,
                        d.gn)(this, r, "f").camera.position, (0,
                        d.gn)(this, l, "f")),
                        n.setPosition(t.x, t.y, t.z),
                        n.multiply((new u.kn4).makeRotationZ(t.rotation));
                        const i = .5 + 2 * (.5 - t.lifetime);
                        n.scale(new u.Pq0(i,i,i)),
                        (0,
                        d.gn)(this, a, "f").setMatrixAt(e, n)
                    }
                    (t || (0,
                    d.gn)(this, s, "f").length > 0) && ((0,
                    d.gn)(this, a, "f").instanceMatrix.needsUpdate = !0)
                }
                static initResources(e) {
                    e.addResource();
                    const t = (new u.Tap).load("images/smoke.png", ( () => {
                        e.loadedResource()
                    }
                    ));
                    (0,
                    d.gn)(this, i, "f", h).map = t
                }
            }
            i = p,
            r = new WeakMap,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            l = new WeakMap,
            c = {
                value: ( () => {
                    const e = new u.bdM;
                    return e.rotateX(Math.PI),
                    e
                }
                )()
            },
            h = {
                value: new u.V9B({
                    opacity: .3,
                    depthWrite: !1,
                    transparent: !0
                })
            };
            const f = p
        }
        ,
        1083: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".game-ui.hidden {\n\tdisplay: hidden;\n}\n", ""]);
            const o = s
        }
        ,
        1113: e => {
            "use strict";
            e.exports = function(e, t) {
                if (t.styleSheet)
                    t.styleSheet.cssText = e;
                else {
                    for (; t.firstChild; )
                        t.removeChild(t.firstChild);
                    t.appendChild(document.createTextNode(e))
                }
            }
        }
        ,
        1120: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".graph-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: calc(50% - 900px / 2);\n\ttop: 15%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\tbox-sizing: border-box;\n}\n\n.graph-ui > h2 {\n\tmargin: 0;\n\tpadding: 10px 20px;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.graph-ui > .content {\n\twidth: 900px;\n\theight: 500px;\n}\n\n.graph-ui > .content > .graph-content {\n\tdisplay: flex;\n\tflex-grow: 1;\n\tbackground-color: rgba(40, 52, 106, 0.85);\n}\n.graph-ui.type-selection-open > .content > .graph-content {\n\tdisplay: none;\n}\n\n.graph-ui > .content > .graph-content > .side-panel {\n\twidth: 150px;\n\theight: 500px;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.graph-ui > .content > .graph-content > .side-panel > div {\n\tmargin: 5px;\n\tpadding: 5px;\n\tbackground-color: var(--surface-color);\n}\n\n.graph-ui > .content > .graph-content > .side-panel > div > div {\n\tfont-size: 15px;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.graph-ui > .content > .graph-content > canvas {\n\tmargin: 0;\n\tpadding: 0;\n}\n\n.graph-ui > .content > .type-selection-content {\n\tdisplay: none;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\twidth: 900px;\n\theight: 500px;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: auto;\n\tpointer-events: auto;\n}\n\n.graph-ui.type-selection-open > .content > .type-selection-content {\n\tdisplay: block;\n}\n\n.graph-ui > .content > .type-selection-content > button {\n\tmargin: 0 0 10px 0;\n\twidth: calc(100% - 2 * 10px);\n}\n\n.graph-ui > .buttons-container {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tpadding: 10px;\n\tbackground-color: var(--surface-color);\n}\n", ""]);
            const o = s
        }
        ,
        1196: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, '.time-announcer-ui {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 35%;\n\twidth: 100%;\n\toverflow: hidden;\n}\n\n.time-announcer-ui > .record {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 64px;\n\tfont-weight: bold;\n\ttext-align: center;\n\topacity: 0;\n}\n.time-announcer-ui > .record.personal-best {\n\ttext-shadow: 3px 3px 0 #660, 0 0 3px #000;\n\tcolor: #ff5;\n\tanimation: 0.25s ease-out 0.6s 1 normal forwards running time-announcer-record-personal-best-animation;\n}\n.time-announcer-ui > .record.session-best {\n\ttext-shadow: 3px 3px 0 #060, 0 0 3px #000;\n\tcolor: #5f5;\n\tanimation: 0.25s ease-out 0.6s 1 normal forwards running time-announcer-record-session-best-animation;\n}\n\n.time-announcer-ui > .track-name {\n\tmargin: 0 0 10px 0;\n\tpadding: 4px 20px;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tbackground-color: var(--surface-secondary-color);\n\tfont-size: 60px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tanimation: 0.3s ease-out 0s 1 normal forwards running time-announcer-animation;\n}\n\n.time-announcer-ui > .current {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 0;\n\tbackground-color: var(--surface-color);\n\tfont-size: 48px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n\tanimation: 0.5s ease-out 0s 1 normal forwards running time-announcer-animation;\n}\n.time-announcer-ui > .current:after {\n\tcontent: "\\200b"; /* Keep height even with absolute elements */\n}\n.time-announcer-ui > .current > div {\n\tposition: absolute;\n\tleft: 50%;\n}\n.time-announcer-ui > .current > .time {\n\ttext-align: right;\n\ttransform: translateX(-50%);\n\ttransition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;\n}\n.time-announcer-ui > .current > .position-dash {\n\ttransform: translateX(-50%);\n\topacity: 0;\n\ttransition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;\n}\n.time-announcer-ui > .current > .position {\n\ttext-align: left;\n\topacity: 0;\n\ttransform: translateX(-50%);\n\ttransition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;\n}\n\n.time-announcer-ui > .current.show-position > .time {\n\ttransform: translateX(calc(-100% - 35px));\n}\n.time-announcer-ui > .current.show-position > .position-dash {\n\topacity: 1;\n}\n.time-announcer-ui > .current.show-position > .position {\n\ttransform: translateX(35px);\n\topacity: 1;\n}\n\n.time-announcer-ui > .difference > p {\n\tmargin: 0 0 0 auto;\n\tpadding: 0;\n\twidth: 0;\n\tbackground-color: var(--surface-secondary-color);\n\tcolor: #5f5;\n\tfont-size: 30px;\n\ttext-align: center;\n\tanimation: 0.4s ease-out 0.5s 1 normal forwards running time-announcer-animation;\n}\n.time-announcer-ui > .difference.red > p {\n\tcolor: #f55;\n}\n.time-announcer-ui > .difference > p.title {\n\tmargin-top: 30px;\n\tbackground-color: transparent;\n\ttext-shadow: 0 0 3px #000;\n}\n\n@keyframes time-announcer-record-personal-best-animation {\n\t0% {\n\t\topacity: 0;\n\t\ttransform: scaleX(0.5);\n\t\tbackground-color: #ffa;\n\t}\n\n\t80% {\n\t\topacity: 1;\n\t\ttransform: scaleX(1.1);\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t\ttransform: scaleX(1);\n\t\tbackground-color: rgba(255, 255, 170, 0.3);\n\t}\n}\n\n@keyframes time-announcer-record-session-best-animation {\n\t0% {\n\t\topacity: 0;\n\t\ttransform: scaleX(0.5);\n\t\tbackground-color: #afa;\n\t}\n\n\t80% {\n\t\topacity: 1;\n\t\ttransform: scaleX(1.1);\n\t}\n\n\t100% {\n\t\topacity: 1;\n\t\ttransform: scaleX(1);\n\t\tbackground-color: rgba(170, 255, 170, 0.3);\n\t}\n}\n\n@keyframes time-announcer-animation {\n\tfrom {\n\t\twidth: 0;\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\twidth: 100%;\n\t\topacity: 1;\n\t}\n}\n', ""]);
            const o = s
        }
        ,
        1223: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => m
            });
            var i, r = n(1635), a = n(4078), s = n(9507);
            !function(e) {
                e[e.Init = 0] = "Init",
                e[e.Verify = 1] = "Verify",
                e[e.TestDeterminism = 2] = "TestDeterminism",
                e[e.CreateCar = 3] = "CreateCar",
                e[e.DeleteCar = 4] = "DeleteCar",
                e[e.StartCar = 5] = "StartCar",
                e[e.ControlCar = 6] = "ControlCar",
                e[e.PauseCar = 7] = "PauseCar",
                e[e.VerifyResult = 8] = "VerifyResult",
                e[e.DeterminismResult = 9] = "DeterminismResult",
                e[e.UpdateResult = 10] = "UpdateResult"
            }(i || (i = {}));
            const o = i;
            var l, c, h, d, u, p, f, g = n(2108);
            c = new WeakMap,
            h = new WeakMap,
            d = new WeakMap,
            u = new WeakMap,
            p = new WeakMap,
            l = new WeakSet,
            f = function(e, t) {
                if (null == a.A.models)
                    throw new Error("Car collision model not loaded");
                const n = t.getPhysicsParts().map((e => ({
                    id: e.id,
                    vertices: e.vertices,
                    detector: null == e.detector ? null : {
                        type: e.detector.type,
                        center: e.detector.center,
                        size: e.detector.size
                    },
                    startOffset: e.startOffset
                })))
                  , i = {
                    messageType: o.Init,
                    isRealtime: e,
                    trackParts: n,
                    carCollisionShapeVertices: a.A.models.collisionShapeVertices,
                    carMassOffset: a.A.massOffset
                };
                (0,
                r.gn)(this, h, "f").postMessage(i)
            }
            ;
            const m = class {
                constructor(e, t, n) {
                    l.add(this),
                    c.set(this, void 0),
                    h.set(this, void 0),
                    d.set(this, !1),
                    u.set(this, 0),
                    p.set(this, new Map),
                    (0,
                    r.GG)(this, h, new Worker("simulation_worker.bundle.js"), "f"),
                    null != t && null != n ? ((0,
                    r.GG)(this, c, t, "f"),
                    n.hasLoaded() ? (0,
                    r.gn)(this, l, "m", f).call(this, e, t) : n.addCompleteListener(( () => {
                        (0,
                        r.gn)(this, l, "m", f).call(this, e, t)
                    }
                    ))) : (0,
                    r.GG)(this, c, null, "f")
                }
                dispose() {
                    (0,
                    r.gn)(this, h, "f").terminate(),
                    (0,
                    r.GG)(this, d, !0, "f")
                }
                validate(e, t, n) {
                    return new Promise(( (i, a) => {
                        var l, p;
                        if (null == (0,
                        r.gn)(this, c, "f"))
                            throw new Error("TrackPartManager is not initialized");
                        if (null == e.getStartTransform())
                            i(!1);
                        else {
                            const c = s.A.createMountainVertices(e.getBounds())
                              , f = ((0,
                            r.GG)(this, u, (p = (0,
                            r.gn)(this, u, "f"),
                            l = p++,
                            p), "f"),
                            l)
                              , g = setInterval(( () => {
                                (0,
                                r.gn)(this, d, "f") && (clearInterval(g),
                                a(new Error("Simulation has been disposed")))
                            }
                            ), 10)
                              , m = e => {
                                const t = e.data;
                                t.messageType == o.VerifyResult && t.carId == f && (clearInterval(g),
                                (0,
                                r.gn)(this, h, "f").removeEventListener("message", m),
                                i(t.result))
                            }
                            ;
                            (0,
                            r.gn)(this, h, "f").addEventListener("message", m);
                            const A = {
                                messageType: o.Verify,
                                mountainVertices: c.vertices,
                                mountainOffset: {
                                    x: c.offset.x,
                                    y: c.offset.y,
                                    z: c.offset.z
                                },
                                trackData: e.toSaveString(),
                                carId: f,
                                carRecording: t.serialize(),
                                targetFrames: n.numberOfFrames
                            };
                            (0,
                            r.gn)(this, h, "f").postMessage(A)
                        }
                    }
                    ))
                }
                testDeterminism() {
                    return new Promise((e => {
                        const t = n => {
                            const i = n.data;
                            i.messageType == o.DeterminismResult && ((0,
                            r.gn)(this, h, "f").removeEventListener("message", t),
                            e(i.isDeterminstic))
                        }
                        ;
                        (0,
                        r.gn)(this, h, "f").addEventListener("message", t);
                        const n = {
                            messageType: o.TestDeterminism
                        };
                        (0,
                        r.gn)(this, h, "f").postMessage(n)
                    }
                    ))
                }
                createCar(e, t, n, i, s, l) {
                    var d, f;
                    if (null == (0,
                    r.gn)(this, c, "f"))
                        throw new Error("TrackPartManager is not initialized");
                    const m = ((0,
                    r.GG)(this, u, (f = (0,
                    r.gn)(this, u, "f"),
                    d = f++,
                    f), "f"),
                    d)
                      , A = e => {
                        const t = e.data;
                        if (t.messageType == o.UpdateResult) {
                            const e = t.carStateBuffers.map((e => {
                                const t = new Uint8Array(e);
                                return {
                                    id: t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24,
                                    carState: g.VO(t.subarray(4)).carState
                                }
                            }
                            ));
                            for (const {id: t, carState: n} of e)
                                t == m && l(n)
                        }
                    }
                    ;
                    (0,
                    r.gn)(this, h, "f").addEventListener("message", A),
                    (0,
                    r.gn)(this, p, "f").set(m, A);
                    const v = {
                        messageType: o.CreateCar,
                        mountainVertices: t,
                        mountainOffset: {
                            x: n.x,
                            y: n.y,
                            z: n.z
                        },
                        trackData: i.toSaveString(),
                        carId: m,
                        carRecording: s?.serialize() ?? null
                    };
                    return (0,
                    r.gn)(this, h, "f").postMessage(v),
                    {
                        id: m,
                        carState: {
                            frames: 0,
                            speedKmh: 0,
                            hasStarted: !1,
                            finishFrames: null,
                            nextCheckpointIndex: 0,
                            hasCheckpointToRespawnAt: !1,
                            position: {
                                x: e.position.x,
                                y: e.position.y,
                                z: e.position.z
                            },
                            quaternion: {
                                x: e.quaternion.x,
                                y: e.quaternion.y,
                                z: e.quaternion.z,
                                w: e.quaternion.w
                            },
                            collisionImpulses: [],
                            wheelContact: [null, null, null, null],
                            wheelSuspensionLength: [a.A.suspensionResetLengthFront, a.A.suspensionResetLengthFront, a.A.suspensionResetLengthRear, a.A.suspensionResetLengthRear],
                            wheelSuspensionVelocity: [0, 0, 0, 0],
                            wheelDeltaRotation: [0, 0, 0, 0],
                            wheelSkidInfo: [0, 0, 0, 0],
                            steering: 0,
                            brakeLightEnabled: !1,
                            controls: {
                                up: !1,
                                right: !1,
                                down: !1,
                                left: !1,
                                reset: !1
                            }
                        }
                    }
                }
                deleteCar(e) {
                    const t = {
                        messageType: o.DeleteCar,
                        carId: e
                    };
                    (0,
                    r.gn)(this, h, "f").postMessage(t);
                    const n = (0,
                    r.gn)(this, p, "f").get(e);
                    if (null == n)
                        throw new Error("Deleting non-existant car");
                    (0,
                    r.gn)(this, h, "f").removeEventListener("message", n),
                    (0,
                    r.gn)(this, p, "f").delete(e)
                }
                startCar(e, t) {
                    const n = {
                        messageType: o.StartCar,
                        carId: e,
                        targetSimulationTimeFrames: t?.numberOfFrames ?? null
                    };
                    (0,
                    r.gn)(this, h, "f").postMessage(n)
                }
                controlCar(e, t, n, i, a, s) {
                    const l = {
                        messageType: o.ControlCar,
                        carId: e,
                        up: t,
                        right: n,
                        down: i,
                        left: a,
                        reset: s
                    };
                    (0,
                    r.gn)(this, h, "f").postMessage(l)
                }
                pauseCar(e, t) {
                    const n = {
                        messageType: o.PauseCar,
                        carId: e,
                        isPaused: t
                    };
                    (0,
                    r.gn)(this, h, "f").postMessage(n)
                }
            }
        }
        ,
        1247: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".news-popup-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: calc(50% - 650px / 2);\n\ttop: calc(50% - 750px / 2);\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 650px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n}\n\n.news-popup-ui > h2 {\n\tmargin: 0;\n\tpadding: 10px 20px 0 20px;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.news-popup-ui > h3 {\n\tmargin: 0;\n\tpadding: 0 20px 10px 20px;\n\tfont-size: 24px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n\topacity: 0.8;\n}\n\n.news-popup-ui > .content {\n\tmargin: 0;\n\tpadding: 0 0 10px 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\tmin-height: 0;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: auto;\n\tpointer-events: auto;\n}\n\n.news-popup-ui > .content > .cover-image {\n\tmargin: 0 auto;\n\tpadding: 20px 20px 10px 20px;\n\twidth: 100%;\n\tbox-sizing: border-box;\n}\n\n.news-popup-ui > .content > p {\n\tmargin: 0;\n\tpadding: 0 20px 20px 20px;\n\ttext-align: center;\n\tfont-size: 24px;\n\tcolor: var(--text-color);\n}\n\n.news-popup-ui > .content > p.small {\n\tfont-size: 18px;\n\topacity: 0.8;\n}\n\n.news-popup-ui > .content > a {\n\tmargin: 0 20px;\n\tpadding: 0;\n\tfont-size: 24px;\n\tcolor: var(--text-color);\n}\n\n.news-popup-ui > .bottom-container {\n\tdisplay: flex;\n\tjustify-content: space-around;\n\tpadding: 10px;\n}\n", ""]);
            const o = s
        }
        ,
        1312: (e, t, n) => {
            var i;
            /**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.11.1
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2025
 * @license MIT
 */
            !function() {
                "use strict";
                var t = "input is invalid type"
                  , r = "object" == typeof window
                  , a = r ? window : {};
                a.JS_SHA256_NO_WINDOW && (r = !1);
                var s = !r && "object" == typeof self
                  , o = !a.JS_SHA256_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node && "renderer" != process.type;
                o ? a = n.g : s && (a = self);
                var l = !a.JS_SHA256_NO_COMMON_JS && e.exports
                  , c = n.amdO
                  , h = !a.JS_SHA256_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer
                  , d = "0123456789abcdef".split("")
                  , u = [-2147483648, 8388608, 32768, 128]
                  , p = [24, 16, 8, 0]
                  , f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]
                  , g = ["hex", "array", "digest", "arrayBuffer"]
                  , m = [];
                !a.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                    return "[object Array]" === Object.prototype.toString.call(e)
                }
                ),
                !h || !a.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                    return "object" == typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                }
                );
                var A = function(e, t) {
                    return function(n) {
                        return new x(t,!0).update(n)[e]()
                    }
                }
                  , v = function(e) {
                    var t = A("hex", e);
                    o && (t = y(t, e)),
                    t.create = function() {
                        return new x(e)
                    }
                    ,
                    t.update = function(e) {
                        return t.create().update(e)
                    }
                    ;
                    for (var n = 0; n < g.length; ++n) {
                        var i = g[n];
                        t[i] = A(i, e)
                    }
                    return t
                }
                  , y = function(e, i) {
                    var r, s = n(4394), o = n(1903).Buffer, l = i ? "sha224" : "sha256";
                    r = o.from && !a.JS_SHA256_NO_BUFFER_FROM ? o.from : function(e) {
                        return new o(e)
                    }
                    ;
                    return function(n) {
                        if ("string" == typeof n)
                            return s.createHash(l).update(n, "utf8").digest("hex");
                        if (null == n)
                            throw new Error(t);
                        return n.constructor === ArrayBuffer && (n = new Uint8Array(n)),
                        Array.isArray(n) || ArrayBuffer.isView(n) || n.constructor === o ? s.createHash(l).update(r(n)).digest("hex") : e(n)
                    }
                }
                  , w = function(e, t) {
                    return function(n, i) {
                        return new S(n,t,!0).update(i)[e]()
                    }
                }
                  , b = function(e) {
                    var t = w("hex", e);
                    t.create = function(t) {
                        return new S(t,e)
                    }
                    ,
                    t.update = function(e, n) {
                        return t.create(e).update(n)
                    }
                    ;
                    for (var n = 0; n < g.length; ++n) {
                        var i = g[n];
                        t[i] = w(i, e)
                    }
                    return t
                };
                function x(e, t) {
                    t ? (m[0] = m[16] = m[1] = m[2] = m[3] = m[4] = m[5] = m[6] = m[7] = m[8] = m[9] = m[10] = m[11] = m[12] = m[13] = m[14] = m[15] = 0,
                    this.blocks = m) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    e ? (this.h0 = 3238371032,
                    this.h1 = 914150663,
                    this.h2 = 812702999,
                    this.h3 = 4144912697,
                    this.h4 = 4290775857,
                    this.h5 = 1750603025,
                    this.h6 = 1694076839,
                    this.h7 = 3204075428) : (this.h0 = 1779033703,
                    this.h1 = 3144134277,
                    this.h2 = 1013904242,
                    this.h3 = 2773480762,
                    this.h4 = 1359893119,
                    this.h5 = 2600822924,
                    this.h6 = 528734635,
                    this.h7 = 1541459225),
                    this.block = this.start = this.bytes = this.hBytes = 0,
                    this.finalized = this.hashed = !1,
                    this.first = !0,
                    this.is224 = e
                }
                function S(e, n, i) {
                    var r, a = typeof e;
                    if ("string" === a) {
                        var s, o = [], l = e.length, c = 0;
                        for (r = 0; r < l; ++r)
                            (s = e.charCodeAt(r)) < 128 ? o[c++] = s : s < 2048 ? (o[c++] = 192 | s >>> 6,
                            o[c++] = 128 | 63 & s) : s < 55296 || s >= 57344 ? (o[c++] = 224 | s >>> 12,
                            o[c++] = 128 | s >>> 6 & 63,
                            o[c++] = 128 | 63 & s) : (s = 65536 + ((1023 & s) << 10 | 1023 & e.charCodeAt(++r)),
                            o[c++] = 240 | s >>> 18,
                            o[c++] = 128 | s >>> 12 & 63,
                            o[c++] = 128 | s >>> 6 & 63,
                            o[c++] = 128 | 63 & s);
                        e = o
                    } else {
                        if ("object" !== a)
                            throw new Error(t);
                        if (null === e)
                            throw new Error(t);
                        if (h && e.constructor === ArrayBuffer)
                            e = new Uint8Array(e);
                        else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                            throw new Error(t)
                    }
                    e.length > 64 && (e = new x(n,!0).update(e).array());
                    var d = []
                      , u = [];
                    for (r = 0; r < 64; ++r) {
                        var p = e[r] || 0;
                        d[r] = 92 ^ p,
                        u[r] = 54 ^ p
                    }
                    x.call(this, n, i),
                    this.update(u),
                    this.oKeyPad = d,
                    this.inner = !0,
                    this.sharedMemory = i
                }
                x.prototype.update = function(e) {
                    if (!this.finalized) {
                        var n, i = typeof e;
                        if ("string" !== i) {
                            if ("object" !== i)
                                throw new Error(t);
                            if (null === e)
                                throw new Error(t);
                            if (h && e.constructor === ArrayBuffer)
                                e = new Uint8Array(e);
                            else if (!(Array.isArray(e) || h && ArrayBuffer.isView(e)))
                                throw new Error(t);
                            n = !0
                        }
                        for (var r, a, s = 0, o = e.length, l = this.blocks; s < o; ) {
                            if (this.hashed && (this.hashed = !1,
                            l[0] = this.block,
                            this.block = l[16] = l[1] = l[2] = l[3] = l[4] = l[5] = l[6] = l[7] = l[8] = l[9] = l[10] = l[11] = l[12] = l[13] = l[14] = l[15] = 0),
                            n)
                                for (a = this.start; s < o && a < 64; ++s)
                                    l[a >>> 2] |= e[s] << p[3 & a++];
                            else
                                for (a = this.start; s < o && a < 64; ++s)
                                    (r = e.charCodeAt(s)) < 128 ? l[a >>> 2] |= r << p[3 & a++] : r < 2048 ? (l[a >>> 2] |= (192 | r >>> 6) << p[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]) : r < 55296 || r >= 57344 ? (l[a >>> 2] |= (224 | r >>> 12) << p[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 6 & 63) << p[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++s)),
                                    l[a >>> 2] |= (240 | r >>> 18) << p[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 12 & 63) << p[3 & a++],
                                    l[a >>> 2] |= (128 | r >>> 6 & 63) << p[3 & a++],
                                    l[a >>> 2] |= (128 | 63 & r) << p[3 & a++]);
                            this.lastByteIndex = a,
                            this.bytes += a - this.start,
                            a >= 64 ? (this.block = l[16],
                            this.start = a - 64,
                            this.hash(),
                            this.hashed = !0) : this.start = a
                        }
                        return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 | 0,
                        this.bytes = this.bytes % 4294967296),
                        this
                    }
                }
                ,
                x.prototype.finalize = function() {
                    if (!this.finalized) {
                        this.finalized = !0;
                        var e = this.blocks
                          , t = this.lastByteIndex;
                        e[16] = this.block,
                        e[t >>> 2] |= u[3 & t],
                        this.block = e[16],
                        t >= 56 && (this.hashed || this.hash(),
                        e[0] = this.block,
                        e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0),
                        e[14] = this.hBytes << 3 | this.bytes >>> 29,
                        e[15] = this.bytes << 3,
                        this.hash()
                    }
                }
                ,
                x.prototype.hash = function() {
                    var e, t, n, i, r, a, s, o, l, c = this.h0, h = this.h1, d = this.h2, u = this.h3, p = this.h4, g = this.h5, m = this.h6, A = this.h7, v = this.blocks;
                    for (e = 16; e < 64; ++e)
                        t = ((r = v[e - 15]) >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3,
                        n = ((r = v[e - 2]) >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10,
                        v[e] = v[e - 16] + t + v[e - 7] + n | 0;
                    for (l = h & d,
                    e = 0; e < 64; e += 4)
                        this.first ? (this.is224 ? (a = 300032,
                        A = (r = v[0] - 1413257819) - 150054599 | 0,
                        u = r + 24177077 | 0) : (a = 704751109,
                        A = (r = v[0] - 210244248) - 1521486534 | 0,
                        u = r + 143694565 | 0),
                        this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10),
                        i = (a = c & h) ^ c & d ^ l,
                        A = u + (r = A + (n = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & g ^ ~p & m) + f[e] + v[e]) | 0,
                        u = r + (t + i) | 0),
                        t = (u >>> 2 | u << 30) ^ (u >>> 13 | u << 19) ^ (u >>> 22 | u << 10),
                        i = (s = u & c) ^ u & h ^ a,
                        m = d + (r = m + (n = (A >>> 6 | A << 26) ^ (A >>> 11 | A << 21) ^ (A >>> 25 | A << 7)) + (A & p ^ ~A & g) + f[e + 1] + v[e + 1]) | 0,
                        t = ((d = r + (t + i) | 0) >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10),
                        i = (o = d & u) ^ d & c ^ s,
                        g = h + (r = g + (n = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7)) + (m & A ^ ~m & p) + f[e + 2] + v[e + 2]) | 0,
                        t = ((h = r + (t + i) | 0) >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10),
                        i = (l = h & d) ^ h & u ^ o,
                        p = c + (r = p + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & m ^ ~g & A) + f[e + 3] + v[e + 3]) | 0,
                        c = r + (t + i) | 0,
                        this.chromeBugWorkAround = !0;
                    this.h0 = this.h0 + c | 0,
                    this.h1 = this.h1 + h | 0,
                    this.h2 = this.h2 + d | 0,
                    this.h3 = this.h3 + u | 0,
                    this.h4 = this.h4 + p | 0,
                    this.h5 = this.h5 + g | 0,
                    this.h6 = this.h6 + m | 0,
                    this.h7 = this.h7 + A | 0
                }
                ,
                x.prototype.hex = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = d[e >>> 28 & 15] + d[e >>> 24 & 15] + d[e >>> 20 & 15] + d[e >>> 16 & 15] + d[e >>> 12 & 15] + d[e >>> 8 & 15] + d[e >>> 4 & 15] + d[15 & e] + d[t >>> 28 & 15] + d[t >>> 24 & 15] + d[t >>> 20 & 15] + d[t >>> 16 & 15] + d[t >>> 12 & 15] + d[t >>> 8 & 15] + d[t >>> 4 & 15] + d[15 & t] + d[n >>> 28 & 15] + d[n >>> 24 & 15] + d[n >>> 20 & 15] + d[n >>> 16 & 15] + d[n >>> 12 & 15] + d[n >>> 8 & 15] + d[n >>> 4 & 15] + d[15 & n] + d[i >>> 28 & 15] + d[i >>> 24 & 15] + d[i >>> 20 & 15] + d[i >>> 16 & 15] + d[i >>> 12 & 15] + d[i >>> 8 & 15] + d[i >>> 4 & 15] + d[15 & i] + d[r >>> 28 & 15] + d[r >>> 24 & 15] + d[r >>> 20 & 15] + d[r >>> 16 & 15] + d[r >>> 12 & 15] + d[r >>> 8 & 15] + d[r >>> 4 & 15] + d[15 & r] + d[a >>> 28 & 15] + d[a >>> 24 & 15] + d[a >>> 20 & 15] + d[a >>> 16 & 15] + d[a >>> 12 & 15] + d[a >>> 8 & 15] + d[a >>> 4 & 15] + d[15 & a] + d[s >>> 28 & 15] + d[s >>> 24 & 15] + d[s >>> 20 & 15] + d[s >>> 16 & 15] + d[s >>> 12 & 15] + d[s >>> 8 & 15] + d[s >>> 4 & 15] + d[15 & s];
                    return this.is224 || (l += d[o >>> 28 & 15] + d[o >>> 24 & 15] + d[o >>> 20 & 15] + d[o >>> 16 & 15] + d[o >>> 12 & 15] + d[o >>> 8 & 15] + d[o >>> 4 & 15] + d[15 & o]),
                    l
                }
                ,
                x.prototype.toString = x.prototype.hex,
                x.prototype.digest = function() {
                    this.finalize();
                    var e = this.h0
                      , t = this.h1
                      , n = this.h2
                      , i = this.h3
                      , r = this.h4
                      , a = this.h5
                      , s = this.h6
                      , o = this.h7
                      , l = [e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e, t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, 255 & t, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s];
                    return this.is224 || l.push(o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, 255 & o),
                    l
                }
                ,
                x.prototype.array = x.prototype.digest,
                x.prototype.arrayBuffer = function() {
                    this.finalize();
                    var e = new ArrayBuffer(this.is224 ? 28 : 32)
                      , t = new DataView(e);
                    return t.setUint32(0, this.h0),
                    t.setUint32(4, this.h1),
                    t.setUint32(8, this.h2),
                    t.setUint32(12, this.h3),
                    t.setUint32(16, this.h4),
                    t.setUint32(20, this.h5),
                    t.setUint32(24, this.h6),
                    this.is224 || t.setUint32(28, this.h7),
                    e
                }
                ,
                S.prototype = new x,
                S.prototype.finalize = function() {
                    if (x.prototype.finalize.call(this),
                    this.inner) {
                        this.inner = !1;
                        var e = this.array();
                        x.call(this, this.is224, this.sharedMemory),
                        this.update(this.oKeyPad),
                        this.update(e),
                        x.prototype.finalize.call(this)
                    }
                }
                ;
                var E = v();
                E.sha256 = E,
                E.sha224 = v(!0),
                E.sha256.hmac = b(),
                E.sha224.hmac = b(!0),
                l ? e.exports = E : (a.sha256 = E.sha256,
                a.sha224 = E.sha224,
                c && (void 0 === (i = function() {
                    return E
                }
                .call(E, n, E, e)) || (e.exports = i)))
            }()
        }
        ,
        1333: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/helmet.svg"
        }
        ,
        1411: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_horseshoe.svg"
        }
        ,
        1566: (e, t, n) => {
            "use strict";
            n.d(t, {
                _c: () => o,
                ec: () => s,
                pP: () => r
            });
            var i = n(4922);
            function r(e, t=!1) {
                const n = null !== e[0].index
                  , r = new Set(Object.keys(e[0].attributes))
                  , s = new Set(Object.keys(e[0].morphAttributes))
                  , o = {}
                  , l = {}
                  , c = e[0].morphTargetsRelative
                  , h = new i.LoY;
                let d = 0;
                for (let i = 0; i < e.length; ++i) {
                    const a = e[i];
                    let u = 0;
                    if (n !== (null !== a.index))
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
                        null;
                    for (const e in a.attributes) {
                        if (!r.has(e))
                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + e + '" attribute exists among all geometries, or in none of them.'),
                            null;
                        void 0 === o[e] && (o[e] = []),
                        o[e].push(a.attributes[e]),
                        u++
                    }
                    if (u !== r.size)
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes."),
                        null;
                    if (c !== a.morphTargetsRelative)
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries."),
                        null;
                    for (const e in a.morphAttributes) {
                        if (!s.has(e))
                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries."),
                            null;
                        void 0 === l[e] && (l[e] = []),
                        l[e].push(a.morphAttributes[e])
                    }
                    if (t) {
                        let e;
                        if (n)
                            e = a.index.count;
                        else {
                            if (void 0 === a.attributes.position)
                                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute"),
                                null;
                            e = a.attributes.position.count
                        }
                        h.addGroup(d, e, i),
                        d += e
                    }
                }
                if (n) {
                    let t = 0;
                    const n = [];
                    for (let i = 0; i < e.length; ++i) {
                        const r = e[i].index;
                        for (let e = 0; e < r.count; ++e)
                            n.push(r.getX(e) + t);
                        t += e[i].attributes.position.count
                    }
                    h.setIndex(n)
                }
                for (const e in o) {
                    const t = a(o[e]);
                    if (!t)
                        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " attribute."),
                        null;
                    h.setAttribute(e, t)
                }
                for (const e in l) {
                    const t = l[e][0].length;
                    if (0 === t)
                        break;
                    h.morphAttributes = h.morphAttributes || {},
                    h.morphAttributes[e] = [];
                    for (let n = 0; n < t; ++n) {
                        const t = [];
                        for (let i = 0; i < l[e].length; ++i)
                            t.push(l[e][i][n]);
                        const i = a(t);
                        if (!i)
                            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + e + " morphAttribute."),
                            null;
                        h.morphAttributes[e].push(i)
                    }
                }
                return h
            }
            function a(e) {
                let t, n, r, a = -1, s = 0;
                for (let i = 0; i < e.length; ++i) {
                    const o = e[i];
                    if (void 0 === t && (t = o.array.constructor),
                    t !== o.array.constructor)
                        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
                        null;
                    if (void 0 === n && (n = o.itemSize),
                    n !== o.itemSize)
                        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
                        null;
                    if (void 0 === r && (r = o.normalized),
                    r !== o.normalized)
                        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
                        null;
                    if (-1 === a && (a = o.gpuType),
                    a !== o.gpuType)
                        return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
                        null;
                    s += o.count * n
                }
                const o = new t(s)
                  , l = new i.THS(o,n,r);
                let c = 0;
                for (let t = 0; t < e.length; ++t) {
                    const i = e[t];
                    if (i.isInterleavedBufferAttribute) {
                        const e = c / n;
                        for (let t = 0, r = i.count; t < r; t++)
                            for (let r = 0; r < n; r++) {
                                const n = i.getComponent(t, r);
                                l.setComponent(t + e, r, n)
                            }
                    } else
                        o.set(i.array, c);
                    c += i.count * n
                }
                return void 0 !== a && (l.gpuType = a),
                l
            }
            function s(e, t=1e-4) {
                t = Math.max(t, Number.EPSILON);
                const n = {}
                  , i = e.getIndex()
                  , r = e.getAttribute("position")
                  , a = i ? i.count : r.count;
                let s = 0;
                const o = Object.keys(e.attributes)
                  , l = {}
                  , c = {}
                  , h = []
                  , d = ["getX", "getY", "getZ", "getW"]
                  , u = ["setX", "setY", "setZ", "setW"];
                for (let t = 0, n = o.length; t < n; t++) {
                    const n = o[t]
                      , i = e.attributes[n];
                    l[n] = new i.constructor(new i.array.constructor(i.count * i.itemSize),i.itemSize,i.normalized);
                    const r = e.morphAttributes[n];
                    r && (c[n] || (c[n] = []),
                    r.forEach(( (e, t) => {
                        const i = new e.array.constructor(e.count * e.itemSize);
                        c[n][t] = new e.constructor(i,e.itemSize,e.normalized)
                    }
                    )))
                }
                const p = .5 * t
                  , f = Math.log10(1 / t)
                  , g = Math.pow(10, f)
                  , m = p * g;
                for (let t = 0; t < a; t++) {
                    const r = i ? i.getX(t) : t;
                    let a = "";
                    for (let t = 0, n = o.length; t < n; t++) {
                        const n = o[t]
                          , i = e.getAttribute(n)
                          , s = i.itemSize;
                        for (let e = 0; e < s; e++)
                            a += ~~(i[d[e]](r) * g + m) + ","
                    }
                    if (a in n)
                        h.push(n[a]);
                    else {
                        for (let t = 0, n = o.length; t < n; t++) {
                            const n = o[t]
                              , i = e.getAttribute(n)
                              , a = e.morphAttributes[n]
                              , h = i.itemSize
                              , p = l[n]
                              , f = c[n];
                            for (let e = 0; e < h; e++) {
                                const t = d[e]
                                  , n = u[e];
                                if (p[n](s, i[t](r)),
                                a)
                                    for (let e = 0, i = a.length; e < i; e++)
                                        f[e][n](s, a[e][t](r))
                            }
                        }
                        n[a] = s,
                        h.push(s),
                        s++
                    }
                }
                const A = e.clone();
                for (const t in e.attributes) {
                    const e = l[t];
                    if (A.setAttribute(t, new e.constructor(e.array.slice(0, s * e.itemSize),e.itemSize,e.normalized)),
                    t in c)
                        for (let e = 0; e < c[t].length; e++) {
                            const n = c[t][e];
                            A.morphAttributes[t][e] = new n.constructor(n.array.slice(0, s * n.itemSize),n.itemSize,n.normalized)
                        }
                }
                return A.setIndex(h),
                A
            }
            function o(e, t) {
                if (t === i.RJ4)
                    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                    e;
                if (t === i.rYR || t === i.O49) {
                    let n = e.getIndex();
                    if (null === n) {
                        const t = []
                          , i = e.getAttribute("position");
                        if (void 0 === i)
                            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                            e;
                        for (let e = 0; e < i.count; e++)
                            t.push(e);
                        e.setIndex(t),
                        n = e.getIndex()
                    }
                    const r = n.count - 2
                      , a = [];
                    if (t === i.rYR)
                        for (let e = 1; e <= r; e++)
                            a.push(n.getX(0)),
                            a.push(n.getX(e)),
                            a.push(n.getX(e + 1));
                    else
                        for (let e = 0; e < r; e++)
                            e % 2 == 0 ? (a.push(n.getX(e)),
                            a.push(n.getX(e + 1)),
                            a.push(n.getX(e + 2))) : (a.push(n.getX(e + 2)),
                            a.push(n.getX(e + 1)),
                            a.push(n.getX(e)));
                    a.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    const s = e.clone();
                    return s.setIndex(a),
                    s.clearGroups(),
                    s
                }
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
                e
            }
        }
        ,
        1601: e => {
            "use strict";
            e.exports = function(e) {
                return e[1]
            }
        }
        ,
        1635: (e, t, n) => {
            "use strict";
            n.d(t, {
                GG: () => r,
                gn: () => i
            });
            Object.create;
            Object.create;
            function i(e, t, n, i) {
                if ("a" === n && !i)
                    throw new TypeError("Private accessor was defined without a getter");
                if ("function" == typeof t ? e !== t || !i : !t.has(e))
                    throw new TypeError("Cannot read private member from an object whose class did not declare it");
                return "m" === n ? i : "a" === n ? i.call(e) : i ? i.value : t.get(e)
            }
            function r(e, t, n, i, r) {
                if ("m" === i)
                    throw new TypeError("Private method is not writable");
                if ("a" === i && !r)
                    throw new TypeError("Private accessor was defined without a setter");
                if ("function" == typeof t ? e !== t || !r : !t.has(e))
                    throw new TypeError("Cannot write private member to an object whose class did not declare it");
                return "a" === i ? r.call(e, n) : r ? r.value = n : t.set(e, n),
                n
            }
            "function" == typeof SuppressedError && SuppressedError
        }
        ,
        1705: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/desert.svg"
        }
        ,
        1719: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/reset.svg"
        }
        ,
        1728: (e, t, n) => {
            "use strict";
            n.d(t, {
                Z: () => a
            });
            var i = n(4922);
            const r = new WeakMap;
            class a extends i.aHM {
                constructor(e) {
                    super(e),
                    this.decoderPath = "",
                    this.decoderConfig = {},
                    this.decoderBinary = null,
                    this.decoderPending = null,
                    this.workerLimit = 4,
                    this.workerPool = [],
                    this.workerNextTaskID = 1,
                    this.workerSourceURL = "",
                    this.defaultAttributeIDs = {
                        position: "POSITION",
                        normal: "NORMAL",
                        color: "COLOR",
                        uv: "TEX_COORD"
                    },
                    this.defaultAttributeTypes = {
                        position: "Float32Array",
                        normal: "Float32Array",
                        color: "Float32Array",
                        uv: "Float32Array"
                    }
                }
                setDecoderPath(e) {
                    return this.decoderPath = e,
                    this
                }
                setDecoderConfig(e) {
                    return this.decoderConfig = e,
                    this
                }
                setWorkerLimit(e) {
                    return this.workerLimit = e,
                    this
                }
                load(e, t, n, r) {
                    const a = new i.Y9S(this.manager);
                    a.setPath(this.path),
                    a.setResponseType("arraybuffer"),
                    a.setRequestHeader(this.requestHeader),
                    a.setWithCredentials(this.withCredentials),
                    a.load(e, (e => {
                        this.parse(e, t, r)
                    }
                    ), n, r)
                }
                parse(e, t, n= () => {}
                ) {
                    this.decodeDracoFile(e, t, null, null, i.er$, n).catch(n)
                }
                decodeDracoFile(e, t, n, r, a=i.Zr2, s= () => {}
                ) {
                    const o = {
                        attributeIDs: n || this.defaultAttributeIDs,
                        attributeTypes: r || this.defaultAttributeTypes,
                        useUniqueIDs: !!n,
                        vertexColorSpace: a
                    };
                    return this.decodeGeometry(e, o).then(t).catch(s)
                }
                decodeGeometry(e, t) {
                    const n = JSON.stringify(t);
                    if (r.has(e)) {
                        const t = r.get(e);
                        if (t.key === n)
                            return t.promise;
                        if (0 === e.byteLength)
                            throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                    }
                    let i;
                    const a = this.workerNextTaskID++
                      , s = e.byteLength
                      , o = this._getWorker(a, s).then((n => (i = n,
                    new Promise(( (n, r) => {
                        i._callbacks[a] = {
                            resolve: n,
                            reject: r
                        },
                        i.postMessage({
                            type: "decode",
                            id: a,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }
                    ))))).then((e => this._createGeometry(e.geometry)));
                    return o.catch(( () => !0)).then(( () => {
                        i && a && this._releaseTask(i, a)
                    }
                    )),
                    r.set(e, {
                        key: n,
                        promise: o
                    }),
                    o
                }
                _createGeometry(e) {
                    const t = new i.LoY;
                    e.index && t.setIndex(new i.THS(e.index.array,1));
                    for (let n = 0; n < e.attributes.length; n++) {
                        const {name: r, array: a, itemSize: s, stride: o, vertexColorSpace: l} = e.attributes[n];
                        let c;
                        if (s === o)
                            c = new i.THS(a,s);
                        else {
                            const e = new i.eB$(a,o);
                            c = new i.eHs(e,s,0)
                        }
                        "color" === r && (this._assignVertexColorSpace(c, l),
                        c.normalized = a instanceof Float32Array == !1),
                        t.setAttribute(r, c)
                    }
                    return t
                }
                _assignVertexColorSpace(e, t) {
                    if (t !== i.er$)
                        return;
                    const n = new i.Q1f;
                    for (let t = 0, r = e.count; t < r; t++)
                        n.fromBufferAttribute(e, t),
                        i.ppV.colorSpaceToWorking(n, i.er$),
                        e.setXYZ(t, n.r, n.g, n.b)
                }
                _loadLibrary(e, t) {
                    const n = new i.Y9S(this.manager);
                    return n.setPath(this.decoderPath),
                    n.setResponseType(t),
                    n.setWithCredentials(this.withCredentials),
                    new Promise(( (t, i) => {
                        n.load(e, t, void 0, i)
                    }
                    ))
                }
                preload() {
                    return this._initDecoder(),
                    this
                }
                _initDecoder() {
                    if (this.decoderPending)
                        return this.decoderPending;
                    const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                      , t = [];
                    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                    t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                    this.decoderPending = Promise.all(t).then((t => {
                        const n = t[0];
                        e || (this.decoderConfig.wasmBinary = t[1]);
                        const i = s.toString()
                          , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                    }
                    )),
                    this.decoderPending
                }
                _getWorker(e, t) {
                    return this._initDecoder().then(( () => {
                        if (this.workerPool.length < this.workerLimit) {
                            const e = new Worker(this.workerSourceURL);
                            e._callbacks = {},
                            e._taskCosts = {},
                            e._taskLoad = 0,
                            e.postMessage({
                                type: "init",
                                decoderConfig: this.decoderConfig
                            }),
                            e.onmessage = function(t) {
                                const n = t.data;
                                switch (n.type) {
                                case "decode":
                                    e._callbacks[n.id].resolve(n);
                                    break;
                                case "error":
                                    e._callbacks[n.id].reject(n);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                                }
                            }
                            ,
                            this.workerPool.push(e)
                        } else
                            this.workerPool.sort((function(e, t) {
                                return e._taskLoad > t._taskLoad ? -1 : 1
                            }
                            ));
                        const n = this.workerPool[this.workerPool.length - 1];
                        return n._taskCosts[e] = t,
                        n._taskLoad += t,
                        n
                    }
                    ))
                }
                _releaseTask(e, t) {
                    e._taskLoad -= e._taskCosts[t],
                    delete e._callbacks[t],
                    delete e._taskCosts[t]
                }
                debug() {
                    console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
                }
                dispose() {
                    for (let e = 0; e < this.workerPool.length; ++e)
                        this.workerPool[e].terminate();
                    return this.workerPool.length = 0,
                    "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                    this
                }
            }
            function s() {
                let e, t;
                function n(e, t, n, i, r, a) {
                    const s = n.num_points()
                      , o = a.num_components()
                      , l = function(e, t) {
                        switch (t) {
                        case Float32Array:
                            return e.DT_FLOAT32;
                        case Int8Array:
                            return e.DT_INT8;
                        case Int16Array:
                            return e.DT_INT16;
                        case Int32Array:
                            return e.DT_INT32;
                        case Uint8Array:
                            return e.DT_UINT8;
                        case Uint16Array:
                            return e.DT_UINT16;
                        case Uint32Array:
                            return e.DT_UINT32
                        }
                    }(e, r)
                      , c = o * r.BYTES_PER_ELEMENT
                      , h = 4 * Math.ceil(c / 4)
                      , d = h / r.BYTES_PER_ELEMENT
                      , u = s * c
                      , p = s * h
                      , f = e._malloc(u);
                    t.GetAttributeDataArrayForAllPoints(n, a, l, u, f);
                    const g = new r(e.HEAPF32.buffer,f,u / r.BYTES_PER_ELEMENT);
                    let m;
                    if (c === h)
                        m = g.slice();
                    else {
                        m = new r(p / r.BYTES_PER_ELEMENT);
                        let e = 0;
                        for (let t = 0, n = g.length; t < n; t++) {
                            for (let n = 0; n < o; n++)
                                m[e + n] = g[t * o + n];
                            e += d
                        }
                    }
                    return e._free(f),
                    {
                        name: i,
                        count: s,
                        itemSize: o,
                        array: m,
                        stride: d
                    }
                }
                onmessage = function(i) {
                    const r = i.data;
                    switch (r.type) {
                    case "init":
                        e = r.decoderConfig,
                        t = new Promise((function(t) {
                            e.onModuleLoaded = function(e) {
                                t({
                                    draco: e
                                })
                            }
                            ,
                            DracoDecoderModule(e)
                        }
                        ));
                        break;
                    case "decode":
                        const i = r.buffer
                          , a = r.taskConfig;
                        t.then((e => {
                            const t = e.draco
                              , s = new t.Decoder;
                            try {
                                const e = function(e, t, i, r) {
                                    const a = r.attributeIDs
                                      , s = r.attributeTypes;
                                    let o, l;
                                    const c = t.GetEncodedGeometryType(i);
                                    if (c === e.TRIANGULAR_MESH)
                                        o = new e.Mesh,
                                        l = t.DecodeArrayToMesh(i, i.byteLength, o);
                                    else {
                                        if (c !== e.POINT_CLOUD)
                                            throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                        o = new e.PointCloud,
                                        l = t.DecodeArrayToPointCloud(i, i.byteLength, o)
                                    }
                                    if (!l.ok() || 0 === o.ptr)
                                        throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                    const h = {
                                        index: null,
                                        attributes: []
                                    };
                                    for (const i in a) {
                                        const l = self[s[i]];
                                        let c, d;
                                        if (r.useUniqueIDs)
                                            d = a[i],
                                            c = t.GetAttributeByUniqueId(o, d);
                                        else {
                                            if (d = t.GetAttributeId(o, e[a[i]]),
                                            -1 === d)
                                                continue;
                                            c = t.GetAttribute(o, d)
                                        }
                                        const u = n(e, t, o, i, l, c);
                                        "color" === i && (u.vertexColorSpace = r.vertexColorSpace),
                                        h.attributes.push(u)
                                    }
                                    c === e.TRIANGULAR_MESH && (h.index = function(e, t, n) {
                                        const i = n.num_faces()
                                          , r = 3 * i
                                          , a = 4 * r
                                          , s = e._malloc(a);
                                        t.GetTrianglesUInt32Array(n, a, s);
                                        const o = new Uint32Array(e.HEAPF32.buffer,s,r).slice();
                                        return e._free(s),
                                        {
                                            array: o,
                                            itemSize: 1
                                        }
                                    }(e, t, o));
                                    return e.destroy(o),
                                    h
                                }(t, s, new Int8Array(i), a)
                                  , o = e.attributes.map((e => e.array.buffer));
                                e.index && o.push(e.index.array.buffer),
                                self.postMessage({
                                    type: "decode",
                                    id: r.id,
                                    geometry: e
                                }, o)
                            } catch (e) {
                                console.error(e),
                                self.postMessage({
                                    type: "error",
                                    id: r.id,
                                    error: e.message
                                })
                            } finally {
                                t.destroy(s)
                            }
                        }
                        ))
                    }
                }
            }
        }
        ,
        1734: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/test.svg"
        }
        ,
        1758: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/desert_colored.svg"
        }
        ,
        1784: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/cancel.svg"
        }
        ,
        1820: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/paper.svg"
        }
        ,
        1882: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.Special = 0] = "Special",
                e[e.Road = 1] = "Road",
                e[e.RoadTurns = 2] = "RoadTurns",
                e[e.RoadWide = 3] = "RoadWide",
                e[e.Plane = 4] = "Plane",
                e[e.Block = 5] = "Block",
                e[e.WallTrack = 6] = "WallTrack",
                e[e.Pillar = 7] = "Pillar",
                e[e.Sign = 8] = "Sign"
            }(i || (i = {}));
            const r = i
        }
        ,
        1901: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".player-list-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: calc(50% - 750px / 2);\n\ttop: 150px;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 750px;\n\theight: calc(100% - 150px * 2);\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n}\n\n.player-list-ui > h2 {\n\tmargin: 0;\n\tpadding: 10px 20px;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.player-list-ui > .content {\n\tmargin: 0;\n\tpadding: 10px 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n\tmin-height: 0;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: auto;\n\tpointer-events: auto;\n}\n\n.player-list-ui > .content > div {\n\tdisplay: flex;\n\talign-items: stretch;\n\tmargin: 0 10px;\n\tpadding: 0;\n\theight: 50px;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n}\n.player-list-ui > .content > div:not(:last-of-type) {\n\tmargin: 0 10px 5px 10px;\n}\n\n.player-list-ui > .content > div > div, .player-list-ui > .content > div > .car-thumbnail {\n\tbackground-color: var(--button-color);\n}\n.player-list-ui > .content > div.self > div, .player-list-ui > .content > div.self > .car-thumbnail {\n\tbackground-color: #2e4182;\n}\n\n.player-list-ui > .content > div > .position, .player-list-ui > .content > div > .time {\n\tmargin-right: 5px;\n}\n\n.player-list-ui > .content > div > .car-thumbnail {\n\tdisplay: inline-block;\n\tmargin: 0 5px 0 0;\n\tpadding: 0;\n\tbox-sizing: border-box;\n\twidth: 50px;\n\theight: 50px;\n}\n\n.player-list-ui > .content > div > .position {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tpadding: 0 10px;\n\tflex-shrink: 0;\n\tmin-width: 66px;\n\ttext-align: center;\n}\n\n.player-list-ui > .content > div > .position > span {\n\tfont-size: 20px;\n\topacity: 0.3;\n}\n\n.player-list-ui > .content > div > .time {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tpadding: 0 10px;\n\tflex-shrink: 0;\n\twidth: 110px;\n\ttext-align: center;\n}\n\n.player-list-ui > .content > div > .nickname {\n\tdisplay: flex;\n\talign-items: center;\n\tmargin: 0 5px 0 0;\n\tpadding: 0 10px;\n\tflex-grow: 1;\n\tmin-width: 0;\n}\n\n.player-list-ui > .content > div > .nickname > .country-flag {\n\tmargin: 0 10px 0 0;\n\t/* Flag aspect ratio is 4:3. */\n\twidth: 32px;\n\theight: 24px;\n\tfilter: drop-shadow(2px 2px 1px rgba(0, 0, 0, 0.5)); /* box-shadow cannot be used because of Nepal. */\n}\n\n.player-list-ui > .content > div > .nickname > span:first-of-type {\n\t/* Prevent italic text from being cut off. */\n\tmargin-right: -4px;\n\tpadding-right: 4px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\twhite-space: nowrap;\n}\n\n.player-list-ui > .content > div > .nickname > .self {\n\tmargin: 0 0 -2px 0;\n\tpadding: 10px;\n\topacity: 0.5;\n\tfont-size: 16px;\n}\n\n.player-list-ui > .content > div > .ping {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\tpadding: 0 10px;\n\tflex-shrink: 0;\n\twidth: 60px;\n\ttext-align: center;\n}\n\n.player-list-ui > .content > div > .ping > span {\n\tfont-size: 20px;\n\topacity: 0.3;\n}\n\n.player-list-ui > .content > div > .kick-button, .player-list-ui > .content > div > .kick-button-placeholder {\n\tflex-shrink: 0;\n\tmargin: 0 0 0 5px;\n\tpadding: 4px;\n\tbox-sizing: border-box;\n\twidth: 50px;\n\theight: 50px;\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);\n}\n.player-list-ui > .content > div.self > .kick-button-placeholder {\n\tbackground-color: #2e4182;\n}\n\n.player-list-ui > .bottom-container {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tpadding: 10px;\n}\n\n.player-list-ui > .bottom-container > .session-ended-text {\n\tflex-grow: 1;\n\talign-self: center;\n\ttext-align: center;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n", ""]);
            const o = s
        }
        ,
        1903: () => {}
        ,
        1925: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/copy.svg"
        }
        ,
        1936: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/erase.svg"
        }
        ,
        2108: (e, t, n) => {
            "use strict";
            n.d(t, {
                VO: () => r,
                _c: () => i
            });
            function i(e) {
                let t = 0;
                t += 3,
                t += 4,
                t += 1,
                null != e.finishFrames && (t += 3),
                t += 2,
                t += 12,
                t += 16,
                t += 1 + 4 * e.collisionImpulses.length;
                for (const n of e.wheelContact)
                    null != n && (t += 24);
                t += 16,
                t += 16,
                t += 16,
                t += 16,
                t += 4,
                t += 1;
                let n = 0;
                const i = new Uint8Array(t);
                i.set(new Uint8Array(new Uint32Array([e.frames]).buffer).subarray(0, 3), n),
                n += 3,
                i.set(new Uint8Array(new Float32Array([e.speedKmh]).buffer), n),
                n += 4,
                i[n] = (e.hasStarted ? 1 : 0) | (null != e.finishFrames ? 1 : 0) << 1 | (e.hasCheckpointToRespawnAt ? 1 : 0) << 2 | (null != e.wheelContact[0] ? 1 : 0) << 3 | (null != e.wheelContact[1] ? 1 : 0) << 4 | (null != e.wheelContact[2] ? 1 : 0) << 5 | (null != e.wheelContact[3] ? 1 : 0) << 6,
                n += 1,
                null != e.finishFrames && (i.set(new Uint8Array(new Uint32Array([e.finishFrames]).buffer).subarray(0, 3), n),
                n += 3),
                i.set(new Uint8Array(new Uint16Array([e.nextCheckpointIndex]).buffer), n),
                n += 2,
                i.set(new Uint8Array(new Float32Array([e.position.x, e.position.y, e.position.z]).buffer), n),
                n += 12,
                i.set(new Uint8Array(new Float32Array([e.quaternion.x, e.quaternion.y, e.quaternion.z, e.quaternion.w]).buffer), n),
                n += 16,
                i[n + 0] = 255 & e.collisionImpulses.length,
                n += 1,
                i.set(new Uint8Array(new Float32Array(e.collisionImpulses).buffer), n),
                n += 4 * e.collisionImpulses.length;
                for (const t of e.wheelContact)
                    null != t && (i.set(new Uint8Array(new Float32Array([t.position.x, t.position.y, t.position.z]).buffer), n),
                    n += 12,
                    i.set(new Uint8Array(new Float32Array([t.normal.x, t.normal.y, t.normal.z]).buffer), n),
                    n += 12);
                return i.set(new Uint8Array(new Float32Array(e.wheelSuspensionLength).buffer), n),
                n += 16,
                i.set(new Uint8Array(new Float32Array(e.wheelSuspensionVelocity).buffer), n),
                n += 16,
                i.set(new Uint8Array(new Float32Array(e.wheelDeltaRotation).buffer), n),
                n += 16,
                i.set(new Uint8Array(new Float32Array(e.wheelSkidInfo).buffer), n),
                n += 16,
                i.set(new Uint8Array(new Float32Array([e.steering]).buffer), n),
                n += 4,
                i[n] = (e.controls.up ? 1 : 0) | (e.controls.right ? 1 : 0) << 1 | (e.controls.down ? 1 : 0) << 2 | (e.controls.left ? 1 : 0) << 3 | (e.controls.reset ? 1 : 0) << 4 | (e.brakeLightEnabled ? 1 : 0) << 5,
                n += 1,
                i
            }
            function r(e) {
                const t = "CarState data is too short"
                  , n = new DataView(e.buffer,e.byteOffset,e.byteLength);
                let i = 0;
                if (e.length < i + 3)
                    throw new Error(t);
                const r = e[i] | e[i + 1] << 8 | e[i + 2] << 16;
                if (i += 3,
                e.length < i + 4)
                    throw new Error(t);
                const a = n.getFloat32(i, !0);
                if (i += 4,
                e.length < i + 1)
                    throw new Error(t);
                const s = !!(1 & e[i])
                  , o = !!(2 & e[i])
                  , l = !!(4 & e[i])
                  , c = [!!(8 & e[i]), !!(16 & e[i]), !!(32 & e[i]), !!(64 & e[i])];
                if (i += 1,
                e.length < i + 1)
                    throw new Error(t);
                let h;
                if (o) {
                    if (e.length < i + 3)
                        throw new Error(t);
                    h = e[i] | e[i + 1] << 8 | e[i + 2] << 16,
                    i += 3
                } else
                    h = null;
                if (e.length < i + 2)
                    throw new Error(t);
                const d = n.getUint16(i, !0);
                if (i += 2,
                e.length < i + 12)
                    throw new Error(t);
                const u = {
                    x: n.getFloat32(i, !0),
                    y: n.getFloat32(i + 4, !0),
                    z: n.getFloat32(i + 8, !0)
                };
                if (i += 12,
                e.length < i + 16)
                    throw new Error(t);
                const p = {
                    x: n.getFloat32(i, !0),
                    y: n.getFloat32(i + 4, !0),
                    z: n.getFloat32(i + 8, !0),
                    w: n.getFloat32(i + 12, !0)
                };
                if (i += 16,
                e.length < i + 1)
                    throw new Error(t);
                const f = n.getUint8(i);
                if (i += 1,
                f > 4)
                    throw new Error("Number of collision impulses exceeds maximum allowed");
                const g = [];
                for (let r = 0; r < f; r++) {
                    if (e.length < i + 4)
                        throw new Error(t);
                    g.push(n.getFloat32(i, !0)),
                    i += 4
                }
                const m = [null, null, null, null];
                for (let r = 0; r < 4; r++)
                    if (c[r]) {
                        if (e.length < i + 24)
                            throw new Error(t);
                        const a = {
                            x: n.getFloat32(i, !0),
                            y: n.getFloat32(i + 4, !0),
                            z: n.getFloat32(i + 8, !0)
                        };
                        i += 12;
                        const s = {
                            x: n.getFloat32(i, !0),
                            y: n.getFloat32(i + 4, !0),
                            z: n.getFloat32(i + 8, !0)
                        };
                        i += 12,
                        m[r] = {
                            position: a,
                            normal: s
                        }
                    }
                const A = [0, 0, 0, 0];
                for (let r = 0; r < 4; r++) {
                    if (e.length < i + 4)
                        throw new Error(t);
                    A[r] = n.getFloat32(i, !0),
                    i += 4
                }
                const v = [0, 0, 0, 0];
                for (let r = 0; r < 4; r++) {
                    if (e.length < i + 4)
                        throw new Error(t);
                    v[r] = n.getFloat32(i, !0),
                    i += 4
                }
                const y = [0, 0, 0, 0];
                for (let r = 0; r < 4; r++) {
                    if (e.length < i + 4)
                        throw new Error(t);
                    y[r] = n.getFloat32(i, !0),
                    i += 4
                }
                const w = [0, 0, 0, 0];
                for (let r = 0; r < 4; r++) {
                    if (e.length < i + 4)
                        throw new Error(t);
                    w[r] = n.getFloat32(i, !0),
                    i += 4
                }
                if (e.length < i + 4)
                    throw new Error(t);
                const b = n.getFloat32(i, !0);
                if (i += 4,
                e.length < i + 1)
                    throw new Error(t);
                const x = {
                    up: !!(1 & e[i]),
                    right: !!(2 & e[i]),
                    down: !!(4 & e[i]),
                    left: !!(8 & e[i]),
                    reset: !!(16 & e[i])
                }
                  , S = !!(32 & e[i]);
                return i += 1,
                {
                    numberOfBytes: i,
                    carState: {
                        frames: r,
                        speedKmh: a,
                        hasStarted: s,
                        finishFrames: h,
                        nextCheckpointIndex: d,
                        hasCheckpointToRespawnAt: l,
                        position: u,
                        quaternion: p,
                        collisionImpulses: g,
                        wheelContact: m,
                        wheelSuspensionLength: A,
                        wheelSuspensionVelocity: v,
                        wheelDeltaRotation: y,
                        wheelSkidInfo: w,
                        steering: b,
                        brakeLightEnabled: S,
                        controls: x
                    }
                }
            }
        }
        ,
        2175: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/random.svg"
        }
        ,
        2203: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.Straight = 0] = "Straight",
                e[e.TurnSharp = 1] = "TurnSharp",
                e[e.SlopeUp = 2] = "SlopeUp",
                e[e.SlopeDown = 3] = "SlopeDown",
                e[e.Slope = 4] = "Slope",
                e[e.Start = 5] = "Start",
                e[e.Finish = 6] = "Finish",
                e[e.ToWideMiddle = 7] = "ToWideMiddle",
                e[e.ToWideLeft = 8] = "ToWideLeft",
                e[e.ToWideRight = 9] = "ToWideRight",
                e[e.StraightWide = 10] = "StraightWide",
                e[e.InnerCornerWide = 11] = "InnerCornerWide",
                e[e.OuterCornerWide = 12] = "OuterCornerWide",
                e[e.SlopeUpLeftWide = 13] = "SlopeUpLeftWide",
                e[e.SlopeUpRightWide = 14] = "SlopeUpRightWide",
                e[e.SlopeDownLeftWide = 15] = "SlopeDownLeftWide",
                e[e.SlopeDownRightWide = 16] = "SlopeDownRightWide",
                e[e.SlopeLeftWide = 17] = "SlopeLeftWide",
                e[e.SlopeRightWide = 18] = "SlopeRightWide",
                e[e.PillarTop = 19] = "PillarTop",
                e[e.PillarMiddle = 20] = "PillarMiddle",
                e[e.PillarBottom = 21] = "PillarBottom",
                e[e.PillarShort = 22] = "PillarShort",
                e[e.PlanePillarBottom = 23] = "PlanePillarBottom",
                e[e.PlanePillarShort = 24] = "PlanePillarShort",
                e[e.Plane = 25] = "Plane",
                e[e.PlaneWall = 26] = "PlaneWall",
                e[e.PlaneWallCorner = 27] = "PlaneWallCorner",
                e[e.PlaneWallInnerCorner = 28] = "PlaneWallInnerCorner",
                e[e.Block = 29] = "Block",
                e[e.WallTrackTop = 30] = "WallTrackTop",
                e[e.WallTrackMiddle = 31] = "WallTrackMiddle",
                e[e.WallTrackBottom = 32] = "WallTrackBottom",
                e[e.PlaneSlopeUp = 33] = "PlaneSlopeUp",
                e[e.PlaneSlopeDown = 34] = "PlaneSlopeDown",
                e[e.PlaneSlope = 35] = "PlaneSlope",
                e[e.TurnShort = 36] = "TurnShort",
                e[e.TurnLong = 37] = "TurnLong",
                e[e.SlopeUpLong = 38] = "SlopeUpLong",
                e[e.SlopeDownLong = 39] = "SlopeDownLong",
                e[e.TurnSLeft = 41] = "TurnSLeft",
                e[e.TurnSRight = 42] = "TurnSRight",
                e[e.IntersectionT = 43] = "IntersectionT",
                e[e.IntersectionCross = 44] = "IntersectionCross",
                e[e.PillarBranch1 = 45] = "PillarBranch1",
                e[e.PillarBranch2 = 46] = "PillarBranch2",
                e[e.PillarBranch3 = 47] = "PillarBranch3",
                e[e.PillarBranch4 = 48] = "PillarBranch4",
                e[e.WallTrackBottomCorner = 49] = "WallTrackBottomCorner",
                e[e.WallTrackMiddleCorner = 50] = "WallTrackMiddleCorner",
                e[e.WallTrackTopCorner = 51] = "WallTrackTopCorner",
                e[e.Checkpoint = 52] = "Checkpoint",
                e[e.HalfBlock = 53] = "HalfBlock",
                e[e.QuarterBlock = 54] = "QuarterBlock",
                e[e.HalfPlane = 55] = "HalfPlane",
                e[e.QuarterPlane = 56] = "QuarterPlane",
                e[e.PlaneBridge = 57] = "PlaneBridge",
                e[e.SignArrowLeft = 58] = "SignArrowLeft",
                e[e.SignArrowRight = 59] = "SignArrowRight",
                e[e.SignArrowUp = 61] = "SignArrowUp",
                e[e.SignArrowDown = 62] = "SignArrowDown",
                e[e.SignWarning = 63] = "SignWarning",
                e[e.SignWrongWay = 64] = "SignWrongWay",
                e[e.CheckpointWide = 65] = "CheckpointWide",
                e[e.WallTrackCeiling = 66] = "WallTrackCeiling",
                e[e.WallTrackFloor = 67] = "WallTrackFloor",
                e[e.BlockSlopedDown = 68] = "BlockSlopedDown",
                e[e.BlockSlopedDownInnerCorner = 69] = "BlockSlopedDownInnerCorner",
                e[e.BlockSlopedDownOuterCorner = 70] = "BlockSlopedDownOuterCorner",
                e[e.BlockSlopedUp = 71] = "BlockSlopedUp",
                e[e.BlockSlopedUpInnerCorner = 72] = "BlockSlopedUpInnerCorner",
                e[e.BlockSlopedUpOuterCorner = 73] = "BlockSlopedUpOuterCorner",
                e[e.FinishWide = 74] = "FinishWide",
                e[e.PlaneCheckpoint = 75] = "PlaneCheckpoint",
                e[e.PlaneFinish = 76] = "PlaneFinish",
                e[e.PlaneCheckpointWide = 77] = "PlaneCheckpointWide",
                e[e.PlaneFinishWide = 78] = "PlaneFinishWide",
                e[e.WallTrackBottomInnerCorner = 79] = "WallTrackBottomInnerCorner",
                e[e.WallTrackInnerCorner = 80] = "WallTrackInnerCorner",
                e[e.WallTrackTopInnerCorner = 81] = "WallTrackTopInnerCorner",
                e[e.TurnLong2 = 82] = "TurnLong2",
                e[e.TurnLong3 = 83] = "TurnLong3",
                e[e.BlockSlopeUp = 85] = "BlockSlopeUp",
                e[e.BlockSlopeDown = 86] = "BlockSlopeDown",
                e[e.BlockSlopeVerticalTop = 87] = "BlockSlopeVerticalTop",
                e[e.BlockSlopeVerticalBottom = 88] = "BlockSlopeVerticalBottom",
                e[e.PlaneSlopeVerticalBottom = 90] = "PlaneSlopeVerticalBottom",
                e[e.StartWide = 91] = "StartWide",
                e[e.PlaneStart = 92] = "PlaneStart",
                e[e.PlaneStartWide = 93] = "PlaneStartWide",
                e[e.TurnShortLeftWide = 94] = "TurnShortLeftWide",
                e[e.TurnShortRightWide = 95] = "TurnShortRightWide",
                e[e.TurnLongLeftWide = 96] = "TurnLongLeftWide",
                e[e.TurnLongRightWide = 97] = "TurnLongRightWide",
                e[e.SlopeUpVertical = 98] = "SlopeUpVertical",
                e[e.IntersectionY = 99] = "IntersectionY",
                e[e.IntersectionYLong = 100] = "IntersectionYLong",
                e[e.PillarBranch1Top = 101] = "PillarBranch1Top",
                e[e.PillarBranch1Bottom = 102] = "PillarBranch1Bottom",
                e[e.PillarBranch1Middle = 103] = "PillarBranch1Middle",
                e[e.PillarBranch2Top = 104] = "PillarBranch2Top",
                e[e.PillarBranch2Middle = 105] = "PillarBranch2Middle",
                e[e.PillarBranch2Bottom = 106] = "PillarBranch2Bottom",
                e[e.PillarBranch3Top = 107] = "PillarBranch3Top",
                e[e.PillarBranch3Middle = 108] = "PillarBranch3Middle",
                e[e.PillarBranch3Bottom = 109] = "PillarBranch3Bottom",
                e[e.PillarBranch4Top = 110] = "PillarBranch4Top",
                e[e.PillarBranch4Middle = 111] = "PillarBranch4Middle",
                e[e.PillarBranch4Bottom = 112] = "PillarBranch4Bottom",
                e[e.PillarBranch5 = 113] = "PillarBranch5",
                e[e.PillarBranch5Top = 114] = "PillarBranch5Top",
                e[e.PillarBranch5Middle = 115] = "PillarBranch5Middle",
                e[e.PillarBranch5Bottom = 116] = "PillarBranch5Bottom",
                e[e.ToWideDouble = 117] = "ToWideDouble",
                e[e.ToWideDiagonal = 118] = "ToWideDiagonal",
                e[e.StraightPillarBottom = 119] = "StraightPillarBottom",
                e[e.StraightPillarShort = 120] = "StraightPillarShort",
                e[e.TurnSharpPillarBottom = 121] = "TurnSharpPillarBottom",
                e[e.TurnSharpPillarShort = 122] = "TurnSharpPillarShort",
                e[e.IntersectionTPillarBottom = 123] = "IntersectionTPillarBottom",
                e[e.IntersectionTPillarShort = 124] = "IntersectionTPillarShort",
                e[e.IntersectionCrossPillarBottom = 125] = "IntersectionCrossPillarBottom",
                e[e.IntersectionCrossPillarShort = 126] = "IntersectionCrossPillarShort",
                e[e.PlaneBridgeCorner = 127] = "PlaneBridgeCorner",
                e[e.PlaneBridgeIntersectionT = 128] = "PlaneBridgeIntersectionT",
                e[e.PlaneBridgeIntersectionCross = 129] = "PlaneBridgeIntersectionCross",
                e[e.BlockBridge = 130] = "BlockBridge",
                e[e.BlockBridgeCorner = 131] = "BlockBridgeCorner",
                e[e.BlockBridgeIntersectionT = 132] = "BlockBridgeIntersectionT",
                e[e.BlockBridgeIntersectionCross = 133] = "BlockBridgeIntersectionCross",
                e[e.WallTrackCeilingCorner = 134] = "WallTrackCeilingCorner",
                e[e.WallTrackCeilingPlaneCorner = 135] = "WallTrackCeilingPlaneCorner",
                e[e.WallTrackFloorCorner = 136] = "WallTrackFloorCorner",
                e[e.WallTrackFloorPlaneCorner = 137] = "WallTrackFloorPlaneCorner",
                e[e.SlopeUpVerticalLeftWide = 138] = "SlopeUpVerticalLeftWide",
                e[e.SlopeUpVerticalRightWide = 139] = "SlopeUpVerticalRightWide",
                e[e.BlockSlopeVerticalCornerTop = 140] = "BlockSlopeVerticalCornerTop",
                e[e.BlockSlopeVerticalCornerBottom = 141] = "BlockSlopeVerticalCornerBottom",
                e[e.WallTrackSlopeToVertical = 142] = "WallTrackSlopeToVertical",
                e[e.PlaneSlopeToVertical = 143] = "PlaneSlopeToVertical",
                e[e.BlockSlopeToVertical = 144] = "BlockSlopeToVertical",
                e[e.PlaneSlopeUpLong = 145] = "PlaneSlopeUpLong",
                e[e.PlaneSlopeDownLong = 146] = "PlaneSlopeDownLong",
                e[e.SlopeUpLongLeftWide = 147] = "SlopeUpLongLeftWide",
                e[e.SlopeUpLongRightWide = 148] = "SlopeUpLongRightWide",
                e[e.SlopeDownLongLeftWide = 149] = "SlopeDownLongLeftWide",
                e[e.SlopeDownLongRightWide = 150] = "SlopeDownLongRightWide",
                e[e.BlockSlopeUpLong = 151] = "BlockSlopeUpLong",
                e[e.BlockSlopeDownLong = 152] = "BlockSlopeDownLong",
                e[e.BlockSlopeVerticalInnerCornerBottom = 153] = "BlockSlopeVerticalInnerCornerBottom",
                e[e.BlockSlopeVerticalInnerCornerTop = 154] = "BlockSlopeVerticalInnerCornerTop",
                e[e.BlockInnerCorner = 155] = "BlockInnerCorner",
                e[e.SlopeToVertical = 156] = "SlopeToVertical",
                e[e.SlopeToVerticalLeftWide = 157] = "SlopeToVerticalLeftWide",
                e[e.SlopeToVerticalRightWide = 158] = "SlopeToVerticalRightWide",
                e[e.StraightTilted = 159] = "StraightTilted",
                e[e.TurnShortTilted = 160] = "TurnShortTilted",
                e[e.TurnLongTilted = 161] = "TurnLongTilted",
                e[e.TurnLong2Tilted = 162] = "TurnLong2Tilted",
                e[e.TurnLong3Tilted = 163] = "TurnLong3Tilted",
                e[e.TurnSLongLeft = 164] = "TurnSLongLeft",
                e[e.TurnSLongRight = 165] = "TurnSLongRight",
                e[e.ToTiltedLeft = 166] = "ToTiltedLeft",
                e[e.ToTiltedRight = 167] = "ToTiltedRight",
                e[e.PillarTopSlope = 168] = "PillarTopSlope",
                e[e.PillarShortSlope = 169] = "PillarShortSlope",
                e[e.HalfPlaneSlopeBottomLeft = 170] = "HalfPlaneSlopeBottomLeft",
                e[e.HalfPlaneSlopeBottomRight = 171] = "HalfPlaneSlopeBottomRight",
                e[e.HalfPlaneSlopeTopLeft = 172] = "HalfPlaneSlopeTopLeft",
                e[e.HalfPlaneSlopeTopRight = 173] = "HalfPlaneSlopeTopRight",
                e[e.HalfBlockSlopeBottomLeft = 174] = "HalfBlockSlopeBottomLeft",
                e[e.HalfBlockSlopeBottomRight = 175] = "HalfBlockSlopeBottomRight",
                e[e.HalfBlockSlopeTopLeft = 176] = "HalfBlockSlopeTopLeft",
                e[e.HalfBlockSlopeTopRight = 177] = "HalfBlockSlopeTopRight",
                e[e.PlaneWallSlopeLeft = 178] = "PlaneWallSlopeLeft",
                e[e.PlaneWallSlopeRight = 179] = "PlaneWallSlopeRight",
                e[e.PlaneWallSlopeUpLeft = 180] = "PlaneWallSlopeUpLeft",
                e[e.PlaneWallSlopeUpRight = 181] = "PlaneWallSlopeUpRight",
                e[e.PlaneWallSlopeDownLeft = 182] = "PlaneWallSlopeDownLeft",
                e[e.PlaneWallSlopeDownRight = 183] = "PlaneWallSlopeDownRight",
                e[e.PlaneWallSlopeUpLongLeft = 184] = "PlaneWallSlopeUpLongLeft",
                e[e.PlaneWallSlopeUpLongRight = 185] = "PlaneWallSlopeUpLongRight",
                e[e.PlaneWallSlopeDownLongLeft = 186] = "PlaneWallSlopeDownLongLeft",
                e[e.PlaneWallSlopeDownLongRight = 187] = "PlaneWallSlopeDownLongRight"
            }(i || (i = {}));
            const r = i
        }
        ,
        2207: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/arrow_up.svg"
        }
        ,
        2208: (e, t, n) => {
            "use strict";
            e.exports = n.p + "forced_square.woff"
        }
        ,
        2244: (e, t, n) => {
            "use strict";
            function i(e) {
                let t = "";
                for (const n of e)
                    t += String.fromCharCode(n);
                let n = btoa(t);
                return n = n.replace(/\+/g, "-"),
                n = n.replace(/\//g, "_"),
                n = n.replace(/=/g, ""),
                n
            }
            function r(e) {
                let t;
                e = (e = e.replace(/-/g, "+")).replace(/_/g, "/");
                try {
                    t = atob(e)
                } catch {
                    return null
                }
                const n = new Uint8Array(t.length);
                for (let e = 0; e < t.length; ++e) {
                    const i = t.charCodeAt(e);
                    if (i > 255)
                        return null;
                    n[e] = i
                }
                return n
            }
            n.d(t, {
                D: () => r,
                l: () => i
            })
        }
        ,
        2247: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.Checkpoint = 0] = "Checkpoint",
                e[e.Finish = 1] = "Finish"
            }(i || (i = {}));
            const r = i
        }
        ,
        2319: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/delete.svg"
        }
        ,
        2387: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1312)
              , r = n(765)
              , a = n(2951);
            class s {
                constructor(e=a.A.createToken(), t=a.A.defaultNickname, n=null, i=r.A.default(), s=!1) {
                    this.token = e,
                    this.nickname = t,
                    this.countryCode = n,
                    this.carStyle = i,
                    this.isVerifier = s
                }
                get tokenHash() {
                    return (0,
                    i.sha256)(this.token)
                }
                clone() {
                    return new s(this.token,this.nickname,this.countryCode,this.carStyle,this.isVerifier)
                }
            }
            const o = s
        }
        ,
        2493: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/overlapping_enabled.svg"
        }
        ,
        2553: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/state_invalid.svg"
        }
        ,
        2588: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_half.svg"
        }
        ,
        2646: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/multiplayer.svg"
        }
        ,
        2709: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/custom_tracks.jpg"
        }
        ,
        2825: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => K
            });
            var i = n(1635)
              , r = n(4922)
              , a = n(9437);
            const s = new r.kn4;
            class o {
                constructor(e) {
                    e = e || {},
                    this.zNear = !0 === e.webGL ? -1 : 0,
                    this.vertices = {
                        near: [new r.Pq0, new r.Pq0, new r.Pq0, new r.Pq0],
                        far: [new r.Pq0, new r.Pq0, new r.Pq0, new r.Pq0]
                    },
                    void 0 !== e.projectionMatrix && this.setFromProjectionMatrix(e.projectionMatrix, e.maxFar || 1e4)
                }
                setFromProjectionMatrix(e, t) {
                    const n = this.zNear
                      , i = 0 === e.elements[11];
                    return s.copy(e).invert(),
                    this.vertices.near[0].set(1, 1, n),
                    this.vertices.near[1].set(1, -1, n),
                    this.vertices.near[2].set(-1, -1, n),
                    this.vertices.near[3].set(-1, 1, n),
                    this.vertices.near.forEach((function(e) {
                        e.applyMatrix4(s)
                    }
                    )),
                    this.vertices.far[0].set(1, 1, 1),
                    this.vertices.far[1].set(1, -1, 1),
                    this.vertices.far[2].set(-1, -1, 1),
                    this.vertices.far[3].set(-1, 1, 1),
                    this.vertices.far.forEach((function(e) {
                        e.applyMatrix4(s);
                        const n = Math.abs(e.z);
                        i ? e.z *= Math.min(t / n, 1) : e.multiplyScalar(Math.min(t / n, 1))
                    }
                    )),
                    this.vertices
                }
                split(e, t) {
                    for (; e.length > t.length; )
                        t.push(new o);
                    t.length = e.length;
                    for (let n = 0; n < e.length; n++) {
                        const i = t[n];
                        if (0 === n)
                            for (let e = 0; e < 4; e++)
                                i.vertices.near[e].copy(this.vertices.near[e]);
                        else
                            for (let t = 0; t < 4; t++)
                                i.vertices.near[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], e[n - 1]);
                        if (n === e.length - 1)
                            for (let e = 0; e < 4; e++)
                                i.vertices.far[e].copy(this.vertices.far[e]);
                        else
                            for (let t = 0; t < 4; t++)
                                i.vertices.far[t].lerpVectors(this.vertices.near[t], this.vertices.far[t], e[n])
                    }
                }
                toSpace(e, t) {
                    for (let n = 0; n < 4; n++)
                        t.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(e),
                        t.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(e)
                }
            }
            const l = {
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometryClearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n \tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\n  \t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\t\tvec2 cascade;\n\t\tfloat cascadeCenter;\n\t\tfloat closestEdge;\n\t\tfloat margin;\n\t\tfloat csmx;\n\t\tfloat csmy;\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\t\tcascade = CSM_cascades[ i ];\n\t\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#elif defined (USE_SHADOWMAP)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\t#if ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#elif ( NUM_DIR_LIGHT_SHADOWS > 0 )\n\t\t// note: no loop here - all CSM lights are in fact one light only\n\t\tgetDirectionalLightInfo( directionalLights[0], directLight );\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t#if defined( USE_LIGHT_PROBES )\n\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n\t#endif\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
                lights_pars_begin: "\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t" + a.vxI.lights_pars_begin
            }
              , c = new r.kn4
              , h = new o({
                webGL: !0
            })
              , d = new r.Pq0
              , u = new r.Pq0
              , p = new r.NRn
              , f = []
              , g = []
              , m = new r.kn4
              , A = new r.kn4
              , v = new r.Pq0(0,1,0);
            class y {
                constructor(e) {
                    this.camera = e.camera,
                    this.parent = e.parent,
                    this.cascades = e.cascades || 3,
                    this.maxFar = e.maxFar || 1e5,
                    this.mode = e.mode || "practical",
                    this.shadowMapSize = e.shadowMapSize || 2048,
                    this.shadowBias = e.shadowBias || 1e-6,
                    this.lightDirection = e.lightDirection || new r.Pq0(1,-1,1).normalize(),
                    this.lightIntensity = e.lightIntensity || 3,
                    this.lightNear = e.lightNear || 1,
                    this.lightFar = e.lightFar || 2e3,
                    this.lightMargin = e.lightMargin || 200,
                    this.customSplitsCallback = e.customSplitsCallback,
                    this.fade = !1,
                    this.mainFrustum = new o({
                        webGL: !0
                    }),
                    this.frustums = [],
                    this.breaks = [],
                    this.lights = [],
                    this.shaders = new Map,
                    this._createLights(),
                    this.updateFrustums(),
                    this._injectInclude()
                }
                _createLights() {
                    for (let e = 0; e < this.cascades; e++) {
                        const e = new r.ZyN(16777215,this.lightIntensity);
                        e.castShadow = !0,
                        e.shadow.mapSize.width = this.shadowMapSize,
                        e.shadow.mapSize.height = this.shadowMapSize,
                        e.shadow.camera.near = this.lightNear,
                        e.shadow.camera.far = this.lightFar,
                        e.shadow.bias = this.shadowBias,
                        this.parent.add(e),
                        this.parent.add(e.target),
                        this.lights.push(e)
                    }
                }
                _initCascades() {
                    const e = this.camera;
                    e.updateProjectionMatrix(),
                    this.mainFrustum.setFromProjectionMatrix(e.projectionMatrix, this.maxFar),
                    this.mainFrustum.split(this.breaks, this.frustums)
                }
                _updateShadowBounds() {
                    const e = this.frustums;
                    for (let t = 0; t < e.length; t++) {
                        const e = this.lights[t].shadow.camera
                          , n = this.frustums[t]
                          , i = n.vertices.near
                          , r = n.vertices.far
                          , a = r[0];
                        let s;
                        s = a.distanceTo(r[2]) > a.distanceTo(i[2]) ? r[2] : i[2];
                        let o = a.distanceTo(s);
                        if (this.fade) {
                            const e = this.camera
                              , t = Math.max(e.far, this.maxFar)
                              , i = n.vertices.far[0].z / (t - e.near);
                            o += .25 * Math.pow(i, 2) * (t - e.near)
                        }
                        e.left = -o / 2,
                        e.right = o / 2,
                        e.top = o / 2,
                        e.bottom = -o / 2,
                        e.updateProjectionMatrix()
                    }
                }
                _getBreaks() {
                    const e = this.camera
                      , t = Math.min(e.far, this.maxFar);
                    switch (this.breaks.length = 0,
                    this.mode) {
                    case "uniform":
                        n(this.cascades, e.near, t, this.breaks);
                        break;
                    case "logarithmic":
                        i(this.cascades, e.near, t, this.breaks);
                        break;
                    case "practical":
                        !function(e, t, a, s, o) {
                            f.length = 0,
                            g.length = 0,
                            i(e, t, a, g),
                            n(e, t, a, f);
                            for (let t = 1; t < e; t++)
                                o.push(r.cj9.lerp(f[t - 1], g[t - 1], s));
                            o.push(1)
                        }(this.cascades, e.near, t, .5, this.breaks);
                        break;
                    case "custom":
                        void 0 === this.customSplitsCallback && console.error("CSM: Custom split scheme callback not defined."),
                        this.customSplitsCallback(this.cascades, e.near, t, this.breaks)
                    }
                    function n(e, t, n, i) {
                        for (let r = 1; r < e; r++)
                            i.push((t + (n - t) * r / e) / n);
                        i.push(1)
                    }
                    function i(e, t, n, i) {
                        for (let r = 1; r < e; r++)
                            i.push(t * (n / t) ** (r / e) / n);
                        i.push(1)
                    }
                }
                update() {
                    const e = this.camera
                      , t = this.frustums;
                    m.lookAt(u, this.lightDirection, v),
                    A.copy(m).invert();
                    for (let n = 0; n < t.length; n++) {
                        const i = this.lights[n]
                          , r = i.shadow.camera
                          , a = (r.right - r.left) / this.shadowMapSize
                          , s = (r.top - r.bottom) / this.shadowMapSize;
                        c.multiplyMatrices(A, e.matrixWorld),
                        t[n].toSpace(c, h);
                        const o = h.vertices.near
                          , l = h.vertices.far;
                        p.makeEmpty();
                        for (let e = 0; e < 4; e++)
                            p.expandByPoint(o[e]),
                            p.expandByPoint(l[e]);
                        p.getCenter(d),
                        d.z = p.max.z + this.lightMargin,
                        d.x = Math.floor(d.x / a) * a,
                        d.y = Math.floor(d.y / s) * s,
                        d.applyMatrix4(m),
                        i.position.copy(d),
                        i.target.position.copy(d),
                        i.target.position.x += this.lightDirection.x,
                        i.target.position.y += this.lightDirection.y,
                        i.target.position.z += this.lightDirection.z
                    }
                }
                _injectInclude() {
                    a.vxI.lights_fragment_begin = l.lights_fragment_begin,
                    a.vxI.lights_pars_begin = l.lights_pars_begin
                }
                setupMaterial(e) {
                    e.defines = e.defines || {},
                    e.defines.USE_CSM = 1,
                    e.defines.CSM_CASCADES = this.cascades,
                    this.fade && (e.defines.CSM_FADE = "");
                    const t = []
                      , n = this
                      , i = this.shaders;
                    e.onBeforeCompile = function(r) {
                        const a = Math.min(n.camera.far, n.maxFar);
                        n._getExtendedBreaks(t),
                        r.uniforms.CSM_cascades = {
                            value: t
                        },
                        r.uniforms.cameraNear = {
                            value: n.camera.near
                        },
                        r.uniforms.shadowFar = {
                            value: a
                        },
                        i.set(e, r)
                    }
                    ,
                    i.set(e, null)
                }
                _updateUniforms() {
                    const e = Math.min(this.camera.far, this.maxFar);
                    this.shaders.forEach((function(t, n) {
                        if (null !== t) {
                            const n = t.uniforms;
                            this._getExtendedBreaks(n.CSM_cascades.value),
                            n.cameraNear.value = this.camera.near,
                            n.shadowFar.value = e
                        }
                        !this.fade && "CSM_FADE"in n.defines ? (delete n.defines.CSM_FADE,
                        n.needsUpdate = !0) : this.fade && !("CSM_FADE"in n.defines) && (n.defines.CSM_FADE = "",
                        n.needsUpdate = !0)
                    }
                    ), this)
                }
                _getExtendedBreaks(e) {
                    for (; e.length < this.breaks.length; )
                        e.push(new r.I9Y);
                    e.length = this.breaks.length;
                    for (let t = 0; t < this.cascades; t++) {
                        const n = this.breaks[t]
                          , i = this.breaks[t - 1] || 0;
                        e[t].x = i,
                        e[t].y = n
                    }
                }
                updateFrustums() {
                    this._getBreaks(),
                    this._initCascades(),
                    this._updateShadowBounds(),
                    this._updateUniforms()
                }
                remove() {
                    for (let e = 0; e < this.lights.length; e++)
                        this.parent.remove(this.lights[e].target),
                        this.parent.remove(this.lights[e])
                }
                dispose() {
                    const e = this.shaders;
                    e.forEach((function(e, t) {
                        delete t.onBeforeCompile,
                        delete t.defines.USE_CSM,
                        delete t.defines.CSM_CASCADES,
                        delete t.defines.CSM_FADE,
                        null !== e && (delete e.uniforms.CSM_cascades,
                        delete e.uniforms.cameraNear,
                        delete e.uniforms.shadowFar),
                        t.needsUpdate = !0
                    }
                    )),
                    e.clear()
                }
            }
            var w, b, x, S, E, T, k, M, _, C, R, P, I, L, N, z, U, D, B, G, F, O, W, V = n(3476), H = n(4865);
            class j {
                constructor(e, t, n=null, s=!1) {
                    w.add(this),
                    x.set(this, void 0),
                    S.set(this, void 0),
                    E.set(this, void 0),
                    T.set(this, void 0),
                    k.set(this, !1),
                    M.set(this, void 0),
                    _.set(this, new r.ubm),
                    C.set(this, null),
                    R.set(this, null),
                    P.set(this, []),
                    I.set(this, null),
                    L.set(this, new r.Pq0(8,10,10)),
                    N.set(this, []),
                    z.set(this, []),
                    (0,
                    i.GG)(this, x, e, "f"),
                    (0,
                    i.GG)(this, S, t, "f"),
                    (0,
                    i.GG)(this, E, n, "f");
                    const o = {
                        antialias: t?.getSettingBoolean(V.A.Antialiasing) ?? !0,
                        powerPreference: "high-performance",
                        canvas: e,
                        alpha: s
                    };
                    try {
                        o.failIfMajorPerformanceCaveat = !0,
                        (0,
                        i.GG)(this, T, new a.JeP(o), "f"),
                        (0,
                        i.GG)(this, k, !1, "f")
                    } catch {
                        o.failIfMajorPerformanceCaveat = !1,
                        (0,
                        i.GG)(this, T, new a.JeP(o), "f"),
                        (0,
                        i.GG)(this, k, !0, "f")
                    }
                    (0,
                    i.gn)(this, T, "f").outputColorSpace = r.Zr2,
                    (0,
                    i.gn)(this, T, "f").debug.checkShaderErrors = H.EM,
                    (0,
                    i.GG)(this, M, new r.Z58, "f"),
                    (0,
                    i.gn)(this, w, "m", F).call(this),
                    (0,
                    i.gn)(this, M, "f").add(new r.dth(3891597,11714755,4.7)),
                    document.addEventListener("fullscreenchange", ( () => {
                        (0,
                        i.gn)(this, w, "m", O).call(this)
                    }
                    )),
                    (0,
                    i.gn)(this, x, "f").addEventListener("webglcontextrestored", ( () => {
                        for (const e of (0,
                        i.gn)(this, z, "f"))
                            e()
                    }
                    )),
                    null != window.electron && window.electron.addFullscreenChangeListener(( () => {
                        (0,
                        i.gn)(this, w, "m", O).call(this)
                    }
                    ))
                }
                clear() {
                    (0,
                    i.gn)(this, T, "f").clear()
                }
                update(e) {
                    (0,
                    i.gn)(this, L, "f").copy(e.getSunPosition());
                    let t = (0,
                    i.gn)(this, S, "f")?.getSettingInteger(V.A.ShadowQuality) ?? 0;
                    if (this.isShadowQualitySupported(t) || (t = 0),
                    !Number.isSafeInteger(t) || t <= 2 || t > 5)
                        if (null != (0,
                        i.gn)(this, C, "f") && ((0,
                        i.gn)(this, C, "f").remove(),
                        (0,
                        i.gn)(this, C, "f").dispose(),
                        (0,
                        i.GG)(this, C, null, "f"),
                        (0,
                        i.GG)(this, R, null, "f")),
                        null == (0,
                        i.gn)(this, I, "f") && ((0,
                        i.GG)(this, I, new r.ZyN(16777215,4.7), "f"),
                        (0,
                        i.gn)(this, I, "f").position.copy((0,
                        i.gn)(this, L, "f")),
                        (0,
                        i.gn)(this, M, "f").add((0,
                        i.gn)(this, I, "f")),
                        (0,
                        i.gn)(this, M, "f").add((0,
                        i.gn)(this, I, "f").target)),
                        1 == t || 2 == t) {
                            if (!(0,
                            i.gn)(this, I, "f").castShadow) {
                                const e = (0,
                                i.gn)(this, w, "m", G).call(this, t);
                                (0,
                                i.gn)(this, I, "f").castShadow = !0,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.top = 10,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.right = 10,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.bottom = -10,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.left = -10,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.near = 1,
                                (0,
                                i.gn)(this, I, "f").shadow.camera.far = 50,
                                (0,
                                i.gn)(this, I, "f").shadow.mapSize.width = e,
                                (0,
                                i.gn)(this, I, "f").shadow.mapSize.height = e,
                                (0,
                                i.gn)(this, I, "f").shadow.normalBias = .03,
                                (0,
                                i.gn)(this, I, "f").shadow.intensity = .6
                            }
                            (0,
                            i.gn)(this, I, "f").position.addVectors((0,
                            i.gn)(this, _, "f").position, (0,
                            i.gn)(this, L, "f").multiplyScalar(12.5)),
                            (0,
                            i.gn)(this, I, "f").target.position.copy((0,
                            i.gn)(this, _, "f").position),
                            (0,
                            i.gn)(this, T, "f").shadowMap.enabled = !0
                        } else
                            (0,
                            i.gn)(this, I, "f").castShadow = !1,
                            (0,
                            i.gn)(this, I, "f").shadow.map?.dispose(),
                            (0,
                            i.gn)(this, I, "f").shadow.map = null,
                            (0,
                            i.gn)(this, T, "f").shadowMap.enabled = !1;
                    else {
                        if (null != (0,
                        i.gn)(this, C, "f") && (0,
                        i.gn)(this, R, "f") != t && ((0,
                        i.gn)(this, C, "f").remove(),
                        (0,
                        i.gn)(this, C, "f").dispose(),
                        (0,
                        i.GG)(this, C, null, "f"),
                        (0,
                        i.GG)(this, R, null, "f"),
                        (0,
                        i.gn)(this, T, "f").compile((0,
                        i.gn)(this, M, "f"), (0,
                        i.gn)(this, _, "f"))),
                        null == (0,
                        i.gn)(this, C, "f")) {
                            (0,
                            i.gn)(this, T, "f").shadowMap.enabled = !0,
                            (0,
                            i.GG)(this, C, (0,
                            i.gn)(this, w, "m", U).call(this, t), "f"),
                            (0,
                            i.GG)(this, R, t, "f");
                            for (const {material: e, onBeforeCompile: t, customProgramCacheKey: n} of (0,
                            i.gn)(this, P, "f"))
                                (0,
                                i.gn)(this, w, "m", B).call(this, e, t, n)
                        }
                        null != (0,
                        i.gn)(this, I, "f") && ((0,
                        i.gn)(this, M, "f").remove((0,
                        i.gn)(this, I, "f")),
                        (0,
                        i.gn)(this, M, "f").remove((0,
                        i.gn)(this, I, "f").target),
                        (0,
                        i.GG)(this, I, null, "f")),
                        (0,
                        i.gn)(this, C, "f").lightDirection = (0,
                        i.gn)(this, L, "f").clone().negate().normalize(),
                        (0,
                        i.gn)(this, C, "f").update()
                    }
                    if (H.EM && (0,
                    i.gn)(this, _, "f")instanceof r.ubm && (0,
                    i.gn)(this, _, "f").fov > 100)
                        throw new Error("Shadow CSM does not support FOVs greater than 100 degrees.");
                    (0,
                    i.gn)(this, w, "m", D).call(this),
                    (0,
                    i.gn)(this, w, "m", F).call(this),
                    (0,
                    i.gn)(this, T, "f").render((0,
                    i.gn)(this, M, "f"), (0,
                    i.gn)(this, _, "f"))
                }
                addMaterial(e) {
                    const t = Array.isArray(e) ? e : [e];
                    for (const e of t) {
                        const t = e.onBeforeCompile.bind(e)
                          , n = e.onBeforeCompile.toString();
                        (0,
                        i.gn)(this, P, "f").push({
                            material: e,
                            onBeforeCompile: t,
                            customProgramCacheKey: n
                        }),
                        null != (0,
                        i.gn)(this, C, "f") && (0,
                        i.gn)(this, w, "m", B).call(this, e, t, n)
                    }
                }
                removeMaterial(e) {
                    if (Array.isArray(e))
                        for (const t of e) {
                            const e = (0,
                            i.gn)(this, P, "f").findIndex((e => e.material == t));
                            e >= 0 && (0,
                            i.gn)(this, P, "f").splice(e, 1)
                        }
                    else {
                        const t = (0,
                        i.gn)(this, P, "f").findIndex((t => t.material == e));
                        t >= 0 && (0,
                        i.gn)(this, P, "f").splice(t, 1)
                    }
                }
                isTrackShadowsEnabled() {
                    const e = (0,
                    i.gn)(this, S, "f")?.getSettingInteger(V.A.ShadowQuality) ?? 0;
                    return 3 == e || 4 == e || 5 == e
                }
                isShadowQualitySupported(e) {
                    return !Number.isSafeInteger(e) || e <= 0 || e > 5 || (0,
                    i.gn)(this, T, "f").capabilities.maxTextureSize >= (0,
                    i.gn)(this, w, "m", G).call(this, e)
                }
                getMaxAnisotropy() {
                    return (0,
                    i.gn)(this, T, "f").capabilities.getMaxAnisotropy()
                }
                get isUsingSoftwareRenderer() {
                    return (0,
                    i.gn)(this, k, "f")
                }
                get isFullscreen() {
                    return null != window.electron ? window.electron.isFullscreen() : null != document.fullscreenElement
                }
                async toggleFullscreen() {
                    this.isFullscreen ? null != window.electron ? window.electron.setFullscreen(!1) : await document.exitFullscreen() : null != window.electron ? window.electron.setFullscreen(!0) : await document.body.requestFullscreen()
                }
                addFullscreenChangeListener(e) {
                    (0,
                    i.gn)(this, N, "f").push(e)
                }
                removeFullscreenChangeListener(e) {
                    const t = (0,
                    i.gn)(this, N, "f").indexOf(e);
                    t >= 0 && (0,
                    i.gn)(this, N, "f").splice(t, 1)
                }
                addContextRestoredEventListener(e) {
                    (0,
                    i.gn)(this, z, "f").push(e)
                }
                removeContextRestoredEventListener(e) {
                    const t = (0,
                    i.gn)(this, z, "f").indexOf(e);
                    t >= 0 && (0,
                    i.gn)(this, z, "f").splice(t, 1)
                }
                get csm() {
                    return (0,
                    i.gn)(this, C, "f")
                }
                setCamera(e) {
                    (0,
                    i.GG)(this, _, e, "f"),
                    (0,
                    i.gn)(this, w, "m", D).call(this),
                    null != (0,
                    i.gn)(this, C, "f") && ((0,
                    i.gn)(this, C, "f").camera = e,
                    (0,
                    i.gn)(this, w, "m", W).call(this))
                }
                get camera() {
                    return (0,
                    i.gn)(this, _, "f")
                }
                get canvas() {
                    return (0,
                    i.gn)(this, x, "f")
                }
                setAnimationLoop(e) {
                    (0,
                    i.gn)(this, T, "f").setAnimationLoop(e)
                }
                get scene() {
                    return (0,
                    i.gn)(this, M, "f")
                }
            }
            b = j,
            x = new WeakMap,
            S = new WeakMap,
            E = new WeakMap,
            T = new WeakMap,
            k = new WeakMap,
            M = new WeakMap,
            _ = new WeakMap,
            C = new WeakMap,
            R = new WeakMap,
            P = new WeakMap,
            I = new WeakMap,
            L = new WeakMap,
            N = new WeakMap,
            z = new WeakMap,
            w = new WeakSet,
            U = function(e) {
                if (3 != e && 4 != e && 5 != e)
                    throw new Error("Unsupported shadow quality: " + e.toString());
                const t = (0,
                i.gn)(this, w, "m", G).call(this, e);
                let n, a;
                switch (e) {
                case 5:
                    n = 2e3;
                    break;
                case 4:
                    n = 1e3;
                    break;
                case 3:
                    n = 500
                }
                switch (e) {
                case 5:
                    a = 5;
                    break;
                case 4:
                case 3:
                    a = 4
                }
                const s = new y({
                    maxFar: n,
                    lightFar: 15e3,
                    lightNear: 10,
                    lightMargin: 5e3,
                    cascades: a,
                    mode: "custom",
                    customSplitsCallback: (t, n, i, r) => {
                        5 == e ? (r.push((15 - n) / i),
                        r.push((40 - n) / i),
                        r.push((150 - n) / i),
                        r.push((500 - n) / i),
                        r.push(1)) : 4 == e ? (r.push((15 - n) / i),
                        r.push((80 - n) / i),
                        r.push((300 - n) / i),
                        r.push(1)) : (r.push((15 - n) / i),
                        r.push((60 - n) / i),
                        r.push((150 - n) / i),
                        r.push(1))
                    }
                    ,
                    parent: (0,
                    i.gn)(this, M, "f"),
                    shadowMapSize: t,
                    lightDirection: new r.Pq0(0,0,-1),
                    lightIntensity: 4.7,
                    camera: (0,
                    i.gn)(this, _, "f")
                });
                s.fade = !0,
                5 == e ? (s.lights[0].shadow.normalBias = .025,
                s.lights[1].shadow.normalBias = .04,
                s.lights[2].shadow.normalBias = .11,
                s.lights[3].shadow.normalBias = .32,
                s.lights[4].shadow.normalBias = 1.25) : 4 == e ? (s.lights[0].shadow.normalBias = .041,
                s.lights[1].shadow.normalBias = .13,
                s.lights[2].shadow.normalBias = .48,
                s.lights[3].shadow.normalBias = 1.25) : (s.lights[0].shadow.normalBias = .08,
                s.lights[1].shadow.normalBias = .21,
                s.lights[2].shadow.normalBias = .6,
                s.lights[3].shadow.normalBias = 1.9);
                for (const e of s.lights)
                    e.shadow.intensity = .6;
                return s
            }
            ,
            D = function() {
                let e, t = (0,
                i.gn)(this, S, "f")?.getSettingFloat(V.A.RenderScale) ?? 1;
                if (t = Number.isFinite(t) ? Math.min(Math.max(t, .25), 2) : 1,
                (0,
                i.gn)(this, _, "f")instanceof r.ubm) {
                    const e = window.innerWidth / window.innerHeight
                      , t = new r.I9Y;
                    (0,
                    i.gn)(this, T, "f").getSize(t);
                    const n = Math.max(1, .5 * e);
                    t.width == window.innerWidth && t.height == window.innerHeight && (0,
                    i.gn)(this, _, "f").aspect == e && (0,
                    i.gn)(this, _, "f").zoom == n || ((0,
                    i.gn)(this, T, "f").setSize(window.innerWidth, window.innerHeight),
                    (0,
                    i.gn)(this, _, "f").aspect = e,
                    (0,
                    i.gn)(this, _, "f").zoom = n,
                    (0,
                    i.gn)(this, w, "m", W).call(this),
                    (0,
                    i.gn)(this, _, "f").updateProjectionMatrix())
                }
                e = (0,
                i.gn)(this, S, "f")?.getSettingBoolean(V.A.ScreenPixelDensity) ?? 1 ? window.devicePixelRatio : 1;
                const n = (0,
                i.gn)(this, T, "f").getPixelRatio()
                  , a = Math.min((0,
                i.gn)(this, T, "f").capabilities.maxTextureSize / window.innerWidth, (0,
                i.gn)(this, T, "f").capabilities.maxTextureSize / window.innerHeight)
                  , s = Math.min(e * t, a);
                n != s && (0,
                i.gn)(this, T, "f").setPixelRatio(s)
            }
            ,
            B = function(e, t, n) {
                const r = Array.isArray(e) ? e : [e];
                for (const e of r) {
                    (0,
                    i.gn)(this, C, "f")?.setupMaterial(e);
                    const r = e.onBeforeCompile.toString()
                      , a = e.onBeforeCompile.bind(e);
                    e.onBeforeCompile = (e, n) => {
                        a(e, n),
                        t(e, n)
                    }
                    ,
                    e.customProgramCacheKey = () => r + n,
                    e.needsUpdate = !0
                }
            }
            ,
            G = function(e) {
                switch (e) {
                case 5:
                    return 8192;
                case 4:
                    return 4096;
                case 3:
                    return 2048;
                case 2:
                case 1:
                    return 1024;
                default:
                    throw new Error("Unsupported shadow quality: " + e.toString())
                }
            }
            ,
            F = function() {
                let e;
                e = null != (0,
                i.gn)(this, E, "f") ? (0,
                i.gn)(this, E, "f") : (0,
                i.gn)(this, S, "f")?.getSettingBoolean(V.A.FogEnabled) ?? !0,
                e ? null == (0,
                i.gn)(this, M, "f").fog && ((0,
                i.gn)(this, M, "f").fog = new r.jUj(10211839,0,b.maxViewDistance)) : null != (0,
                i.gn)(this, M, "f").fog && ((0,
                i.gn)(this, M, "f").fog = null)
            }
            ,
            O = function() {
                for (const e of (0,
                i.gn)(this, N, "f"))
                    e()
            }
            ,
            W = function() {
                if (null != (0,
                i.gn)(this, C, "f"))
                    if ((0,
                    i.gn)(this, _, "f")instanceof r.ubm) {
                        const e = (0,
                        i.gn)(this, _, "f").fov;
                        (0,
                        i.gn)(this, _, "f").fov = 100,
                        (0,
                        i.gn)(this, C, "f").updateFrustums(),
                        (0,
                        i.gn)(this, _, "f").fov = e
                    } else
                        (0,
                        i.gn)(this, C, "f").updateFrustums()
            }
            ,
            j.maxViewDistance = 1e4;
            const K = j
        }
        ,
        2832: (e, t, n) => {
            "use strict";
            e.exports = n.p + "forced_square.ttf"
        }
        ,
        2927: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".loading-ui {\n\tmargin: 200px 0 0 0;\n\tpadding: 0;\n}\n.loading-ui.fade-out {\n\topacity: 0;\n\ttransition: opacity 0.25s ease-out;\n}\n\n.loading-ui > p {\n\tmargin: 5px;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n}\n\n.loading-ui > div {\n\tmargin: 0 auto;\n\tpadding: 0;\n\twidth: 600px;\n\theight: 50px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(9px 0, 100% 0, calc(100% - 9px) 100%, 0 100%);\n\toverflow: hidden;\n}\n\n.loading-ui > div > div {\n\tmargin: 15px 20px;\n\tpadding: 0;\n\twidth: 560px;\n\theight: 20px;\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\n\tbackground-color: #224;\n\tbox-shadow: inset 0 0 6px #000;\n}\n\n.loading-ui > div > div > div {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 0;\n\theight: 100%;\n\tclip-path: polygon(2px 0, 100% 0, calc(100% - 2px) 100%, 0 100%);\n\tbackground-color: #fff;\n\tbox-shadow: inset 0 0 6px #000;\n\ttransition: width 0.1s ease-in-out;\n}\n", ""]);
            const o = s
        }
        ,
        2931: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".game-toolbar-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\talign-items: stretch;\n\tposition: absolute;\n\tleft: var(--safe-area-horizontal);\n\tbottom: 0;\n\tz-index: 1;\n\topacity: 0;\n\ttransform: translateX(-10px);\n\ttransition: opacity 0.2s ease-in-out 0.5s, transform 0.2s ease-in-out 0.5s;\n\tpointer-events: none;\n}\n.game-toolbar-ui.up {\n\tflex-direction: column-reverse;\n\tposition: absolute;\n\tbottom: auto;\n\ttop: 0;\n}\n.game-toolbar-ui.visible {\n\topacity: 1;\n\ttransform: translateX(0);\n\ttransition: opacity ease-in-out 0.2s, transform ease-in-out 0.2s;\n\tpointer-events: auto;\n}\n\n.game-toolbar-ui > .info-container {\n\talign-self: flex-start;\n\tmargin-bottom: -1px; /* Prevents gap when UI is scaled */\n\tmargin-right: 8px;\n\tpadding: 8px 10px 0 10px;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-color);\n}\n.game-toolbar-ui.up > .info-container {\n\tmargin-top: -1px; /* Prevents gap when UI is scaled */\n\tpadding: 0 10px 8px 10px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.game-toolbar-ui > .info-container.hidden {\n\tdisplay: none;\n}\n\n.game-toolbar-ui > .info-container > .content {\n\tpadding: 4px 15px 4px 10px;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-tertiary-color);\n\tcolor: var(--text-color);\n}\n.game-toolbar-ui.up > .info-container > .content {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n.game-toolbar-ui > .info-container > .content > .track-name {\n\tfont-size: 28px;\n\tfont-weight: bold;\n}\n\n.game-toolbar-ui > .info-container > .content > .game-mode {\n\tfont-size: 24px;\n\tfont-weight: bold;\n}\n\n.game-toolbar-ui > .info-container > .content > .record {\n\tfont-size: 24px;\n\topacity: 0.5;\n}\n.game-toolbar-ui > .info-container > .content > .position {\n\theight: 0;\n\topacity: 0;\n\tfont-size: 20px;\n\ttransition: height 0.5s ease-in-out, opacity 0.5s ease-in-out;\n}\n.game-toolbar-ui > .info-container > .content > .position.visible {\n\theight: 20px;\n\topacity: 1;\n}\n\n.game-toolbar-ui > .button-container {\n\tpadding: 8px 10px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n#ui.has-safe-area-horizontal .game-toolbar-ui > .button-container {\n\tpadding-right: 16px;\n\tclip-path: polygon(10px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n#ui.has-safe-area-horizontal .game-toolbar-ui.up > .button-container {\n\tpadding-left: 16px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n\n.game-toolbar-ui.touch > .button-container > .button {\n\tfont-size: 24px;\n}\n.game-toolbar-ui.touch > .button-container > .button > img {\n\twidth: 24px;\n\theight: 24px;\n}\n", ""]);
            const o = s
        }
        ,
        2951: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => g
            });
            var i, r, a, s, o, l, c, h = n(1635), d = n(1312), u = n(765), p = n(2387);
            class f {
                constructor(e) {
                    i.add(this),
                    a.set(this, void 0),
                    s.set(this, void 0),
                    o.set(this, void 0),
                    (0,
                    h.GG)(this, a, e, "f"),
                    (0,
                    h.GG)(this, s, (0,
                    h.gn)(this, a, "f").loadUserProfileSlot() ?? 0, "f"),
                    (0,
                    h.GG)(this, o, (0,
                    h.gn)(this, i, "m", c).call(this, (0,
                    h.gn)(this, s, "f")), "f")
                }
                static createToken() {
                    let e = "";
                    try {
                        const t = new Uint8Array(32);
                        crypto.getRandomValues(t),
                        e += t.toString()
                    } catch {}
                    try {
                        e += crypto.randomUUID()
                    } catch {}
                    if (0 == e.length)
                        throw new Error("Failed to generate user token");
                    return (0,
                    d.sha256)(e)
                }
                createProfile(e, t, n, i, r) {
                    return !!this.isValidToken(t) && ((0,
                    h.gn)(this, a, "f").saveUserProfile(e, new p.A(t,n,i,r,!1)),
                    null != (0,
                    h.gn)(this, a, "f").loadUserProfile(e))
                }
                isValidToken(e) {
                    return !(!/^[0-9a-f]*$/.test(e) || 64 != e.length)
                }
                hasDuplicateToken(e) {
                    for (let t = 0; t < r.maxNumberOfProfiles; t++)
                        if ((0,
                        h.gn)(this, a, "f").loadUserProfile(t)?.token == e)
                            return !0;
                    return !1
                }
                firstOccupiedProfileSlot() {
                    for (let e = 0; e < r.maxNumberOfProfiles; e++)
                        if (null != (0,
                        h.gn)(this, a, "f").loadUserProfile(e))
                            return e;
                    return null
                }
                firstFreeProfileSlot() {
                    for (let e = 0; e < r.maxNumberOfProfiles; e++)
                        if (null == (0,
                        h.gn)(this, a, "f").loadUserProfile(e))
                            return e;
                    return null
                }
                deleteProfileSlot(e) {
                    (0,
                    h.gn)(this, a, "f").deleteAllRecordsForProfile(e),
                    (0,
                    h.gn)(this, a, "f").deleteUserProfile(e)
                }
                setProfileSlot(e) {
                    if (!Number.isSafeInteger(e) || e < 0)
                        throw new Error("Profile slot is invalid");
                    (0,
                    h.GG)(this, s, e, "f"),
                    (0,
                    h.GG)(this, o, (0,
                    h.gn)(this, i, "m", c).call(this, (0,
                    h.gn)(this, s, "f")), "f"),
                    (0,
                    h.gn)(this, a, "f").saveUserProfileSlot((0,
                    h.gn)(this, s, "f"))
                }
                setNickname(e, t=(0,
                h.gn)(this, s, "f")) {
                    let n;
                    n = t == (0,
                    h.gn)(this, s, "f") ? (0,
                    h.gn)(this, o, "f") : (0,
                    h.gn)(this, i, "m", c).call(this, t),
                    n.nickname = e,
                    (0,
                    h.gn)(this, a, "f").saveUserProfile(t, n)
                }
                setCountryCode(e, t=(0,
                h.gn)(this, s, "f")) {
                    let n;
                    n = t == (0,
                    h.gn)(this, s, "f") ? (0,
                    h.gn)(this, o, "f") : (0,
                    h.gn)(this, i, "m", c).call(this, t),
                    n.countryCode = e,
                    (0,
                    h.gn)(this, a, "f").saveUserProfile(t, n)
                }
                setCarStyle(e, t=(0,
                h.gn)(this, s, "f")) {
                    let n;
                    n = t == (0,
                    h.gn)(this, s, "f") ? (0,
                    h.gn)(this, o, "f") : (0,
                    h.gn)(this, i, "m", c).call(this, t),
                    n.carStyle = e,
                    (0,
                    h.gn)(this, a, "f").saveUserProfile(t, n)
                }
                setIsVerifier(e, t=(0,
                h.gn)(this, s, "f")) {
                    let n;
                    n = t == (0,
                    h.gn)(this, s, "f") ? (0,
                    h.gn)(this, o, "f") : (0,
                    h.gn)(this, i, "m", c).call(this, t),
                    n.isVerifier = e,
                    (0,
                    h.gn)(this, a, "f").saveUserProfile(t, n)
                }
                get profileSlot() {
                    return (0,
                    h.gn)(this, s, "f")
                }
                getCurrentUserProfile() {
                    return (0,
                    h.gn)(this, o, "f").clone()
                }
                getUserProfile(e) {
                    if (e == (0,
                    h.gn)(this, s, "f"))
                        return this.getCurrentUserProfile();
                    {
                        const t = (0,
                        h.gn)(this, a, "f").loadUserProfile(e);
                        return null != t ? t : null
                    }
                }
                syncUserProfile(e) {
                    const t = this.getCurrentUserProfile();
                    e.getUser(t.token).then((e => {
                        if (null == e)
                            return;
                        const n = this.getCurrentUserProfile();
                        n.token == t.token && n.nickname == t.nickname && n.countryCode == t.countryCode && n.carStyle.serialize() == t.carStyle.serialize() && (this.setNickname(e.nickname),
                        this.setCountryCode(e.countryCode),
                        this.setCarStyle(e.carStyle),
                        this.setIsVerifier(e.isVerifier))
                    }
                    )).catch((e => {
                        console.error(e)
                    }
                    ))
                }
            }
            r = f,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            i = new WeakSet,
            l = function(e) {
                const t = r.createToken()
                  , n = r.defaultNickname
                  , i = u.A.default();
                (0,
                h.gn)(this, a, "f").saveUserProfile(e, new p.A(t,n,null,i,!1))
            }
            ,
            c = function(e) {
                return null == (0,
                h.gn)(this, a, "f").loadUserProfile(e) && (0,
                h.gn)(this, i, "m", l).call(this, e),
                (0,
                h.gn)(this, a, "f").loadUserProfile(e) ?? new p.A
            }
            ,
            f.defaultNickname = "Anonymous",
            f.maxNumberOfProfiles = 3;
            const g = f
        }
        ,
        2970: (e, t, n) => {
            "use strict";
            n.d(t, {
                O: () => a,
                j: () => r
            });
            const i = {
                af: "Afghanistan",
                al: "Albania",
                dz: "Algeria",
                ad: "Andorra",
                ao: "Angola",
                ag: "Antigua and Barbuda",
                ar: "Argentina",
                am: "Armenia",
                au: "Australia",
                at: "Austria",
                az: "Azerbaijan",
                bs: "Bahamas",
                bh: "Bahrain",
                bd: "Bangladesh",
                bb: "Barbados",
                by: "Belarus",
                be: "Belgium",
                bz: "Belize",
                bj: "Benin",
                bt: "Bhutan",
                bo: "Bolivia",
                ba: "Bosnia and Herzegovina",
                bw: "Botswana",
                br: "Brazil",
                bn: "Brunei Darussalam",
                bg: "Bulgaria",
                bf: "Burkina Faso",
                bi: "Burundi",
                cv: "Cabo Verde",
                kh: "Cambodia",
                cm: "Cameroon",
                ca: "Canada",
                cf: "Central African Republic",
                td: "Chad",
                cl: "Chile",
                cn: "China",
                co: "Colombia",
                km: "Comoros",
                cg: "Congo",
                cr: "Costa Rica",
                ci: "Cte D'Ivoire",
                hr: "Croatia",
                cu: "Cuba",
                cy: "Cyprus",
                cz: "Czechia",
                kp: "Democratic People's Republic of Korea",
                cd: "Democratic Republic of the Congo",
                dk: "Denmark",
                dj: "Djibouti",
                dm: "Dominica",
                do: "Dominican Republic",
                ec: "Ecuador",
                eg: "Egypt",
                sv: "El Salvador",
                gq: "Equatorial Guinea",
                er: "Eritrea",
                ee: "Estonia",
                sz: "Eswatini",
                et: "Ethiopia",
                fj: "Fiji",
                fi: "Finland",
                fr: "France",
                ga: "Gabon",
                gm: "Gambia",
                ge: "Georgia",
                de: "Germany",
                gh: "Ghana",
                gr: "Greece",
                gd: "Grenada",
                gt: "Guatemala",
                gn: "Guinea",
                gw: "Guinea Bissau",
                gy: "Guyana",
                ht: "Haiti",
                hn: "Honduras",
                hu: "Hungary",
                is: "Iceland",
                in: "India",
                id: "Indonesia",
                ir: "Iran",
                iq: "Iraq",
                ie: "Ireland",
                il: "Israel",
                it: "Italy",
                jm: "Jamaica",
                jp: "Japan",
                jo: "Jordan",
                kz: "Kazakhstan",
                ke: "Kenya",
                ki: "Kiribati",
                kw: "Kuwait",
                kg: "Kyrgyzstan",
                la: "Lao People's Democratic Republic",
                lv: "Latvia",
                lb: "Lebanon",
                ls: "Lesotho",
                lr: "Liberia",
                ly: "Libya",
                li: "Liechtenstein",
                lt: "Lithuania",
                lu: "Luxembourg",
                mg: "Madagascar",
                mw: "Malawi",
                my: "Malaysia",
                mv: "Maldives",
                ml: "Mali",
                mt: "Malta",
                mh: "Marshall Islands",
                mr: "Mauritania",
                mu: "Mauritius",
                mx: "Mexico",
                fm: "Micronesia",
                mc: "Monaco",
                mn: "Mongolia",
                me: "Montenegro",
                ma: "Morocco",
                mz: "Mozambique",
                mm: "Myanmar",
                na: "Namibia",
                nr: "Nauru",
                np: "Nepal",
                nl: "Netherlands",
                nz: "New Zealand",
                ni: "Nicaragua",
                ne: "Niger",
                ng: "Nigeria",
                mk: "North Macedonia",
                no: "Norway",
                om: "Oman",
                pk: "Pakistan",
                pw: "Palau",
                pa: "Panama",
                pg: "Papua New Guinea",
                py: "Paraguay",
                pe: "Peru",
                ph: "Philippines",
                pl: "Poland",
                pt: "Portugal",
                qa: "Qatar",
                kr: "Republic of Korea",
                md: "Republic of Moldova",
                ro: "Romania",
                ru: "Russian Federation",
                rw: "Rwanda",
                kn: "Saint Kitts and Nevis",
                lc: "Saint Lucia",
                vc: "Saint Vincent and the Grenadines",
                ws: "Samoa",
                sm: "San Marino",
                st: "Sao Tome and Principe",
                sa: "Saudi Arabia",
                sn: "Senegal",
                rs: "Serbia",
                sc: "Seychelles",
                sl: "Sierra Leone",
                sg: "Singapore",
                sk: "Slovakia",
                si: "Slovenia",
                sb: "Solomon Islands",
                so: "Somalia",
                za: "South Africa",
                ss: "South Sudan",
                es: "Spain",
                lk: "Sri Lanka",
                sd: "Sudan",
                sr: "Suriname",
                se: "Sweden",
                ch: "Switzerland",
                sy: "Syrian Arab Republic",
                tj: "Tajikistan",
                th: "Thailand",
                tl: "Timor-Leste",
                tg: "Togo",
                to: "Tonga",
                tt: "Trinidad and Tobago",
                tn: "Tunisia",
                tr: "Trkiye",
                tm: "Turkmenistan",
                tv: "Tuvalu",
                ug: "Uganda",
                ua: "Ukraine",
                ae: "United Arab Emirates",
                gb: "United Kingdom of Great Britain and Northern Ireland",
                tz: "United Republic of Tanzania",
                us: "United States of America",
                uy: "Uruguay",
                uz: "Uzbekistan",
                vu: "Vanuatu",
                ve: "Venezuela",
                vn: "Viet Nam",
                ye: "Yemen",
                zm: "Zambia",
                zw: "Zimbabwe"
            };
            function r(e) {
                return function(e) {
                    return e in i
                }(e) ? e : null
            }
            function a() {
                return Object.entries(i).map(( ([e,t]) => ({
                    code: e,
                    name: t
                })))
            }
        }
        ,
        3025: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".track-info-ui {\n\tposition: absolute;\n\tleft: calc(50% - 1050px / 2);\n\ttop: 0;\n\tz-index: 2;\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 1000px;\n\theight: 100%;\n}\n.track-info-ui.hidden {\n\tdisplay: none;\n}\n\n.track-info-ui > .side-panel {\n\tposition: relative;\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-shrink: 0;\n\tmin-height: 0;\n\tmargin-left: 50px;\n\twidth: 400px;\n\tbackground-color: var(--surface-color);\n}\n\n.track-info-ui > .side-panel > h2 {\n\tmargin: 8px 8px 0 8px;\n\tpadding: 0;\n\tflex-shrink: 0;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tfont-weight: normal;\n\tfont-size: 32px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n\n.track-info-ui > .side-panel > .thumbnail {\n\tposition: relative;\n\tmargin: 10px 0 0 0;\n\tpadding: 45px;\n\tflex-grow: 1;\n\tmin-height: 0;\n\tmax-height: 300px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.track-info-ui > .side-panel > .thumbnail > canvas, .track-info-ui > .side-panel > .thumbnail > img:not(.environment) {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n\tobject-fit: contain;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\timage-rendering: pixelated;\n}\n\n.track-info-ui > .side-panel > .thumbnail > .share {\n\tdisplay: inline-block;\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tmargin: 8px;\n\tpadding: 0 9px;\n\tclip-path: polygon(3px 0, 100% 0, calc(100% - 3px) 100%, 0 100%);\n}\n.track-info-ui > .side-panel > .thumbnail > .share > img {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 16px;\n\tpointer-events: none;\n}\n\n.track-info-ui > .side-panel > .thumbnail > .environment {\n\tposition: absolute;\n\tright: 0;\n\tbottom: 0;\n\tmargin: 8px;\n\twidth: 32px;\n\topacity: 0.2;\n\tpointer-events: none;\n}\n\n.track-info-ui > .side-panel > .track-author {\n\tmargin: 8px 8px 0 8px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\toverflow-wrap: anywhere;\n\tfont-weight: bold;\n}\n\n.track-info-ui > .side-panel > .last-modified {\n\tmargin: 0 8px 8px 8px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\toverflow-wrap: anywhere;\n\tfont-weight: bold;\n}\n\n.track-info-ui > .side-panel > .track-author > span, .track-info-ui > .side-panel > .last-modified > span {\n\tfont-weight: normal;\n\topacity: 0.5;\n}\n\n.track-info-ui > .side-panel > .divider {\n\tborder-top: 1px solid var(--text-color);\n}\n\n.track-info-ui > .side-panel > .personal-best-title, .track-info-ui > .side-panel > .opponents-title {\n\tmargin: 10px 0 0 0;\n\tfont-size: 32px;\n\tcolor: var(--text-color);\n}\n\n.track-info-ui > .side-panel > .personal-best {\n\tmargin: 0 0 16px 0;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n}\n.track-info-ui > .side-panel > .personal-best.no-record {\n\topacity: 0.5;\n}\n\n.track-info-ui > .side-panel > .personal-best > div {\n\tmargin: 8px 0;\n\tpadding: 0 30px;\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tfont-size: 26px;\n\ttext-align: left;\n\tline-height: 30px;;\n}\n\n.track-info-ui > .side-panel > .personal-best > div > img {\n\tmargin: -1px 8px 1px 0;\n\twidth: 30px;\n\theight: 30px;\n\tvertical-align: top;\n}\n\n.track-info-ui > .side-panel > .personal-best > div > .faded {\n\topacity: 0.5;\n}\n\n.track-info-ui > .side-panel > .opponents-container {\n\tmargin: 8px 16px 16px 16px;\n\tflex-grow: 1;\n\tmin-height: 50px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.track-info-ui > .side-panel > .opponents-container.no-opponents {\n\tmargin: 8px 16px 16px 16px;\n\tfont-size: 18px;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.track-info-ui > .side-panel > .button.watch, .track-info-ui > .side-panel > .button.play {\n\tflex-shrink: 0;\n\tmargin: 0 10px 10px 10px;\n\tpadding: 0 0 0 30px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 2 * 10px);\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: center;\n\tfont-size: 50px;\n}\n.track-info-ui > .side-panel > .button.watch {\n\theight: 50px;\n\tfont-size: 40px;\n}\n\n.track-info-ui > .side-panel > .button.watch > img, .track-info-ui > .side-panel > .button.play > img {\n\tmargin: 0 0 0 10px;\n\tpadding: 0;\n\tvertical-align: middle;\n\twidth: 48px;\n\theight: 48px;\n\ttransition: transform 0.2s ease-in-out;\n\tpointer-events: none;\n}\n.track-info-ui > .side-panel > .button.watch > img {\n\twidth: 36px;\n\theight: 36px;\n}\n.track-info-ui > .side-panel > .button.watch:disabled > img {\n\topacity: 0.3;\n}\n\n.track-info-ui > .side-panel > .button.watch:hover > img, .track-info-ui > .side-panel > .button.play:hover > img {\n\ttransform: translateX(10px);\n}\n.track-info-ui > .side-panel > .button.watch:disabled:hover > img {\n\ttransform: none;\n}\n\n@media (hover: none) {\n\t.track-info-ui > .side-panel > .button.watch:hover > img, .track-info-ui > .side-panel > .button.play:hover > img {\n\t\ttransform: none;\n\t}\n}\n\n.track-info-ui > .side-panel > .back {\n\tmargin: 10px;\n}\n\n.track-info-ui > .side-panel > .leaderboard-button {\n\tmargin: 10px;\n\tfloat: right;\n}\n", ""]);
            const o = s
        }
        ,
        3075: (e, t, n) => {
            "use strict";
            n.d(t, {
                Ay: () => wn
            });
            function i(e) {
                let t = e.length;
                for (; --t >= 0; )
                    e[t] = 0
            }
            const r = 256
              , a = 286
              , s = 30
              , o = 15
              , l = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
              , c = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
              , h = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
              , d = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              , u = new Array(576);
            i(u);
            const p = new Array(60);
            i(p);
            const f = new Array(512);
            i(f);
            const g = new Array(256);
            i(g);
            const m = new Array(29);
            i(m);
            const A = new Array(s);
            function v(e, t, n, i, r) {
                this.static_tree = e,
                this.extra_bits = t,
                this.extra_base = n,
                this.elems = i,
                this.max_length = r,
                this.has_stree = e && e.length
            }
            let y, w, b;
            function x(e, t) {
                this.dyn_tree = e,
                this.max_code = 0,
                this.stat_desc = t
            }
            i(A);
            const S = e => e < 256 ? f[e] : f[256 + (e >>> 7)]
              , E = (e, t) => {
                e.pending_buf[e.pending++] = 255 & t,
                e.pending_buf[e.pending++] = t >>> 8 & 255
            }
              , T = (e, t, n) => {
                e.bi_valid > 16 - n ? (e.bi_buf |= t << e.bi_valid & 65535,
                E(e, e.bi_buf),
                e.bi_buf = t >> 16 - e.bi_valid,
                e.bi_valid += n - 16) : (e.bi_buf |= t << e.bi_valid & 65535,
                e.bi_valid += n)
            }
              , k = (e, t, n) => {
                T(e, n[2 * t], n[2 * t + 1])
            }
              , M = (e, t) => {
                let n = 0;
                do {
                    n |= 1 & e,
                    e >>>= 1,
                    n <<= 1
                } while (--t > 0);
                return n >>> 1
            }
              , _ = (e, t, n) => {
                const i = new Array(16);
                let r, a, s = 0;
                for (r = 1; r <= o; r++)
                    s = s + n[r - 1] << 1,
                    i[r] = s;
                for (a = 0; a <= t; a++) {
                    let t = e[2 * a + 1];
                    0 !== t && (e[2 * a] = M(i[t]++, t))
                }
            }
              , C = e => {
                let t;
                for (t = 0; t < a; t++)
                    e.dyn_ltree[2 * t] = 0;
                for (t = 0; t < s; t++)
                    e.dyn_dtree[2 * t] = 0;
                for (t = 0; t < 19; t++)
                    e.bl_tree[2 * t] = 0;
                e.dyn_ltree[512] = 1,
                e.opt_len = e.static_len = 0,
                e.sym_next = e.matches = 0
            }
              , R = e => {
                e.bi_valid > 8 ? E(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf),
                e.bi_buf = 0,
                e.bi_valid = 0
            }
              , P = (e, t, n, i) => {
                const r = 2 * t
                  , a = 2 * n;
                return e[r] < e[a] || e[r] === e[a] && i[t] <= i[n]
            }
              , I = (e, t, n) => {
                const i = e.heap[n];
                let r = n << 1;
                for (; r <= e.heap_len && (r < e.heap_len && P(t, e.heap[r + 1], e.heap[r], e.depth) && r++,
                !P(t, i, e.heap[r], e.depth)); )
                    e.heap[n] = e.heap[r],
                    n = r,
                    r <<= 1;
                e.heap[n] = i
            }
              , L = (e, t, n) => {
                let i, a, s, o, h = 0;
                if (0 !== e.sym_next)
                    do {
                        i = 255 & e.pending_buf[e.sym_buf + h++],
                        i += (255 & e.pending_buf[e.sym_buf + h++]) << 8,
                        a = e.pending_buf[e.sym_buf + h++],
                        0 === i ? k(e, a, t) : (s = g[a],
                        k(e, s + r + 1, t),
                        o = l[s],
                        0 !== o && (a -= m[s],
                        T(e, a, o)),
                        i--,
                        s = S(i),
                        k(e, s, n),
                        o = c[s],
                        0 !== o && (i -= A[s],
                        T(e, i, o)))
                    } while (h < e.sym_next);
                k(e, 256, t)
            }
              , N = (e, t) => {
                const n = t.dyn_tree
                  , i = t.stat_desc.static_tree
                  , r = t.stat_desc.has_stree
                  , a = t.stat_desc.elems;
                let s, l, c, h = -1;
                for (e.heap_len = 0,
                e.heap_max = 573,
                s = 0; s < a; s++)
                    0 !== n[2 * s] ? (e.heap[++e.heap_len] = h = s,
                    e.depth[s] = 0) : n[2 * s + 1] = 0;
                for (; e.heap_len < 2; )
                    c = e.heap[++e.heap_len] = h < 2 ? ++h : 0,
                    n[2 * c] = 1,
                    e.depth[c] = 0,
                    e.opt_len--,
                    r && (e.static_len -= i[2 * c + 1]);
                for (t.max_code = h,
                s = e.heap_len >> 1; s >= 1; s--)
                    I(e, n, s);
                c = a;
                do {
                    s = e.heap[1],
                    e.heap[1] = e.heap[e.heap_len--],
                    I(e, n, 1),
                    l = e.heap[1],
                    e.heap[--e.heap_max] = s,
                    e.heap[--e.heap_max] = l,
                    n[2 * c] = n[2 * s] + n[2 * l],
                    e.depth[c] = (e.depth[s] >= e.depth[l] ? e.depth[s] : e.depth[l]) + 1,
                    n[2 * s + 1] = n[2 * l + 1] = c,
                    e.heap[1] = c++,
                    I(e, n, 1)
                } while (e.heap_len >= 2);
                e.heap[--e.heap_max] = e.heap[1],
                ( (e, t) => {
                    const n = t.dyn_tree
                      , i = t.max_code
                      , r = t.stat_desc.static_tree
                      , a = t.stat_desc.has_stree
                      , s = t.stat_desc.extra_bits
                      , l = t.stat_desc.extra_base
                      , c = t.stat_desc.max_length;
                    let h, d, u, p, f, g, m = 0;
                    for (p = 0; p <= o; p++)
                        e.bl_count[p] = 0;
                    for (n[2 * e.heap[e.heap_max] + 1] = 0,
                    h = e.heap_max + 1; h < 573; h++)
                        d = e.heap[h],
                        p = n[2 * n[2 * d + 1] + 1] + 1,
                        p > c && (p = c,
                        m++),
                        n[2 * d + 1] = p,
                        d > i || (e.bl_count[p]++,
                        f = 0,
                        d >= l && (f = s[d - l]),
                        g = n[2 * d],
                        e.opt_len += g * (p + f),
                        a && (e.static_len += g * (r[2 * d + 1] + f)));
                    if (0 !== m) {
                        do {
                            for (p = c - 1; 0 === e.bl_count[p]; )
                                p--;
                            e.bl_count[p]--,
                            e.bl_count[p + 1] += 2,
                            e.bl_count[c]--,
                            m -= 2
                        } while (m > 0);
                        for (p = c; 0 !== p; p--)
                            for (d = e.bl_count[p]; 0 !== d; )
                                u = e.heap[--h],
                                u > i || (n[2 * u + 1] !== p && (e.opt_len += (p - n[2 * u + 1]) * n[2 * u],
                                n[2 * u + 1] = p),
                                d--)
                    }
                }
                )(e, t),
                _(n, h, e.bl_count)
            }
              , z = (e, t, n) => {
                let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
                for (0 === s && (l = 138,
                c = 3),
                t[2 * (n + 1) + 1] = 65535,
                i = 0; i <= n; i++)
                    r = s,
                    s = t[2 * (i + 1) + 1],
                    ++o < l && r === s || (o < c ? e.bl_tree[2 * r] += o : 0 !== r ? (r !== a && e.bl_tree[2 * r]++,
                    e.bl_tree[32]++) : o <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++,
                    o = 0,
                    a = r,
                    0 === s ? (l = 138,
                    c = 3) : r === s ? (l = 6,
                    c = 3) : (l = 7,
                    c = 4))
            }
              , U = (e, t, n) => {
                let i, r, a = -1, s = t[1], o = 0, l = 7, c = 4;
                for (0 === s && (l = 138,
                c = 3),
                i = 0; i <= n; i++)
                    if (r = s,
                    s = t[2 * (i + 1) + 1],
                    !(++o < l && r === s)) {
                        if (o < c)
                            do {
                                k(e, r, e.bl_tree)
                            } while (0 != --o);
                        else
                            0 !== r ? (r !== a && (k(e, r, e.bl_tree),
                            o--),
                            k(e, 16, e.bl_tree),
                            T(e, o - 3, 2)) : o <= 10 ? (k(e, 17, e.bl_tree),
                            T(e, o - 3, 3)) : (k(e, 18, e.bl_tree),
                            T(e, o - 11, 7));
                        o = 0,
                        a = r,
                        0 === s ? (l = 138,
                        c = 3) : r === s ? (l = 6,
                        c = 3) : (l = 7,
                        c = 4)
                    }
            }
            ;
            let D = !1;
            const B = (e, t, n, i) => {
                T(e, 0 + (i ? 1 : 0), 3),
                R(e),
                E(e, n),
                E(e, ~n),
                n && e.pending_buf.set(e.window.subarray(t, t + n), e.pending),
                e.pending += n
            }
            ;
            var G = (e, t, n, i) => {
                let a, s, o = 0;
                e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {
                    let t, n = 4093624447;
                    for (t = 0; t <= 31; t++,
                    n >>>= 1)
                        if (1 & n && 0 !== e.dyn_ltree[2 * t])
                            return 0;
                    if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26])
                        return 1;
                    for (t = 32; t < r; t++)
                        if (0 !== e.dyn_ltree[2 * t])
                            return 1;
                    return 0
                }
                )(e)),
                N(e, e.l_desc),
                N(e, e.d_desc),
                o = (e => {
                    let t;
                    for (z(e, e.dyn_ltree, e.l_desc.max_code),
                    z(e, e.dyn_dtree, e.d_desc.max_code),
                    N(e, e.bl_desc),
                    t = 18; t >= 3 && 0 === e.bl_tree[2 * d[t] + 1]; t--)
                        ;
                    return e.opt_len += 3 * (t + 1) + 5 + 5 + 4,
                    t
                }
                )(e),
                a = e.opt_len + 3 + 7 >>> 3,
                s = e.static_len + 3 + 7 >>> 3,
                s <= a && (a = s)) : a = s = n + 5,
                n + 4 <= a && -1 !== t ? B(e, t, n, i) : 4 === e.strategy || s === a ? (T(e, 2 + (i ? 1 : 0), 3),
                L(e, u, p)) : (T(e, 4 + (i ? 1 : 0), 3),
                ( (e, t, n, i) => {
                    let r;
                    for (T(e, t - 257, 5),
                    T(e, n - 1, 5),
                    T(e, i - 4, 4),
                    r = 0; r < i; r++)
                        T(e, e.bl_tree[2 * d[r] + 1], 3);
                    U(e, e.dyn_ltree, t - 1),
                    U(e, e.dyn_dtree, n - 1)
                }
                )(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, o + 1),
                L(e, e.dyn_ltree, e.dyn_dtree)),
                C(e),
                i && R(e)
            }
              , F = {
                _tr_init: e => {
                    D || (( () => {
                        let e, t, n, i, r;
                        const d = new Array(16);
                        for (n = 0,
                        i = 0; i < 28; i++)
                            for (m[i] = n,
                            e = 0; e < 1 << l[i]; e++)
                                g[n++] = i;
                        for (g[n - 1] = i,
                        r = 0,
                        i = 0; i < 16; i++)
                            for (A[i] = r,
                            e = 0; e < 1 << c[i]; e++)
                                f[r++] = i;
                        for (r >>= 7; i < s; i++)
                            for (A[i] = r << 7,
                            e = 0; e < 1 << c[i] - 7; e++)
                                f[256 + r++] = i;
                        for (t = 0; t <= o; t++)
                            d[t] = 0;
                        for (e = 0; e <= 143; )
                            u[2 * e + 1] = 8,
                            e++,
                            d[8]++;
                        for (; e <= 255; )
                            u[2 * e + 1] = 9,
                            e++,
                            d[9]++;
                        for (; e <= 279; )
                            u[2 * e + 1] = 7,
                            e++,
                            d[7]++;
                        for (; e <= 287; )
                            u[2 * e + 1] = 8,
                            e++,
                            d[8]++;
                        for (_(u, 287, d),
                        e = 0; e < s; e++)
                            p[2 * e + 1] = 5,
                            p[2 * e] = M(e, 5);
                        y = new v(u,l,257,a,o),
                        w = new v(p,c,0,s,o),
                        b = new v(new Array(0),h,0,19,7)
                    }
                    )(),
                    D = !0),
                    e.l_desc = new x(e.dyn_ltree,y),
                    e.d_desc = new x(e.dyn_dtree,w),
                    e.bl_desc = new x(e.bl_tree,b),
                    e.bi_buf = 0,
                    e.bi_valid = 0,
                    C(e)
                }
                ,
                _tr_stored_block: B,
                _tr_flush_block: G,
                _tr_tally: (e, t, n) => (e.pending_buf[e.sym_buf + e.sym_next++] = t,
                e.pending_buf[e.sym_buf + e.sym_next++] = t >> 8,
                e.pending_buf[e.sym_buf + e.sym_next++] = n,
                0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++,
                t--,
                e.dyn_ltree[2 * (g[n] + r + 1)]++,
                e.dyn_dtree[2 * S(t)]++),
                e.sym_next === e.sym_end),
                _tr_align: e => {
                    T(e, 2, 3),
                    k(e, 256, u),
                    (e => {
                        16 === e.bi_valid ? (E(e, e.bi_buf),
                        e.bi_buf = 0,
                        e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf,
                        e.bi_buf >>= 8,
                        e.bi_valid -= 8)
                    }
                    )(e)
                }
            };
            var O = (e, t, n, i) => {
                let r = 65535 & e
                  , a = e >>> 16 & 65535
                  , s = 0;
                for (; 0 !== n; ) {
                    s = n > 2e3 ? 2e3 : n,
                    n -= s;
                    do {
                        r = r + t[i++] | 0,
                        a = a + r | 0
                    } while (--s);
                    r %= 65521,
                    a %= 65521
                }
                return r | a << 16
            }
            ;
            const W = new Uint32Array(( () => {
                let e, t = [];
                for (var n = 0; n < 256; n++) {
                    e = n;
                    for (var i = 0; i < 8; i++)
                        e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                    t[n] = e
                }
                return t
            }
            )());
            var V = (e, t, n, i) => {
                const r = W
                  , a = i + n;
                e ^= -1;
                for (let n = i; n < a; n++)
                    e = e >>> 8 ^ r[255 & (e ^ t[n])];
                return ~e
            }
              , H = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            }
              , j = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            };
            const {_tr_init: K, _tr_stored_block: q, _tr_flush_block: Q, _tr_tally: J, _tr_align: X} = F
              , {Z_NO_FLUSH: Y, Z_PARTIAL_FLUSH: Z, Z_FULL_FLUSH: $, Z_FINISH: ee, Z_BLOCK: te, Z_OK: ne, Z_STREAM_END: ie, Z_STREAM_ERROR: re, Z_DATA_ERROR: ae, Z_BUF_ERROR: se, Z_DEFAULT_COMPRESSION: oe, Z_FILTERED: le, Z_HUFFMAN_ONLY: ce, Z_RLE: he, Z_FIXED: de, Z_DEFAULT_STRATEGY: ue, Z_UNKNOWN: pe, Z_DEFLATED: fe} = j
              , ge = 258
              , me = 262
              , Ae = 42
              , ve = 113
              , ye = 666
              , we = (e, t) => (e.msg = H[t],
            t)
              , be = e => 2 * e - (e > 4 ? 9 : 0)
              , xe = e => {
                let t = e.length;
                for (; --t >= 0; )
                    e[t] = 0
            }
              , Se = e => {
                let t, n, i, r = e.w_size;
                t = e.hash_size,
                i = t;
                do {
                    n = e.head[--i],
                    e.head[i] = n >= r ? n - r : 0
                } while (--t);
                t = r,
                i = t;
                do {
                    n = e.prev[--i],
                    e.prev[i] = n >= r ? n - r : 0
                } while (--t)
            }
            ;
            let Ee = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask;
            const Te = e => {
                const t = e.state;
                let n = t.pending;
                n > e.avail_out && (n = e.avail_out),
                0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out),
                e.next_out += n,
                t.pending_out += n,
                e.total_out += n,
                e.avail_out -= n,
                t.pending -= n,
                0 === t.pending && (t.pending_out = 0))
            }
              , ke = (e, t) => {
                Q(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t),
                e.block_start = e.strstart,
                Te(e.strm)
            }
              , Me = (e, t) => {
                e.pending_buf[e.pending++] = t
            }
              , _e = (e, t) => {
                e.pending_buf[e.pending++] = t >>> 8 & 255,
                e.pending_buf[e.pending++] = 255 & t
            }
              , Ce = (e, t, n, i) => {
                let r = e.avail_in;
                return r > i && (r = i),
                0 === r ? 0 : (e.avail_in -= r,
                t.set(e.input.subarray(e.next_in, e.next_in + r), n),
                1 === e.state.wrap ? e.adler = O(e.adler, t, r, n) : 2 === e.state.wrap && (e.adler = V(e.adler, t, r, n)),
                e.next_in += r,
                e.total_in += r,
                r)
            }
              , Re = (e, t) => {
                let n, i, r = e.max_chain_length, a = e.strstart, s = e.prev_length, o = e.nice_match;
                const l = e.strstart > e.w_size - me ? e.strstart - (e.w_size - me) : 0
                  , c = e.window
                  , h = e.w_mask
                  , d = e.prev
                  , u = e.strstart + ge;
                let p = c[a + s - 1]
                  , f = c[a + s];
                e.prev_length >= e.good_match && (r >>= 2),
                o > e.lookahead && (o = e.lookahead);
                do {
                    if (n = t,
                    c[n + s] === f && c[n + s - 1] === p && c[n] === c[a] && c[++n] === c[a + 1]) {
                        a += 2,
                        n++;
                        do {} while (c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && c[++a] === c[++n] && a < u);
                        if (i = ge - (u - a),
                        a = u - ge,
                        i > s) {
                            if (e.match_start = t,
                            s = i,
                            i >= o)
                                break;
                            p = c[a + s - 1],
                            f = c[a + s]
                        }
                    }
                } while ((t = d[t & h]) > l && 0 != --r);
                return s <= e.lookahead ? s : e.lookahead
            }
              , Pe = e => {
                const t = e.w_size;
                let n, i, r;
                do {
                    if (i = e.window_size - e.lookahead - e.strstart,
                    e.strstart >= t + (t - me) && (e.window.set(e.window.subarray(t, t + t - i), 0),
                    e.match_start -= t,
                    e.strstart -= t,
                    e.block_start -= t,
                    e.insert > e.strstart && (e.insert = e.strstart),
                    Se(e),
                    i += t),
                    0 === e.strm.avail_in)
                        break;
                    if (n = Ce(e.strm, e.window, e.strstart + e.lookahead, i),
                    e.lookahead += n,
                    e.lookahead + e.insert >= 3)
                        for (r = e.strstart - e.insert,
                        e.ins_h = e.window[r],
                        e.ins_h = Ee(e, e.ins_h, e.window[r + 1]); e.insert && (e.ins_h = Ee(e, e.ins_h, e.window[r + 3 - 1]),
                        e.prev[r & e.w_mask] = e.head[e.ins_h],
                        e.head[e.ins_h] = r,
                        r++,
                        e.insert--,
                        !(e.lookahead + e.insert < 3)); )
                            ;
                } while (e.lookahead < me && 0 !== e.strm.avail_in)
            }
              , Ie = (e, t) => {
                let n, i, r, a = e.pending_buf_size - 5 > e.w_size ? e.w_size : e.pending_buf_size - 5, s = 0, o = e.strm.avail_in;
                do {
                    if (n = 65535,
                    r = e.bi_valid + 42 >> 3,
                    e.strm.avail_out < r)
                        break;
                    if (r = e.strm.avail_out - r,
                    i = e.strstart - e.block_start,
                    n > i + e.strm.avail_in && (n = i + e.strm.avail_in),
                    n > r && (n = r),
                    n < a && (0 === n && t !== ee || t === Y || n !== i + e.strm.avail_in))
                        break;
                    s = t === ee && n === i + e.strm.avail_in ? 1 : 0,
                    q(e, 0, 0, s),
                    e.pending_buf[e.pending - 4] = n,
                    e.pending_buf[e.pending - 3] = n >> 8,
                    e.pending_buf[e.pending - 2] = ~n,
                    e.pending_buf[e.pending - 1] = ~n >> 8,
                    Te(e.strm),
                    i && (i > n && (i = n),
                    e.strm.output.set(e.window.subarray(e.block_start, e.block_start + i), e.strm.next_out),
                    e.strm.next_out += i,
                    e.strm.avail_out -= i,
                    e.strm.total_out += i,
                    e.block_start += i,
                    n -= i),
                    n && (Ce(e.strm, e.strm.output, e.strm.next_out, n),
                    e.strm.next_out += n,
                    e.strm.avail_out -= n,
                    e.strm.total_out += n)
                } while (0 === s);
                return o -= e.strm.avail_in,
                o && (o >= e.w_size ? (e.matches = 2,
                e.window.set(e.strm.input.subarray(e.strm.next_in - e.w_size, e.strm.next_in), 0),
                e.strstart = e.w_size,
                e.insert = e.strstart) : (e.window_size - e.strstart <= o && (e.strstart -= e.w_size,
                e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
                e.matches < 2 && e.matches++,
                e.insert > e.strstart && (e.insert = e.strstart)),
                e.window.set(e.strm.input.subarray(e.strm.next_in - o, e.strm.next_in), e.strstart),
                e.strstart += o,
                e.insert += o > e.w_size - e.insert ? e.w_size - e.insert : o),
                e.block_start = e.strstart),
                e.high_water < e.strstart && (e.high_water = e.strstart),
                s ? 4 : t !== Y && t !== ee && 0 === e.strm.avail_in && e.strstart === e.block_start ? 2 : (r = e.window_size - e.strstart,
                e.strm.avail_in > r && e.block_start >= e.w_size && (e.block_start -= e.w_size,
                e.strstart -= e.w_size,
                e.window.set(e.window.subarray(e.w_size, e.w_size + e.strstart), 0),
                e.matches < 2 && e.matches++,
                r += e.w_size,
                e.insert > e.strstart && (e.insert = e.strstart)),
                r > e.strm.avail_in && (r = e.strm.avail_in),
                r && (Ce(e.strm, e.window, e.strstart, r),
                e.strstart += r,
                e.insert += r > e.w_size - e.insert ? e.w_size - e.insert : r),
                e.high_water < e.strstart && (e.high_water = e.strstart),
                r = e.bi_valid + 42 >> 3,
                r = e.pending_buf_size - r > 65535 ? 65535 : e.pending_buf_size - r,
                a = r > e.w_size ? e.w_size : r,
                i = e.strstart - e.block_start,
                (i >= a || (i || t === ee) && t !== Y && 0 === e.strm.avail_in && i <= r) && (n = i > r ? r : i,
                s = t === ee && 0 === e.strm.avail_in && n === i ? 1 : 0,
                q(e, e.block_start, n, s),
                e.block_start += n,
                Te(e.strm)),
                s ? 3 : 1)
            }
              , Le = (e, t) => {
                let n, i;
                for (; ; ) {
                    if (e.lookahead < me) {
                        if (Pe(e),
                        e.lookahead < me && t === Y)
                            return 1;
                        if (0 === e.lookahead)
                            break
                    }
                    if (n = 0,
                    e.lookahead >= 3 && (e.ins_h = Ee(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                    n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                    e.head[e.ins_h] = e.strstart),
                    0 !== n && e.strstart - n <= e.w_size - me && (e.match_length = Re(e, n)),
                    e.match_length >= 3)
                        if (i = J(e, e.strstart - e.match_start, e.match_length - 3),
                        e.lookahead -= e.match_length,
                        e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                            e.match_length--;
                            do {
                                e.strstart++,
                                e.ins_h = Ee(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                                n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                                e.head[e.ins_h] = e.strstart
                            } while (0 != --e.match_length);
                            e.strstart++
                        } else
                            e.strstart += e.match_length,
                            e.match_length = 0,
                            e.ins_h = e.window[e.strstart],
                            e.ins_h = Ee(e, e.ins_h, e.window[e.strstart + 1]);
                    else
                        i = J(e, 0, e.window[e.strstart]),
                        e.lookahead--,
                        e.strstart++;
                    if (i && (ke(e, !1),
                    0 === e.strm.avail_out))
                        return 1
                }
                return e.insert = e.strstart < 2 ? e.strstart : 2,
                t === ee ? (ke(e, !0),
                0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ke(e, !1),
                0 === e.strm.avail_out) ? 1 : 2
            }
              , Ne = (e, t) => {
                let n, i, r;
                for (; ; ) {
                    if (e.lookahead < me) {
                        if (Pe(e),
                        e.lookahead < me && t === Y)
                            return 1;
                        if (0 === e.lookahead)
                            break
                    }
                    if (n = 0,
                    e.lookahead >= 3 && (e.ins_h = Ee(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                    n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                    e.head[e.ins_h] = e.strstart),
                    e.prev_length = e.match_length,
                    e.prev_match = e.match_start,
                    e.match_length = 2,
                    0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - me && (e.match_length = Re(e, n),
                    e.match_length <= 5 && (e.strategy === le || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)),
                    e.prev_length >= 3 && e.match_length <= e.prev_length) {
                        r = e.strstart + e.lookahead - 3,
                        i = J(e, e.strstart - 1 - e.prev_match, e.prev_length - 3),
                        e.lookahead -= e.prev_length - 1,
                        e.prev_length -= 2;
                        do {
                            ++e.strstart <= r && (e.ins_h = Ee(e, e.ins_h, e.window[e.strstart + 3 - 1]),
                            n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h],
                            e.head[e.ins_h] = e.strstart)
                        } while (0 != --e.prev_length);
                        if (e.match_available = 0,
                        e.match_length = 2,
                        e.strstart++,
                        i && (ke(e, !1),
                        0 === e.strm.avail_out))
                            return 1
                    } else if (e.match_available) {
                        if (i = J(e, 0, e.window[e.strstart - 1]),
                        i && ke(e, !1),
                        e.strstart++,
                        e.lookahead--,
                        0 === e.strm.avail_out)
                            return 1
                    } else
                        e.match_available = 1,
                        e.strstart++,
                        e.lookahead--
                }
                return e.match_available && (i = J(e, 0, e.window[e.strstart - 1]),
                e.match_available = 0),
                e.insert = e.strstart < 2 ? e.strstart : 2,
                t === ee ? (ke(e, !0),
                0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ke(e, !1),
                0 === e.strm.avail_out) ? 1 : 2
            }
            ;
            function ze(e, t, n, i, r) {
                this.good_length = e,
                this.max_lazy = t,
                this.nice_length = n,
                this.max_chain = i,
                this.func = r
            }
            const Ue = [new ze(0,0,0,0,Ie), new ze(4,4,8,4,Le), new ze(4,5,16,8,Le), new ze(4,6,32,32,Le), new ze(4,4,16,16,Ne), new ze(8,16,32,32,Ne), new ze(8,16,128,128,Ne), new ze(8,32,128,256,Ne), new ze(32,128,258,1024,Ne), new ze(32,258,258,4096,Ne)];
            function De() {
                this.strm = null,
                this.status = 0,
                this.pending_buf = null,
                this.pending_buf_size = 0,
                this.pending_out = 0,
                this.pending = 0,
                this.wrap = 0,
                this.gzhead = null,
                this.gzindex = 0,
                this.method = fe,
                this.last_flush = -1,
                this.w_size = 0,
                this.w_bits = 0,
                this.w_mask = 0,
                this.window = null,
                this.window_size = 0,
                this.prev = null,
                this.head = null,
                this.ins_h = 0,
                this.hash_size = 0,
                this.hash_bits = 0,
                this.hash_mask = 0,
                this.hash_shift = 0,
                this.block_start = 0,
                this.match_length = 0,
                this.prev_match = 0,
                this.match_available = 0,
                this.strstart = 0,
                this.match_start = 0,
                this.lookahead = 0,
                this.prev_length = 0,
                this.max_chain_length = 0,
                this.max_lazy_match = 0,
                this.level = 0,
                this.strategy = 0,
                this.good_match = 0,
                this.nice_match = 0,
                this.dyn_ltree = new Uint16Array(1146),
                this.dyn_dtree = new Uint16Array(122),
                this.bl_tree = new Uint16Array(78),
                xe(this.dyn_ltree),
                xe(this.dyn_dtree),
                xe(this.bl_tree),
                this.l_desc = null,
                this.d_desc = null,
                this.bl_desc = null,
                this.bl_count = new Uint16Array(16),
                this.heap = new Uint16Array(573),
                xe(this.heap),
                this.heap_len = 0,
                this.heap_max = 0,
                this.depth = new Uint16Array(573),
                xe(this.depth),
                this.sym_buf = 0,
                this.lit_bufsize = 0,
                this.sym_next = 0,
                this.sym_end = 0,
                this.opt_len = 0,
                this.static_len = 0,
                this.matches = 0,
                this.insert = 0,
                this.bi_buf = 0,
                this.bi_valid = 0
            }
            const Be = e => {
                if (!e)
                    return 1;
                const t = e.state;
                return !t || t.strm !== e || t.status !== Ae && 57 !== t.status && 69 !== t.status && 73 !== t.status && 91 !== t.status && 103 !== t.status && t.status !== ve && t.status !== ye ? 1 : 0
            }
              , Ge = e => {
                if (Be(e))
                    return we(e, re);
                e.total_in = e.total_out = 0,
                e.data_type = pe;
                const t = e.state;
                return t.pending = 0,
                t.pending_out = 0,
                t.wrap < 0 && (t.wrap = -t.wrap),
                t.status = 2 === t.wrap ? 57 : t.wrap ? Ae : ve,
                e.adler = 2 === t.wrap ? 0 : 1,
                t.last_flush = -2,
                K(t),
                ne
            }
              , Fe = e => {
                const t = Ge(e);
                var n;
                return t === ne && ((n = e.state).window_size = 2 * n.w_size,
                xe(n.head),
                n.max_lazy_match = Ue[n.level].max_lazy,
                n.good_match = Ue[n.level].good_length,
                n.nice_match = Ue[n.level].nice_length,
                n.max_chain_length = Ue[n.level].max_chain,
                n.strstart = 0,
                n.block_start = 0,
                n.lookahead = 0,
                n.insert = 0,
                n.match_length = n.prev_length = 2,
                n.match_available = 0,
                n.ins_h = 0),
                t
            }
              , Oe = (e, t, n, i, r, a) => {
                if (!e)
                    return re;
                let s = 1;
                if (t === oe && (t = 6),
                i < 0 ? (s = 0,
                i = -i) : i > 15 && (s = 2,
                i -= 16),
                r < 1 || r > 9 || n !== fe || i < 8 || i > 15 || t < 0 || t > 9 || a < 0 || a > de || 8 === i && 1 !== s)
                    return we(e, re);
                8 === i && (i = 9);
                const o = new De;
                return e.state = o,
                o.strm = e,
                o.status = Ae,
                o.wrap = s,
                o.gzhead = null,
                o.w_bits = i,
                o.w_size = 1 << o.w_bits,
                o.w_mask = o.w_size - 1,
                o.hash_bits = r + 7,
                o.hash_size = 1 << o.hash_bits,
                o.hash_mask = o.hash_size - 1,
                o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3),
                o.window = new Uint8Array(2 * o.w_size),
                o.head = new Uint16Array(o.hash_size),
                o.prev = new Uint16Array(o.w_size),
                o.lit_bufsize = 1 << r + 6,
                o.pending_buf_size = 4 * o.lit_bufsize,
                o.pending_buf = new Uint8Array(o.pending_buf_size),
                o.sym_buf = o.lit_bufsize,
                o.sym_end = 3 * (o.lit_bufsize - 1),
                o.level = t,
                o.strategy = a,
                o.method = n,
                Fe(e)
            }
            ;
            var We = {
                deflateInit: (e, t) => Oe(e, t, fe, 15, 8, ue),
                deflateInit2: Oe,
                deflateReset: Fe,
                deflateResetKeep: Ge,
                deflateSetHeader: (e, t) => Be(e) || 2 !== e.state.wrap ? re : (e.state.gzhead = t,
                ne),
                deflate: (e, t) => {
                    if (Be(e) || t > te || t < 0)
                        return e ? we(e, re) : re;
                    const n = e.state;
                    if (!e.output || 0 !== e.avail_in && !e.input || n.status === ye && t !== ee)
                        return we(e, 0 === e.avail_out ? se : re);
                    const i = n.last_flush;
                    if (n.last_flush = t,
                    0 !== n.pending) {
                        if (Te(e),
                        0 === e.avail_out)
                            return n.last_flush = -1,
                            ne
                    } else if (0 === e.avail_in && be(t) <= be(i) && t !== ee)
                        return we(e, se);
                    if (n.status === ye && 0 !== e.avail_in)
                        return we(e, se);
                    if (n.status === Ae && 0 === n.wrap && (n.status = ve),
                    n.status === Ae) {
                        let t = fe + (n.w_bits - 8 << 4) << 8
                          , i = -1;
                        if (i = n.strategy >= ce || n.level < 2 ? 0 : n.level < 6 ? 1 : 6 === n.level ? 2 : 3,
                        t |= i << 6,
                        0 !== n.strstart && (t |= 32),
                        t += 31 - t % 31,
                        _e(n, t),
                        0 !== n.strstart && (_e(n, e.adler >>> 16),
                        _e(n, 65535 & e.adler)),
                        e.adler = 1,
                        n.status = ve,
                        Te(e),
                        0 !== n.pending)
                            return n.last_flush = -1,
                            ne
                    }
                    if (57 === n.status)
                        if (e.adler = 0,
                        Me(n, 31),
                        Me(n, 139),
                        Me(n, 8),
                        n.gzhead)
                            Me(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)),
                            Me(n, 255 & n.gzhead.time),
                            Me(n, n.gzhead.time >> 8 & 255),
                            Me(n, n.gzhead.time >> 16 & 255),
                            Me(n, n.gzhead.time >> 24 & 255),
                            Me(n, 9 === n.level ? 2 : n.strategy >= ce || n.level < 2 ? 4 : 0),
                            Me(n, 255 & n.gzhead.os),
                            n.gzhead.extra && n.gzhead.extra.length && (Me(n, 255 & n.gzhead.extra.length),
                            Me(n, n.gzhead.extra.length >> 8 & 255)),
                            n.gzhead.hcrc && (e.adler = V(e.adler, n.pending_buf, n.pending, 0)),
                            n.gzindex = 0,
                            n.status = 69;
                        else if (Me(n, 0),
                        Me(n, 0),
                        Me(n, 0),
                        Me(n, 0),
                        Me(n, 0),
                        Me(n, 9 === n.level ? 2 : n.strategy >= ce || n.level < 2 ? 4 : 0),
                        Me(n, 3),
                        n.status = ve,
                        Te(e),
                        0 !== n.pending)
                            return n.last_flush = -1,
                            ne;
                    if (69 === n.status) {
                        if (n.gzhead.extra) {
                            let t = n.pending
                              , i = (65535 & n.gzhead.extra.length) - n.gzindex;
                            for (; n.pending + i > n.pending_buf_size; ) {
                                let r = n.pending_buf_size - n.pending;
                                if (n.pending_buf.set(n.gzhead.extra.subarray(n.gzindex, n.gzindex + r), n.pending),
                                n.pending = n.pending_buf_size,
                                n.gzhead.hcrc && n.pending > t && (e.adler = V(e.adler, n.pending_buf, n.pending - t, t)),
                                n.gzindex += r,
                                Te(e),
                                0 !== n.pending)
                                    return n.last_flush = -1,
                                    ne;
                                t = 0,
                                i -= r
                            }
                            let r = new Uint8Array(n.gzhead.extra);
                            n.pending_buf.set(r.subarray(n.gzindex, n.gzindex + i), n.pending),
                            n.pending += i,
                            n.gzhead.hcrc && n.pending > t && (e.adler = V(e.adler, n.pending_buf, n.pending - t, t)),
                            n.gzindex = 0
                        }
                        n.status = 73
                    }
                    if (73 === n.status) {
                        if (n.gzhead.name) {
                            let t, i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size) {
                                    if (n.gzhead.hcrc && n.pending > i && (e.adler = V(e.adler, n.pending_buf, n.pending - i, i)),
                                    Te(e),
                                    0 !== n.pending)
                                        return n.last_flush = -1,
                                        ne;
                                    i = 0
                                }
                                t = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0,
                                Me(n, t)
                            } while (0 !== t);
                            n.gzhead.hcrc && n.pending > i && (e.adler = V(e.adler, n.pending_buf, n.pending - i, i)),
                            n.gzindex = 0
                        }
                        n.status = 91
                    }
                    if (91 === n.status) {
                        if (n.gzhead.comment) {
                            let t, i = n.pending;
                            do {
                                if (n.pending === n.pending_buf_size) {
                                    if (n.gzhead.hcrc && n.pending > i && (e.adler = V(e.adler, n.pending_buf, n.pending - i, i)),
                                    Te(e),
                                    0 !== n.pending)
                                        return n.last_flush = -1,
                                        ne;
                                    i = 0
                                }
                                t = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0,
                                Me(n, t)
                            } while (0 !== t);
                            n.gzhead.hcrc && n.pending > i && (e.adler = V(e.adler, n.pending_buf, n.pending - i, i))
                        }
                        n.status = 103
                    }
                    if (103 === n.status) {
                        if (n.gzhead.hcrc) {
                            if (n.pending + 2 > n.pending_buf_size && (Te(e),
                            0 !== n.pending))
                                return n.last_flush = -1,
                                ne;
                            Me(n, 255 & e.adler),
                            Me(n, e.adler >> 8 & 255),
                            e.adler = 0
                        }
                        if (n.status = ve,
                        Te(e),
                        0 !== n.pending)
                            return n.last_flush = -1,
                            ne
                    }
                    if (0 !== e.avail_in || 0 !== n.lookahead || t !== Y && n.status !== ye) {
                        let i = 0 === n.level ? Ie(n, t) : n.strategy === ce ? ( (e, t) => {
                            let n;
                            for (; ; ) {
                                if (0 === e.lookahead && (Pe(e),
                                0 === e.lookahead)) {
                                    if (t === Y)
                                        return 1;
                                    break
                                }
                                if (e.match_length = 0,
                                n = J(e, 0, e.window[e.strstart]),
                                e.lookahead--,
                                e.strstart++,
                                n && (ke(e, !1),
                                0 === e.strm.avail_out))
                                    return 1
                            }
                            return e.insert = 0,
                            t === ee ? (ke(e, !0),
                            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ke(e, !1),
                            0 === e.strm.avail_out) ? 1 : 2
                        }
                        )(n, t) : n.strategy === he ? ( (e, t) => {
                            let n, i, r, a;
                            const s = e.window;
                            for (; ; ) {
                                if (e.lookahead <= ge) {
                                    if (Pe(e),
                                    e.lookahead <= ge && t === Y)
                                        return 1;
                                    if (0 === e.lookahead)
                                        break
                                }
                                if (e.match_length = 0,
                                e.lookahead >= 3 && e.strstart > 0 && (r = e.strstart - 1,
                                i = s[r],
                                i === s[++r] && i === s[++r] && i === s[++r])) {
                                    a = e.strstart + ge;
                                    do {} while (i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && i === s[++r] && r < a);
                                    e.match_length = ge - (a - r),
                                    e.match_length > e.lookahead && (e.match_length = e.lookahead)
                                }
                                if (e.match_length >= 3 ? (n = J(e, 1, e.match_length - 3),
                                e.lookahead -= e.match_length,
                                e.strstart += e.match_length,
                                e.match_length = 0) : (n = J(e, 0, e.window[e.strstart]),
                                e.lookahead--,
                                e.strstart++),
                                n && (ke(e, !1),
                                0 === e.strm.avail_out))
                                    return 1
                            }
                            return e.insert = 0,
                            t === ee ? (ke(e, !0),
                            0 === e.strm.avail_out ? 3 : 4) : e.sym_next && (ke(e, !1),
                            0 === e.strm.avail_out) ? 1 : 2
                        }
                        )(n, t) : Ue[n.level].func(n, t);
                        if (3 !== i && 4 !== i || (n.status = ye),
                        1 === i || 3 === i)
                            return 0 === e.avail_out && (n.last_flush = -1),
                            ne;
                        if (2 === i && (t === Z ? X(n) : t !== te && (q(n, 0, 0, !1),
                        t === $ && (xe(n.head),
                        0 === n.lookahead && (n.strstart = 0,
                        n.block_start = 0,
                        n.insert = 0))),
                        Te(e),
                        0 === e.avail_out))
                            return n.last_flush = -1,
                            ne
                    }
                    return t !== ee ? ne : n.wrap <= 0 ? ie : (2 === n.wrap ? (Me(n, 255 & e.adler),
                    Me(n, e.adler >> 8 & 255),
                    Me(n, e.adler >> 16 & 255),
                    Me(n, e.adler >> 24 & 255),
                    Me(n, 255 & e.total_in),
                    Me(n, e.total_in >> 8 & 255),
                    Me(n, e.total_in >> 16 & 255),
                    Me(n, e.total_in >> 24 & 255)) : (_e(n, e.adler >>> 16),
                    _e(n, 65535 & e.adler)),
                    Te(e),
                    n.wrap > 0 && (n.wrap = -n.wrap),
                    0 !== n.pending ? ne : ie)
                }
                ,
                deflateEnd: e => {
                    if (Be(e))
                        return re;
                    const t = e.state.status;
                    return e.state = null,
                    t === ve ? we(e, ae) : ne
                }
                ,
                deflateSetDictionary: (e, t) => {
                    let n = t.length;
                    if (Be(e))
                        return re;
                    const i = e.state
                      , r = i.wrap;
                    if (2 === r || 1 === r && i.status !== Ae || i.lookahead)
                        return re;
                    if (1 === r && (e.adler = O(e.adler, t, n, 0)),
                    i.wrap = 0,
                    n >= i.w_size) {
                        0 === r && (xe(i.head),
                        i.strstart = 0,
                        i.block_start = 0,
                        i.insert = 0);
                        let e = new Uint8Array(i.w_size);
                        e.set(t.subarray(n - i.w_size, n), 0),
                        t = e,
                        n = i.w_size
                    }
                    const a = e.avail_in
                      , s = e.next_in
                      , o = e.input;
                    for (e.avail_in = n,
                    e.next_in = 0,
                    e.input = t,
                    Pe(i); i.lookahead >= 3; ) {
                        let e = i.strstart
                          , t = i.lookahead - 2;
                        do {
                            i.ins_h = Ee(i, i.ins_h, i.window[e + 3 - 1]),
                            i.prev[e & i.w_mask] = i.head[i.ins_h],
                            i.head[i.ins_h] = e,
                            e++
                        } while (--t);
                        i.strstart = e,
                        i.lookahead = 2,
                        Pe(i)
                    }
                    return i.strstart += i.lookahead,
                    i.block_start = i.strstart,
                    i.insert = i.lookahead,
                    i.lookahead = 0,
                    i.match_length = i.prev_length = 2,
                    i.match_available = 0,
                    e.next_in = s,
                    e.input = o,
                    e.avail_in = a,
                    i.wrap = r,
                    ne
                }
                ,
                deflateInfo: "pako deflate (from Nodeca project)"
            };
            const Ve = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
            var He = function(e) {
                const t = Array.prototype.slice.call(arguments, 1);
                for (; t.length; ) {
                    const n = t.shift();
                    if (n) {
                        if ("object" != typeof n)
                            throw new TypeError(n + "must be non-object");
                        for (const t in n)
                            Ve(n, t) && (e[t] = n[t])
                    }
                }
                return e
            }
              , je = e => {
                let t = 0;
                for (let n = 0, i = e.length; n < i; n++)
                    t += e[n].length;
                const n = new Uint8Array(t);
                for (let t = 0, i = 0, r = e.length; t < r; t++) {
                    let r = e[t];
                    n.set(r, i),
                    i += r.length
                }
                return n
            }
            ;
            let Ke = !0;
            try {
                String.fromCharCode.apply(null, new Uint8Array(1))
            } catch (e) {
                Ke = !1
            }
            const qe = new Uint8Array(256);
            for (let e = 0; e < 256; e++)
                qe[e] = e >= 252 ? 6 : e >= 248 ? 5 : e >= 240 ? 4 : e >= 224 ? 3 : e >= 192 ? 2 : 1;
            qe[254] = qe[254] = 1;
            var Qe = e => {
                if ("function" == typeof TextEncoder && TextEncoder.prototype.encode)
                    return (new TextEncoder).encode(e);
                let t, n, i, r, a, s = e.length, o = 0;
                for (r = 0; r < s; r++)
                    n = e.charCodeAt(r),
                    55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                    56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                    r++)),
                    o += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
                for (t = new Uint8Array(o),
                a = 0,
                r = 0; a < o; r++)
                    n = e.charCodeAt(r),
                    55296 == (64512 & n) && r + 1 < s && (i = e.charCodeAt(r + 1),
                    56320 == (64512 & i) && (n = 65536 + (n - 55296 << 10) + (i - 56320),
                    r++)),
                    n < 128 ? t[a++] = n : n < 2048 ? (t[a++] = 192 | n >>> 6,
                    t[a++] = 128 | 63 & n) : n < 65536 ? (t[a++] = 224 | n >>> 12,
                    t[a++] = 128 | n >>> 6 & 63,
                    t[a++] = 128 | 63 & n) : (t[a++] = 240 | n >>> 18,
                    t[a++] = 128 | n >>> 12 & 63,
                    t[a++] = 128 | n >>> 6 & 63,
                    t[a++] = 128 | 63 & n);
                return t
            }
              , Je = (e, t) => {
                const n = t || e.length;
                if ("function" == typeof TextDecoder && TextDecoder.prototype.decode)
                    return (new TextDecoder).decode(e.subarray(0, t));
                let i, r;
                const a = new Array(2 * n);
                for (r = 0,
                i = 0; i < n; ) {
                    let t = e[i++];
                    if (t < 128) {
                        a[r++] = t;
                        continue
                    }
                    let s = qe[t];
                    if (s > 4)
                        a[r++] = 65533,
                        i += s - 1;
                    else {
                        for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < n; )
                            t = t << 6 | 63 & e[i++],
                            s--;
                        s > 1 ? a[r++] = 65533 : t < 65536 ? a[r++] = t : (t -= 65536,
                        a[r++] = 55296 | t >> 10 & 1023,
                        a[r++] = 56320 | 1023 & t)
                    }
                }
                return ( (e, t) => {
                    if (t < 65534 && e.subarray && Ke)
                        return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                    let n = "";
                    for (let i = 0; i < t; i++)
                        n += String.fromCharCode(e[i]);
                    return n
                }
                )(a, r)
            }
              , Xe = (e, t) => {
                (t = t || e.length) > e.length && (t = e.length);
                let n = t - 1;
                for (; n >= 0 && 128 == (192 & e[n]); )
                    n--;
                return n < 0 || 0 === n ? t : n + qe[e[n]] > t ? n : t
            }
            ;
            var Ye = function() {
                this.input = null,
                this.next_in = 0,
                this.avail_in = 0,
                this.total_in = 0,
                this.output = null,
                this.next_out = 0,
                this.avail_out = 0,
                this.total_out = 0,
                this.msg = "",
                this.state = null,
                this.data_type = 2,
                this.adler = 0
            };
            const Ze = Object.prototype.toString
              , {Z_NO_FLUSH: $e, Z_SYNC_FLUSH: et, Z_FULL_FLUSH: tt, Z_FINISH: nt, Z_OK: it, Z_STREAM_END: rt, Z_DEFAULT_COMPRESSION: at, Z_DEFAULT_STRATEGY: st, Z_DEFLATED: ot} = j;
            function lt(e) {
                this.options = He({
                    level: at,
                    method: ot,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: st
                }, e || {});
                let t = this.options;
                t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new Ye,
                this.strm.avail_out = 0;
                let n = We.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
                if (n !== it)
                    throw new Error(H[n]);
                if (t.header && We.deflateSetHeader(this.strm, t.header),
                t.dictionary) {
                    let e;
                    if (e = "string" == typeof t.dictionary ? Qe(t.dictionary) : "[object ArrayBuffer]" === Ze.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary,
                    n = We.deflateSetDictionary(this.strm, e),
                    n !== it)
                        throw new Error(H[n]);
                    this._dict_set = !0
                }
            }
            function ct(e, t) {
                const n = new lt(t);
                if (n.push(e, !0),
                n.err)
                    throw n.msg || H[n.err];
                return n.result
            }
            lt.prototype.push = function(e, t) {
                const n = this.strm
                  , i = this.options.chunkSize;
                let r, a;
                if (this.ended)
                    return !1;
                for (a = t === ~~t ? t : !0 === t ? nt : $e,
                "string" == typeof e ? n.input = Qe(e) : "[object ArrayBuffer]" === Ze.call(e) ? n.input = new Uint8Array(e) : n.input = e,
                n.next_in = 0,
                n.avail_in = n.input.length; ; )
                    if (0 === n.avail_out && (n.output = new Uint8Array(i),
                    n.next_out = 0,
                    n.avail_out = i),
                    (a === et || a === tt) && n.avail_out <= 6)
                        this.onData(n.output.subarray(0, n.next_out)),
                        n.avail_out = 0;
                    else {
                        if (r = We.deflate(n, a),
                        r === rt)
                            return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)),
                            r = We.deflateEnd(this.strm),
                            this.onEnd(r),
                            this.ended = !0,
                            r === it;
                        if (0 !== n.avail_out) {
                            if (a > 0 && n.next_out > 0)
                                this.onData(n.output.subarray(0, n.next_out)),
                                n.avail_out = 0;
                            else if (0 === n.avail_in)
                                break
                        } else
                            this.onData(n.output)
                    }
                return !0
            }
            ,
            lt.prototype.onData = function(e) {
                this.chunks.push(e)
            }
            ,
            lt.prototype.onEnd = function(e) {
                e === it && (this.result = je(this.chunks)),
                this.chunks = [],
                this.err = e,
                this.msg = this.strm.msg
            }
            ;
            var ht = {
                Deflate: lt,
                deflate: ct,
                deflateRaw: function(e, t) {
                    return (t = t || {}).raw = !0,
                    ct(e, t)
                },
                gzip: function(e, t) {
                    return (t = t || {}).gzip = !0,
                    ct(e, t)
                },
                constants: j
            };
            const dt = 16209;
            var ut = function(e, t) {
                let n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A, v, y, w, b, x, S, E, T;
                const k = e.state;
                n = e.next_in,
                E = e.input,
                i = n + (e.avail_in - 5),
                r = e.next_out,
                T = e.output,
                a = r - (t - e.avail_out),
                s = r + (e.avail_out - 257),
                o = k.dmax,
                l = k.wsize,
                c = k.whave,
                h = k.wnext,
                d = k.window,
                u = k.hold,
                p = k.bits,
                f = k.lencode,
                g = k.distcode,
                m = (1 << k.lenbits) - 1,
                A = (1 << k.distbits) - 1;
                e: do {
                    p < 15 && (u += E[n++] << p,
                    p += 8,
                    u += E[n++] << p,
                    p += 8),
                    v = f[u & m];
                    t: for (; ; ) {
                        if (y = v >>> 24,
                        u >>>= y,
                        p -= y,
                        y = v >>> 16 & 255,
                        0 === y)
                            T[r++] = 65535 & v;
                        else {
                            if (!(16 & y)) {
                                if (64 & y) {
                                    if (32 & y) {
                                        k.mode = 16191;
                                        break e
                                    }
                                    e.msg = "invalid literal/length code",
                                    k.mode = dt;
                                    break e
                                }
                                v = f[(65535 & v) + (u & (1 << y) - 1)];
                                continue t
                            }
                            for (w = 65535 & v,
                            y &= 15,
                            y && (p < y && (u += E[n++] << p,
                            p += 8),
                            w += u & (1 << y) - 1,
                            u >>>= y,
                            p -= y),
                            p < 15 && (u += E[n++] << p,
                            p += 8,
                            u += E[n++] << p,
                            p += 8),
                            v = g[u & A]; ; ) {
                                if (y = v >>> 24,
                                u >>>= y,
                                p -= y,
                                y = v >>> 16 & 255,
                                16 & y) {
                                    if (b = 65535 & v,
                                    y &= 15,
                                    p < y && (u += E[n++] << p,
                                    p += 8,
                                    p < y && (u += E[n++] << p,
                                    p += 8)),
                                    b += u & (1 << y) - 1,
                                    b > o) {
                                        e.msg = "invalid distance too far back",
                                        k.mode = dt;
                                        break e
                                    }
                                    if (u >>>= y,
                                    p -= y,
                                    y = r - a,
                                    b > y) {
                                        if (y = b - y,
                                        y > c && k.sane) {
                                            e.msg = "invalid distance too far back",
                                            k.mode = dt;
                                            break e
                                        }
                                        if (x = 0,
                                        S = d,
                                        0 === h) {
                                            if (x += l - y,
                                            y < w) {
                                                w -= y;
                                                do {
                                                    T[r++] = d[x++]
                                                } while (--y);
                                                x = r - b,
                                                S = T
                                            }
                                        } else if (h < y) {
                                            if (x += l + h - y,
                                            y -= h,
                                            y < w) {
                                                w -= y;
                                                do {
                                                    T[r++] = d[x++]
                                                } while (--y);
                                                if (x = 0,
                                                h < w) {
                                                    y = h,
                                                    w -= y;
                                                    do {
                                                        T[r++] = d[x++]
                                                    } while (--y);
                                                    x = r - b,
                                                    S = T
                                                }
                                            }
                                        } else if (x += h - y,
                                        y < w) {
                                            w -= y;
                                            do {
                                                T[r++] = d[x++]
                                            } while (--y);
                                            x = r - b,
                                            S = T
                                        }
                                        for (; w > 2; )
                                            T[r++] = S[x++],
                                            T[r++] = S[x++],
                                            T[r++] = S[x++],
                                            w -= 3;
                                        w && (T[r++] = S[x++],
                                        w > 1 && (T[r++] = S[x++]))
                                    } else {
                                        x = r - b;
                                        do {
                                            T[r++] = T[x++],
                                            T[r++] = T[x++],
                                            T[r++] = T[x++],
                                            w -= 3
                                        } while (w > 2);
                                        w && (T[r++] = T[x++],
                                        w > 1 && (T[r++] = T[x++]))
                                    }
                                    break
                                }
                                if (64 & y) {
                                    e.msg = "invalid distance code",
                                    k.mode = dt;
                                    break e
                                }
                                v = g[(65535 & v) + (u & (1 << y) - 1)]
                            }
                        }
                        break
                    }
                } while (n < i && r < s);
                w = p >> 3,
                n -= w,
                p -= w << 3,
                u &= (1 << p) - 1,
                e.next_in = n,
                e.next_out = r,
                e.avail_in = n < i ? i - n + 5 : 5 - (n - i),
                e.avail_out = r < s ? s - r + 257 : 257 - (r - s),
                k.hold = u,
                k.bits = p
            };
            const pt = 15
              , ft = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
              , gt = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
              , mt = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
              , At = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
            var vt = (e, t, n, i, r, a, s, o) => {
                const l = o.bits;
                let c, h, d, u, p, f, g = 0, m = 0, A = 0, v = 0, y = 0, w = 0, b = 0, x = 0, S = 0, E = 0, T = null;
                const k = new Uint16Array(16)
                  , M = new Uint16Array(16);
                let _, C, R, P = null;
                for (g = 0; g <= pt; g++)
                    k[g] = 0;
                for (m = 0; m < i; m++)
                    k[t[n + m]]++;
                for (y = l,
                v = pt; v >= 1 && 0 === k[v]; v--)
                    ;
                if (y > v && (y = v),
                0 === v)
                    return r[a++] = 20971520,
                    r[a++] = 20971520,
                    o.bits = 1,
                    0;
                for (A = 1; A < v && 0 === k[A]; A++)
                    ;
                for (y < A && (y = A),
                x = 1,
                g = 1; g <= pt; g++)
                    if (x <<= 1,
                    x -= k[g],
                    x < 0)
                        return -1;
                if (x > 0 && (0 === e || 1 !== v))
                    return -1;
                for (M[1] = 0,
                g = 1; g < pt; g++)
                    M[g + 1] = M[g] + k[g];
                for (m = 0; m < i; m++)
                    0 !== t[n + m] && (s[M[t[n + m]]++] = m);
                if (0 === e ? (T = P = s,
                f = 20) : 1 === e ? (T = ft,
                P = gt,
                f = 257) : (T = mt,
                P = At,
                f = 0),
                E = 0,
                m = 0,
                g = A,
                p = a,
                w = y,
                b = 0,
                d = -1,
                S = 1 << y,
                u = S - 1,
                1 === e && S > 852 || 2 === e && S > 592)
                    return 1;
                for (; ; ) {
                    _ = g - b,
                    s[m] + 1 < f ? (C = 0,
                    R = s[m]) : s[m] >= f ? (C = P[s[m] - f],
                    R = T[s[m] - f]) : (C = 96,
                    R = 0),
                    c = 1 << g - b,
                    h = 1 << w,
                    A = h;
                    do {
                        h -= c,
                        r[p + (E >> b) + h] = _ << 24 | C << 16 | R
                    } while (0 !== h);
                    for (c = 1 << g - 1; E & c; )
                        c >>= 1;
                    if (0 !== c ? (E &= c - 1,
                    E += c) : E = 0,
                    m++,
                    0 == --k[g]) {
                        if (g === v)
                            break;
                        g = t[n + s[m]]
                    }
                    if (g > y && (E & u) !== d) {
                        for (0 === b && (b = y),
                        p += A,
                        w = g - b,
                        x = 1 << w; w + b < v && (x -= k[w + b],
                        !(x <= 0)); )
                            w++,
                            x <<= 1;
                        if (S += 1 << w,
                        1 === e && S > 852 || 2 === e && S > 592)
                            return 1;
                        d = E & u,
                        r[d] = y << 24 | w << 16 | p - a
                    }
                }
                return 0 !== E && (r[p + E] = g - b << 24 | 64 << 16),
                o.bits = y,
                0
            }
            ;
            const {Z_FINISH: yt, Z_BLOCK: wt, Z_TREES: bt, Z_OK: xt, Z_STREAM_END: St, Z_NEED_DICT: Et, Z_STREAM_ERROR: Tt, Z_DATA_ERROR: kt, Z_MEM_ERROR: Mt, Z_BUF_ERROR: _t, Z_DEFLATED: Ct} = j
              , Rt = 16180
              , Pt = 16190
              , It = 16191
              , Lt = 16192
              , Nt = 16194
              , zt = 16199
              , Ut = 16200
              , Dt = 16206
              , Bt = 16209
              , Gt = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);
            function Ft() {
                this.strm = null,
                this.mode = 0,
                this.last = !1,
                this.wrap = 0,
                this.havedict = !1,
                this.flags = 0,
                this.dmax = 0,
                this.check = 0,
                this.total = 0,
                this.head = null,
                this.wbits = 0,
                this.wsize = 0,
                this.whave = 0,
                this.wnext = 0,
                this.window = null,
                this.hold = 0,
                this.bits = 0,
                this.length = 0,
                this.offset = 0,
                this.extra = 0,
                this.lencode = null,
                this.distcode = null,
                this.lenbits = 0,
                this.distbits = 0,
                this.ncode = 0,
                this.nlen = 0,
                this.ndist = 0,
                this.have = 0,
                this.next = null,
                this.lens = new Uint16Array(320),
                this.work = new Uint16Array(288),
                this.lendyn = null,
                this.distdyn = null,
                this.sane = 0,
                this.back = 0,
                this.was = 0
            }
            const Ot = e => {
                if (!e)
                    return 1;
                const t = e.state;
                return !t || t.strm !== e || t.mode < Rt || t.mode > 16211 ? 1 : 0
            }
              , Wt = e => {
                if (Ot(e))
                    return Tt;
                const t = e.state;
                return e.total_in = e.total_out = t.total = 0,
                e.msg = "",
                t.wrap && (e.adler = 1 & t.wrap),
                t.mode = Rt,
                t.last = 0,
                t.havedict = 0,
                t.flags = -1,
                t.dmax = 32768,
                t.head = null,
                t.hold = 0,
                t.bits = 0,
                t.lencode = t.lendyn = new Int32Array(852),
                t.distcode = t.distdyn = new Int32Array(592),
                t.sane = 1,
                t.back = -1,
                xt
            }
              , Vt = e => {
                if (Ot(e))
                    return Tt;
                const t = e.state;
                return t.wsize = 0,
                t.whave = 0,
                t.wnext = 0,
                Wt(e)
            }
              , Ht = (e, t) => {
                let n;
                if (Ot(e))
                    return Tt;
                const i = e.state;
                return t < 0 ? (n = 0,
                t = -t) : (n = 5 + (t >> 4),
                t < 48 && (t &= 15)),
                t && (t < 8 || t > 15) ? Tt : (null !== i.window && i.wbits !== t && (i.window = null),
                i.wrap = n,
                i.wbits = t,
                Vt(e))
            }
              , jt = (e, t) => {
                if (!e)
                    return Tt;
                const n = new Ft;
                e.state = n,
                n.strm = e,
                n.window = null,
                n.mode = Rt;
                const i = Ht(e, t);
                return i !== xt && (e.state = null),
                i
            }
            ;
            let Kt, qt, Qt = !0;
            const Jt = e => {
                if (Qt) {
                    Kt = new Int32Array(512),
                    qt = new Int32Array(32);
                    let t = 0;
                    for (; t < 144; )
                        e.lens[t++] = 8;
                    for (; t < 256; )
                        e.lens[t++] = 9;
                    for (; t < 280; )
                        e.lens[t++] = 7;
                    for (; t < 288; )
                        e.lens[t++] = 8;
                    for (vt(1, e.lens, 0, 288, Kt, 0, e.work, {
                        bits: 9
                    }),
                    t = 0; t < 32; )
                        e.lens[t++] = 5;
                    vt(2, e.lens, 0, 32, qt, 0, e.work, {
                        bits: 5
                    }),
                    Qt = !1
                }
                e.lencode = Kt,
                e.lenbits = 9,
                e.distcode = qt,
                e.distbits = 5
            }
              , Xt = (e, t, n, i) => {
                let r;
                const a = e.state;
                return null === a.window && (a.wsize = 1 << a.wbits,
                a.wnext = 0,
                a.whave = 0,
                a.window = new Uint8Array(a.wsize)),
                i >= a.wsize ? (a.window.set(t.subarray(n - a.wsize, n), 0),
                a.wnext = 0,
                a.whave = a.wsize) : (r = a.wsize - a.wnext,
                r > i && (r = i),
                a.window.set(t.subarray(n - i, n - i + r), a.wnext),
                (i -= r) ? (a.window.set(t.subarray(n - i, n), 0),
                a.wnext = i,
                a.whave = a.wsize) : (a.wnext += r,
                a.wnext === a.wsize && (a.wnext = 0),
                a.whave < a.wsize && (a.whave += r))),
                0
            }
            ;
            var Yt = {
                inflateReset: Vt,
                inflateReset2: Ht,
                inflateResetKeep: Wt,
                inflateInit: e => jt(e, 15),
                inflateInit2: jt,
                inflate: (e, t) => {
                    let n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A, v, y, w, b, x, S, E = 0;
                    const T = new Uint8Array(4);
                    let k, M;
                    const _ = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                    if (Ot(e) || !e.output || !e.input && 0 !== e.avail_in)
                        return Tt;
                    n = e.state,
                    n.mode === It && (n.mode = Lt),
                    s = e.next_out,
                    r = e.output,
                    l = e.avail_out,
                    a = e.next_in,
                    i = e.input,
                    o = e.avail_in,
                    c = n.hold,
                    h = n.bits,
                    d = o,
                    u = l,
                    S = xt;
                    e: for (; ; )
                        switch (n.mode) {
                        case Rt:
                            if (0 === n.wrap) {
                                n.mode = Lt;
                                break
                            }
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (2 & n.wrap && 35615 === c) {
                                0 === n.wbits && (n.wbits = 15),
                                n.check = 0,
                                T[0] = 255 & c,
                                T[1] = c >>> 8 & 255,
                                n.check = V(n.check, T, 2, 0),
                                c = 0,
                                h = 0,
                                n.mode = 16181;
                                break
                            }
                            if (n.head && (n.head.done = !1),
                            !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                                e.msg = "incorrect header check",
                                n.mode = Bt;
                                break
                            }
                            if ((15 & c) !== Ct) {
                                e.msg = "unknown compression method",
                                n.mode = Bt;
                                break
                            }
                            if (c >>>= 4,
                            h -= 4,
                            x = 8 + (15 & c),
                            0 === n.wbits && (n.wbits = x),
                            x > 15 || x > n.wbits) {
                                e.msg = "invalid window size",
                                n.mode = Bt;
                                break
                            }
                            n.dmax = 1 << n.wbits,
                            n.flags = 0,
                            e.adler = n.check = 1,
                            n.mode = 512 & c ? 16189 : It,
                            c = 0,
                            h = 0;
                            break;
                        case 16181:
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (n.flags = c,
                            (255 & n.flags) !== Ct) {
                                e.msg = "unknown compression method",
                                n.mode = Bt;
                                break
                            }
                            if (57344 & n.flags) {
                                e.msg = "unknown header flags set",
                                n.mode = Bt;
                                break
                            }
                            n.head && (n.head.text = c >> 8 & 1),
                            512 & n.flags && 4 & n.wrap && (T[0] = 255 & c,
                            T[1] = c >>> 8 & 255,
                            n.check = V(n.check, T, 2, 0)),
                            c = 0,
                            h = 0,
                            n.mode = 16182;
                        case 16182:
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.head && (n.head.time = c),
                            512 & n.flags && 4 & n.wrap && (T[0] = 255 & c,
                            T[1] = c >>> 8 & 255,
                            T[2] = c >>> 16 & 255,
                            T[3] = c >>> 24 & 255,
                            n.check = V(n.check, T, 4, 0)),
                            c = 0,
                            h = 0,
                            n.mode = 16183;
                        case 16183:
                            for (; h < 16; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            n.head && (n.head.xflags = 255 & c,
                            n.head.os = c >> 8),
                            512 & n.flags && 4 & n.wrap && (T[0] = 255 & c,
                            T[1] = c >>> 8 & 255,
                            n.check = V(n.check, T, 2, 0)),
                            c = 0,
                            h = 0,
                            n.mode = 16184;
                        case 16184:
                            if (1024 & n.flags) {
                                for (; h < 16; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                n.length = c,
                                n.head && (n.head.extra_len = c),
                                512 & n.flags && 4 & n.wrap && (T[0] = 255 & c,
                                T[1] = c >>> 8 & 255,
                                n.check = V(n.check, T, 2, 0)),
                                c = 0,
                                h = 0
                            } else
                                n.head && (n.head.extra = null);
                            n.mode = 16185;
                        case 16185:
                            if (1024 & n.flags && (p = n.length,
                            p > o && (p = o),
                            p && (n.head && (x = n.head.extra_len - n.length,
                            n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)),
                            n.head.extra.set(i.subarray(a, a + p), x)),
                            512 & n.flags && 4 & n.wrap && (n.check = V(n.check, i, p, a)),
                            o -= p,
                            a += p,
                            n.length -= p),
                            n.length))
                                break e;
                            n.length = 0,
                            n.mode = 16186;
                        case 16186:
                            if (2048 & n.flags) {
                                if (0 === o)
                                    break e;
                                p = 0;
                                do {
                                    x = i[a + p++],
                                    n.head && x && n.length < 65536 && (n.head.name += String.fromCharCode(x))
                                } while (x && p < o);
                                if (512 & n.flags && 4 & n.wrap && (n.check = V(n.check, i, p, a)),
                                o -= p,
                                a += p,
                                x)
                                    break e
                            } else
                                n.head && (n.head.name = null);
                            n.length = 0,
                            n.mode = 16187;
                        case 16187:
                            if (4096 & n.flags) {
                                if (0 === o)
                                    break e;
                                p = 0;
                                do {
                                    x = i[a + p++],
                                    n.head && x && n.length < 65536 && (n.head.comment += String.fromCharCode(x))
                                } while (x && p < o);
                                if (512 & n.flags && 4 & n.wrap && (n.check = V(n.check, i, p, a)),
                                o -= p,
                                a += p,
                                x)
                                    break e
                            } else
                                n.head && (n.head.comment = null);
                            n.mode = 16188;
                        case 16188:
                            if (512 & n.flags) {
                                for (; h < 16; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                if (4 & n.wrap && c !== (65535 & n.check)) {
                                    e.msg = "header crc mismatch",
                                    n.mode = Bt;
                                    break
                                }
                                c = 0,
                                h = 0
                            }
                            n.head && (n.head.hcrc = n.flags >> 9 & 1,
                            n.head.done = !0),
                            e.adler = n.check = 0,
                            n.mode = It;
                            break;
                        case 16189:
                            for (; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            e.adler = n.check = Gt(c),
                            c = 0,
                            h = 0,
                            n.mode = Pt;
                        case Pt:
                            if (0 === n.havedict)
                                return e.next_out = s,
                                e.avail_out = l,
                                e.next_in = a,
                                e.avail_in = o,
                                n.hold = c,
                                n.bits = h,
                                Et;
                            e.adler = n.check = 1,
                            n.mode = It;
                        case It:
                            if (t === wt || t === bt)
                                break e;
                        case Lt:
                            if (n.last) {
                                c >>>= 7 & h,
                                h -= 7 & h,
                                n.mode = Dt;
                                break
                            }
                            for (; h < 3; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            switch (n.last = 1 & c,
                            c >>>= 1,
                            h -= 1,
                            3 & c) {
                            case 0:
                                n.mode = 16193;
                                break;
                            case 1:
                                if (Jt(n),
                                n.mode = zt,
                                t === bt) {
                                    c >>>= 2,
                                    h -= 2;
                                    break e
                                }
                                break;
                            case 2:
                                n.mode = 16196;
                                break;
                            case 3:
                                e.msg = "invalid block type",
                                n.mode = Bt
                            }
                            c >>>= 2,
                            h -= 2;
                            break;
                        case 16193:
                            for (c >>>= 7 & h,
                            h -= 7 & h; h < 32; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if ((65535 & c) != (c >>> 16 ^ 65535)) {
                                e.msg = "invalid stored block lengths",
                                n.mode = Bt;
                                break
                            }
                            if (n.length = 65535 & c,
                            c = 0,
                            h = 0,
                            n.mode = Nt,
                            t === bt)
                                break e;
                        case Nt:
                            n.mode = 16195;
                        case 16195:
                            if (p = n.length,
                            p) {
                                if (p > o && (p = o),
                                p > l && (p = l),
                                0 === p)
                                    break e;
                                r.set(i.subarray(a, a + p), s),
                                o -= p,
                                a += p,
                                l -= p,
                                s += p,
                                n.length -= p;
                                break
                            }
                            n.mode = It;
                            break;
                        case 16196:
                            for (; h < 14; ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (n.nlen = 257 + (31 & c),
                            c >>>= 5,
                            h -= 5,
                            n.ndist = 1 + (31 & c),
                            c >>>= 5,
                            h -= 5,
                            n.ncode = 4 + (15 & c),
                            c >>>= 4,
                            h -= 4,
                            n.nlen > 286 || n.ndist > 30) {
                                e.msg = "too many length or distance symbols",
                                n.mode = Bt;
                                break
                            }
                            n.have = 0,
                            n.mode = 16197;
                        case 16197:
                            for (; n.have < n.ncode; ) {
                                for (; h < 3; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                n.lens[_[n.have++]] = 7 & c,
                                c >>>= 3,
                                h -= 3
                            }
                            for (; n.have < 19; )
                                n.lens[_[n.have++]] = 0;
                            if (n.lencode = n.lendyn,
                            n.lenbits = 7,
                            k = {
                                bits: n.lenbits
                            },
                            S = vt(0, n.lens, 0, 19, n.lencode, 0, n.work, k),
                            n.lenbits = k.bits,
                            S) {
                                e.msg = "invalid code lengths set",
                                n.mode = Bt;
                                break
                            }
                            n.have = 0,
                            n.mode = 16198;
                        case 16198:
                            for (; n.have < n.nlen + n.ndist; ) {
                                for (; E = n.lencode[c & (1 << n.lenbits) - 1],
                                m = E >>> 24,
                                A = E >>> 16 & 255,
                                v = 65535 & E,
                                !(m <= h); ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                if (v < 16)
                                    c >>>= m,
                                    h -= m,
                                    n.lens[n.have++] = v;
                                else {
                                    if (16 === v) {
                                        for (M = m + 2; h < M; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                            c += i[a++] << h,
                                            h += 8
                                        }
                                        if (c >>>= m,
                                        h -= m,
                                        0 === n.have) {
                                            e.msg = "invalid bit length repeat",
                                            n.mode = Bt;
                                            break
                                        }
                                        x = n.lens[n.have - 1],
                                        p = 3 + (3 & c),
                                        c >>>= 2,
                                        h -= 2
                                    } else if (17 === v) {
                                        for (M = m + 3; h < M; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                            c += i[a++] << h,
                                            h += 8
                                        }
                                        c >>>= m,
                                        h -= m,
                                        x = 0,
                                        p = 3 + (7 & c),
                                        c >>>= 3,
                                        h -= 3
                                    } else {
                                        for (M = m + 7; h < M; ) {
                                            if (0 === o)
                                                break e;
                                            o--,
                                            c += i[a++] << h,
                                            h += 8
                                        }
                                        c >>>= m,
                                        h -= m,
                                        x = 0,
                                        p = 11 + (127 & c),
                                        c >>>= 7,
                                        h -= 7
                                    }
                                    if (n.have + p > n.nlen + n.ndist) {
                                        e.msg = "invalid bit length repeat",
                                        n.mode = Bt;
                                        break
                                    }
                                    for (; p--; )
                                        n.lens[n.have++] = x
                                }
                            }
                            if (n.mode === Bt)
                                break;
                            if (0 === n.lens[256]) {
                                e.msg = "invalid code -- missing end-of-block",
                                n.mode = Bt;
                                break
                            }
                            if (n.lenbits = 9,
                            k = {
                                bits: n.lenbits
                            },
                            S = vt(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, k),
                            n.lenbits = k.bits,
                            S) {
                                e.msg = "invalid literal/lengths set",
                                n.mode = Bt;
                                break
                            }
                            if (n.distbits = 6,
                            n.distcode = n.distdyn,
                            k = {
                                bits: n.distbits
                            },
                            S = vt(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, k),
                            n.distbits = k.bits,
                            S) {
                                e.msg = "invalid distances set",
                                n.mode = Bt;
                                break
                            }
                            if (n.mode = zt,
                            t === bt)
                                break e;
                        case zt:
                            n.mode = Ut;
                        case Ut:
                            if (o >= 6 && l >= 258) {
                                e.next_out = s,
                                e.avail_out = l,
                                e.next_in = a,
                                e.avail_in = o,
                                n.hold = c,
                                n.bits = h,
                                ut(e, u),
                                s = e.next_out,
                                r = e.output,
                                l = e.avail_out,
                                a = e.next_in,
                                i = e.input,
                                o = e.avail_in,
                                c = n.hold,
                                h = n.bits,
                                n.mode === It && (n.back = -1);
                                break
                            }
                            for (n.back = 0; E = n.lencode[c & (1 << n.lenbits) - 1],
                            m = E >>> 24,
                            A = E >>> 16 & 255,
                            v = 65535 & E,
                            !(m <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (A && !(240 & A)) {
                                for (y = m,
                                w = A,
                                b = v; E = n.lencode[b + ((c & (1 << y + w) - 1) >> y)],
                                m = E >>> 24,
                                A = E >>> 16 & 255,
                                v = 65535 & E,
                                !(y + m <= h); ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                c >>>= y,
                                h -= y,
                                n.back += y
                            }
                            if (c >>>= m,
                            h -= m,
                            n.back += m,
                            n.length = v,
                            0 === A) {
                                n.mode = 16205;
                                break
                            }
                            if (32 & A) {
                                n.back = -1,
                                n.mode = It;
                                break
                            }
                            if (64 & A) {
                                e.msg = "invalid literal/length code",
                                n.mode = Bt;
                                break
                            }
                            n.extra = 15 & A,
                            n.mode = 16201;
                        case 16201:
                            if (n.extra) {
                                for (M = n.extra; h < M; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                n.length += c & (1 << n.extra) - 1,
                                c >>>= n.extra,
                                h -= n.extra,
                                n.back += n.extra
                            }
                            n.was = n.length,
                            n.mode = 16202;
                        case 16202:
                            for (; E = n.distcode[c & (1 << n.distbits) - 1],
                            m = E >>> 24,
                            A = E >>> 16 & 255,
                            v = 65535 & E,
                            !(m <= h); ) {
                                if (0 === o)
                                    break e;
                                o--,
                                c += i[a++] << h,
                                h += 8
                            }
                            if (!(240 & A)) {
                                for (y = m,
                                w = A,
                                b = v; E = n.distcode[b + ((c & (1 << y + w) - 1) >> y)],
                                m = E >>> 24,
                                A = E >>> 16 & 255,
                                v = 65535 & E,
                                !(y + m <= h); ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                c >>>= y,
                                h -= y,
                                n.back += y
                            }
                            if (c >>>= m,
                            h -= m,
                            n.back += m,
                            64 & A) {
                                e.msg = "invalid distance code",
                                n.mode = Bt;
                                break
                            }
                            n.offset = v,
                            n.extra = 15 & A,
                            n.mode = 16203;
                        case 16203:
                            if (n.extra) {
                                for (M = n.extra; h < M; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                n.offset += c & (1 << n.extra) - 1,
                                c >>>= n.extra,
                                h -= n.extra,
                                n.back += n.extra
                            }
                            if (n.offset > n.dmax) {
                                e.msg = "invalid distance too far back",
                                n.mode = Bt;
                                break
                            }
                            n.mode = 16204;
                        case 16204:
                            if (0 === l)
                                break e;
                            if (p = u - l,
                            n.offset > p) {
                                if (p = n.offset - p,
                                p > n.whave && n.sane) {
                                    e.msg = "invalid distance too far back",
                                    n.mode = Bt;
                                    break
                                }
                                p > n.wnext ? (p -= n.wnext,
                                f = n.wsize - p) : f = n.wnext - p,
                                p > n.length && (p = n.length),
                                g = n.window
                            } else
                                g = r,
                                f = s - n.offset,
                                p = n.length;
                            p > l && (p = l),
                            l -= p,
                            n.length -= p;
                            do {
                                r[s++] = g[f++]
                            } while (--p);
                            0 === n.length && (n.mode = Ut);
                            break;
                        case 16205:
                            if (0 === l)
                                break e;
                            r[s++] = n.length,
                            l--,
                            n.mode = Ut;
                            break;
                        case Dt:
                            if (n.wrap) {
                                for (; h < 32; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c |= i[a++] << h,
                                    h += 8
                                }
                                if (u -= l,
                                e.total_out += u,
                                n.total += u,
                                4 & n.wrap && u && (e.adler = n.check = n.flags ? V(n.check, r, u, s - u) : O(n.check, r, u, s - u)),
                                u = l,
                                4 & n.wrap && (n.flags ? c : Gt(c)) !== n.check) {
                                    e.msg = "incorrect data check",
                                    n.mode = Bt;
                                    break
                                }
                                c = 0,
                                h = 0
                            }
                            n.mode = 16207;
                        case 16207:
                            if (n.wrap && n.flags) {
                                for (; h < 32; ) {
                                    if (0 === o)
                                        break e;
                                    o--,
                                    c += i[a++] << h,
                                    h += 8
                                }
                                if (4 & n.wrap && c !== (4294967295 & n.total)) {
                                    e.msg = "incorrect length check",
                                    n.mode = Bt;
                                    break
                                }
                                c = 0,
                                h = 0
                            }
                            n.mode = 16208;
                        case 16208:
                            S = St;
                            break e;
                        case Bt:
                            S = kt;
                            break e;
                        case 16210:
                            return Mt;
                        default:
                            return Tt
                        }
                    return e.next_out = s,
                    e.avail_out = l,
                    e.next_in = a,
                    e.avail_in = o,
                    n.hold = c,
                    n.bits = h,
                    (n.wsize || u !== e.avail_out && n.mode < Bt && (n.mode < Dt || t !== yt)) && Xt(e, e.output, e.next_out, u - e.avail_out),
                    d -= e.avail_in,
                    u -= e.avail_out,
                    e.total_in += d,
                    e.total_out += u,
                    n.total += u,
                    4 & n.wrap && u && (e.adler = n.check = n.flags ? V(n.check, r, u, e.next_out - u) : O(n.check, r, u, e.next_out - u)),
                    e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === It ? 128 : 0) + (n.mode === zt || n.mode === Nt ? 256 : 0),
                    (0 === d && 0 === u || t === yt) && S === xt && (S = _t),
                    S
                }
                ,
                inflateEnd: e => {
                    if (Ot(e))
                        return Tt;
                    let t = e.state;
                    return t.window && (t.window = null),
                    e.state = null,
                    xt
                }
                ,
                inflateGetHeader: (e, t) => {
                    if (Ot(e))
                        return Tt;
                    const n = e.state;
                    return 2 & n.wrap ? (n.head = t,
                    t.done = !1,
                    xt) : Tt
                }
                ,
                inflateSetDictionary: (e, t) => {
                    const n = t.length;
                    let i, r, a;
                    return Ot(e) ? Tt : (i = e.state,
                    0 !== i.wrap && i.mode !== Pt ? Tt : i.mode === Pt && (r = 1,
                    r = O(r, t, n, 0),
                    r !== i.check) ? kt : (a = Xt(e, t, n, n),
                    a ? (i.mode = 16210,
                    Mt) : (i.havedict = 1,
                    xt)))
                }
                ,
                inflateInfo: "pako inflate (from Nodeca project)"
            };
            var Zt = function() {
                this.text = 0,
                this.time = 0,
                this.xflags = 0,
                this.os = 0,
                this.extra = null,
                this.extra_len = 0,
                this.name = "",
                this.comment = "",
                this.hcrc = 0,
                this.done = !1
            };
            const $t = Object.prototype.toString
              , {Z_NO_FLUSH: en, Z_FINISH: tn, Z_OK: nn, Z_STREAM_END: rn, Z_NEED_DICT: an, Z_STREAM_ERROR: sn, Z_DATA_ERROR: on, Z_MEM_ERROR: ln} = j;
            function cn(e) {
                this.options = He({
                    chunkSize: 65536,
                    windowBits: 15,
                    to: ""
                }, e || {});
                const t = this.options;
                t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits,
                0 === t.windowBits && (t.windowBits = -15)),
                !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32),
                t.windowBits > 15 && t.windowBits < 48 && (15 & t.windowBits || (t.windowBits |= 15)),
                this.err = 0,
                this.msg = "",
                this.ended = !1,
                this.chunks = [],
                this.strm = new Ye,
                this.strm.avail_out = 0;
                let n = Yt.inflateInit2(this.strm, t.windowBits);
                if (n !== nn)
                    throw new Error(H[n]);
                if (this.header = new Zt,
                Yt.inflateGetHeader(this.strm, this.header),
                t.dictionary && ("string" == typeof t.dictionary ? t.dictionary = Qe(t.dictionary) : "[object ArrayBuffer]" === $t.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)),
                t.raw && (n = Yt.inflateSetDictionary(this.strm, t.dictionary),
                n !== nn)))
                    throw new Error(H[n])
            }
            function hn(e, t) {
                const n = new cn(t);
                if (n.push(e),
                n.err)
                    throw n.msg || H[n.err];
                return n.result
            }
            cn.prototype.push = function(e, t) {
                const n = this.strm
                  , i = this.options.chunkSize
                  , r = this.options.dictionary;
                let a, s, o;
                if (this.ended)
                    return !1;
                for (s = t === ~~t ? t : !0 === t ? tn : en,
                "[object ArrayBuffer]" === $t.call(e) ? n.input = new Uint8Array(e) : n.input = e,
                n.next_in = 0,
                n.avail_in = n.input.length; ; ) {
                    for (0 === n.avail_out && (n.output = new Uint8Array(i),
                    n.next_out = 0,
                    n.avail_out = i),
                    a = Yt.inflate(n, s),
                    a === an && r && (a = Yt.inflateSetDictionary(n, r),
                    a === nn ? a = Yt.inflate(n, s) : a === on && (a = an)); n.avail_in > 0 && a === rn && n.state.wrap > 0 && 0 !== e[n.next_in]; )
                        Yt.inflateReset(n),
                        a = Yt.inflate(n, s);
                    switch (a) {
                    case sn:
                    case on:
                    case an:
                    case ln:
                        return this.onEnd(a),
                        this.ended = !0,
                        !1
                    }
                    if (o = n.avail_out,
                    n.next_out && (0 === n.avail_out || a === rn))
                        if ("string" === this.options.to) {
                            let e = Xe(n.output, n.next_out)
                              , t = n.next_out - e
                              , r = Je(n.output, e);
                            n.next_out = t,
                            n.avail_out = i - t,
                            t && n.output.set(n.output.subarray(e, e + t), 0),
                            this.onData(r)
                        } else
                            this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                    if (a !== nn || 0 !== o) {
                        if (a === rn)
                            return a = Yt.inflateEnd(this.strm),
                            this.onEnd(a),
                            this.ended = !0,
                            !0;
                        if (0 === n.avail_in)
                            break
                    }
                }
                return !0
            }
            ,
            cn.prototype.onData = function(e) {
                this.chunks.push(e)
            }
            ,
            cn.prototype.onEnd = function(e) {
                e === nn && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = je(this.chunks)),
                this.chunks = [],
                this.err = e,
                this.msg = this.strm.msg
            }
            ;
            var dn = {
                Inflate: cn,
                inflate: hn,
                inflateRaw: function(e, t) {
                    return (t = t || {}).raw = !0,
                    hn(e, t)
                },
                ungzip: hn,
                constants: j
            };
            const {Deflate: un, deflate: pn, deflateRaw: fn, gzip: gn} = ht
              , {Inflate: mn, inflate: An, inflateRaw: vn, ungzip: yn} = dn;
            var wn = {
                Deflate: un,
                deflate: pn,
                deflateRaw: fn,
                gzip: gn,
                Inflate: mn,
                inflate: An,
                inflateRaw: vn,
                ungzip: yn,
                constants: j
            }
        }
        ,
        3144: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/undo.svg"
        }
        ,
        3223: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pending.svg"
        }
        ,
        3375: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_stripe3.svg"
        }
        ,
        3476: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.ImperialUnitsEnabled = 0] = "ImperialUnitsEnabled",
                e[e.ResetHintEnabled = 1] = "ResetHintEnabled",
                e[e.GhostCarEnabled = 2] = "GhostCarEnabled",
                e[e.DefaultCameraMode = 3] = "DefaultCameraMode",
                e[e.CockpitCameraToggle = 4] = "CockpitCameraToggle",
                e[e.Checkpoints = 5] = "Checkpoints",
                e[e.Timer = 6] = "Timer",
                e[e.Speedometer = 7] = "Speedometer",
                e[e.Language = 8] = "Language",
                e[e.ShadowQuality = 9] = "ShadowQuality",
                e[e.CloudsEnabled = 10] = "CloudsEnabled",
                e[e.ParticlesEnabled = 11] = "ParticlesEnabled",
                e[e.SkidmarksEnabled = 12] = "SkidmarksEnabled",
                e[e.FogEnabled = 13] = "FogEnabled",
                e[e.RenderScale = 14] = "RenderScale",
                e[e.ScreenPixelDensity = 15] = "ScreenPixelDensity",
                e[e.Antialiasing = 16] = "Antialiasing",
                e[e.MasterVolume = 17] = "MasterVolume",
                e[e.SoundEffectVolume = 18] = "SoundEffectVolume",
                e[e.MusicVolume = 19] = "MusicVolume",
                e[e.CheckpointVolume = 20] = "CheckpointVolume",
                e[e.GhostCarSoundsEnabled = 21] = "GhostCarSoundsEnabled",
                e[e.VibrationEnabled = 22] = "VibrationEnabled",
                e[e.TouchSteeringSide = 23] = "TouchSteeringSide",
                e[e.SpeedDecimalPlaces = 24] = "SpeedDecimalPlaces",
                e[e.HuSplitsSize = 25] = "HuSplitsSize",
                e[e.HuSplitsHeight = 26] = "HuSplitsHeight",
                e[e.HuSplitsOpacity = 27] = "HuSplitsOpacity",
                e[e.HuSplitsShowSpeed = 28] = "HuSplitsShowSpeed"
            }(i || (i = {}));
            const r = i
        }
        ,
        3518: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/grid_large.svg"
        }
        ,
        3571: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => u
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)
              , o = n(4417)
              , l = n.n(o)
              , c = new URL(n(5148),n.b)
              , h = s()(r())
              , d = l()(c);
            h.push([e.id, `.touch-controls-ui {\n\tpointer-events: none;\n}\n\n.touch-controls-ui > button {\n\tposition: absolute;\n\ttop: calc(1.5cm + 50px);\n\tmargin: 10px;\n\tpadding: 0;\n\twidth: 160px;\n\theight: 160px;\n\tbackground-color: var(--button-color);\n\tborder: none;\n\topacity: 0.6;\n\tpointer-events: auto;\n\ttouch-action: none;\n}\n.touch-controls-ui > button  > img {\n\tmargin: 0;\n\tpadding: 30px;\n\tvertical-align: top;\n\twidth: 100%;\n    height: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n\ttransition: transform 0.25s ease-out;\n}\n.touch-controls-ui > button.active > img {\n    transform: scale(0.9);\n}\n\n.touch-controls-ui > .camera {\n\tleft: 1.5cm;\n}\n\n.touch-controls-ui > .reset.checkpoint-available {\n\tbackground-image: url(${d});\n\tbackground-position: 71px 64px;\n\tbackground-size: 32px;\n\tbackground-repeat: no-repeat;\n}\n.touch-controls-ui > .reset {\n\tright: 1.5cm;\n}\n\n.touch-controls-ui > .left-container {\n\tposition: absolute;\n\tleft: 1.5cm;\n\tbottom: 1.5cm;\n}\n\n.touch-controls-ui > .right-container {\n\tposition: absolute;\n\tright: 1.5cm;\n\tbottom: 1.5cm;\n}\n.touch-controls-ui > div.steering > div {\n\tdisplay: inline-block;\n}\n\n.touch-controls-ui > div > div {\n\tmargin: 10px;\n\tpadding: 0;\n\twidth: 160px;\n\theight: 160px;\n\tbackground-color: var(--button-color);\n\topacity: 0.5;\n\tpointer-events: auto;\n\ttouch-action: none;\n}\n.touch-controls-ui > div > div.active {\n\tbackground-color: var(--button-active-color);\n\topacity: 0.6;\n}\n\n.touch-controls-ui > div > div > img {\n\tmargin: 0;\n\tpadding: 40px;\n\tvertical-align: top;\n\twidth: 100%;\n    height: 100%;\n\tbox-sizing: border-box;\n\tpointer-events: none;\n}\n.touch-controls-ui > div > div.active > img {\n    padding: 50px;\n}\n`, ""]);
            const u = h
        }
        ,
        3682: (e, t, n) => {
            "use strict";
            e.exports = n.p + "forced_square.woff2"
        }
        ,
        3693: (e, t, n) => {
            "use strict";
            var i, r;
            n.d(t, {
                _: () => r,
                k: () => i
            }),
            function(e) {
                e.Heavy = "HEAVY",
                e.Medium = "MEDIUM",
                e.Light = "LIGHT"
            }(i || (i = {})),
            function(e) {
                e.Success = "SUCCESS",
                e.Warning = "WARNING",
                e.Error = "ERROR"
            }(r || (r = {}))
        }
        ,
        3755: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/share.svg"
        }
        ,
        3844: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_double_stripe.svg"
        }
        ,
        3849: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/timer.svg"
        }
        ,
        3895: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_z_negative.svg"
        }
        ,
        3901: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/summer.svg"
        }
        ,
        3902: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/verified.svg"
        }
        ,
        4055: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/paste.svg"
        }
        ,
        4078: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => ht
            });
            var i, r, a, s, o, l = n(1635), c = n(4922), h = n(1728), d = n(7888), u = n(1566), p = n(2825);
            class f {
                constructor() {
                    i.add(this),
                    s.set(this, new c.ubm((0,
                    l.gn)(r, r, "f", a),1,.5,p.A.maxViewDistance))
                }
                reset(e, t, n) {
                    this.update(e, t, 0),
                    (0,
                    l.gn)(this, s, "f").fov = (0,
                    l.gn)(this, i, "m", o).call(this, n ?? 0),
                    (0,
                    l.gn)(this, s, "f").updateProjectionMatrix()
                }
                update(e, t, n) {
                    (0,
                    l.gn)(this, s, "f").fov = (0,
                    l.gn)(this, i, "m", o).call(this, n),
                    (0,
                    l.gn)(this, s, "f").updateProjectionMatrix();
                    const r = new c.Pq0(0,1.1 + .46 / (0,
                    l.gn)(this, s, "f").zoom - .46,.4);
                    (0,
                    l.gn)(this, s, "f").position.addVectors(e, r.applyQuaternion(t)),
                    (0,
                    l.gn)(this, s, "f").quaternion.copy(t),
                    (0,
                    l.gn)(this, s, "f").quaternion.multiply((new c.PTz).setFromEuler(new c.O9p(0,Math.PI,0))),
                    (0,
                    l.gn)(this, s, "f").updateMatrix()
                }
                get camera() {
                    return (0,
                    l.gn)(this, s, "f")
                }
            }
            r = f,
            s = new WeakMap,
            i = new WeakSet,
            o = function(e) {
                return (0,
                l.gn)(r, r, "f", a) + (80 - (0,
                l.gn)(r, r, "f", a)) * (1 - Math.exp(-Math.abs(e) / 200))
            }
            ,
            a = {
                value: 70
            };
            const g = f;
            var m, A, v, y, w, b, x, S = n(765);
            class E {
                constructor() {
                    m.add(this),
                    y.set(this, new c.ubm((0,
                    l.gn)(A, A, "f", v),1,.5,p.A.maxViewDistance)),
                    w.set(this, new c.Pq0),
                    b.set(this, new c.Pq0(0,1,0))
                }
                reset(e, t, n) {
                    (0,
                    l.GG)(this, w, new c.Pq0(1e-5,0,-1), "f"),
                    (0,
                    l.gn)(this, w, "f").applyQuaternion(t),
                    (0,
                    l.gn)(this, w, "f").add(e),
                    (0,
                    l.GG)(this, b, new c.Pq0(0,1,0), "f"),
                    (0,
                    l.gn)(this, b, "f").applyQuaternion(t),
                    this.update(0, e, t, 0),
                    (0,
                    l.gn)(this, y, "f").fov = (0,
                    l.gn)(this, m, "m", x).call(this, n ?? 0),
                    (0,
                    l.gn)(this, y, "f").updateProjectionMatrix()
                }
                update(e, t, n, i) {
                    (0,
                    l.gn)(this, y, "f").fov = (0,
                    l.gn)(this, m, "m", x).call(this, i),
                    (0,
                    l.gn)(this, y, "f").updateProjectionMatrix();
                    const r = new c.Pq0(0,1,0);
                    r.applyQuaternion(n);
                    const a = Math.min(1, 5 * e);
                    (0,
                    l.gn)(this, b, "f").set(a * r.x + (1 - a) * (0,
                    l.gn)(this, b, "f").x, a * r.y + (1 - a) * (0,
                    l.gn)(this, b, "f").y, a * r.z + (1 - a) * (0,
                    l.gn)(this, b, "f").z);
                    const s = (new c.Pq0).subVectors(t, (0,
                    l.gn)(this, w, "f"));
                    s.normalize();
                    const o = 5.5
                      , h = 1.8 / Math.min((0,
                    l.gn)(this, y, "f").zoom, 2);
                    (0,
                    l.gn)(this, y, "f").position.x = t.x - s.x * o + 2 * (0,
                    l.gn)(this, b, "f").x,
                    (0,
                    l.gn)(this, y, "f").position.y = Math.max(.25, t.y - s.y * o + 2 * (0,
                    l.gn)(this, b, "f").y),
                    (0,
                    l.gn)(this, y, "f").position.z = t.z - s.z * o + 2 * (0,
                    l.gn)(this, b, "f").z,
                    (0,
                    l.gn)(this, y, "f").lookAt(t.x + (0,
                    l.gn)(this, b, "f").x * h, t.y + (0,
                    l.gn)(this, b, "f").y * h, t.z + (0,
                    l.gn)(this, b, "f").z * h),
                    (0,
                    l.gn)(this, y, "f").updateMatrix(),
                    (0,
                    l.gn)(this, w, "f").set(t.x - s.x * o, t.y - s.y * o, t.z - s.z * o)
                }
                get camera() {
                    return (0,
                    l.gn)(this, y, "f")
                }
            }
            A = E,
            y = new WeakMap,
            w = new WeakMap,
            b = new WeakMap,
            m = new WeakSet,
            x = function(e) {
                return (0,
                l.gn)(A, A, "f", v) + (100 - (0,
                l.gn)(A, A, "f", v)) * (1 - Math.exp(-Math.abs(e) / 200))
            }
            ,
            v = {
                value: 70
            };
            const T = E;
            var k, M, _, C, R, P, I, L, N, z, U = n(1066);
            class D {
                constructor(e) {
                    M.set(this, void 0),
                    _.set(this, void 0),
                    C.set(this, void 0),
                    R.set(this, void 0),
                    P.set(this, 1e3),
                    I.set(this, 0),
                    L.set(this, null),
                    N.set(this, null),
                    (0,
                    l.GG)(this, M, e, "f");
                    const t = new c.LoY;
                    (0,
                    l.GG)(this, C, new Float32Array(6 * (0,
                    l.gn)(this, P, "f") * 3), "f"),
                    (0,
                    l.GG)(this, R, new c.THS((0,
                    l.gn)(this, C, "f"),3), "f"),
                    t.setAttribute("position", (0,
                    l.gn)(this, R, "f")),
                    (0,
                    l.GG)(this, _, new c.eaF(t,(0,
                    l.gn)(k, k, "f", z)), "f"),
                    (0,
                    l.gn)(this, _, "f").frustumCulled = !1,
                    (0,
                    l.gn)(this, M, "f").scene.add((0,
                    l.gn)(this, _, "f"))
                }
                dispose() {
                    (0,
                    l.gn)(this, _, "f").geometry.dispose(),
                    (0,
                    l.gn)(this, M, "f").scene.remove((0,
                    l.gn)(this, _, "f"))
                }
                clear() {
                    for (let e = 0; e < (0,
                    l.gn)(this, C, "f").length; ++e)
                        (0,
                        l.gn)(this, C, "f")[e] = 0;
                    (0,
                    l.gn)(this, R, "f").needsUpdate = !0,
                    (0,
                    l.GG)(this, I, 0, "f"),
                    this.break()
                }
                break() {
                    (0,
                    l.GG)(this, L, null, "f"),
                    (0,
                    l.GG)(this, N, null, "f")
                }
                spawn(e, t, n, i) {
                    var r, a;
                    const s = (0,
                    l.gn)(this, L, "f")
                      , o = (0,
                    l.gn)(this, N, "f")
                      , h = (new c.Pq0).addVectors(e, new c.Pq0(.172,-.3,0).applyQuaternion(t))
                      , d = (new c.Pq0).addVectors(e, new c.Pq0(-.172,-.3,0).applyQuaternion(t))
                      , u = (new c.Pq0).copy(h)
                      , p = (new c.Pq0).copy(d)
                      , f = (new c.Pq0).subVectors(h, n).dot(i);
                    u.addScaledVector(i, -f);
                    const g = (new c.Pq0).subVectors(d, n).dot(i);
                    if (p.addScaledVector(i, -g),
                    null != s && null != o) {
                        const e = ((0,
                        l.GG)(this, I, (a = (0,
                        l.gn)(this, I, "f"),
                        r = a++,
                        a), "f"),
                        r);
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 0] = u.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 1] = u.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 2] = u.z,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 3] = s.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 4] = s.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 5] = s.z,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 6] = p.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 7] = p.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 8] = p.z,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 9] = p.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 10] = p.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 11] = p.z,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 12] = s.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 13] = s.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 14] = s.z,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 15] = o.x,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 16] = o.y,
                        (0,
                        l.gn)(this, C, "f")[6 * e * 3 + 17] = o.z,
                        (0,
                        l.gn)(this, R, "f").needsUpdate = !0,
                        (0,
                        l.gn)(this, I, "f") >= (0,
                        l.gn)(this, P, "f") - 1 && (0,
                        l.GG)(this, I, 0, "f")
                    }
                    (0,
                    l.GG)(this, L, u, "f"),
                    (0,
                    l.GG)(this, N, p, "f")
                }
            }
            k = D,
            M = new WeakMap,
            _ = new WeakMap,
            C = new WeakMap,
            R = new WeakMap,
            P = new WeakMap,
            I = new WeakMap,
            L = new WeakMap,
            N = new WeakMap,
            z = {
                value: new c.V9B({
                    color: 1118481,
                    side: c.$EB,
                    polygonOffset: !0,
                    polygonOffsetFactor: -1,
                    polygonOffsetUnits: 0
                })
            };
            const B = D;
            var G, F, O, W, V, H, j, K, q, Q, J, X, Y, Z, $, ee, te, ne, ie, re, ae, se, oe, le, ce, he, de, ue, pe, fe, ge, me, Ae, ve, ye, we, be, xe, Se, Ee, Te, ke, Me, _e, Ce, Re, Pe, Ie, Le, Ne, ze, Ue, De, Be, Ge, Fe, Oe, We, Ve, He, je, Ke, qe, Qe, Je, Xe, Ye, Ze, $e, et, tt, nt, it, rt, at, st = n(3476), ot = n(6633), lt = n(927);
            class ct {
                constructor(e, t, n, i, r, a, s, o, h, d, u) {
                    if (G.add(this),
                    O.set(this, void 0),
                    W.set(this, null),
                    V.set(this, 1),
                    H.set(this, null),
                    j.set(this, []),
                    K.set(this, null),
                    q.set(this, null),
                    Q.set(this, null),
                    J.set(this, []),
                    this.notificationAudioEnabled = !1,
                    X.set(this, void 0),
                    Y.set(this, void 0),
                    Z.set(this, void 0),
                    $.set(this, void 0),
                    ee.set(this, !1),
                    te.set(this, !1),
                    ne.set(this, null),
                    ie.set(this, void 0),
                    re.set(this, void 0),
                    ae.set(this, void 0),
                    se.set(this, void 0),
                    de.set(this, []),
                    ue.set(this, []),
                    pe.set(this, []),
                    fe.set(this, [0, 0, 0, 0]),
                    ge.set(this, [0, 0, 0, 0]),
                    me.set(this, [0, 0, 0, 0]),
                    Ae.set(this, void 0),
                    ve.set(this, void 0),
                    ye.set(this, null),
                    we.set(this, null),
                    be.set(this, void 0),
                    xe.set(this, void 0),
                    Se.set(this, void 0),
                    Ee.set(this, void 0),
                    Te.set(this, null),
                    ke.set(this, void 0),
                    Me.set(this, void 0),
                    _e.set(this, void 0),
                    Ce.set(this, void 0),
                    Re.set(this, void 0),
                    Pe.set(this, void 0),
                    Ie.set(this, void 0),
                    Le.set(this, []),
                    Ne.set(this, null),
                    ze.set(this, [.075, .075, .075, .075]),
                    Ue.set(this, null),
                    De.set(this, void 0),
                    Be.set(this, null),
                    Ge.set(this, void 0),
                    Fe.set(this, !1),
                    (0,
                    l.GG)(this, O, a, "f"),
                    (0,
                    l.GG)(this, Ae, r, "f"),
                    (0,
                    l.GG)(this, Re, s, "f"),
                    (0,
                    l.GG)(this, Pe, o, "f"),
                    (0,
                    l.GG)(this, Ie, d, "f"),
                    (0,
                    l.GG)(this, Z, e, "f"),
                    (0,
                    l.GG)(this, $, u, "f"),
                    d?.getSettingBoolean(st.A.ParticlesEnabled) ? (0,
                    l.GG)(this, De, new U.A(r), "f") : (0,
                    l.GG)(this, De, null, "f"),
                    null != (0,
                    l.gn)(this, Re, "f") && null != (0,
                    l.gn)(this, Pe, "f") && (0,
                    l.GG)(this, Le, [new B((0,
                    l.gn)(this, Ae, "f")), new B((0,
                    l.gn)(this, Ae, "f")), new B((0,
                    l.gn)(this, Ae, "f")), new B((0,
                    l.gn)(this, Ae, "f"))], "f"),
                    (0,
                    l.GG)(this, X, new T, "f"),
                    (0,
                    l.gn)(this, X, "f").reset(t.position, t.quaternion),
                    r.scene.add((0,
                    l.gn)(this, X, "f").camera),
                    (0,
                    l.GG)(this, Y, new g, "f"),
                    (0,
                    l.gn)(this, Y, "f").reset(t.position, t.quaternion),
                    r.scene.add((0,
                    l.gn)(this, Y, "f").camera),
                    null == F.models)
                        throw new Error("Car model isn't loaded yet");
                    if (null != (0,
                    l.gn)(this, Z, "f") && null != (0,
                    l.gn)(this, Re, "f") && null != (0,
                    l.gn)(this, Pe, "f") && null != h) {
                        const e = (0,
                        l.gn)(this, Z, "f").createCar(t, (0,
                        l.gn)(this, Re, "f").getMountainVertices(), (0,
                        l.gn)(this, Re, "f").getMountainOffset(), h, n, (e => {
                            this.setCarState(e, !1)
                        }
                        ));
                        (0,
                        l.GG)(this, ne, e.id, "f"),
                        (0,
                        l.GG)(this, ie, e.carState, "f")
                    } else
                        (0,
                        l.GG)(this, ie, {
                            frames: 0,
                            speedKmh: 0,
                            hasStarted: !1,
                            finishFrames: null,
                            nextCheckpointIndex: 0,
                            hasCheckpointToRespawnAt: !1,
                            position: {
                                x: t.position.x,
                                y: t.position.y,
                                z: t.position.z
                            },
                            quaternion: {
                                x: t.quaternion.x,
                                y: t.quaternion.y,
                                z: t.quaternion.z,
                                w: t.quaternion.w
                            },
                            collisionImpulses: [],
                            wheelContact: [null, null, null, null],
                            wheelSuspensionLength: [F.suspensionResetLengthFront, F.suspensionResetLengthFront, F.suspensionResetLengthRear, F.suspensionResetLengthRear],
                            wheelSuspensionVelocity: [0, 0, 0, 0],
                            wheelDeltaRotation: [0, 0, 0, 0],
                            wheelSkidInfo: [0, 0, 0, 0],
                            steering: 0,
                            brakeLightEnabled: !1,
                            controls: {
                                up: !1,
                                right: !1,
                                down: !1,
                                left: !1,
                                reset: !1
                            }
                        }, "f");
                    if ((0,
                    l.gn)(this, $, "f")?.call(this, (0,
                    l.gn)(this, ie, "f")),
                    (0,
                    l.GG)(this, re, i, "f"),
                    null == n)
                        (0,
                        l.GG)(this, ae, null != (0,
                        l.gn)(this, re, "f"), "f"),
                        (0,
                        l.GG)(this, se, new lt.A, "f");
                    else {
                        if (null != (0,
                        l.gn)(this, re, "f"))
                            throw new Error("Can't control car when recording is set");
                        (0,
                        l.GG)(this, ae, !1, "f"),
                        (0,
                        l.GG)(this, se, n, "f")
                    }
                    (0,
                    l.GG)(this, Ce, S.A.default(), "f"),
                    (0,
                    l.GG)(this, ke, (0,
                    l.gn)(F, F, "m", He).call(F, r, (0,
                    l.gn)(this, Ce, "f").pattern), "f"),
                    (0,
                    l.GG)(this, Me, {
                        value: (0,
                        l.gn)(this, ke, "f")
                    }, "f"),
                    (0,
                    l.GG)(this, _e, {
                        value: new c.Pq0(0,0,0)
                    }, "f"),
                    (0,
                    l.GG)(this, be, F.models.chassis.clone(), "f"),
                    (0,
                    l.gn)(this, G, "m", Ve).call(this, (0,
                    l.gn)(this, be, "f")),
                    (0,
                    l.GG)(this, xe, F.models.suspension.clone(), "f"),
                    (0,
                    l.gn)(this, G, "m", Ve).call(this, (0,
                    l.gn)(this, xe, "f")),
                    (0,
                    l.GG)(this, Se, (0,
                    l.gn)(F, F, "m", Ke).call(F, (0,
                    l.gn)(this, Ce, "f").exhaust), "f"),
                    (0,
                    l.gn)(this, G, "m", Ve).call(this, (0,
                    l.gn)(this, Se, "f")),
                    (0,
                    l.GG)(this, Ee, [0, 1, 2, 3].map((e => {
                        const t = (0,
                        l.gn)(F, F, "m", je).call(F, (0,
                        l.gn)(this, Ce, "f").rims);
                        (0,
                        l.gn)(this, G, "m", Ve).call(this, t);
                        return (1 == e || 3 == e) && (t.scale.x = -1),
                        t
                    }
                    )), "f"),
                    (0,
                    l.GG)(this, ve, new c.YJl, "f"),
                    (0,
                    l.gn)(this, ve, "f").add((0,
                    l.gn)(this, be, "f")),
                    (0,
                    l.gn)(this, ve, "f").add((0,
                    l.gn)(this, xe, "f")),
                    (0,
                    l.gn)(this, be, "f").add((0,
                    l.gn)(this, Se, "f"));
                    for (const e of (0,
                    l.gn)(this, Ee, "f"))
                        (0,
                        l.gn)(this, ve, "f").add(e);
                    if ((0,
                    l.gn)(this, Ae, "f").scene.add((0,
                    l.gn)(this, ve, "f")),
                    null != (0,
                    l.gn)(this, re, "f") && null != (0,
                    l.gn)(this, ne, "f")) {
                        const e = (0,
                        l.gn)(this, ne, "f");
                        (0,
                        l.gn)(this, Z, "f")?.controlCar(e, (0,
                        l.gn)(this, re, "f").up, (0,
                        l.gn)(this, re, "f").right, (0,
                        l.gn)(this, re, "f").down, (0,
                        l.gn)(this, re, "f").left, (0,
                        l.gn)(this, re, "f").reset),
                        (0,
                        l.gn)(this, re, "f").addChangeCallback((0,
                        l.GG)(this, Be, (t => {
                            (0,
                            l.gn)(this, te, "f") || (0,
                            l.gn)(this, Z, "f")?.controlCar(e, t.up, t.right, t.down, t.left, t.reset)
                        }
                        ), "f"))
                    }
                    r.addContextRestoredEventListener((0,
                    l.GG)(this, Ge, ( () => {
                        (0,
                        l.gn)(this, ke, "f").dispose(),
                        (0,
                        l.GG)(this, ke, (0,
                        l.gn)(F, F, "m", He).call(F, r, (0,
                        l.gn)(this, Ce, "f").pattern), "f"),
                        (0,
                        l.gn)(this, Me, "f").value = (0,
                        l.gn)(this, ke, "f"),
                        (0,
                        l.gn)(this, G, "m", We).call(this)
                    }
                    ), "f"))
                }
                dispose() {
                    (0,
                    l.GG)(this, Fe, !0, "f"),
                    (0,
                    l.gn)(this, G, "m", Oe).call(this),
                    (0,
                    l.gn)(this, Ae, "f").scene.remove((0,
                    l.gn)(this, X, "f").camera),
                    (0,
                    l.gn)(this, Ae, "f").scene.remove((0,
                    l.gn)(this, Y, "f").camera),
                    (0,
                    l.gn)(this, De, "f")?.dispose();
                    for (const e of (0,
                    l.gn)(this, Le, "f"))
                        e.dispose();
                    (0,
                    l.gn)(this, Le, "f").length = 0,
                    null != (0,
                    l.gn)(this, we, "f") && ((0,
                    l.gn)(this, we, "f").geometry.dispose(),
                    (0,
                    l.gn)(this, we, "f").material.map?.dispose(),
                    (0,
                    l.gn)(this, we, "f").material.dispose(),
                    (0,
                    l.gn)(this, Ae, "f").scene.remove((0,
                    l.gn)(this, we, "f")),
                    (0,
                    l.GG)(this, we, null, "f")),
                    (0,
                    l.gn)(this, Ae, "f").scene.remove((0,
                    l.gn)(this, ve, "f")),
                    (0,
                    l.gn)(this, ke, "f").dispose(),
                    (0,
                    l.gn)(this, ve, "f").traverse((e => {
                        e instanceof c.eaF && (0,
                        l.gn)(this, Ae, "f").removeMaterial(e.material)
                    }
                    )),
                    null != (0,
                    l.gn)(this, ne, "f") && (0,
                    l.gn)(this, Z, "f")?.deleteCar((0,
                    l.gn)(this, ne, "f")),
                    null != (0,
                    l.gn)(this, Be, "f") && (0,
                    l.gn)(this, re, "f")?.removeChangeCallback((0,
                    l.gn)(this, Be, "f")),
                    (0,
                    l.gn)(this, Ae, "f").removeContextRestoredEventListener((0,
                    l.gn)(this, Ge, "f"))
                }
                addResetCallback(e) {
                    (0,
                    l.gn)(this, de, "f").push(e)
                }
                addCheckpointCallback(e) {
                    (0,
                    l.gn)(this, ue, "f").push(e)
                }
                addFinishCallback(e) {
                    (0,
                    l.gn)(this, pe, "f").push(e)
                }
                getChassisMatrix() {
                    return (0,
                    l.gn)(this, be, "f").matrix
                }
                getSpeedKmh() {
                    return (0,
                    l.gn)(this, ie, "f").speedKmh
                }
                start() {
                    null != (0,
                    l.gn)(this, ne, "f") && (0,
                    l.gn)(this, Z, "f")?.startCar((0,
                    l.gn)(this, ne, "f"), null)
                }
                hasStarted() {
                    return (0,
                    l.gn)(this, ie, "f").hasStarted
                }
                hasFinished() {
                    return null != (0,
                    l.gn)(this, ie, "f").finishFrames
                }
                getFinishTime() {
                    return null == (0,
                    l.gn)(this, ie, "f").finishFrames ? null : new ot.A((0,
                    l.gn)(this, ie, "f").finishFrames)
                }
                getRecording() {
                    return (0,
                    l.gn)(this, se, "f")
                }
                getTime() {
                    return new ot.A((0,
                    l.gn)(this, ie, "f").frames)
                }
                getNextCheckpointIndex() {
                    return (0,
                    l.gn)(this, ie, "f").nextCheckpointIndex
                }
                hasCheckpointToRespawnAt() {
                    return (0,
                    l.gn)(this, ie, "f").hasCheckpointToRespawnAt
                }
                getPosition() {
                    return new c.Pq0((0,
                    l.gn)(this, ie, "f").position.x,(0,
                    l.gn)(this, ie, "f").position.y,(0,
                    l.gn)(this, ie, "f").position.z)
                }
                getQuaternion() {
                    return new c.PTz((0,
                    l.gn)(this, ie, "f").quaternion.x,(0,
                    l.gn)(this, ie, "f").quaternion.y,(0,
                    l.gn)(this, ie, "f").quaternion.z,(0,
                    l.gn)(this, ie, "f").quaternion.w)
                }
                getMatrix4() {
                    const e = this.getPosition()
                      , t = this.getQuaternion()
                      , n = (new c.kn4).makeRotationFromQuaternion(t);
                    return n.setPosition(e),
                    n
                }
                get isPaused() {
                    return (0,
                    l.gn)(this, ee, "f")
                }
                set isPaused(e) {
                    (0,
                    l.gn)(this, ee, "f") != e && (null != (0,
                    l.gn)(this, ne, "f") && (0,
                    l.gn)(this, Z, "f")?.pauseCar((0,
                    l.gn)(this, ne, "f"), e),
                    (0,
                    l.GG)(this, ee, e, "f"))
                }
                get isControlsDisabled() {
                    return (0,
                    l.gn)(this, te, "f")
                }
                set isControlsDisabled(e) {
                    e != (0,
                    l.gn)(this, te, "f") && (null != (0,
                    l.gn)(this, re, "f") && null != (0,
                    l.gn)(this, ne, "f") && (e ? (0,
                    l.gn)(this, Z, "f")?.controlCar((0,
                    l.gn)(this, ne, "f"), !1, !1, !1, !1, !1) : (0,
                    l.gn)(this, Z, "f")?.controlCar((0,
                    l.gn)(this, ne, "f"), (0,
                    l.gn)(this, re, "f").up, (0,
                    l.gn)(this, re, "f").right, (0,
                    l.gn)(this, re, "f").down, (0,
                    l.gn)(this, re, "f").left, (0,
                    l.gn)(this, re, "f").reset)),
                    (0,
                    l.GG)(this, te, e, "f"))
                }
                getControls() {
                    return (0,
                    l.gn)(this, te, "f") ? {
                        up: !1,
                        right: !1,
                        down: !1,
                        left: !1,
                        reset: !1
                    } : null != (0,
                    l.gn)(this, re, "f") ? (0,
                    l.gn)(this, re, "f").getControls() : (0,
                    l.gn)(this, ie, "f").controls
                }
                setNameTag(e, t) {
                    null != (0,
                    l.gn)(this, ye, "f") && (0,
                    l.gn)(this, ye, "f").countryCode == e && (0,
                    l.gn)(this, ye, "f").name == t || ((0,
                    l.GG)(this, ye, {
                        countryCode: e,
                        name: t
                    }, "f"),
                    (0,
                    l.gn)(this, G, "m", We).call(this))
                }
                getCarStyle() {
                    return (0,
                    l.gn)(this, Ce, "f")
                }
                setCarStyle(e) {
                    if (!(0,
                    l.gn)(this, Ce, "f").equals(e)) {
                        if (e.pattern != (0,
                        l.gn)(this, Ce, "f").pattern && ((0,
                        l.gn)(this, ke, "f").dispose(),
                        (0,
                        l.GG)(this, ke, (0,
                        l.gn)(F, F, "m", He).call(F, (0,
                        l.gn)(this, Ae, "f"), e.pattern), "f"),
                        (0,
                        l.gn)(this, Me, "f").value = (0,
                        l.gn)(this, ke, "f")),
                        e.rims != (0,
                        l.gn)(this, Ce, "f").rims)
                            for (let t = 0; t < (0,
                            l.gn)(this, Ee, "f").length; t++) {
                                const n = (0,
                                l.gn)(this, Ee, "f")[t];
                                (0,
                                l.gn)(this, ve, "f").remove(n),
                                (0,
                                l.gn)(this, Ae, "f").removeMaterial(n.material);
                                const i = (0,
                                l.gn)(F, F, "m", je).call(F, e.rims);
                                (0,
                                l.gn)(this, G, "m", Ve).call(this, i),
                                i.position.copy(n.position),
                                i.quaternion.copy(n.quaternion),
                                i.scale.copy(n.scale),
                                (0,
                                l.gn)(this, ve, "f").add(i),
                                (0,
                                l.gn)(this, Ee, "f")[t] = i
                            }
                        e.exhaust != (0,
                        l.gn)(this, Ce, "f").exhaust && ((0,
                        l.gn)(this, be, "f").remove((0,
                        l.gn)(this, Se, "f")),
                        (0,
                        l.gn)(this, Ae, "f").removeMaterial((0,
                        l.gn)(this, Se, "f").material),
                        (0,
                        l.GG)(this, Se, (0,
                        l.gn)(F, F, "m", Ke).call(F, e.exhaust), "f"),
                        (0,
                        l.gn)(this, G, "m", Ve).call(this, (0,
                        l.gn)(this, Se, "f")),
                        (0,
                        l.gn)(this, be, "f").add((0,
                        l.gn)(this, Se, "f"))),
                        (0,
                        l.gn)(this, _e, "f").value = (new c.Pq0).setFromColor(e.secondaryColor),
                        (0,
                        l.gn)(this, ve, "f").traverse((t => {
                            if (t instanceof c.eaF) {
                                let n;
                                n = Array.isArray(t.material) ? t.material : [t.material];
                                for (const t of n)
                                    "Main" == t.name ? t.color.set(e.primaryColor) : "Metal" == t.name ? t.color.set(e.frameColor) : "Rim" == t.name && t.color.set(e.rimsColor)
                            }
                        }
                        )),
                        (0,
                        l.GG)(this, Ce, e.clone(), "f")
                    }
                }
                setOpacity(e) {
                    (0,
                    l.gn)(this, ve, "f").traverse((t => {
                        if (t instanceof c.eaF) {
                            let n;
                            n = Array.isArray(t.material) ? t.material : [t.material];
                            for (const t of n) {
                                t.opacity = e;
                                const n = e < 1;
                                t.needsUpdate = n != t.transparent,
                                t.transparent = n
                            }
                        }
                    }
                    ))
                }
                setVisible(e) {
                    (0,
                    l.gn)(this, ve, "f").visible = e
                }
                getCarState() {
                    return (0,
                    l.gn)(this, ie, "f")
                }
                setCarState(e, t) {
                    if ((0,
                    l.gn)(this, Fe, "f"))
                        return;
                    const n = (0,
                    l.gn)(this, ie, "f");
                    (0,
                    l.GG)(this, ie, e, "f");
                    const i = .001;
                    if (t) {
                        (0,
                        l.GG)(this, Ue, null, "f"),
                        (0,
                        l.gn)(this, De, "f")?.clear();
                        for (const e of (0,
                        l.gn)(this, Le, "f"))
                            e.clear()
                    }
                    if ((null == (0,
                    l.gn)(this, Ue, "f") || (0,
                    l.gn)(this, Ue, "f") + 10 <= (0,
                    l.gn)(this, ie, "f").frames) && ((0,
                    l.GG)(this, Ue, (0,
                    l.gn)(this, ie, "f").frames, "f"),
                    (0,
                    l.gn)(this, G, "m", Je).call(this, .01)),
                    t || !n.controls.reset && (0,
                    l.gn)(this, ie, "f").controls.reset) {
                        (0,
                        l.gn)(this, X, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh()),
                        (0,
                        l.gn)(this, Y, "f").reset(this.getPosition(), this.getQuaternion(), this.getSpeedKmh());
                        for (const e of (0,
                        l.gn)(this, de, "f"))
                            e()
                    }
                    if ((0,
                    l.gn)(this, G, "m", Ze).call(this, i),
                    (0,
                    l.gn)(this, G, "m", et).call(this, i),
                    (0,
                    l.gn)(this, ae, "f") && (0,
                    l.gn)(this, ie, "f").hasStarted && null == n.finishFrames && (0,
                    l.gn)(this, se, "f").recordFrame(n.frames, (0,
                    l.gn)(this, ie, "f").controls),
                    (0,
                    l.gn)(this, ie, "f").nextCheckpointIndex > n.nextCheckpointIndex) {
                        this.notificationAudioEnabled && (0,
                        l.gn)(this, G, "m", Qe).call(this);
                        for (const e of (0,
                        l.gn)(this, ue, "f"))
                            e(n.nextCheckpointIndex)
                    }
                    if (null != (0,
                    l.gn)(this, ie, "f").finishFrames && null == n.finishFrames) {
                        this.notificationAudioEnabled && (0,
                        l.gn)(this, G, "m", Qe).call(this);
                        for (const e of (0,
                        l.gn)(this, pe, "f"))
                            e(this)
                    }
                    (t || (0,
                    l.gn)(this, ie, "f").frames % 50 == 0) && (0,
                    l.gn)(this, $, "f")?.call(this, (0,
                    l.gn)(this, ie, "f"))
                }
                update(e) {
                    if ((0,
                    l.gn)(this, G, "m", Xe).call(this),
                    (0,
                    l.gn)(this, De, "f")?.update(e),
                    null != (0,
                    l.gn)(this, we, "f")) {
                        const e = this.getPosition()
                          , t = new c.Pq0(0,1,0).applyQuaternion(this.getQuaternion())
                          , n = 1.75;
                        (0,
                        l.gn)(this, we, "f").position.copy(e.clone().addScaledVector(t, n));
                        const i = (0,
                        l.gn)(this, we, "f").position.distanceToSquared((0,
                        l.gn)(this, Ae, "f").camera.position)
                          , r = 2.5
                          , a = 50;
                        (0,
                        l.gn)(this, we, "f").visible = i >= r * r && i <= a * a,
                        (0,
                        l.gn)(this, we, "f").visible && (0,
                        l.gn)(this, we, "f").lookAt((0,
                        l.gn)(this, Ae, "f").camera.position)
                    }
                    const t = this.getMatrix4()
                      , n = this.getQuaternion();
                    (0,
                    l.gn)(this, be, "f").matrixAutoUpdate = !1,
                    (0,
                    l.gn)(this, be, "f").matrix.copy(t),
                    (0,
                    l.gn)(this, be, "f").matrix.multiply((new c.kn4).makeTranslation(0, F.massOffset, 0)),
                    (0,
                    l.gn)(this, xe, "f").matrixAutoUpdate = !1,
                    (0,
                    l.gn)(this, xe, "f").matrix.copy((0,
                    l.gn)(this, be, "f").matrix);
                    for (let i = 0; i < 4; i++) {
                        const r = null != (0,
                        l.gn)(this, ie, "f").wheelContact[i]
                          , a = (0,
                        l.gn)(this, ie, "f").wheelDeltaRotation[i];
                        if (this.hasStarted()) {
                            if (r)
                                (0,
                                l.gn)(this, fe, "f")[i] = 1e3 * a,
                                (0,
                                l.gn)(this, ge, "f")[i] = 1e3 * a;
                            else {
                                const {up: t, down: n} = this.getControls()
                                  , r = 2 == i || 3 == i;
                                n ? (0,
                                l.gn)(this, ie, "f").brakeLightEnabled ? (0,
                                l.gn)(this, ge, "f")[i] > 0 ? (0,
                                l.gn)(this, ge, "f")[i] = Math.max(0, (0,
                                l.gn)(this, ge, "f")[i] - 50 * e) : (0,
                                l.gn)(this, ge, "f")[i] < 0 && ((0,
                                l.gn)(this, ge, "f")[i] = Math.min(0, (0,
                                l.gn)(this, ge, "f")[i] + 50 * e)) : r && ((0,
                                l.gn)(this, fe, "f")[i] -= 25 * e,
                                (0,
                                l.gn)(this, ge, "f")[i] -= 25 * e) : t && r && ((0,
                                l.gn)(this, fe, "f")[i] += 25 * e,
                                (0,
                                l.gn)(this, ge, "f")[i] += 50 * e),
                                (0,
                                l.gn)(this, fe, "f")[i] *= Math.max(0, 1 - e),
                                (0,
                                l.gn)(this, ge, "f")[i] *= Math.max(0, 1 - e)
                            }
                            (0,
                            l.gn)(this, me, "f")[i] += (0,
                            l.gn)(this, ge, "f")[i] * e
                        }
                        const s = (0,
                        l.gn)(F, F, "f", oe)[i].clone().add(new c.Pq0(0,-(0,
                        l.gn)(this, ie, "f").wheelSuspensionLength[i],0)).applyMatrix4(t)
                          , o = n.clone();
                        (0 == i || 1 == i) && o.multiply((new c.PTz).setFromAxisAngle(new c.Pq0(0,1,0), (0,
                        l.gn)(this, ie, "f").steering)),
                        o.multiply((new c.PTz).setFromAxisAngle(new c.Pq0(1,0,0), (0,
                        l.gn)(this, me, "f")[i])),
                        (0,
                        l.gn)(this, Ee, "f")[i].position.copy(s),
                        (0,
                        l.gn)(this, Ee, "f")[i].quaternion.copy(o);
                        const h = (0,
                        l.gn)(this, ie, "f").wheelSuspensionLength[i]
                          , d = (0,
                        l.gn)(this, ie, "f").wheelSkidInfo[i];
                        if ((0,
                        l.gn)(this, xe, "f").morphTargetInfluences || ((0,
                        l.gn)(this, xe, "f").morphTargetInfluences = []),
                        (0,
                        l.gn)(this, xe, "f").morphTargetInfluences[i] = 2 * h + .06,
                        e > 0 && (0,
                        l.gn)(this, Ie, "f")?.getSettingBoolean(st.A.SkidmarksEnabled) && i < (0,
                        l.gn)(this, Le, "f").length) {
                            const e = (0,
                            l.gn)(this, ie, "f").wheelContact[i]
                              , t = Math.min(1, Math.abs(a) / (0,
                            l.gn)(F, F, "f", le))
                              , r = Math.pow(t, (0,
                            l.gn)(F, F, "f", ce)) * (0,
                            l.gn)(F, F, "f", he);
                            null != e && d < r && 0 == (0,
                            l.gn)(this, ze, "f")[i] && (0,
                            l.gn)(this, Le, "f")[i].spawn(new c.Pq0(s.x,s.y,s.z), n, new c.Pq0(e.position.x,e.position.y,e.position.z), new c.Pq0(e.normal.x,e.normal.y,e.normal.z))
                        }
                    }
                    (0,
                    l.gn)(this, G, "m", it).call(this, (0,
                    l.gn)(this, ie, "f").brakeLightEnabled)
                }
                updateCameras(e) {
                    if (null == (0,
                    l.gn)(this, ie, "f").finishFrames) {
                        const t = this.getPosition()
                          , n = this.getQuaternion()
                          , i = this.getSpeedKmh();
                        (0,
                        l.gn)(this, X, "f").update(e, t, n, i),
                        (0,
                        l.gn)(this, Y, "f").update(t, n, i)
                    }
                }
                get cameraOrbit() {
                    return (0,
                    l.gn)(this, X, "f").camera
                }
                get cameraCockpit() {
                    return (0,
                    l.gn)(this, Y, "f").camera
                }
                set audioVolume(e) {
                    (0,
                    l.GG)(this, V, e, "f"),
                    null != (0,
                    l.gn)(this, W, "f") && (0,
                    l.gn)(this, W, "f").gain.setTargetAtTime((0,
                    l.gn)(this, V, "f"), 0, .01)
                }
                static async initResources() {
                    const e = await new Promise(( (e, t) => {
                        const n = new d.B
                          , i = new h.Z;
                        i.setDecoderPath("lib/draco/"),
                        n.setDRACOLoader(i),
                        n.load("models/car.glb", (n => {
                            function r(e, t) {
                                const i = n.scene.getObjectByName(e);
                                if (null == i)
                                    throw new Error('Mesh "' + e + '" does not exist');
                                if (0 == i.children.length) {
                                    if (!(i instanceof c.eaF))
                                        throw new Error('Mesh "' + e + '" is not a valid mesh');
                                    const n = i;
                                    return t && (n.updateMatrixWorld(!0),
                                    n.geometry.applyMatrix4(n.matrix.clone()),
                                    n.geometry.computeVertexNormals(),
                                    n.matrix.identity()),
                                    n
                                }
                                const r = i.children.map((t => {
                                    if (!(t instanceof c.eaF))
                                        throw new Error('Mesh "' + e + '" has invalid child meshes');
                                    return t
                                }
                                ))
                                  , a = r.map((e => e.geometry))
                                  , s = u.pP(a, !0);
                                t && (i.updateMatrixWorld(!0),
                                s.applyMatrix4(i.matrix.clone())),
                                s.computeVertexNormals();
                                const o = r.map((e => e.material))
                                  , l = new c.eaF(s,o);
                                return l.name = e,
                                l
                            }
                            function a(e) {
                                let t;
                                t = Array.isArray(e.material) ? e.material : [e.material];
                                for (const e of t)
                                    e.side = c.hB5,
                                    e.shadowSide = c.hB5;
                                return e
                            }
                            i.dispose();
                            const s = new Map;
                            for (let e = 0; e < S.A.rims.length; e++) {
                                if (!S.A.isValidRims(e))
                                    throw new Error("Invalid car style rims");
                                s.set(e, a(r(S.A.rims[e].model, !1)))
                            }
                            const o = new Map;
                            for (let e = 0; e < S.A.exhausts.length; e++) {
                                if (!S.A.isValidExhaust(e))
                                    throw new Error("Invalid car style exhaust");
                                o.set(e, a(r(S.A.exhausts[e].model, !0)))
                            }
                            F.models = {
                                chassis: a(r("Body", !0)),
                                suspension: a(r("Suspension", !0)),
                                rims: s,
                                exhausts: o,
                                collisionShapeVertices: (0,
                                l.gn)(F, F, "m", rt).call(F, r("Collision", !0))
                            },
                            (0,
                            l.gn)(F, F, "m", at).call(F).then((t => {
                                e(t)
                            }
                            )).catch(t)
                        }
                        ), void 0, t)
                    }
                    ))
                      , t = S.A.patterns.map(( ({url: e}) => new Promise(( (t, n) => {
                        const i = new Image;
                        i.addEventListener("load", ( () => {
                            t(i)
                        }
                        )),
                        i.addEventListener("error", ( () => {
                            n(new Error("Failed to load image"))
                        }
                        )),
                        i.src = e
                    }
                    ))));
                    return F.patterns = await Promise.all(t),
                    e
                }
            }
            F = ct,
            O = new WeakMap,
            W = new WeakMap,
            V = new WeakMap,
            H = new WeakMap,
            j = new WeakMap,
            K = new WeakMap,
            q = new WeakMap,
            Q = new WeakMap,
            J = new WeakMap,
            X = new WeakMap,
            Y = new WeakMap,
            Z = new WeakMap,
            $ = new WeakMap,
            ee = new WeakMap,
            te = new WeakMap,
            ne = new WeakMap,
            ie = new WeakMap,
            re = new WeakMap,
            ae = new WeakMap,
            se = new WeakMap,
            de = new WeakMap,
            ue = new WeakMap,
            pe = new WeakMap,
            fe = new WeakMap,
            ge = new WeakMap,
            me = new WeakMap,
            Ae = new WeakMap,
            ve = new WeakMap,
            ye = new WeakMap,
            we = new WeakMap,
            be = new WeakMap,
            xe = new WeakMap,
            Se = new WeakMap,
            Ee = new WeakMap,
            Te = new WeakMap,
            ke = new WeakMap,
            Me = new WeakMap,
            _e = new WeakMap,
            Ce = new WeakMap,
            Re = new WeakMap,
            Pe = new WeakMap,
            Ie = new WeakMap,
            Le = new WeakMap,
            Ne = new WeakMap,
            ze = new WeakMap,
            Ue = new WeakMap,
            De = new WeakMap,
            Be = new WeakMap,
            Ge = new WeakMap,
            Fe = new WeakMap,
            G = new WeakSet,
            Oe = function() {
                (0,
                l.gn)(this, G, "m", qe).call(this),
                setTimeout(( () => {
                    if (null != (0,
                    l.gn)(this, H, "f") && ((0,
                    l.gn)(this, H, "f").source.stop(),
                    (0,
                    l.GG)(this, H, null, "f")),
                    null != (0,
                    l.gn)(this, K, "f")) {
                        for (const {source: e} of (0,
                        l.gn)(this, K, "f"))
                            e.stop();
                        (0,
                        l.GG)(this, K, null, "f")
                    }
                }
                ), 200)
            }
            ,
            We = function() {
                if (null != (0,
                l.gn)(this, we, "f") && ((0,
                l.gn)(this, we, "f").geometry.dispose(),
                (0,
                l.gn)(this, we, "f").material.map?.dispose(),
                (0,
                l.gn)(this, we, "f").material.dispose(),
                (0,
                l.gn)(this, Ae, "f").scene.remove((0,
                l.gn)(this, we, "f")),
                (0,
                l.GG)(this, we, null, "f")),
                null != (0,
                l.gn)(this, ye, "f")) {
                    const e = document.createElement("canvas")
                      , t = e.getContext("2d");
                    if (null != t) {
                        const n = 64
                          , i = `bold ${n.toString()}px ForcedSquare, Arial, sans-serif`;
                        let r, a;
                        t.font = i,
                        null == (0,
                        l.gn)(this, ye, "f").countryCode ? (r = 0,
                        a = 0) : (r = n * (4 / 3),
                        a = 10);
                        const s = t.measureText((0,
                        l.gn)(this, ye, "f").name).width;
                        if (e.width = r + a + s + 20,
                        e.height = n + 20,
                        null != (0,
                        l.gn)(this, ye, "f").countryCode) {
                            const e = new Image;
                            e.src = "images/countries/" + (0,
                            l.gn)(this, ye, "f").countryCode + ".svg?v=0.6.0-beta1-mp21",
                            e.addEventListener("load", ( () => {
                                t.drawImage(e, 10, 10, r, n),
                                o.needsUpdate = !0
                            }
                            ))
                        }
                        t.fillStyle = "rgba(0,0,0,0.4)",
                        t.fillRect(0, 0, e.width, e.height),
                        t.fillStyle = "rgba(255,255,255,0.9)",
                        t.font = i,
                        t.fillText((0,
                        l.gn)(this, ye, "f").name, 10 + r + a, n - 5);
                        const o = new c.gPd(e);
                        o.needsUpdate = !0;
                        const h = .4
                          , d = h * e.width / e.height
                          , u = new c.bdM(d,h)
                          , p = new c.V9B({
                            map: o,
                            transparent: !0,
                            depthTest: !1,
                            depthWrite: !1
                        });
                        (0,
                        l.GG)(this, we, new c.eaF(u,p), "f"),
                        (0,
                        l.gn)(this, we, "f").renderOrder = 1,
                        (0,
                        l.gn)(this, Ae, "f").scene.add((0,
                        l.gn)(this, we, "f"))
                    }
                }
            }
            ,
            Ve = function(e) {
                let t;
                Array.isArray(e.material) ? (t = e.material.map((e => {
                    if (!(e instanceof c.imn))
                        throw new Error("Material is not a THREE.Material");
                    return e.clone()
                }
                )),
                e.material = t) : (t = [e.material.clone()],
                e.material = t[0]);
                for (const e of t)
                    if ("Main" == e.name) {
                        if (!(e instanceof c._4j))
                            throw new Error("Main material must be MeshStandardMaterial");
                        e.onBeforeCompile = e => {
                            e.fragmentShader = "uniform sampler2D carColorPattern;\nuniform vec3 carColorSecondary;\n" + e.fragmentShader,
                            e.fragmentShader = e.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );", "float colorSource = texture(carColorPattern, vUv).g;\nvec4 diffuseColor = vec4( carColorSecondary * colorSource + diffuse * (1.0 - colorSource), opacity );"),
                            e.uniforms.carColorPattern = (0,
                            l.gn)(this, Me, "f"),
                            e.uniforms.carColorSecondary = (0,
                            l.gn)(this, _e, "f"),
                            e.defines ?? (e.defines = {}),
                            e.defines.USE_UV = !0
                        }
                        ,
                        e.needsUpdate = !0
                    } else if ("Metal" == e.name)
                        e.needsUpdate = !0;
                    else if ("BrakeLight" == e.name) {
                        if (!(e instanceof c._4j))
                            throw new Error("Brake light material must be MeshStandardMaterial");
                        (0,
                        l.GG)(this, Te, e, "f")
                    }
                e.castShadow = !0,
                e.receiveShadow = !0,
                e.frustumCulled = !1,
                (0,
                l.gn)(this, Ae, "f").addMaterial(e.material)
            }
            ,
            He = function(e, t) {
                if (null == F.patterns)
                    throw new Error("Car patterns are not loaded yet");
                const n = document.createElement("canvas");
                n.width = 2048,
                n.height = 2048;
                const i = new c.gPd(n);
                i.flipY = !1,
                i.anisotropy = e.getMaxAnisotropy(),
                i.needsUpdate = !0;
                const r = n.getContext("2d", {
                    alpha: !1
                });
                return null != r ? (r.clearRect(0, 0, r.canvas.width, r.canvas.height),
                r.drawImage(F.patterns[t], 0, 0, r.canvas.width, r.canvas.height),
                i.needsUpdate = !0) : console.error("Failed to get 2d-context for car texture"),
                i
            }
            ,
            je = function(e) {
                if (null == F.models)
                    throw new Error("Car models aren't loaded yet");
                const t = F.models.rims.get(e);
                if (null == t)
                    throw new Error("Rims model not found");
                return t.clone()
            }
            ,
            Ke = function(e) {
                if (null == F.models)
                    throw new Error("Car models aren't loaded yet");
                const t = F.models.exhausts.get(e);
                if (null == t)
                    throw new Error("Exhaust model not found");
                return t.clone()
            }
            ,
            qe = function() {
                if (null != (0,
                l.gn)(this, H, "f") && ((0,
                l.gn)(this, H, "f").source.playbackRate.setTargetAtTime(.7, 0, .15),
                (0,
                l.gn)(this, H, "f").gain.gain.setTargetAtTime(0, 0, .15)),
                null != (0,
                l.gn)(this, K, "f"))
                    for (const e of (0,
                    l.gn)(this, K, "f"))
                        e.source.playbackRate.setTargetAtTime(.3, 0, .15),
                        e.gain.gain.setTargetAtTime(0, 0, .15);
                if (null != (0,
                l.gn)(this, Ne, "f")) {
                    for (const {source: e} of (0,
                    l.gn)(this, Ne, "f"))
                        e.stop();
                    (0,
                    l.GG)(this, Ne, null, "f")
                }
            }
            ,
            Qe = function() {
                const e = (0,
                l.gn)(this, Ie, "f")?.getSettingFloat(st.A.CheckpointVolume) ?? 0;
                let t = Math.min(Math.max((0,
                l.gn)(this, V, "f") * e, 0), 1);
                if (Number.isNaN(t) && (t = 0),
                t > 0 && null != (0,
                l.gn)(this, O, "f")) {
                    const e = (0,
                    l.gn)(this, O, "f").getBuffer("checkpoint");
                    if (null != e && null != (0,
                    l.gn)(this, O, "f").context && null != (0,
                    l.gn)(this, O, "f").destinationMaster) {
                        const n = (0,
                        l.gn)(this, O, "f").context.createBufferSource();
                        n.buffer = e,
                        n.playbackRate.value = 1.25;
                        const i = (0,
                        l.gn)(this, O, "f").context.createGain();
                        i.gain.value = .03 * t,
                        n.connect(i),
                        i.connect((0,
                        l.gn)(this, O, "f").destinationMaster),
                        n.start(0)
                    }
                }
            }
            ,
            Je = function(e) {
                const t = this.getMatrix4();
                for (let n = 0; n < 4; n++) {
                    const i = (0,
                    l.gn)(F, F, "f", oe)[n].clone().add(new c.Pq0(0,-(0,
                    l.gn)(this, ie, "f").wheelSuspensionLength[n],0)).applyMatrix4(t)
                      , r = null != (0,
                    l.gn)(this, ie, "f").wheelContact[n]
                      , a = (0,
                    l.gn)(this, ie, "f").wheelDeltaRotation[n]
                      , s = (0,
                    l.gn)(this, ie, "f").wheelSkidInfo[n]
                      , o = Math.min(1, Math.abs(a) / (0,
                    l.gn)(F, F, "f", le))
                      , h = Math.pow(o, (0,
                    l.gn)(F, F, "f", ce)) * (0,
                    l.gn)(F, F, "f", he);
                    r && s < h ? (n < (0,
                    l.gn)(this, Le, "f").length && ((0,
                    l.gn)(this, ze, "f")[n] = Math.max(0, (0,
                    l.gn)(this, ze, "f")[n] - e)),
                    0 == (0,
                    l.gn)(this, ze, "f")[n] && null != (0,
                    l.gn)(this, De, "f") && (0,
                    l.gn)(this, De, "f").spawn(i.x, i.y, i.z)) : (n < (0,
                    l.gn)(this, Le, "f").length && (0,
                    l.gn)(this, Ie, "f")?.getSettingBoolean(st.A.SkidmarksEnabled) && (0,
                    l.gn)(this, Le, "f")[n].break(),
                    (0,
                    l.gn)(this, ze, "f")[n] = .075)
                }
            }
            ,
            Xe = function() {
                if (null != (0,
                l.gn)(this, O, "f") && null != (0,
                l.gn)(this, O, "f").context && null != (0,
                l.gn)(this, O, "f").destinationSfx) {
                    null == (0,
                    l.gn)(this, W, "f") && ((0,
                    l.GG)(this, W, (0,
                    l.gn)(this, O, "f").context.createGain(), "f"),
                    (0,
                    l.gn)(this, W, "f").gain.value = (0,
                    l.gn)(this, V, "f"),
                    (0,
                    l.gn)(this, W, "f").connect((0,
                    l.gn)(this, O, "f").destinationSfx)),
                    null == (0,
                    l.gn)(this, Q, "f") && ((0,
                    l.GG)(this, Q, (0,
                    l.gn)(this, O, "f").context.createPanner(), "f"),
                    (0,
                    l.gn)(this, Q, "f").refDistance = 5,
                    (0,
                    l.gn)(this, Q, "f").connect((0,
                    l.gn)(this, W, "f")));
                    const e = this.getPosition();
                    (0,
                    l.gn)(this, Q, "f").positionX.value = e.x,
                    (0,
                    l.gn)(this, Q, "f").positionY.value = e.y,
                    (0,
                    l.gn)(this, Q, "f").positionZ.value = e.z;
                    const t = 4;
                    if ((0,
                    l.gn)(this, J, "f").length < t) {
                        (0,
                        l.gn)(this, J, "f").length = 0;
                        for (let e = 0; e < t; ++e) {
                            const e = (0,
                            l.gn)(this, O, "f").context.createPanner();
                            e.refDistance = 5,
                            e.connect((0,
                            l.gn)(this, W, "f")),
                            (0,
                            l.gn)(this, J, "f").push(e)
                        }
                    }
                    const n = this.getMatrix4();
                    for (let e = 0; e < t; ++e) {
                        const t = (0,
                        l.gn)(this, J, "f")[e]
                          , i = (0,
                        l.gn)(F, F, "f", oe)[e].clone().add(new c.Pq0(0,-(0,
                        l.gn)(this, ie, "f").wheelSuspensionLength[e],0)).applyMatrix4(n);
                        t.positionX.value = i.x,
                        t.positionY.value = i.y,
                        t.positionZ.value = i.z
                    }
                    (0,
                    l.gn)(this, Ae, "f").camera != (0,
                    l.gn)(this, X, "f").camera && (0,
                    l.gn)(this, Ae, "f").camera != (0,
                    l.gn)(this, Y, "f").camera || (0,
                    l.gn)(this, O, "f").refreshListener((0,
                    l.gn)(this, Ae, "f")),
                    (0,
                    l.gn)(this, G, "m", Ye).call(this),
                    (0,
                    l.gn)(this, G, "m", $e).call(this),
                    (0,
                    l.gn)(this, G, "m", nt).call(this)
                }
            }
            ,
            Ye = function() {
                if (null == (0,
                l.gn)(this, H, "f") && null != (0,
                l.gn)(this, Q, "f") && null != (0,
                l.gn)(this, O, "f")) {
                    const e = (0,
                    l.gn)(this, O, "f").getBuffer("engine");
                    if (null != e && null != (0,
                    l.gn)(this, O, "f").context) {
                        const t = (0,
                        l.gn)(this, O, "f").context.createBufferSource();
                        t.buffer = e,
                        t.loop = !0,
                        t.playbackRate.value = .7;
                        const n = (0,
                        l.gn)(this, O, "f").context.createGain();
                        n.gain.value = 0,
                        t.connect(n),
                        n.connect((0,
                        l.gn)(this, Q, "f")),
                        t.start(0, 2 * Math.random()),
                        (0,
                        l.GG)(this, H, {
                            source: t,
                            gain: n
                        }, "f")
                    }
                }
                if (null != (0,
                l.gn)(this, H, "f")) {
                    const e = ((0,
                    l.gn)(this, fe, "f")[0] + (0,
                    l.gn)(this, fe, "f")[1] + (0,
                    l.gn)(this, fe, "f")[2] + (0,
                    l.gn)(this, fe, "f")[3]) / 4
                      , t = .7 + Math.pow(Math.abs(e), 1 / 3) / 3
                      , n = null != (0,
                    l.gn)(this, ie, "f").wheelContact[0] || null != (0,
                    l.gn)(this, ie, "f").wheelContact[1] || null != (0,
                    l.gn)(this, ie, "f").wheelContact[2] || null != (0,
                    l.gn)(this, ie, "f").wheelContact[3]
                      , {up: i, down: r} = this.getControls()
                      , a = this.hasStarted() && !this.hasFinished() && (i && !(r && (0,
                    l.gn)(this, ie, "f").brakeLightEnabled) || r && !(0,
                    l.gn)(this, ie, "f").brakeLightEnabled);
                    let s;
                    s = n ? a ? t : Math.max(.7, t / 2) : a ? Math.max(.7, 1.15 * t) : Math.max(.7, t / 2),
                    (0,
                    l.gn)(this, H, "f").source.playbackRate.setTargetAtTime(s, 0, .05),
                    (0,
                    l.gn)(this, H, "f").gain.gain.setTargetAtTime(Math.min(.285, s / 14), 0, .05)
                }
            }
            ,
            Ze = function(e) {
                if ((0,
                l.gn)(this, j, "f").length < 4) {
                    (0,
                    l.gn)(this, j, "f").length = 0;
                    for (let e = 0; e < 4; ++e)
                        (0,
                        l.gn)(this, j, "f").push(0)
                }
                for (let t = 0; t < 4 && t < (0,
                l.gn)(this, J, "f").length; t++)
                    if ((0,
                    l.gn)(this, j, "f")[t] -= e,
                    (0,
                    l.gn)(this, j, "f")[t] <= 0) {
                        const e = Math.abs((0,
                        l.gn)(this, ie, "f").wheelSuspensionVelocity[t]);
                        if (e > 4 && null != (0,
                        l.gn)(this, O, "f")) {
                            const n = (0,
                            l.gn)(this, O, "f").getBuffer("suspension");
                            if (null != n && null != (0,
                            l.gn)(this, O, "f").context) {
                                const i = (0,
                                l.gn)(this, O, "f").context.createBufferSource();
                                i.buffer = n,
                                i.playbackRate.value = .7 + .1 * Math.random();
                                const r = (0,
                                l.gn)(this, O, "f").context.createGain();
                                r.gain.value = Math.min(.285, e / 140),
                                i.connect(r),
                                r.connect((0,
                                l.gn)(this, J, "f")[t]),
                                i.start((0,
                                l.gn)(this, O, "f").context.currentTime + .02 * Math.random()),
                                (0,
                                l.gn)(this, j, "f")[t] = .1
                            }
                        }
                    }
            }
            ,
            $e = function() {
                if (null == (0,
                l.gn)(this, K, "f") && null != (0,
                l.gn)(this, O, "f")) {
                    const e = (0,
                    l.gn)(this, O, "f").getBuffer("tires");
                    if (null != e && null != (0,
                    l.gn)(this, O, "f").context) {
                        (0,
                        l.GG)(this, K, [], "f");
                        const t = 4;
                        for (let n = 0; n < t; n++) {
                            const i = (0,
                            l.gn)(this, O, "f").context.createBufferSource();
                            i.buffer = e,
                            i.loop = !0,
                            i.playbackRate.value = .3;
                            const r = (0,
                            l.gn)(this, O, "f").context.createGain();
                            r.gain.value = 0,
                            i.connect(r),
                            r.connect((0,
                            l.gn)(this, J, "f")[n]),
                            i.start(0, n / t * 3.5 + .25 * Math.random()),
                            (0,
                            l.gn)(this, K, "f").push({
                                source: i,
                                gain: r
                            })
                        }
                    }
                }
                if (null != (0,
                l.gn)(this, K, "f"))
                    for (let e = 0; e < (0,
                    l.gn)(this, K, "f").length; ++e) {
                        const t = (0,
                        l.gn)(this, K, "f")[e];
                        if (null != (0,
                        l.gn)(this, ie, "f").wheelContact[e]) {
                            const e = Math.min(3, Math.abs(this.getSpeedKmh()) / 110);
                            t.gain.gain.setTargetAtTime(e / 10.5, 0, .15)
                        } else
                            t.gain.gain.setTargetAtTime(0, 0, .15);
                        const n = .3 + Math.min(.4, Math.abs(this.getSpeedKmh()) / 800);
                        t.source.playbackRate.setTargetAtTime(n, 0, .15)
                    }
            }
            ,
            et = function(e) {
                null != (0,
                l.gn)(this, q, "f") && ((0,
                l.gn)(this, q, "f").timeout -= e,
                (0,
                l.gn)(this, q, "f").timeout <= 0 && (0,
                l.GG)(this, q, null, "f"));
                const t = (0,
                l.gn)(this, ie, "f").collisionImpulses;
                for (const e of t)
                    (0,
                    l.gn)(this, G, "m", tt).call(this, e)
            }
            ,
            tt = function(e) {
                if (e > 25 && null != (0,
                l.gn)(this, Q, "f") && null != (0,
                l.gn)(this, O, "f") && (null == (0,
                l.gn)(this, q, "f") || (0,
                l.gn)(this, q, "f").impulse + 100 < e)) {
                    (0,
                    l.GG)(this, q, {
                        timeout: .2,
                        impulse: e
                    }, "f");
                    const t = (0,
                    l.gn)(this, O, "f").getBuffer("collision");
                    if (null != t && null != (0,
                    l.gn)(this, O, "f").context) {
                        const n = (0,
                        l.gn)(this, O, "f").context.createBufferSource();
                        n.buffer = t,
                        n.playbackRate.value = .1 + .15 * Math.min(e / 4e3, 1);
                        const i = (0,
                        l.gn)(this, O, "f").context.createGain();
                        i.gain.value = Math.max(.3, Math.min(e / 4e3, 1)) / 2.5,
                        n.connect(i),
                        i.connect((0,
                        l.gn)(this, Q, "f")),
                        n.start(0)
                    }
                }
            }
            ,
            nt = function() {
                if (null == (0,
                l.gn)(this, Ne, "f") && null != (0,
                l.gn)(this, O, "f")) {
                    const e = (0,
                    l.gn)(this, O, "f").getBuffer("skidding");
                    if (null != e && null != (0,
                    l.gn)(this, O, "f").context) {
                        (0,
                        l.GG)(this, Ne, [], "f");
                        const t = 4;
                        for (let n = 0; n < t; ++n) {
                            const i = (0,
                            l.gn)(this, O, "f").context.createBufferSource();
                            i.buffer = e,
                            i.loop = !0,
                            i.playbackRate.value = .5;
                            const r = (0,
                            l.gn)(this, O, "f").context.createGain();
                            r.gain.value = 0,
                            i.connect(r),
                            r.connect((0,
                            l.gn)(this, J, "f")[n]),
                            i.start(0, n / t * 3.5 + .25 * Math.random()),
                            (0,
                            l.gn)(this, Ne, "f").push({
                                source: i,
                                gain: r
                            })
                        }
                    }
                }
                if (null != (0,
                l.gn)(this, Ne, "f"))
                    for (let e = 0; e < (0,
                    l.gn)(this, Ne, "f").length; ++e) {
                        const t = (0,
                        l.gn)(this, Ne, "f")[e];
                        0 == (0,
                        l.gn)(this, ze, "f")[e] ? t.gain.gain.setTargetAtTime(.75 / 3.5, 0, .1) : t.gain.gain.setTargetAtTime(0, 0, .1)
                    }
            }
            ,
            it = function(e) {
                null != (0,
                l.gn)(this, Te, "f") && (e ? (0,
                l.gn)(this, Te, "f").emissive.setRGB(1, .4, .3) : (0,
                l.gn)(this, Te, "f").emissive.setRGB(0, 0, 0))
            }
            ,
            rt = function(e) {
                const t = e.geometry.toNonIndexed();
                if (!(t.attributes.position instanceof c.THS))
                    throw new Error("Vertices must use BufferAttribute");
                return Array.from(t.attributes.position.array)
            }
            ,
            at = async function() {
                if (null == F.models)
                    throw new Error("Car models are not loaded yet");
                const e = new Float32Array(F.models.collisionShapeVertices)
                  , t = await window.crypto.subtle.digest("SHA-256", e.buffer)
                  , n = Array.from(new Uint8Array(t)).map((e => e.toString(16).padStart(2, "0"))).join("")
                  , i = "c12d4421883ae86b922550f98efea3cf5e6b9c168436f9f5c989ad33a41ce50b";
                return n == i || console.error("Car collision model checksum mismatch: " + n + " != " + i),
                n == i
            }
            ,
            ct.massOffset = .6,
            ct.detectorBoxCenter = new c.Pq0(0,.48,-.15),
            ct.detectorBoxSize = new c.Pq0(.89,.22,1.8),
            oe = {
                value: [new c.Pq0(.627909,.27,1.3478), new c.Pq0(-.627909,.27,1.3478), new c.Pq0(.720832,.27,-1.52686), new c.Pq0(-.720832,.27,-1.52686)]
            },
            ct.suspensionResetLengthFront = .07809501004219055,
            ct.suspensionResetLengthRear = .0781289680480957,
            le = {
                value: .08
            },
            ce = {
                value: 3
            },
            he = {
                value: .5
            },
            ct.models = null,
            ct.patterns = null;
            const ht = ct
        }
        ,
        4183: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.Default = 0] = "Default",
                e[e.Summer = 1] = "Summer",
                e[e.Winter = 2] = "Winter",
                e[e.Desert = 3] = "Desert",
                e[e.Custom0 = 32] = "Custom0",
                e[e.Custom1 = 33] = "Custom1",
                e[e.Custom2 = 34] = "Custom2",
                e[e.Custom3 = 35] = "Custom3",
                e[e.Custom4 = 36] = "Custom4",
                e[e.Custom5 = 37] = "Custom5",
                e[e.Custom6 = 38] = "Custom6",
                e[e.Custom7 = 39] = "Custom7",
                e[e.Custom8 = 40] = "Custom8"
            }(i || (i = {}));
            const r = i
        }
        ,
        4239: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".ghost-loading-ui {\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tmargin: 4px;\n\tcolor: var(--text-color);\n\tfont-size: 22px;\n\tfont-weight: normal;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n\ttransition: opacity 0.25s ease-in-out;\n}\n.ghost-loading-ui.hide {\n\topacity: 0;\n\ttransform: translateX(20px);\n\ttransition: opacity 0.25s ease-in-out 0.5s, transform 0.25s ease-in-out 0.5s;\n}\n.ghost-loading-ui.down {\n\ttop: initial;\n\tbottom: 0;\n}\n\n.ghost-loading-ui > .percentage {\n\tdisplay: inline-block;\n\twidth: 60px;\n\ttext-align: center;\n}\n", ""]);
            const o = s
        }
        ,
        4309: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/save.svg"
        }
        ,
        4344: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".debug-ui {\n\tmargin: 0.25em;\n\tpadding: 0;\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tfont-size: 28px;\n\ttext-shadow: 0 0 5px #000;\n\tcolor: #fff;\n\tz-index: 10;\n}\n", ""]);
            const o = s
        }
        ,
        4394: () => {}
        ,
        4411: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_z_positive.svg"
        }
        ,
        4417: e => {
            "use strict";
            e.exports = function(e, t) {
                return t || (t = {}),
                e ? (e = String(e.__esModule ? e.default : e),
                /^['"].*['"]$/.test(e) && (e = e.slice(1, -1)),
                t.hash && (e += t.hash),
                /["'() \t\n]|(%20)/.test(e) || t.needQuotes ? '"'.concat(e.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : e) : e
            }
        }
        ,
        4464: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".loading-screen-ui {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n}\n.loading-screen-ui.background {\n\tbackground-color: rgba(20, 20, 45, 0.8);\n\t-webkit-backdrop-filter: blur(4px);\n\tbackdrop-filter: blur(4px);\n}\n\n.loading-screen-ui > .loading-spinner-container {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\twidth: 100%;\n\theight: 100%;\n\topacity: 0;\n\tanimation: loading-screen-ui-fade-in 0.5s forwards;\n}\n\n@keyframes loading-screen-ui-fade-in {\n\tfrom {\n\t\topacity: 0;\n\t}\n\tto {\n\t\topacity: 1;\n\t}\n}", ""]);
            const o = s
        }
        ,
        4538: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".pause-screen-ui {\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(0, 0, 0, 0.75);\n\tanimation: pause-screen-ui-fade-in 0.25s forwards;\n}\n.pause-screen-ui.fade-out {\n\topacity: 0;\n\ttransition: opacity 0.25s;\n}\n\n@keyframes pause-screen-ui-fade-in {\n\tfrom {\n\t\tbackground-color: rgba(0, 0, 0, 0);\n\t}\n\tto {\n\t\tbackground-color: rgba(0, 0, 0, 0.75);\n\t}\n}\n\n\n.pause-screen-ui > .title {\n\tposition: absolute;\n\ttop: 40%;\n\tleft: 50%;\n\ttransform: translate(-50%, -50%);\n\tfont-size: 100px;\n\tcolor: var(--text-color);\n\tanimation: pause-screen-ui-slide-fade-in 0.5s 0.3s forwards;\n\topacity: 0;\n}\n\n@keyframes pause-screen-ui-slide-fade-in {\n\tfrom {\n\t\ttransform: translate(-60%, -50%);\n\t\topacity: 0;\n\t}\n\tto {\n\t\ttransform: translate(-50%, -50%);\n\t\topacity: 1;\n\t}\n}\n", ""]);
            const o = s
        }
        ,
        4563: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotate.svg"
        }
        ,
        4593: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/reset_settings.svg"
        }
        ,
        4644: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_edge.svg"
        }
        ,
        4724: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_stripe.svg"
        }
        ,
        4784: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                Y: () => i
            }),
            function(e) {
                e[e.Pending = 0] = "Pending",
                e[e.Verified = 1] = "Verified",
                e[e.Invalid = 2] = "Invalid",
                e[e.InvalidDuplicate = 3] = "InvalidDuplicate",
                e[e.InvalidManual = 4] = "InvalidManual"
            }(i || (i = {}))
        }
        ,
        4839: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => ie
            });
            var i = n(1635)
              , r = n(5072)
              , a = n.n(r)
              , s = n(7825)
              , o = n.n(s)
              , l = n(7659)
              , c = n.n(l)
              , h = n(5056)
              , d = n.n(h)
              , u = n(540)
              , p = n.n(u)
              , f = n(1113)
              , g = n.n(f)
              , m = n(8353)
              , A = {};
            A.styleTagTransform = g(),
            A.setAttributes = d(),
            A.insert = c().bind(null, "head"),
            A.domAPI = o(),
            A.insertStyleElement = p();
            a()(m.A, A);
            m.A && m.A.locals && m.A.locals;
            var v, y, w, b, x, S, E, T, k, M, _, C, R, P, I, L, N, z, U, D, B, G, F, O, W, V, H, j, K, q, Q, J, X = n(5839), Y = n(579), Z = n(5169);
            let $ = null
              , ee = 0
              , te = 0
              , ne = 0;
            const re = []
              , oe = e => "pt_thumb_" + Pt.rE + "_" + e
              , le = e => {
                try {
                    const t = ("undefined" != typeof globalThis ? globalThis : window).__ptThumbUrlCache;
                    if (t instanceof Map) {
                        const n = t.get(e);
                        if ("string" == typeof n && n.startsWith("data:image/"))
                            return n
                    }
                } catch {}
                try {
                    const t = localStorage.getItem(oe(e));
                    if ("string" == typeof t && t.startsWith("data:image/")) {
                        try {
                            const n = ("undefined" != typeof globalThis ? globalThis : window);
                            n.__ptThumbUrlCache instanceof Map || (n.__ptThumbUrlCache = new Map),
                            n.__ptThumbUrlCache.set(e, t)
                        } catch {}
                        return t
                    }
                } catch {}
                return null
            }
              , ce = (e, t) => {
                try {
                    const n = ("undefined" != typeof globalThis ? globalThis : window);
                    n.__ptThumbUrlCache instanceof Map || (n.__ptThumbUrlCache = new Map),
                    "string" == typeof e && e.length > 0 && "string" == typeof t && t.startsWith("data:image/") && n.__ptThumbUrlCache.set(e, t)
                } catch {}
                try {
                    "string" == typeof e && e.length > 0 && "string" == typeof t && t.startsWith("data:image/") && localStorage.setItem(oe(e), t)
                } catch {}
            }
              , he = (e, t) => {
                if (!("string" == typeof e && e.length > 0) || !(t instanceof HTMLCanvasElement))
                    return;
                try {
                    const n = ("undefined" != typeof globalThis ? globalThis : window);
                    n.__ptThumbCanvasCache instanceof Map || (n.__ptThumbCanvasCache = new Map);
                    const i = document.createElement("canvas");
                    i.width = t.width,
                    i.height = t.height;
                    const r = i.getContext("2d");
                    null != r && r.drawImage(t, 0, 0),
                    n.__ptThumbCanvasCache.set(e, i);
                    try {
                        ce(e, i.toDataURL())
                    } catch {}
                } catch {}
            }
              , ae = () => {
                if (0 == re.length)
                    return;
                const e = re.shift();
                if (null == e)
                    return void ae();
                const {button: t, img: n, getTrackData: i, trackId: r} = e;
                if (!(t instanceof HTMLElement) || !(n instanceof HTMLElement) || !t.isConnected || !n.isConnected)
                    return void ae();
                i().then((e => {
                    const i = () => {
                        try {
                            const i = e.createThumbnail();
                            if (i instanceof HTMLCanvasElement)
                                try {
                                    null != r && he(r, i)
                                } catch {}
                            t.isConnected && n.isConnected && t.replaceChild(i, n)
                        } catch (e) {
                            console.warn(e)
                        }
                    }
                    ;
                    "function" == typeof requestIdleCallback ? requestIdleCallback(i, {
                        timeout: 2e3
                    }) : setTimeout(i, 0)
                }
                )).catch((e => {
                    console.warn(e)
                }
                )).finally(( () => {
                    ae()
                }
                ))
            }
              , se = () => {
                if (0 == re.length)
                    return;
                "function" == typeof requestIdleCallback ? requestIdleCallback(( () => {
                    ae()
                }
                ), {
                    timeout: 1e3
                }) : setTimeout(( () => {
                    ae()
                }
                ), 0)
            }
            ;
            y = new WeakMap,
            w = new WeakMap,
            b = new WeakMap,
            x = new WeakMap,
            S = new WeakMap,
            E = new WeakMap,
            T = new WeakMap,
            k = new WeakMap,
            M = new WeakMap,
            _ = new WeakMap,
            C = new WeakMap,
            R = new WeakMap,
            P = new WeakMap,
            I = new WeakMap,
            L = new WeakMap,
            N = new WeakMap,
            z = new WeakMap,
            U = new WeakMap,
            D = new WeakMap,
            B = new WeakMap,
            G = new WeakMap,
            F = new WeakMap,
            O = new WeakMap,
            W = new WeakMap,
            V = new WeakMap,
            H = new WeakMap,
            j = new WeakMap,
            K = new WeakMap,
            v = new WeakSet,
            q = function(e, t, n, r, a, s, o, l=null) {
                const c = document.createElement("div");
                let h, d;
                switch (c.className = "track",
                e) {
                case "official":
                    h = (0,
                    i.gn)(this, I, "f"),
                    d = (0,
                    i.gn)(this, z, "f");
                    break;
                case "community":
                    h = (0,
                    i.gn)(this, L, "f"),
                    d = (0,
                    i.gn)(this, U, "f");
                    break;
                case "custom":
                    h = (0,
                    i.gn)(this, N, "f"),
                    d = (0,
                    i.gn)(this, D, "f")
                }
                if (null == t)
                    h.appendChild(c);
                else {
                    let e = d.get(t);
                    if (null == e)
                        if (e = document.createElement("div"),
                        d.set(t, e),
                        "string" == typeof t) {
                            h.appendChild(e);
                            const n = document.createElement("div");
                            n.className = "group-title",
                            n.textContent = t,
                            e.appendChild(n)
                        } else {
                            switch (t) {
                            case Z.A.Summer:
                                h.prepend(e);
                                break;
                            case Z.A.Winter:
                                {
                                    const t = d.get(Z.A.Desert);
                                    null != t ? h.insertBefore(e, t) : h.appendChild(e);
                                    break
                                }
                            case Z.A.Desert:
                                h.appendChild(e)
                            }
                            let n, a, s;
                            switch (r) {
                            case Z.A.Summer:
                                n = "",
                                a = (0,
                                i.gn)(this, w, "f").get("Summer"),
                                s = "images/summer.svg";
                                break;
                            case Z.A.Winter:
                                n = "winter",
                                a = (0,
                                i.gn)(this, w, "f").get("Winter"),
                                s = "images/winter_colored.svg";
                                break;
                            case Z.A.Desert:
                                n = "desert",
                                a = (0,
                                i.gn)(this, w, "f").get("Desert"),
                                s = "images/desert_colored.svg"
                            }
                            const o = document.createElement("div");
                            o.className = "group-title " + n,
                            o.textContent = a,
                            e.appendChild(o);
                            const l = document.createElement("img");
                            l.src = s,
                            o.prepend(l)
                        }
                    e.appendChild(c)
                }
                const u = document.createElement("button");
                u.className = "button",
                u.addEventListener("click", ( () => {
                    (0,
                    i.gn)(this, b, "f").playUIClick(),
                    (0,
                    i.gn)(this, M, "f").call(this, n, r, a, e, s, o)
                }
                )),
                c.appendChild(u);
                const p = document.createElement("div");
                p.className = "track-title",
                u.appendChild(p);
                const f = document.createElement("p");
                if (f.textContent = n.name,
                p.appendChild(f),
                o instanceof HTMLCanvasElement)
                    u.appendChild(o);
                else {
                    let e = null;
                    try {
                        const t = ("undefined" != typeof globalThis ? globalThis : window).__ptThumbCanvasCache;
                        e = t instanceof Map ? t.get(s) : null
                    } catch {}
                    if (e instanceof HTMLCanvasElement) {
                        const t = document.createElement("canvas");
                        t.width = e.width,
                        t.height = e.height;
                        const n = t.getContext("2d");
                        null != n && n.drawImage(e, 0, 0),
                        u.appendChild(t)
                    } else {
                        const e = document.createElement("img");
                        let t = null;
                        !o && (t = le(s));
                        e.loading = "lazy",
                        e.src = o || t || "images/preview.svg",
                    e.onerror = ( () => {
                        e.onerror = null,
                        re.push({
                            button: u,
                            img: e,
                            getTrackData: a,
                            trackId: s
                        }),
                        se()
                    }
                    ),
                    u.appendChild(e),
                    !o && !t && (re.push({
                        button: u,
                        img: e,
                        getTrackData: a,
                        trackId: s
                    }),
                    se())
                    }
                }
                let g;
                switch (r) {
                case Z.A.Summer:
                    g = "images/summer.svg";
                    break;
                case Z.A.Winter:
                    g = "images/winter.svg";
                    break;
                case Z.A.Desert:
                    g = "images/desert.svg"
                }
                const m = document.createElement("img");
                m.className = "environment",
                m.src = g,
                u.appendChild(m);
                const A = (0,
                i.gn)(this, x, "f").getRecordTime((0,
                i.gn)(this, E, "f").profileSlot, s)
                  , v = document.createElement("div");
                if (v.className = "record",
                v.textContent = null != A ? X.A.formatTimeString(A) : (0,
                i.gn)(this, w, "f").get("No record"),
                u.appendChild(v),
                null != l) {
                    const e = document.createElement("button");
                    e.className = "delete-button",
                    e.innerHTML = '<img src="images/erase.svg">',
                    e.addEventListener("click", ( () => {
                        (0,
                        i.gn)(this, b, "f").playUIClick(),
                        l()
                    }
                    )),
                    c.appendChild(e)
                }
                (0,
                i.gn)(this, B, "f").push({
                    category: e,
                    group: t,
                    trackMetadata: n,
                    trackEnvironment: r,
                    trackData: a,
                    buttonContainer: c
                })
            }
            ,
            Q = function(e) {
                $ = e,
                (0,
                i.gn)(this, k, "f").saveTrackSelectionTab($),
                "official" == e ? ((0,
                i.gn)(this, C, "f").classList.add("selected"),
                (0,
                i.gn)(this, R, "f").classList.remove("selected"),
                (0,
                i.gn)(this, P, "f").classList.remove("selected"),
                (0,
                i.gn)(this, I, "f").classList.add("open"),
                (0,
                i.gn)(this, L, "f").classList.remove("open"),
                (0,
                i.gn)(this, N, "f").classList.remove("open")) : "community" == e ? ((0,
                i.gn)(this, C, "f").classList.remove("selected"),
                (0,
                i.gn)(this, R, "f").classList.add("selected"),
                (0,
                i.gn)(this, P, "f").classList.remove("selected"),
                (0,
                i.gn)(this, I, "f").classList.remove("open"),
                (0,
                i.gn)(this, L, "f").classList.add("open"),
                (0,
                i.gn)(this, N, "f").classList.remove("open")) : ((0,
                i.gn)(this, C, "f").classList.remove("selected"),
                (0,
                i.gn)(this, R, "f").classList.remove("selected"),
                (0,
                i.gn)(this, P, "f").classList.add("selected"),
                (0,
                i.gn)(this, I, "f").classList.remove("open"),
                (0,
                i.gn)(this, L, "f").classList.remove("open"),
                (0,
                i.gn)(this, N, "f").classList.add("open"))
            }
            ,
            J = function() {
                const e = (0,
                i.gn)(this, G, "f").value.trim().toLowerCase();
                for (const t of (0,
                i.gn)(this, B, "f"))
                    t.trackMetadata.name.toLowerCase().includes(e) || t.trackMetadata.author?.toLowerCase().includes(e) ? t.buttonContainer.style.display = "" : t.buttonContainer.style.display = "none";
                for (const e of ["official", "community", "custom"]) {
                    let t;
                    switch (e) {
                    case "official":
                        t = (0,
                        i.gn)(this, z, "f");
                        break;
                    case "community":
                        t = (0,
                        i.gn)(this, U, "f");
                        break;
                    case "custom":
                        t = (0,
                        i.gn)(this, D, "f")
                    }
                    for (const [n,r] of t.entries())
                        (0,
                        i.gn)(this, B, "f").some((t => t.category == e && t.group == n && "none" != t.buttonContainer.style.display)) ? r.style.display = "" : r.style.display = "none"
                }
                if ($ ?? ($ = (0,
                i.gn)(this, k, "f").loadTrackSelectionTab()),
                (0,
                i.gn)(this, B, "f").filter((e => e.category == $)).every((e => "none" == e.buttonContainer.style.display)))
                    for (const e of ["official", "community", "custom"])
                        if ((0,
                        i.gn)(this, B, "f").some((t => t.category == e && "none" != t.buttonContainer.style.display))) {
                            (0,
                            i.gn)(this, v, "m", Q).call(this, e);
                            break
                        }
            }
            ;
            const ie = class {
                constructor(e, t, n, r, a, s, o, l, c, h, d, u) {
                    if (v.add(this),
                    y.set(this, void 0),
                    w.set(this, void 0),
                    b.set(this, void 0),
                    x.set(this, void 0),
                    S.set(this, void 0),
                    E.set(this, void 0),
                    T.set(this, void 0),
                    k.set(this, void 0),
                    M.set(this, void 0),
                    _.set(this, void 0),
                    C.set(this, void 0),
                    R.set(this, void 0),
                    P.set(this, void 0),
                    I.set(this, void 0),
                    L.set(this, void 0),
                    N.set(this, void 0),
                    z.set(this, new Map),
                    U.set(this, new Map),
                    D.set(this, new Map),
                    B.set(this, []),
                    G.set(this, void 0),
                    F.set(this, null),
                    O.set(this, !1),
                    W.set(this, !1),
                    V.set(this, void 0),
                    H.set(this, void 0),
                    j.set(this, void 0),
                    K.set(this, void 0),
                    null == e) {
                        const t = document.getElementById("ui");
                        if (null == t)
                            throw new Error("UI element not found");
                        e = t
                    }
                    (0,
                    i.GG)(this, y, e, "f"),
                    (0,
                    i.GG)(this, w, t, "f"),
                    (0,
                    i.GG)(this, b, n, "f"),
                    (0,
                    i.GG)(this, x, r, "f"),
                    (0,
                    i.GG)(this, S, a, "f"),
                    (0,
                    i.GG)(this, E, s, "f"),
                    (0,
                    i.GG)(this, T, o, "f"),
                    (0,
                    i.GG)(this, k, l, "f"),
                    (0,
                    i.GG)(this, M, u, "f"),
                    (0,
                    i.GG)(this, _, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, _, "f").className = h ? "track-selection-ui with-background hidden" : "track-selection-ui hidden",
                    e.appendChild((0,
                    i.gn)(this, _, "f"));
                    const p = document.createElement("div");
                    p.className = "safe-area-left",
                    (0,
                    i.gn)(this, _, "f").appendChild(p);
                    const f = document.createElement("div");
                    f.className = "safe-area-right",
                    (0,
                    i.gn)(this, _, "f").appendChild(f);
                    const g = document.createElement("div");
                    g.className = "bar",
                    (0,
                    i.gn)(this, _, "f").appendChild(g);
                    const m = document.createElement("div");
                    m.className = "category-container",
                    (0,
                    i.gn)(this, _, "f").appendChild(m),
                    (0,
                    i.GG)(this, C, document.createElement("button"), "f"),
                    (0,
                    i.gn)(this, C, "f").className = "button official selected",
                    (0,
                    i.gn)(this, C, "f").append(document.createTextNode((0,
                    i.gn)(this, w, "f").get("Official tracks"))),
                    (0,
                    i.gn)(this, C, "f").addEventListener("click", ( () => {
                        (0,
                        i.gn)(this, b, "f").playUIClick(),
                        (0,
                        i.gn)(this, v, "m", Q).call(this, "official")
                    }
                    )),
                    m.appendChild((0,
                    i.gn)(this, C, "f"));
                    const A = document.createElement("div");
                    A.className = "cover",
                    (0,
                    i.gn)(this, C, "f").prepend(A),
                    (0,
                    i.GG)(this, R, document.createElement("button"), "f"),
                    (0,
                    i.gn)(this, R, "f").className = "button community",
                    (0,
                    i.gn)(this, R, "f").append(document.createTextNode((0,
                    i.gn)(this, w, "f").get("Community tracks"))),
                    (0,
                    i.gn)(this, R, "f").addEventListener("click", ( () => {
                        (0,
                        i.gn)(this, b, "f").playUIClick(),
                        (0,
                        i.gn)(this, v, "m", Q).call(this, "community")
                    }
                    )),
                    m.appendChild((0,
                    i.gn)(this, R, "f"));
                    const q = document.createElement("div");
                    q.className = "cover",
                    (0,
                    i.gn)(this, R, "f").prepend(q),
                    (0,
                    i.GG)(this, P, document.createElement("button"), "f"),
                    (0,
                    i.gn)(this, P, "f").className = "button custom",
                    (0,
                    i.gn)(this, P, "f").append(document.createTextNode((0,
                    i.gn)(this, w, "f").get("Custom tracks"))),
                    (0,
                    i.gn)(this, P, "f").addEventListener("click", ( () => {
                        (0,
                        i.gn)(this, b, "f").playUIClick(),
                        (0,
                        i.gn)(this, v, "m", Q).call(this, "custom")
                    }
                    )),
                    m.appendChild((0,
                    i.gn)(this, P, "f"));
                    const X = document.createElement("div");
                    X.className = "cover",
                    (0,
                    i.gn)(this, P, "f").prepend(X),
                    (0,
                    i.GG)(this, I, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, I, "f").className = "tracks-container open",
                    (0,
                    i.gn)(this, _, "f").appendChild((0,
                    i.gn)(this, I, "f")),
                    (0,
                    i.GG)(this, L, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, L, "f").className = "tracks-container",
                    (0,
                    i.gn)(this, _, "f").appendChild((0,
                    i.gn)(this, L, "f")),
                    (0,
                    i.GG)(this, N, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, N, "f").className = "tracks-container no-group-containers",
                    (0,
                    i.gn)(this, _, "f").appendChild((0,
                    i.gn)(this, N, "f"));
                    let Z = null;
                    const ie = e => {
                        Z = 1 == e.touches.length ? {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY,
                            time: Date.now()
                        } : null
                    }
                      , re = e => {
                        if (null != Z && 1 == e.changedTouches.length) {
                            const t = e.changedTouches[0].clientX - Z.x
                              , n = e.changedTouches[0].clientY - Z.y;
                            Date.now() - Z.time < 500 && Math.abs(t) > 75 && Math.abs(n) < Math.abs(t) && (t > 0 ? "community" == $ ? (0,
                            i.gn)(this, v, "m", Q).call(this, "official") : "custom" == $ && (0,
                            i.gn)(this, v, "m", Q).call(this, "community") : "official" == $ ? (0,
                            i.gn)(this, v, "m", Q).call(this, "community") : "community" == $ && (0,
                            i.gn)(this, v, "m", Q).call(this, "custom"))
                        }
                        Z = null
                    }
                    ;
                    (0,
                    i.gn)(this, I, "f").addEventListener("touchstart", ie, {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, L, "f").addEventListener("touchstart", ie, {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, N, "f").addEventListener("touchstart", ie, {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, I, "f").addEventListener("touchend", re, {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, L, "f").addEventListener("touchend", re, {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, N, "f").addEventListener("touchend", re, {
                        passive: !0
                    });
                    const ae = document.createElement("button");
                    ae.className = "button",
                    "cancel" == c ? (ae.innerHTML = '<img class="button-icon" src="images/erase.svg"> ',
                    ae.append(document.createTextNode((0,
                    i.gn)(this, w, "f").get("Cancel")))) : (ae.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
	                    ae.append(document.createTextNode((0,
	                    i.gn)(this, w, "f").get("Back")))),
	                    ae.addEventListener("click", ( () => {
	                        (0,
	                        i.gn)(this, b, "f").playUIClick(),
	                        this.hide(),
	                        "function" == typeof requestIdleCallback ? requestIdleCallback(( () => d()), {
	                            timeout: 1e3
	                        }) : setTimeout(( () => d()), 200)
	                    }
	                    )),
	                    g.appendChild(ae);
                    const se = document.createElement("div");
                    se.className = "search-bar-container",
                    g.appendChild(se),
                    (0,
                    i.GG)(this, G, document.createElement("input"), "f"),
                    (0,
                    i.gn)(this, G, "f").type = "text",
                    (0,
                    i.gn)(this, G, "f").spellcheck = !1,
                    (0,
                    i.gn)(this, G, "f").autocomplete = "off",
                    (0,
                    i.gn)(this, G, "f").autocapitalize = "off",
                    (0,
                    i.gn)(this, G, "f").enterKeyHint = "search",
                    (0,
                    i.gn)(this, G, "f").placeholder = (0,
                    i.gn)(this, w, "f").get("Search by track or author..."),
                    (0,
                    i.gn)(this, G, "f").addEventListener("input", ( () => {
                        (0,
                        i.gn)(this, v, "m", J).call(this)
                    }
                    )),
                    se.appendChild((0,
                    i.gn)(this, G, "f"));
                    const oe = document.createElement("img");
                    oe.src = "images/search.svg",
                    se.appendChild(oe);
                    const le = document.createElement("button");
                    le.className = "button",
                    le.innerHTML = '<img class="button-icon" src="images/import.svg"> ',
                    le.append(document.createTextNode((0,
                    i.gn)(this, w, "f").get("Import"))),
                    le.addEventListener("click", ( () => {
                        (0,
                        i.gn)(this, b, "f").playUIClick(),
                        this.hide(),
                        (0,
                        i.GG)(this, F, new Y.A("",( () => {
                            this.show(),
                            (0,
                            i.gn)(this, F, "f")?.dispose(),
                            (0,
                            i.GG)(this, F, null, "f")
                        }
                        ),( (e, t) => {
                            if ((0,
                            i.gn)(this, F, "f")?.dispose(),
                            (0,
                            i.GG)(this, F, null, "f"),
                            (0,
                            i.gn)(this, v, "m", Q).call(this, "custom"),
                            t || 1 != e.length)
                                this.show();
                            else {
                                const {trackMetadata: t, trackData: n, trackId: r, trackThumbnail: a} = e[0];
                                (0,
                                i.gn)(this, M, "f").call(this, t, n.environment, ( () => Promise.resolve(n)), "custom", r, a)
                            }
                        }
                        ),t,n,a,o), "f")
                    }
                    )),
                    g.appendChild(le),
                    window.addEventListener("keydown", (0,
                    i.GG)(this, V, (e => {
                        (0,
                        i.gn)(this, O, "f") && "Escape" == e.code && (d(),
                        e.preventDefault()),
                        "ShiftLeft" != e.code && "ShiftRight" != e.code || (0,
                        i.GG)(this, W, !0, "f")
                    }
                    ), "f")),
                    window.addEventListener("keyup", (0,
                    i.GG)(this, H, (e => {
                        "ShiftLeft" != e.code && "ShiftRight" != e.code || (0,
                        i.GG)(this, W, !1, "f")
                    }
                    ), "f")),
                    (0,
                    i.gn)(this, S, "f").addCustomTracksChangedListener((0,
                    i.GG)(this, j, ( () => {
                        this.refresh()
                    }
                    ), "f")),
                    (0,
                    i.gn)(this, I, "f").addEventListener("scroll", ( () => {
                        ee = (0,
                        i.gn)(this, I, "f").scrollTop
                    }
                    ), {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, L, "f").addEventListener("scroll", ( () => {
                        te = (0,
                        i.gn)(this, L, "f").scrollTop
                    }
                    ), {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, N, "f").addEventListener("scroll", ( () => {
                        ne = (0,
                        i.gn)(this, N, "f").scrollTop
                    }
                    ), {
                        passive: !0
                    }),
                    (0,
                    i.gn)(this, x, "f").addRecordChangedCallback((0,
                    i.GG)(this, K, ( () => {
                        this.refresh()
                    }
                    ), "f"))
                }
                dispose() {
                    (0,
                    i.gn)(this, y, "f").removeChild((0,
                    i.gn)(this, _, "f")),
                    window.removeEventListener("keydown", (0,
                    i.gn)(this, V, "f")),
                    window.removeEventListener("keyup", (0,
                    i.gn)(this, H, "f")),
                    (0,
                    i.gn)(this, F, "f")?.dispose(),
                    (0,
                    i.GG)(this, F, null, "f"),
                    (0,
                    i.gn)(this, S, "f").removeCustomTracksChangedListener((0,
                    i.gn)(this, j, "f")),
                    (0,
                    i.gn)(this, x, "f").removeRecordChangedCallback((0,
                    i.gn)(this, K, "f"))
                }
                hide() {
                    (0,
                    i.gn)(this, _, "f").classList.add("hidden"),
                    (0,
                    i.GG)(this, O, !1, "f")
                }
                show() {
                    (0,
                    i.gn)(this, _, "f").classList.remove("hidden"),
                    (0,
                    i.GG)(this, O, !0, "f"),
                    this.refresh(),
                    $ ?? ($ = (0,
                    i.gn)(this, k, "f").loadTrackSelectionTab()),
                    "official" == $ ? ((0,
                    i.gn)(this, C, "f").classList.add("selected"),
                    (0,
                    i.gn)(this, R, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, P, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, I, "f").classList.add("open"),
                    (0,
                    i.gn)(this, L, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, N, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, I, "f").scrollTop = ee) : "community" == $ ? ((0,
                    i.gn)(this, C, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, R, "f").classList.add("selected"),
                    (0,
                    i.gn)(this, P, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, I, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, L, "f").classList.add("open"),
                    (0,
                    i.gn)(this, N, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, L, "f").scrollTop = te) : ((0,
                    i.gn)(this, C, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, R, "f").classList.remove("selected"),
                    (0,
                    i.gn)(this, P, "f").classList.add("selected"),
                    (0,
                    i.gn)(this, I, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, L, "f").classList.remove("open"),
                    (0,
                    i.gn)(this, N, "f").classList.add("open"),
                    (0,
                    i.gn)(this, N, "f").scrollTop = ne)
                }
                get isOpen() {
                    return (0,
                    i.gn)(this, O, "f") || null != (0,
                    i.gn)(this, F, "f")
                }
                refresh() {
                    if ((0,
                    i.GG)(this, B, [], "f"),
                    (0,
                    i.gn)(this, I, "f").innerHTML = "",
                    (0,
                    i.gn)(this, L, "f").innerHTML = "",
                    (0,
                    i.gn)(this, N, "f").innerHTML = "",
                    (0,
                    i.gn)(this, z, "f").clear(),
                    (0,
                    i.gn)(this, U, "f").clear(),
                    (0,
                    i.gn)(this, D, "f").clear(),
                    (0,
                    i.gn)(this, S, "f").forEachOfficialTrack(( (e, t, n, r) => {
                        (0,
                        i.gn)(this, v, "m", q).call(this, "official", n.environment, t, n.environment, ( () => Promise.resolve(n)), e, r)
                    }
                    )),
                    (0,
                    i.gn)(this, S, "f").isCommunityTracksEmpty()) {
                        const e = document.createElement("div");
                        e.className = "empty";
                        const t = document.createElement("div");
                        t.className = "title",
                        t.textContent = (0,
                        i.gn)(this, w, "f").get("No community tracks"),
                        e.appendChild(t);
                        const n = document.createElement("div");
                        n.className = "description",
                        n.textContent = (0,
                        i.gn)(this, w, "f").get("Community tracks are coming soon"),
                        e.appendChild(n),
                        (0,
                        i.gn)(this, L, "f").appendChild(e)
                    } else
                        (0,
                        i.gn)(this, S, "f").forEachCommunityTrack(( (e, t, n, r, a, s) => {
                            (0,
                            i.gn)(this, v, "m", q).call(this, "community", t, n, r, a, e, s)
                        }
                        ));
                    if ((0,
                    i.gn)(this, S, "f").isCustomTracksEmpty()) {
                        const e = document.createElement("div");
                        e.className = "empty";
                        const t = document.createElement("div");
                        t.className = "title",
                        t.textContent = (0,
                        i.gn)(this, w, "f").get("No custom tracks"),
                        e.appendChild(t);
                        const n = document.createElement("div");
                        n.className = "description",
                        n.textContent = (0,
                        i.gn)(this, w, "f").get("Create a track using the editor or import a track code"),
                        e.appendChild(n),
                        (0,
                        i.gn)(this, N, "f").appendChild(e)
                    } else
                        (0,
                        i.gn)(this, S, "f").forEachCustomTrack(( (e, t, n, r) => {
                            (0,
                            i.gn)(this, v, "m", q).call(this, "custom", null, t, n.environment, ( () => Promise.resolve(n)), e, r, ( () => {
                                (0,
                                i.gn)(this, W, "f") ? (0,
                                i.gn)(this, S, "f").deleteCustomTrack(t.name) : (this.hide(),
                                (0,
                                i.gn)(this, T, "f").showConfirm((0,
                                i.gn)(this, w, "f").get('Are you sure you want to delete "{0}"?', [t.name]), (0,
                                i.gn)(this, w, "f").get("Cancel"), (0,
                                i.gn)(this, w, "f").get("Delete"), ( () => {
                                    this.show()
                                }
                                ), ( () => {
                                    (0,
                                    i.gn)(this, S, "f").deleteCustomTrack(t.name),
                                    this.show()
                                }
                                )))
                            }
                            ))
                        }
                        ));
                    (0,
                    i.gn)(this, v, "m", J).call(this)
                }
            }
        }
        ,
        4865: (e, t, n) => {
            "use strict";
            n.d(t, {
                EM: () => o,
                GK: () => g,
                Ko: () => a,
                Tn: () => l,
                aC: () => r,
                gp: () => p,
                ml: () => s,
                rE: () => u,
                y0: () => c
            });
            var i = n(8330);
            const r = "kodub"
              , a = "kodub" == r || "electron" == r || "itch" == r
              , s = "kodub" == r || "electron" == r || "capacitor" == r || "itch" == r || "crazygames" == r
              , o = !1
              , l = !0
              , c = "/__proxy_vps__/"
              , h = i.l$.r;
            if (!Number.isSafeInteger(h) || h < 1)
                throw new Error("package.json beta version property must be a positive integer");
            let d = "";
            o ? d = "-dev" : l && (d = "-beta" + h.toString());
            const u = i.rE + d
              , p = i.rE
              , f = i.l$.M;
            if (!Number.isSafeInteger(f) || f < 1)
                throw new Error("package.json beta physicsVersion property must be a positive integer");
            const g = f
        }
        ,
        4922: (e, t, n) => {
            "use strict";
            n.d(t, {
                $EB: () => f,
                $Ed: () => As,
                $Kf: () => _a,
                $Yl: () => B,
                $_I: () => we,
                $ei: () => T,
                A$4: () => Tr,
                AQS: () => tn,
                B69: () => Yi,
                BH$: () => Is,
                BKk: () => ea,
                BND: () => Xl,
                BVL: () => tt,
                BXX: () => qe,
                B_h: () => st,
                CSG: () => jo,
                CVz: () => Ze,
                CWW: () => Tt,
                Cfg: () => Ae,
                D$Q: () => Oo,
                DXC: () => Rs,
                Dmk: () => Ie,
                EAD: () => Ia,
                EZo: () => A,
                EdD: () => y,
                FCc: () => Ps,
                FFZ: () => Xt,
                FV: () => ne,
                FXf: () => x,
                Fn: () => yt,
                GJx: () => ue,
                GWd: () => Ue,
                GYF: () => Ca,
                G_z: () => Ho,
                Gc6: () => Fs,
                Gu$: () => Fo,
                Gwm: () => K,
                H23: () => wt,
                H2z: () => Zl,
                HIg: () => ze,
                HO_: () => Et,
                HXV: () => Xe,
                HiM: () => Rl,
                Hit: () => rl,
                I46: () => Ma,
                I9Y: () => Tn,
                IE4: () => He,
                IUQ: () => Kn,
                Iit: () => Yr,
                Jnc: () => l,
                K52: () => q,
                KDk: () => et,
                KLL: () => Ot,
                KRh: () => X,
                Kef: () => xt,
                Kwu: () => v,
                Kzg: () => Ul,
                LAk: () => re,
                Ld9: () => Yl,
                LiQ: () => C,
                LlO: () => $r,
                LoY: () => zr,
                MBL: () => sl,
                MSw: () => Go,
                MW4: () => kr,
                Mjd: () => ee,
                N1A: () => ks,
                NRn: () => Yn,
                NTi: () => m,
                Nex: () => $l,
                Nt7: () => L,
                Nwf: () => Hl,
                Nz6: () => je,
                O49: () => Lt,
                O9p: () => Ni,
                ONl: () => Ds,
                OUM: () => be,
                Om: () => de,
                OtU: () => it,
                OuU: () => P,
                PJ3: () => Mt,
                PPD: () => Ja,
                PTz: () => kn,
                Pq0: () => Mn,
                Q1f: () => mr,
                QP0: () => c,
                Qev: () => pn,
                Qrf: () => ct,
                R3r: () => ua,
                R8M: () => cn,
                RJ4: () => It,
                RQf: () => Me,
                RiT: () => ll,
                Riy: () => $e,
                RlV: () => Si,
                Rm2: () => ln,
                RrE: () => D,
                RyA: () => d,
                S$4: () => vt,
                THS: () => Er,
                Tap: () => wl,
                TdN: () => $t,
                TiK: () => Kt,
                TkQ: () => We,
                U3G: () => j,
                V3x: () => Pe,
                V9B: () => wr,
                VCu: () => Gs,
                VT0: () => Ge,
                Vb5: () => o,
                VxR: () => Ft,
                W9U: () => bt,
                WNZ: () => s,
                Wdf: () => Zt,
                Wew: () => Ce,
                Wk7: () => h,
                XG_: () => St,
                XIg: () => g,
                XrR: () => Y,
                Y9S: () => Al,
                YHV: () => Jl,
                YJl: () => ha,
                Yuy: () => Te,
                Z58: () => fa,
                ZLX: () => Oa,
                ZQM: () => Fe,
                Zcv: () => ja,
                Zr2: () => Gt,
                ZyN: () => Ll,
                _4j: () => Wo,
                _QJ: () => ut,
                _Ut: () => Zr,
                a55: () => An,
                a5J: () => dt,
                aEY: () => z,
                aHM: () => fl,
                aJ8: () => ae,
                aVO: () => Ko,
                amv: () => Vt,
                b4q: () => la,
                bC7: () => gt,
                bCz: () => w,
                bI3: () => zt,
                bdM: () => Bo,
                bkx: () => ke,
                brA: () => V,
                bw0: () => Q,
                c90: () => Ve,
                cHt: () => Ee,
                caT: () => J,
                cj9: () => En,
                czI: () => ot,
                dYF: () => Xn,
                dcC: () => Be,
                dth: () => xl,
                dwI: () => Rn,
                e0p: () => G,
                eB$: () => ga,
                eHc: () => O,
                eHs: () => Aa,
                eaF: () => qr,
                eoi: () => qt,
                er$: () => Bt,
                f4X: () => _,
                fBL: () => Se,
                g7M: () => ie,
                gJ2: () => Re,
                gO9: () => b,
                gPd: () => jn,
                gWB: () => Jt,
                gZr: () => nt,
                ghU: () => pe,
                hB5: () => u,
                hdd: () => I,
                hgQ: () => U,
                hsX: () => p,
                hxR: () => ge,
                hy7: () => oe,
                iNn: () => Jr,
                ie2: () => R,
                imn: () => yr,
                ix0: () => _e,
                iyt: () => gi,
                jR7: () => Ke,
                jSS: () => rt,
                jUj: () => pa,
                jej: () => un,
                jf0: () => Dt,
                jzd: () => Qt,
                k6Q: () => Qe,
                k6q: () => ve,
                kBv: () => r,
                kO0: () => jt,
                kRr: () => ye,
                kTW: () => fe,
                kTp: () => Je,
                kn4: () => Ei,
                kyO: () => $,
                lGu: () => W,
                lGw: () => Yo,
                lPF: () => an,
                ljd: () => kt,
                lxW: () => Xr,
                lyL: () => ft,
                mcG: () => dn,
                mrM: () => vs,
                nCl: () => _l,
                nNL: () => te,
                nST: () => S,
                nWS: () => Qn,
                nZQ: () => Dl,
                o6l: () => ca,
                ojh: () => k,
                ojs: () => At,
                ov9: () => F,
                pBf: () => Ye,
                pHI: () => me,
                paN: () => Oe,
                ppV: () => zn,
                psI: () => ht,
                qUd: () => Pl,
                qa3: () => at,
                qad: () => M,
                qq$: () => rn,
                qtW: () => Mr,
                r6x: () => Nl,
                rFo: () => Jn,
                rSH: () => lt,
                rYR: () => Nt,
                rjZ: () => Os,
                sPf: () => i,
                tBo: () => Kl,
                tJf: () => xe,
                tz3: () => cl,
                uB5: () => pt,
                uSd: () => Vo,
                uV5: () => he,
                uWO: () => La,
                ubm: () => aa,
                vim: () => Ht,
                vyJ: () => Ut,
                wfO: () => ce,
                wn6: () => N,
                wrO: () => Ne,
                wtR: () => a,
                xFO: () => le,
                xSv: () => H,
                y3Z: () => mt,
                yT7: () => Le,
                y_p: () => Z,
                z3S: () => hn,
                zdS: () => De,
                zgK: () => zi,
                znC: () => E
            });
            /**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
            const i = "182"
              , r = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2,
                ROTATE: 0,
                DOLLY: 1,
                PAN: 2
            }
              , a = {
                ROTATE: 0,
                PAN: 1,
                DOLLY_PAN: 2,
                DOLLY_ROTATE: 3
            }
              , s = 0
              , o = 1
              , l = 2
              , c = 1
              , h = 2
              , d = 3
              , u = 0
              , p = 1
              , f = 2
              , g = 0
              , m = 1
              , A = 2
              , v = 3
              , y = 4
              , w = 5
              , b = 100
              , x = 101
              , S = 102
              , E = 103
              , T = 104
              , k = 200
              , M = 201
              , _ = 202
              , C = 203
              , R = 204
              , P = 205
              , I = 206
              , L = 207
              , N = 208
              , z = 209
              , U = 210
              , D = 211
              , B = 212
              , G = 213
              , F = 214
              , O = 0
              , W = 1
              , V = 2
              , H = 3
              , j = 4
              , K = 5
              , q = 6
              , Q = 7
              , J = 0
              , X = 1
              , Y = 2
              , Z = 0
              , $ = 1
              , ee = 2
              , te = 3
              , ne = 4
              , ie = 5
              , re = 6
              , ae = 7
              , se = "attached"
              , oe = 301
              , le = 302
              , ce = 303
              , he = 304
              , de = 306
              , ue = 1e3
              , pe = 1001
              , fe = 1002
              , ge = 1003
              , me = 1004
              , Ae = 1005
              , ve = 1006
              , ye = 1007
              , we = 1008
              , be = 1009
              , xe = 1010
              , Se = 1011
              , Ee = 1012
              , Te = 1013
              , ke = 1014
              , Me = 1015
              , _e = 1016
              , Ce = 1017
              , Re = 1018
              , Pe = 1020
              , Ie = 35902
              , Le = 35899
              , Ne = 1021
              , ze = 1022
              , Ue = 1023
              , De = 1026
              , Be = 1027
              , Ge = 1028
              , Fe = 1029
              , Oe = 1030
              , We = 1031
              , Ve = 1033
              , He = 33776
              , je = 33777
              , Ke = 33778
              , qe = 33779
              , Qe = 35840
              , Je = 35841
              , Xe = 35842
              , Ye = 35843
              , Ze = 36196
              , $e = 37492
              , et = 37496
              , tt = 37488
              , nt = 37489
              , it = 37490
              , rt = 37491
              , at = 37808
              , st = 37809
              , ot = 37810
              , lt = 37811
              , ct = 37812
              , ht = 37813
              , dt = 37814
              , ut = 37815
              , pt = 37816
              , ft = 37817
              , gt = 37818
              , mt = 37819
              , At = 37820
              , vt = 37821
              , yt = 36492
              , wt = 36494
              , bt = 36495
              , xt = 36283
              , St = 36284
              , Et = 36285
              , Tt = 36286
              , kt = 2300
              , Mt = 2301
              , _t = 2302
              , Ct = 2400
              , Rt = 2401
              , Pt = 2402
              , It = 0
              , Lt = 1
              , Nt = 2
              , zt = 0
              , Ut = 1
              , Dt = ""
              , Bt = "srgb"
              , Gt = "srgb-linear"
              , Ft = "linear"
              , Ot = "srgb"
              , Wt = 7680
              , Vt = 512
              , Ht = 513
              , jt = 514
              , Kt = 515
              , qt = 516
              , Qt = 517
              , Jt = 518
              , Xt = 519
              , Yt = 35044
              , Zt = "300 es"
              , $t = 2e3
              , en = 2001;
            function tn(e) {
                for (let t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535)
                        return !0;
                return !1
            }
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array;
            function nn(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }
            function rn(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            function an() {
                const e = rn("canvas");
                return e.style.display = "block",
                e
            }
            const sn = {};
            let on = null;
            function ln(...e) {
                const t = "THREE." + e.shift();
                on ? on("log", t, ...e) : console.log(t, ...e)
            }
            function cn(...e) {
                const t = "THREE." + e.shift();
                on ? on("warn", t, ...e) : console.warn(t, ...e)
            }
            function hn(...e) {
                const t = "THREE." + e.shift();
                on ? on("error", t, ...e) : console.error(t, ...e)
            }
            function dn(...e) {
                const t = e.join(" ");
                t in sn || (sn[t] = !0,
                cn(...e))
            }
            function un(e, t, n) {
                return new Promise((function(i, r) {
                    setTimeout((function a() {
                        switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                        case e.WAIT_FAILED:
                            r();
                            break;
                        case e.TIMEOUT_EXPIRED:
                            setTimeout(a, n);
                            break;
                        default:
                            i()
                        }
                    }
                    ), n)
                }
                ))
            }
            class pn {
                addEventListener(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[e] && (n[e] = []),
                    -1 === n[e].indexOf(t) && n[e].push(t)
                }
                hasEventListener(e, t) {
                    const n = this._listeners;
                    return void 0 !== n && (void 0 !== n[e] && -1 !== n[e].indexOf(t))
                }
                removeEventListener(e, t) {
                    const n = this._listeners;
                    if (void 0 === n)
                        return;
                    const i = n[e];
                    if (void 0 !== i) {
                        const e = i.indexOf(t);
                        -1 !== e && i.splice(e, 1)
                    }
                }
                dispatchEvent(e) {
                    const t = this._listeners;
                    if (void 0 === t)
                        return;
                    const n = t[e.type];
                    if (void 0 !== n) {
                        e.target = this;
                        const t = n.slice(0);
                        for (let n = 0, i = t.length; n < i; n++)
                            t[n].call(this, e);
                        e.target = null
                    }
                }
            }
            const fn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
            let gn = 1234567;
            const mn = Math.PI / 180
              , An = 180 / Math.PI;
            function vn() {
                const e = 4294967295 * Math.random() | 0
                  , t = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0;
                return (fn[255 & e] + fn[e >> 8 & 255] + fn[e >> 16 & 255] + fn[e >> 24 & 255] + "-" + fn[255 & t] + fn[t >> 8 & 255] + "-" + fn[t >> 16 & 15 | 64] + fn[t >> 24 & 255] + "-" + fn[63 & n | 128] + fn[n >> 8 & 255] + "-" + fn[n >> 16 & 255] + fn[n >> 24 & 255] + fn[255 & i] + fn[i >> 8 & 255] + fn[i >> 16 & 255] + fn[i >> 24 & 255]).toLowerCase()
            }
            function yn(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }
            function wn(e, t) {
                return (e % t + t) % t
            }
            function bn(e, t, n) {
                return (1 - n) * e + n * t
            }
            function xn(e, t) {
                switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return e / 4294967295;
                case Uint16Array:
                    return e / 65535;
                case Uint8Array:
                    return e / 255;
                case Int32Array:
                    return Math.max(e / 2147483647, -1);
                case Int16Array:
                    return Math.max(e / 32767, -1);
                case Int8Array:
                    return Math.max(e / 127, -1);
                default:
                    throw new Error("Invalid component type.")
                }
            }
            function Sn(e, t) {
                switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return Math.round(4294967295 * e);
                case Uint16Array:
                    return Math.round(65535 * e);
                case Uint8Array:
                    return Math.round(255 * e);
                case Int32Array:
                    return Math.round(2147483647 * e);
                case Int16Array:
                    return Math.round(32767 * e);
                case Int8Array:
                    return Math.round(127 * e);
                default:
                    throw new Error("Invalid component type.")
                }
            }
            const En = {
                DEG2RAD: mn,
                RAD2DEG: An,
                generateUUID: vn,
                clamp: yn,
                euclideanModulo: wn,
                mapLinear: function(e, t, n, i, r) {
                    return i + (e - t) * (r - i) / (n - t)
                },
                inverseLerp: function(e, t, n) {
                    return e !== t ? (n - e) / (t - e) : 0
                },
                lerp: bn,
                damp: function(e, t, n, i) {
                    return bn(e, t, 1 - Math.exp(-n * i))
                },
                pingpong: function(e, t=1) {
                    return t - Math.abs(wn(e, 2 * t) - t)
                },
                smoothstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                },
                smootherstep: function(e, t, n) {
                    return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                seededRandom: function(e) {
                    void 0 !== e && (gn = e);
                    let t = gn += 1831565813;
                    return t = Math.imul(t ^ t >>> 15, 1 | t),
                    t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                    ((t ^ t >>> 14) >>> 0) / 4294967296
                },
                degToRad: function(e) {
                    return e * mn
                },
                radToDeg: function(e) {
                    return e * An
                },
                isPowerOfTwo: function(e) {
                    return !(e & e - 1) && 0 !== e
                },
                ceilPowerOfTwo: function(e) {
                    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                },
                floorPowerOfTwo: function(e) {
                    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(e, t, n, i, r) {
                    const a = Math.cos
                      , s = Math.sin
                      , o = a(n / 2)
                      , l = s(n / 2)
                      , c = a((t + i) / 2)
                      , h = s((t + i) / 2)
                      , d = a((t - i) / 2)
                      , u = s((t - i) / 2)
                      , p = a((i - t) / 2)
                      , f = s((i - t) / 2);
                    switch (r) {
                    case "XYX":
                        e.set(o * h, l * d, l * u, o * c);
                        break;
                    case "YZY":
                        e.set(l * u, o * h, l * d, o * c);
                        break;
                    case "ZXZ":
                        e.set(l * d, l * u, o * h, o * c);
                        break;
                    case "XZX":
                        e.set(o * h, l * f, l * p, o * c);
                        break;
                    case "YXY":
                        e.set(l * p, o * h, l * f, o * c);
                        break;
                    case "ZYZ":
                        e.set(l * f, l * p, o * h, o * c);
                        break;
                    default:
                        cn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                },
                normalize: Sn,
                denormalize: xn
            };
            class Tn {
                constructor(e=0, t=0) {
                    Tn.prototype.isVector2 = !0,
                    this.x = e,
                    this.y = t
                }
                get width() {
                    return this.x
                }
                set width(e) {
                    this.x = e
                }
                get height() {
                    return this.y
                }
                set height(e) {
                    this.y = e
                }
                set(e, t) {
                    return this.x = e,
                    this.y = t,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this
                }
                divide(e) {
                    return this.x /= e.x,
                    this.y /= e.y,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                applyMatrix3(e) {
                    const t = this.x
                      , n = this.y
                      , i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6],
                    this.y = i[1] * t + i[4] * n + i[7],
                    this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this
                }
                clamp(e, t) {
                    return this.x = yn(this.x, e.x, t.x),
                    this.y = yn(this.y, e.y, t.y),
                    this
                }
                clampScalar(e, t) {
                    return this.x = yn(this.x, e, t),
                    this.y = yn(this.y, e, t),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(yn(n, e, t))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y
                }
                cross(e) {
                    return this.x * e.y - this.y * e.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t)
                        return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(yn(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x
                      , n = this.y - e.y;
                    return t * t + n * n
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this
                }
                rotateAround(e, t) {
                    const n = Math.cos(t)
                      , i = Math.sin(t)
                      , r = this.x - e.x
                      , a = this.y - e.y;
                    return this.x = r * n - a * i + e.x,
                    this.y = r * i + a * n + e.y,
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y
                }
            }
            class kn {
                constructor(e=0, t=0, n=0, i=1) {
                    this.isQuaternion = !0,
                    this._x = e,
                    this._y = t,
                    this._z = n,
                    this._w = i
                }
                static slerpFlat(e, t, n, i, r, a, s) {
                    let o = n[i + 0]
                      , l = n[i + 1]
                      , c = n[i + 2]
                      , h = n[i + 3]
                      , d = r[a + 0]
                      , u = r[a + 1]
                      , p = r[a + 2]
                      , f = r[a + 3];
                    if (s <= 0)
                        return e[t + 0] = o,
                        e[t + 1] = l,
                        e[t + 2] = c,
                        void (e[t + 3] = h);
                    if (s >= 1)
                        return e[t + 0] = d,
                        e[t + 1] = u,
                        e[t + 2] = p,
                        void (e[t + 3] = f);
                    if (h !== f || o !== d || l !== u || c !== p) {
                        let e = o * d + l * u + c * p + h * f;
                        e < 0 && (d = -d,
                        u = -u,
                        p = -p,
                        f = -f,
                        e = -e);
                        let t = 1 - s;
                        if (e < .9995) {
                            const n = Math.acos(e)
                              , i = Math.sin(n);
                            t = Math.sin(t * n) / i,
                            o = o * t + d * (s = Math.sin(s * n) / i),
                            l = l * t + u * s,
                            c = c * t + p * s,
                            h = h * t + f * s
                        } else {
                            o = o * t + d * s,
                            l = l * t + u * s,
                            c = c * t + p * s,
                            h = h * t + f * s;
                            const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                            o *= e,
                            l *= e,
                            c *= e,
                            h *= e
                        }
                    }
                    e[t] = o,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    e[t + 3] = h
                }
                static multiplyQuaternionsFlat(e, t, n, i, r, a) {
                    const s = n[i]
                      , o = n[i + 1]
                      , l = n[i + 2]
                      , c = n[i + 3]
                      , h = r[a]
                      , d = r[a + 1]
                      , u = r[a + 2]
                      , p = r[a + 3];
                    return e[t] = s * p + c * h + o * u - l * d,
                    e[t + 1] = o * p + c * d + l * h - s * u,
                    e[t + 2] = l * p + c * u + s * d - o * h,
                    e[t + 3] = c * p - s * h - o * d - l * u,
                    e
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e,
                    this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e,
                    this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e,
                    this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(e) {
                    this._w = e,
                    this._onChangeCallback()
                }
                set(e, t, n, i) {
                    return this._x = e,
                    this._y = t,
                    this._z = n,
                    this._w = i,
                    this._onChangeCallback(),
                    this
                }
                clone() {
                    return new this.constructor(this._x,this._y,this._z,this._w)
                }
                copy(e) {
                    return this._x = e.x,
                    this._y = e.y,
                    this._z = e.z,
                    this._w = e.w,
                    this._onChangeCallback(),
                    this
                }
                setFromEuler(e, t=!0) {
                    const n = e._x
                      , i = e._y
                      , r = e._z
                      , a = e._order
                      , s = Math.cos
                      , o = Math.sin
                      , l = s(n / 2)
                      , c = s(i / 2)
                      , h = s(r / 2)
                      , d = o(n / 2)
                      , u = o(i / 2)
                      , p = o(r / 2);
                    switch (a) {
                    case "XYZ":
                        this._x = d * c * h + l * u * p,
                        this._y = l * u * h - d * c * p,
                        this._z = l * c * p + d * u * h,
                        this._w = l * c * h - d * u * p;
                        break;
                    case "YXZ":
                        this._x = d * c * h + l * u * p,
                        this._y = l * u * h - d * c * p,
                        this._z = l * c * p - d * u * h,
                        this._w = l * c * h + d * u * p;
                        break;
                    case "ZXY":
                        this._x = d * c * h - l * u * p,
                        this._y = l * u * h + d * c * p,
                        this._z = l * c * p + d * u * h,
                        this._w = l * c * h - d * u * p;
                        break;
                    case "ZYX":
                        this._x = d * c * h - l * u * p,
                        this._y = l * u * h + d * c * p,
                        this._z = l * c * p - d * u * h,
                        this._w = l * c * h + d * u * p;
                        break;
                    case "YZX":
                        this._x = d * c * h + l * u * p,
                        this._y = l * u * h + d * c * p,
                        this._z = l * c * p - d * u * h,
                        this._w = l * c * h - d * u * p;
                        break;
                    case "XZY":
                        this._x = d * c * h - l * u * p,
                        this._y = l * u * h - d * c * p,
                        this._z = l * c * p + d * u * h,
                        this._w = l * c * h + d * u * p;
                        break;
                    default:
                        cn("Quaternion: .setFromEuler() encountered an unknown order: " + a)
                    }
                    return !0 === t && this._onChangeCallback(),
                    this
                }
                setFromAxisAngle(e, t) {
                    const n = t / 2
                      , i = Math.sin(n);
                    return this._x = e.x * i,
                    this._y = e.y * i,
                    this._z = e.z * i,
                    this._w = Math.cos(n),
                    this._onChangeCallback(),
                    this
                }
                setFromRotationMatrix(e) {
                    const t = e.elements
                      , n = t[0]
                      , i = t[4]
                      , r = t[8]
                      , a = t[1]
                      , s = t[5]
                      , o = t[9]
                      , l = t[2]
                      , c = t[6]
                      , h = t[10]
                      , d = n + s + h;
                    if (d > 0) {
                        const e = .5 / Math.sqrt(d + 1);
                        this._w = .25 / e,
                        this._x = (c - o) * e,
                        this._y = (r - l) * e,
                        this._z = (a - i) * e
                    } else if (n > s && n > h) {
                        const e = 2 * Math.sqrt(1 + n - s - h);
                        this._w = (c - o) / e,
                        this._x = .25 * e,
                        this._y = (i + a) / e,
                        this._z = (r + l) / e
                    } else if (s > h) {
                        const e = 2 * Math.sqrt(1 + s - n - h);
                        this._w = (r - l) / e,
                        this._x = (i + a) / e,
                        this._y = .25 * e,
                        this._z = (o + c) / e
                    } else {
                        const e = 2 * Math.sqrt(1 + h - n - s);
                        this._w = (a - i) / e,
                        this._x = (r + l) / e,
                        this._y = (o + c) / e,
                        this._z = .25 * e
                    }
                    return this._onChangeCallback(),
                    this
                }
                setFromUnitVectors(e, t) {
                    let n = e.dot(t) + 1;
                    return n < 1e-8 ? (n = 0,
                    Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                    this._y = e.x,
                    this._z = 0,
                    this._w = n) : (this._x = 0,
                    this._y = -e.z,
                    this._z = e.y,
                    this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                    this._y = e.z * t.x - e.x * t.z,
                    this._z = e.x * t.y - e.y * t.x,
                    this._w = n),
                    this.normalize()
                }
                angleTo(e) {
                    return 2 * Math.acos(Math.abs(yn(this.dot(e), -1, 1)))
                }
                rotateTowards(e, t) {
                    const n = this.angleTo(e);
                    if (0 === n)
                        return this;
                    const i = Math.min(1, t / n);
                    return this.slerp(e, i),
                    this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1,
                    this._y *= -1,
                    this._z *= -1,
                    this._onChangeCallback(),
                    this
                }
                dot(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let e = this.length();
                    return 0 === e ? (this._x = 0,
                    this._y = 0,
                    this._z = 0,
                    this._w = 1) : (e = 1 / e,
                    this._x = this._x * e,
                    this._y = this._y * e,
                    this._z = this._z * e,
                    this._w = this._w * e),
                    this._onChangeCallback(),
                    this
                }
                multiply(e) {
                    return this.multiplyQuaternions(this, e)
                }
                premultiply(e) {
                    return this.multiplyQuaternions(e, this)
                }
                multiplyQuaternions(e, t) {
                    const n = e._x
                      , i = e._y
                      , r = e._z
                      , a = e._w
                      , s = t._x
                      , o = t._y
                      , l = t._z
                      , c = t._w;
                    return this._x = n * c + a * s + i * l - r * o,
                    this._y = i * c + a * o + r * s - n * l,
                    this._z = r * c + a * l + n * o - i * s,
                    this._w = a * c - n * s - i * o - r * l,
                    this._onChangeCallback(),
                    this
                }
                slerp(e, t) {
                    if (t <= 0)
                        return this;
                    if (t >= 1)
                        return this.copy(e);
                    let n = e._x
                      , i = e._y
                      , r = e._z
                      , a = e._w
                      , s = this.dot(e);
                    s < 0 && (n = -n,
                    i = -i,
                    r = -r,
                    a = -a,
                    s = -s);
                    let o = 1 - t;
                    if (s < .9995) {
                        const e = Math.acos(s)
                          , l = Math.sin(e);
                        o = Math.sin(o * e) / l,
                        t = Math.sin(t * e) / l,
                        this._x = this._x * o + n * t,
                        this._y = this._y * o + i * t,
                        this._z = this._z * o + r * t,
                        this._w = this._w * o + a * t,
                        this._onChangeCallback()
                    } else
                        this._x = this._x * o + n * t,
                        this._y = this._y * o + i * t,
                        this._z = this._z * o + r * t,
                        this._w = this._w * o + a * t,
                        this.normalize();
                    return this
                }
                slerpQuaternions(e, t, n) {
                    return this.copy(e).slerp(t, n)
                }
                random() {
                    const e = 2 * Math.PI * Math.random()
                      , t = 2 * Math.PI * Math.random()
                      , n = Math.random()
                      , i = Math.sqrt(1 - n)
                      , r = Math.sqrt(n);
                    return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                }
                fromArray(e, t=0) {
                    return this._x = e[t],
                    this._y = e[t + 1],
                    this._z = e[t + 2],
                    this._w = e[t + 3],
                    this._onChangeCallback(),
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this._x,
                    e[t + 1] = this._y,
                    e[t + 2] = this._z,
                    e[t + 3] = this._w,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this._x = e.getX(t),
                    this._y = e.getY(t),
                    this._z = e.getZ(t),
                    this._w = e.getW(t),
                    this._onChangeCallback(),
                    this
                }
                toJSON() {
                    return this.toArray()
                }
                _onChange(e) {
                    return this._onChangeCallback = e,
                    this
                }
                _onChangeCallback() {}
                *[Symbol.iterator]() {
                    yield this._x,
                    yield this._y,
                    yield this._z,
                    yield this._w
                }
            }
            class Mn {
                constructor(e=0, t=0, n=0) {
                    Mn.prototype.isVector3 = !0,
                    this.x = e,
                    this.y = t,
                    this.z = n
                }
                set(e, t, n) {
                    return void 0 === n && (n = this.z),
                    this.x = e,
                    this.y = t,
                    this.z = n,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this.z = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setZ(e) {
                    return this.z = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y,this.z)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this.z = e.z,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this.z += e.z,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this.z += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this.z = e.z + t.z,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this.z += e.z * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this.z -= e.z,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this.z -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this.z = e.z - t.z,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this.z *= e.z,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this.z *= e,
                    this
                }
                multiplyVectors(e, t) {
                    return this.x = e.x * t.x,
                    this.y = e.y * t.y,
                    this.z = e.z * t.z,
                    this
                }
                applyEuler(e) {
                    return this.applyQuaternion(Cn.setFromEuler(e))
                }
                applyAxisAngle(e, t) {
                    return this.applyQuaternion(Cn.setFromAxisAngle(e, t))
                }
                applyMatrix3(e) {
                    const t = this.x
                      , n = this.y
                      , i = this.z
                      , r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i,
                    this.y = r[1] * t + r[4] * n + r[7] * i,
                    this.z = r[2] * t + r[5] * n + r[8] * i,
                    this
                }
                applyNormalMatrix(e) {
                    return this.applyMatrix3(e).normalize()
                }
                applyMatrix4(e) {
                    const t = this.x
                      , n = this.y
                      , i = this.z
                      , r = e.elements
                      , a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a,
                    this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a,
                    this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a,
                    this
                }
                applyQuaternion(e) {
                    const t = this.x
                      , n = this.y
                      , i = this.z
                      , r = e.x
                      , a = e.y
                      , s = e.z
                      , o = e.w
                      , l = 2 * (a * i - s * n)
                      , c = 2 * (s * t - r * i)
                      , h = 2 * (r * n - a * t);
                    return this.x = t + o * l + a * h - s * c,
                    this.y = n + o * c + s * l - r * h,
                    this.z = i + o * h + r * c - a * l,
                    this
                }
                project(e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                }
                unproject(e) {
                    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                }
                transformDirection(e) {
                    const t = this.x
                      , n = this.y
                      , i = this.z
                      , r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i,
                    this.y = r[1] * t + r[5] * n + r[9] * i,
                    this.z = r[2] * t + r[6] * n + r[10] * i,
                    this.normalize()
                }
                divide(e) {
                    return this.x /= e.x,
                    this.y /= e.y,
                    this.z /= e.z,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this.z = Math.min(this.z, e.z),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this.z = Math.max(this.z, e.z),
                    this
                }
                clamp(e, t) {
                    return this.x = yn(this.x, e.x, t.x),
                    this.y = yn(this.y, e.y, t.y),
                    this.z = yn(this.z, e.z, t.z),
                    this
                }
                clampScalar(e, t) {
                    return this.x = yn(this.x, e, t),
                    this.y = yn(this.y, e, t),
                    this.z = yn(this.z, e, t),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(yn(n, e, t))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this.z = Math.trunc(this.z),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this.z += (e.z - this.z) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this.z = e.z + (t.z - e.z) * n,
                    this
                }
                cross(e) {
                    return this.crossVectors(this, e)
                }
                crossVectors(e, t) {
                    const n = e.x
                      , i = e.y
                      , r = e.z
                      , a = t.x
                      , s = t.y
                      , o = t.z;
                    return this.x = i * o - r * s,
                    this.y = r * a - n * o,
                    this.z = n * s - i * a,
                    this
                }
                projectOnVector(e) {
                    const t = e.lengthSq();
                    if (0 === t)
                        return this.set(0, 0, 0);
                    const n = e.dot(this) / t;
                    return this.copy(e).multiplyScalar(n)
                }
                projectOnPlane(e) {
                    return _n.copy(this).projectOnVector(e),
                    this.sub(_n)
                }
                reflect(e) {
                    return this.sub(_n.copy(e).multiplyScalar(2 * this.dot(e)))
                }
                angleTo(e) {
                    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                    if (0 === t)
                        return Math.PI / 2;
                    const n = this.dot(e) / t;
                    return Math.acos(yn(n, -1, 1))
                }
                distanceTo(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                }
                distanceToSquared(e) {
                    const t = this.x - e.x
                      , n = this.y - e.y
                      , i = this.z - e.z;
                    return t * t + n * n + i * i
                }
                manhattanDistanceTo(e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                }
                setFromSpherical(e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                }
                setFromSphericalCoords(e, t, n) {
                    const i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n),
                    this.y = Math.cos(t) * e,
                    this.z = i * Math.cos(n),
                    this
                }
                setFromCylindrical(e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                }
                setFromCylindricalCoords(e, t, n) {
                    return this.x = e * Math.sin(t),
                    this.y = n,
                    this.z = e * Math.cos(t),
                    this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12],
                    this.y = t[13],
                    this.z = t[14],
                    this
                }
                setFromMatrixScale(e) {
                    const t = this.setFromMatrixColumn(e, 0).length()
                      , n = this.setFromMatrixColumn(e, 1).length()
                      , i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t,
                    this.y = n,
                    this.z = i,
                    this
                }
                setFromMatrixColumn(e, t) {
                    return this.fromArray(e.elements, 4 * t)
                }
                setFromMatrix3Column(e, t) {
                    return this.fromArray(e.elements, 3 * t)
                }
                setFromEuler(e) {
                    return this.x = e._x,
                    this.y = e._y,
                    this.z = e._z,
                    this
                }
                setFromColor(e) {
                    return this.x = e.r,
                    this.y = e.g,
                    this.z = e.b,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this.z = e[t + 2],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e[t + 2] = this.z,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this.z = e.getZ(t),
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this
                }
                randomDirection() {
                    const e = Math.random() * Math.PI * 2
                      , t = 2 * Math.random() - 1
                      , n = Math.sqrt(1 - t * t);
                    return this.x = n * Math.cos(e),
                    this.y = t,
                    this.z = n * Math.sin(e),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y,
                    yield this.z
                }
            }
            const _n = new Mn
              , Cn = new kn;
            class Rn {
                constructor(e, t, n, i, r, a, s, o, l) {
                    Rn.prototype.isMatrix3 = !0,
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                    void 0 !== e && this.set(e, t, n, i, r, a, s, o, l)
                }
                set(e, t, n, i, r, a, s, o, l) {
                    const c = this.elements;
                    return c[0] = e,
                    c[1] = i,
                    c[2] = s,
                    c[3] = t,
                    c[4] = r,
                    c[5] = o,
                    c[6] = n,
                    c[7] = a,
                    c[8] = l,
                    this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                    this
                }
                copy(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t[3] = n[3],
                    t[4] = n[4],
                    t[5] = n[5],
                    t[6] = n[6],
                    t[7] = n[7],
                    t[8] = n[8],
                    this
                }
                extractBasis(e, t, n) {
                    return e.setFromMatrix3Column(this, 0),
                    t.setFromMatrix3Column(this, 1),
                    n.setFromMatrix3Column(this, 2),
                    this
                }
                setFromMatrix4(e) {
                    const t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                    this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements
                      , i = t.elements
                      , r = this.elements
                      , a = n[0]
                      , s = n[3]
                      , o = n[6]
                      , l = n[1]
                      , c = n[4]
                      , h = n[7]
                      , d = n[2]
                      , u = n[5]
                      , p = n[8]
                      , f = i[0]
                      , g = i[3]
                      , m = i[6]
                      , A = i[1]
                      , v = i[4]
                      , y = i[7]
                      , w = i[2]
                      , b = i[5]
                      , x = i[8];
                    return r[0] = a * f + s * A + o * w,
                    r[3] = a * g + s * v + o * b,
                    r[6] = a * m + s * y + o * x,
                    r[1] = l * f + c * A + h * w,
                    r[4] = l * g + c * v + h * b,
                    r[7] = l * m + c * y + h * x,
                    r[2] = d * f + u * A + p * w,
                    r[5] = d * g + u * v + p * b,
                    r[8] = d * m + u * y + p * x,
                    this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e,
                    t[3] *= e,
                    t[6] *= e,
                    t[1] *= e,
                    t[4] *= e,
                    t[7] *= e,
                    t[2] *= e,
                    t[5] *= e,
                    t[8] *= e,
                    this
                }
                determinant() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , i = e[2]
                      , r = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8];
                    return t * a * c - t * s * l - n * r * c + n * s * o + i * r * l - i * a * o
                }
                invert() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , i = e[2]
                      , r = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8]
                      , h = c * a - s * l
                      , d = s * o - c * r
                      , u = l * r - a * o
                      , p = t * h + n * d + i * u;
                    if (0 === p)
                        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return e[0] = h * f,
                    e[1] = (i * l - c * n) * f,
                    e[2] = (s * n - i * a) * f,
                    e[3] = d * f,
                    e[4] = (c * t - i * o) * f,
                    e[5] = (i * r - s * t) * f,
                    e[6] = u * f,
                    e[7] = (n * o - l * t) * f,
                    e[8] = (a * t - n * r) * f,
                    this
                }
                transpose() {
                    let e;
                    const t = this.elements;
                    return e = t[1],
                    t[1] = t[3],
                    t[3] = e,
                    e = t[2],
                    t[2] = t[6],
                    t[6] = e,
                    e = t[5],
                    t[5] = t[7],
                    t[7] = e,
                    this
                }
                getNormalMatrix(e) {
                    return this.setFromMatrix4(e).invert().transpose()
                }
                transposeIntoArray(e) {
                    const t = this.elements;
                    return e[0] = t[0],
                    e[1] = t[3],
                    e[2] = t[6],
                    e[3] = t[1],
                    e[4] = t[4],
                    e[5] = t[7],
                    e[6] = t[2],
                    e[7] = t[5],
                    e[8] = t[8],
                    this
                }
                setUvTransform(e, t, n, i, r, a, s) {
                    const o = Math.cos(r)
                      , l = Math.sin(r);
                    return this.set(n * o, n * l, -n * (o * a + l * s) + a + e, -i * l, i * o, -i * (-l * a + o * s) + s + t, 0, 0, 1),
                    this
                }
                scale(e, t) {
                    return this.premultiply(Pn.makeScale(e, t)),
                    this
                }
                rotate(e) {
                    return this.premultiply(Pn.makeRotation(-e)),
                    this
                }
                translate(e, t) {
                    return this.premultiply(Pn.makeTranslation(e, t)),
                    this
                }
                makeTranslation(e, t) {
                    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                    this
                }
                makeRotation(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                    this
                }
                makeScale(e, t) {
                    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                    this
                }
                equals(e) {
                    const t = this.elements
                      , n = e.elements;
                    for (let e = 0; e < 9; e++)
                        if (t[e] !== n[e])
                            return !1;
                    return !0
                }
                fromArray(e, t=0) {
                    for (let n = 0; n < 9; n++)
                        this.elements[n] = e[n + t];
                    return this
                }
                toArray(e=[], t=0) {
                    const n = this.elements;
                    return e[t] = n[0],
                    e[t + 1] = n[1],
                    e[t + 2] = n[2],
                    e[t + 3] = n[3],
                    e[t + 4] = n[4],
                    e[t + 5] = n[5],
                    e[t + 6] = n[6],
                    e[t + 7] = n[7],
                    e[t + 8] = n[8],
                    e
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            const Pn = new Rn
              , In = (new Rn).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
              , Ln = (new Rn).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
            function Nn() {
                const e = {
                    enabled: !0,
                    workingColorSpace: Gt,
                    spaces: {},
                    convert: function(e, t, n) {
                        return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === Ot && (e.r = Un(e.r),
                        e.g = Un(e.g),
                        e.b = Un(e.b)),
                        this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ),
                        e.applyMatrix3(this.spaces[n].fromXYZ)),
                        this.spaces[n].transfer === Ot && (e.r = Dn(e.r),
                        e.g = Dn(e.g),
                        e.b = Dn(e.b)),
                        e) : e
                    },
                    workingToColorSpace: function(e, t) {
                        return this.convert(e, this.workingColorSpace, t)
                    },
                    colorSpaceToWorking: function(e, t) {
                        return this.convert(e, t, this.workingColorSpace)
                    },
                    getPrimaries: function(e) {
                        return this.spaces[e].primaries
                    },
                    getTransfer: function(e) {
                        return e === Dt ? Ft : this.spaces[e].transfer
                    },
                    getToneMappingMode: function(e) {
                        return this.spaces[e].outputColorSpaceConfig.toneMappingMode || "standard"
                    },
                    getLuminanceCoefficients: function(e, t=this.workingColorSpace) {
                        return e.fromArray(this.spaces[t].luminanceCoefficients)
                    },
                    define: function(e) {
                        Object.assign(this.spaces, e)
                    },
                    _getMatrix: function(e, t, n) {
                        return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
                    },
                    _getDrawingBufferColorSpace: function(e) {
                        return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
                    },
                    _getUnpackColorSpace: function(e=this.workingColorSpace) {
                        return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
                    },
                    fromWorkingColorSpace: function(t, n) {
                        return dn("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),
                        e.workingToColorSpace(t, n)
                    },
                    toWorkingColorSpace: function(t, n) {
                        return dn("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),
                        e.colorSpaceToWorking(t, n)
                    }
                }
                  , t = [.64, .33, .3, .6, .15, .06]
                  , n = [.2126, .7152, .0722]
                  , i = [.3127, .329];
                return e.define({
                    [Gt]: {
                        primaries: t,
                        whitePoint: i,
                        transfer: Ft,
                        toXYZ: In,
                        fromXYZ: Ln,
                        luminanceCoefficients: n,
                        workingColorSpaceConfig: {
                            unpackColorSpace: Bt
                        },
                        outputColorSpaceConfig: {
                            drawingBufferColorSpace: Bt
                        }
                    },
                    [Bt]: {
                        primaries: t,
                        whitePoint: i,
                        transfer: Ot,
                        toXYZ: In,
                        fromXYZ: Ln,
                        luminanceCoefficients: n,
                        outputColorSpaceConfig: {
                            drawingBufferColorSpace: Bt
                        }
                    }
                }),
                e
            }
            const zn = Nn();
            function Un(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }
            function Dn(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            let Bn;
            class Gn {
                static getDataURL(e, t="image/png") {
                    if (/^data:/i.test(e.src))
                        return e.src;
                    if ("undefined" == typeof HTMLCanvasElement)
                        return e.src;
                    let n;
                    if (e instanceof HTMLCanvasElement)
                        n = e;
                    else {
                        void 0 === Bn && (Bn = rn("canvas")),
                        Bn.width = e.width,
                        Bn.height = e.height;
                        const t = Bn.getContext("2d");
                        e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height),
                        n = Bn
                    }
                    return n.toDataURL(t)
                }
                static sRGBToLinear(e) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                        const t = rn("canvas");
                        t.width = e.width,
                        t.height = e.height;
                        const n = t.getContext("2d");
                        n.drawImage(e, 0, 0, e.width, e.height);
                        const i = n.getImageData(0, 0, e.width, e.height)
                          , r = i.data;
                        for (let e = 0; e < r.length; e++)
                            r[e] = 255 * Un(r[e] / 255);
                        return n.putImageData(i, 0, 0),
                        t
                    }
                    if (e.data) {
                        const t = e.data.slice(0);
                        for (let e = 0; e < t.length; e++)
                            t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Un(t[e] / 255)) : t[e] = Un(t[e]);
                        return {
                            data: t,
                            width: e.width,
                            height: e.height
                        }
                    }
                    return cn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                    e
                }
            }
            let Fn = 0;
            class On {
                constructor(e=null) {
                    this.isSource = !0,
                    Object.defineProperty(this, "id", {
                        value: Fn++
                    }),
                    this.uuid = vn(),
                    this.data = e,
                    this.dataReady = !0,
                    this.version = 0
                }
                getSize(e) {
                    const t = this.data;
                    return "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : "undefined" != typeof VideoFrame && t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : null !== t ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0),
                    e
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.images[this.uuid])
                        return e.images[this.uuid];
                    const n = {
                        uuid: this.uuid,
                        url: ""
                    }
                      , i = this.data;
                    if (null !== i) {
                        let e;
                        if (Array.isArray(i)) {
                            e = [];
                            for (let t = 0, n = i.length; t < n; t++)
                                i[t].isDataTexture ? e.push(Wn(i[t].image)) : e.push(Wn(i[t]))
                        } else
                            e = Wn(i);
                        n.url = e
                    }
                    return t || (e.images[this.uuid] = n),
                    n
                }
            }
            function Wn(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Gn.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (cn("Texture: Unable to serialize Texture."),
                {})
            }
            let Vn = 0;
            const Hn = new Mn;
            class jn extends pn {
                constructor(e=jn.DEFAULT_IMAGE, t=jn.DEFAULT_MAPPING, n=pe, i=pe, r=ve, a=we, s=Ue, o=be, l=jn.DEFAULT_ANISOTROPY, c=Dt) {
                    super(),
                    this.isTexture = !0,
                    Object.defineProperty(this, "id", {
                        value: Vn++
                    }),
                    this.uuid = vn(),
                    this.name = "",
                    this.source = new On(e),
                    this.mipmaps = [],
                    this.mapping = t,
                    this.channel = 0,
                    this.wrapS = n,
                    this.wrapT = i,
                    this.magFilter = r,
                    this.minFilter = a,
                    this.anisotropy = l,
                    this.format = s,
                    this.internalFormat = null,
                    this.type = o,
                    this.offset = new Tn(0,0),
                    this.repeat = new Tn(1,1),
                    this.center = new Tn(0,0),
                    this.rotation = 0,
                    this.matrixAutoUpdate = !0,
                    this.matrix = new Rn,
                    this.generateMipmaps = !0,
                    this.premultiplyAlpha = !1,
                    this.flipY = !0,
                    this.unpackAlignment = 4,
                    this.colorSpace = c,
                    this.userData = {},
                    this.updateRanges = [],
                    this.version = 0,
                    this.onUpdate = null,
                    this.renderTarget = null,
                    this.isRenderTargetTexture = !1,
                    this.isArrayTexture = !!(e && e.depth && e.depth > 1),
                    this.pmremVersion = 0
                }
                get width() {
                    return this.source.getSize(Hn).x
                }
                get height() {
                    return this.source.getSize(Hn).y
                }
                get depth() {
                    return this.source.getSize(Hn).z
                }
                get image() {
                    return this.source.data
                }
                set image(e=null) {
                    this.source.data = e
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.name = e.name,
                    this.source = e.source,
                    this.mipmaps = e.mipmaps.slice(0),
                    this.mapping = e.mapping,
                    this.channel = e.channel,
                    this.wrapS = e.wrapS,
                    this.wrapT = e.wrapT,
                    this.magFilter = e.magFilter,
                    this.minFilter = e.minFilter,
                    this.anisotropy = e.anisotropy,
                    this.format = e.format,
                    this.internalFormat = e.internalFormat,
                    this.type = e.type,
                    this.offset.copy(e.offset),
                    this.repeat.copy(e.repeat),
                    this.center.copy(e.center),
                    this.rotation = e.rotation,
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this.matrix.copy(e.matrix),
                    this.generateMipmaps = e.generateMipmaps,
                    this.premultiplyAlpha = e.premultiplyAlpha,
                    this.flipY = e.flipY,
                    this.unpackAlignment = e.unpackAlignment,
                    this.colorSpace = e.colorSpace,
                    this.renderTarget = e.renderTarget,
                    this.isRenderTargetTexture = e.isRenderTargetTexture,
                    this.isArrayTexture = e.isArrayTexture,
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    this.needsUpdate = !0,
                    this
                }
                setValues(e) {
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            cn(`Texture.setValues(): parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n : cn(`Texture.setValues(): property '${t}' does not exist.`)
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid])
                        return e.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.7,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        image: this.source.toJSON(e).uuid,
                        mapping: this.mapping,
                        channel: this.channel,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        internalFormat: this.internalFormat,
                        type: this.type,
                        colorSpace: this.colorSpace,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        generateMipmaps: this.generateMipmaps,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                    t || (e.textures[this.uuid] = n),
                    n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(e) {
                    if (300 !== this.mapping)
                        return e;
                    if (e.applyMatrix3(this.matrix),
                    e.x < 0 || e.x > 1)
                        switch (this.wrapS) {
                        case ue:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case pe:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case fe:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                        }
                    if (e.y < 0 || e.y > 1)
                        switch (this.wrapT) {
                        case ue:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case pe:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case fe:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                        }
                    return this.flipY && (e.y = 1 - e.y),
                    e
                }
                set needsUpdate(e) {
                    !0 === e && (this.version++,
                    this.source.needsUpdate = !0)
                }
                set needsPMREMUpdate(e) {
                    !0 === e && this.pmremVersion++
                }
            }
            jn.DEFAULT_IMAGE = null,
            jn.DEFAULT_MAPPING = 300,
            jn.DEFAULT_ANISOTROPY = 1;
            class Kn {
                constructor(e=0, t=0, n=0, i=1) {
                    Kn.prototype.isVector4 = !0,
                    this.x = e,
                    this.y = t,
                    this.z = n,
                    this.w = i
                }
                get width() {
                    return this.z
                }
                set width(e) {
                    this.z = e
                }
                get height() {
                    return this.w
                }
                set height(e) {
                    this.w = e
                }
                set(e, t, n, i) {
                    return this.x = e,
                    this.y = t,
                    this.z = n,
                    this.w = i,
                    this
                }
                setScalar(e) {
                    return this.x = e,
                    this.y = e,
                    this.z = e,
                    this.w = e,
                    this
                }
                setX(e) {
                    return this.x = e,
                    this
                }
                setY(e) {
                    return this.y = e,
                    this
                }
                setZ(e) {
                    return this.z = e,
                    this
                }
                setW(e) {
                    return this.w = e,
                    this
                }
                setComponent(e, t) {
                    switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                    return this
                }
                getComponent(e) {
                    switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                    }
                }
                clone() {
                    return new this.constructor(this.x,this.y,this.z,this.w)
                }
                copy(e) {
                    return this.x = e.x,
                    this.y = e.y,
                    this.z = e.z,
                    this.w = void 0 !== e.w ? e.w : 1,
                    this
                }
                add(e) {
                    return this.x += e.x,
                    this.y += e.y,
                    this.z += e.z,
                    this.w += e.w,
                    this
                }
                addScalar(e) {
                    return this.x += e,
                    this.y += e,
                    this.z += e,
                    this.w += e,
                    this
                }
                addVectors(e, t) {
                    return this.x = e.x + t.x,
                    this.y = e.y + t.y,
                    this.z = e.z + t.z,
                    this.w = e.w + t.w,
                    this
                }
                addScaledVector(e, t) {
                    return this.x += e.x * t,
                    this.y += e.y * t,
                    this.z += e.z * t,
                    this.w += e.w * t,
                    this
                }
                sub(e) {
                    return this.x -= e.x,
                    this.y -= e.y,
                    this.z -= e.z,
                    this.w -= e.w,
                    this
                }
                subScalar(e) {
                    return this.x -= e,
                    this.y -= e,
                    this.z -= e,
                    this.w -= e,
                    this
                }
                subVectors(e, t) {
                    return this.x = e.x - t.x,
                    this.y = e.y - t.y,
                    this.z = e.z - t.z,
                    this.w = e.w - t.w,
                    this
                }
                multiply(e) {
                    return this.x *= e.x,
                    this.y *= e.y,
                    this.z *= e.z,
                    this.w *= e.w,
                    this
                }
                multiplyScalar(e) {
                    return this.x *= e,
                    this.y *= e,
                    this.z *= e,
                    this.w *= e,
                    this
                }
                applyMatrix4(e) {
                    const t = this.x
                      , n = this.y
                      , i = this.z
                      , r = this.w
                      , a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r,
                    this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r,
                    this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r,
                    this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r,
                    this
                }
                divide(e) {
                    return this.x /= e.x,
                    this.y /= e.y,
                    this.z /= e.z,
                    this.w /= e.w,
                    this
                }
                divideScalar(e) {
                    return this.multiplyScalar(1 / e)
                }
                setAxisAngleFromQuaternion(e) {
                    this.w = 2 * Math.acos(e.w);
                    const t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1,
                    this.y = 0,
                    this.z = 0) : (this.x = e.x / t,
                    this.y = e.y / t,
                    this.z = e.z / t),
                    this
                }
                setAxisAngleFromRotationMatrix(e) {
                    let t, n, i, r;
                    const a = .01
                      , s = .1
                      , o = e.elements
                      , l = o[0]
                      , c = o[4]
                      , h = o[8]
                      , d = o[1]
                      , u = o[5]
                      , p = o[9]
                      , f = o[2]
                      , g = o[6]
                      , m = o[10];
                    if (Math.abs(c - d) < a && Math.abs(h - f) < a && Math.abs(p - g) < a) {
                        if (Math.abs(c + d) < s && Math.abs(h + f) < s && Math.abs(p + g) < s && Math.abs(l + u + m - 3) < s)
                            return this.set(1, 0, 0, 0),
                            this;
                        t = Math.PI;
                        const e = (l + 1) / 2
                          , o = (u + 1) / 2
                          , A = (m + 1) / 2
                          , v = (c + d) / 4
                          , y = (h + f) / 4
                          , w = (p + g) / 4;
                        return e > o && e > A ? e < a ? (n = 0,
                        i = .707106781,
                        r = .707106781) : (n = Math.sqrt(e),
                        i = v / n,
                        r = y / n) : o > A ? o < a ? (n = .707106781,
                        i = 0,
                        r = .707106781) : (i = Math.sqrt(o),
                        n = v / i,
                        r = w / i) : A < a ? (n = .707106781,
                        i = .707106781,
                        r = 0) : (r = Math.sqrt(A),
                        n = y / r,
                        i = w / r),
                        this.set(n, i, r, t),
                        this
                    }
                    let A = Math.sqrt((g - p) * (g - p) + (h - f) * (h - f) + (d - c) * (d - c));
                    return Math.abs(A) < .001 && (A = 1),
                    this.x = (g - p) / A,
                    this.y = (h - f) / A,
                    this.z = (d - c) / A,
                    this.w = Math.acos((l + u + m - 1) / 2),
                    this
                }
                setFromMatrixPosition(e) {
                    const t = e.elements;
                    return this.x = t[12],
                    this.y = t[13],
                    this.z = t[14],
                    this.w = t[15],
                    this
                }
                min(e) {
                    return this.x = Math.min(this.x, e.x),
                    this.y = Math.min(this.y, e.y),
                    this.z = Math.min(this.z, e.z),
                    this.w = Math.min(this.w, e.w),
                    this
                }
                max(e) {
                    return this.x = Math.max(this.x, e.x),
                    this.y = Math.max(this.y, e.y),
                    this.z = Math.max(this.z, e.z),
                    this.w = Math.max(this.w, e.w),
                    this
                }
                clamp(e, t) {
                    return this.x = yn(this.x, e.x, t.x),
                    this.y = yn(this.y, e.y, t.y),
                    this.z = yn(this.z, e.z, t.z),
                    this.w = yn(this.w, e.w, t.w),
                    this
                }
                clampScalar(e, t) {
                    return this.x = yn(this.x, e, t),
                    this.y = yn(this.y, e, t),
                    this.z = yn(this.z, e, t),
                    this.w = yn(this.w, e, t),
                    this
                }
                clampLength(e, t) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(yn(n, e, t))
                }
                floor() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this.z = Math.floor(this.z),
                    this.w = Math.floor(this.w),
                    this
                }
                ceil() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this.z = Math.ceil(this.z),
                    this.w = Math.ceil(this.w),
                    this
                }
                round() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this.z = Math.round(this.z),
                    this.w = Math.round(this.w),
                    this
                }
                roundToZero() {
                    return this.x = Math.trunc(this.x),
                    this.y = Math.trunc(this.y),
                    this.z = Math.trunc(this.z),
                    this.w = Math.trunc(this.w),
                    this
                }
                negate() {
                    return this.x = -this.x,
                    this.y = -this.y,
                    this.z = -this.z,
                    this.w = -this.w,
                    this
                }
                dot(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(e) {
                    return this.normalize().multiplyScalar(e)
                }
                lerp(e, t) {
                    return this.x += (e.x - this.x) * t,
                    this.y += (e.y - this.y) * t,
                    this.z += (e.z - this.z) * t,
                    this.w += (e.w - this.w) * t,
                    this
                }
                lerpVectors(e, t, n) {
                    return this.x = e.x + (t.x - e.x) * n,
                    this.y = e.y + (t.y - e.y) * n,
                    this.z = e.z + (t.z - e.z) * n,
                    this.w = e.w + (t.w - e.w) * n,
                    this
                }
                equals(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                }
                fromArray(e, t=0) {
                    return this.x = e[t],
                    this.y = e[t + 1],
                    this.z = e[t + 2],
                    this.w = e[t + 3],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.x,
                    e[t + 1] = this.y,
                    e[t + 2] = this.z,
                    e[t + 3] = this.w,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.x = e.getX(t),
                    this.y = e.getY(t),
                    this.z = e.getZ(t),
                    this.w = e.getW(t),
                    this
                }
                random() {
                    return this.x = Math.random(),
                    this.y = Math.random(),
                    this.z = Math.random(),
                    this.w = Math.random(),
                    this
                }
                *[Symbol.iterator]() {
                    yield this.x,
                    yield this.y,
                    yield this.z,
                    yield this.w
                }
            }
            class qn extends pn {
                constructor(e=1, t=1, n={}) {
                    super(),
                    n = Object.assign({
                        generateMipmaps: !1,
                        internalFormat: null,
                        minFilter: ve,
                        depthBuffer: !0,
                        stencilBuffer: !1,
                        resolveDepthBuffer: !0,
                        resolveStencilBuffer: !0,
                        depthTexture: null,
                        samples: 0,
                        count: 1,
                        depth: 1,
                        multiview: !1
                    }, n),
                    this.isRenderTarget = !0,
                    this.width = e,
                    this.height = t,
                    this.depth = n.depth,
                    this.scissor = new Kn(0,0,e,t),
                    this.scissorTest = !1,
                    this.viewport = new Kn(0,0,e,t);
                    const i = {
                        width: e,
                        height: t,
                        depth: n.depth
                    }
                      , r = new jn(i);
                    this.textures = [];
                    const a = n.count;
                    for (let e = 0; e < a; e++)
                        this.textures[e] = r.clone(),
                        this.textures[e].isRenderTargetTexture = !0,
                        this.textures[e].renderTarget = this;
                    this._setTextureOptions(n),
                    this.depthBuffer = n.depthBuffer,
                    this.stencilBuffer = n.stencilBuffer,
                    this.resolveDepthBuffer = n.resolveDepthBuffer,
                    this.resolveStencilBuffer = n.resolveStencilBuffer,
                    this._depthTexture = null,
                    this.depthTexture = n.depthTexture,
                    this.samples = n.samples,
                    this.multiview = n.multiview
                }
                _setTextureOptions(e={}) {
                    const t = {
                        minFilter: ve,
                        generateMipmaps: !1,
                        flipY: !1,
                        internalFormat: null
                    };
                    void 0 !== e.mapping && (t.mapping = e.mapping),
                    void 0 !== e.wrapS && (t.wrapS = e.wrapS),
                    void 0 !== e.wrapT && (t.wrapT = e.wrapT),
                    void 0 !== e.wrapR && (t.wrapR = e.wrapR),
                    void 0 !== e.magFilter && (t.magFilter = e.magFilter),
                    void 0 !== e.minFilter && (t.minFilter = e.minFilter),
                    void 0 !== e.format && (t.format = e.format),
                    void 0 !== e.type && (t.type = e.type),
                    void 0 !== e.anisotropy && (t.anisotropy = e.anisotropy),
                    void 0 !== e.colorSpace && (t.colorSpace = e.colorSpace),
                    void 0 !== e.flipY && (t.flipY = e.flipY),
                    void 0 !== e.generateMipmaps && (t.generateMipmaps = e.generateMipmaps),
                    void 0 !== e.internalFormat && (t.internalFormat = e.internalFormat);
                    for (let e = 0; e < this.textures.length; e++) {
                        this.textures[e].setValues(t)
                    }
                }
                get texture() {
                    return this.textures[0]
                }
                set texture(e) {
                    this.textures[0] = e
                }
                set depthTexture(e) {
                    null !== this._depthTexture && (this._depthTexture.renderTarget = null),
                    null !== e && (e.renderTarget = this),
                    this._depthTexture = e
                }
                get depthTexture() {
                    return this._depthTexture
                }
                setSize(e, t, n=1) {
                    if (this.width !== e || this.height !== t || this.depth !== n) {
                        this.width = e,
                        this.height = t,
                        this.depth = n;
                        for (let i = 0, r = this.textures.length; i < r; i++)
                            this.textures[i].image.width = e,
                            this.textures[i].image.height = t,
                            this.textures[i].image.depth = n,
                            !0 !== this.textures[i].isData3DTexture && (this.textures[i].isArrayTexture = this.textures[i].image.depth > 1);
                        this.dispose()
                    }
                    this.viewport.set(0, 0, e, t),
                    this.scissor.set(0, 0, e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.width = e.width,
                    this.height = e.height,
                    this.depth = e.depth,
                    this.scissor.copy(e.scissor),
                    this.scissorTest = e.scissorTest,
                    this.viewport.copy(e.viewport),
                    this.textures.length = 0;
                    for (let t = 0, n = e.textures.length; t < n; t++) {
                        this.textures[t] = e.textures[t].clone(),
                        this.textures[t].isRenderTargetTexture = !0,
                        this.textures[t].renderTarget = this;
                        const n = Object.assign({}, e.textures[t].image);
                        this.textures[t].source = new On(n)
                    }
                    return this.depthBuffer = e.depthBuffer,
                    this.stencilBuffer = e.stencilBuffer,
                    this.resolveDepthBuffer = e.resolveDepthBuffer,
                    this.resolveStencilBuffer = e.resolveStencilBuffer,
                    null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                    this.samples = e.samples,
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            class Qn extends qn {
                constructor(e=1, t=1, n={}) {
                    super(e, t, n),
                    this.isWebGLRenderTarget = !0
                }
            }
            class Jn extends jn {
                constructor(e=null, t=1, n=1, i=1) {
                    super(null),
                    this.isDataArrayTexture = !0,
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    },
                    this.magFilter = ge,
                    this.minFilter = ge,
                    this.wrapR = pe,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1,
                    this.layerUpdates = new Set
                }
                addLayerUpdate(e) {
                    this.layerUpdates.add(e)
                }
                clearLayerUpdates() {
                    this.layerUpdates.clear()
                }
            }
            class Xn extends jn {
                constructor(e=null, t=1, n=1, i=1) {
                    super(null),
                    this.isData3DTexture = !0,
                    this.image = {
                        data: e,
                        width: t,
                        height: n,
                        depth: i
                    },
                    this.magFilter = ge,
                    this.minFilter = ge,
                    this.wrapR = pe,
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1
                }
            }
            class Yn {
                constructor(e=new Mn(1 / 0,1 / 0,1 / 0), t=new Mn(-1 / 0,-1 / 0,-1 / 0)) {
                    this.isBox3 = !0,
                    this.min = e,
                    this.max = t
                }
                set(e, t) {
                    return this.min.copy(e),
                    this.max.copy(t),
                    this
                }
                setFromArray(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t += 3)
                        this.expandByPoint($n.fromArray(e, t));
                    return this
                }
                setFromBufferAttribute(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.count; t < n; t++)
                        this.expandByPoint($n.fromBufferAttribute(e, t));
                    return this
                }
                setFromPoints(e) {
                    this.makeEmpty();
                    for (let t = 0, n = e.length; t < n; t++)
                        this.expandByPoint(e[t]);
                    return this
                }
                setFromCenterAndSize(e, t) {
                    const n = $n.copy(t).multiplyScalar(.5);
                    return this.min.copy(e).sub(n),
                    this.max.copy(e).add(n),
                    this
                }
                setFromObject(e, t=!1) {
                    return this.makeEmpty(),
                    this.expandByObject(e, t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.min.copy(e.min),
                    this.max.copy(e.max),
                    this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0,
                    this.max.x = this.max.y = this.max.z = -1 / 0,
                    this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(e) {
                    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                }
                expandByPoint(e) {
                    return this.min.min(e),
                    this.max.max(e),
                    this
                }
                expandByVector(e) {
                    return this.min.sub(e),
                    this.max.add(e),
                    this
                }
                expandByScalar(e) {
                    return this.min.addScalar(-e),
                    this.max.addScalar(e),
                    this
                }
                expandByObject(e, t=!1) {
                    e.updateWorldMatrix(!1, !1);
                    const n = e.geometry;
                    if (void 0 !== n) {
                        const i = n.getAttribute("position");
                        if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                            for (let t = 0, n = i.count; t < n; t++)
                                !0 === e.isMesh ? e.getVertexPosition(t, $n) : $n.fromBufferAttribute(i, t),
                                $n.applyMatrix4(e.matrixWorld),
                                this.expandByPoint($n);
                        else
                            void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                            ei.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                            ei.copy(n.boundingBox)),
                            ei.applyMatrix4(e.matrixWorld),
                            this.union(ei)
                    }
                    const i = e.children;
                    for (let e = 0, n = i.length; e < n; e++)
                        this.expandByObject(i[e], t);
                    return this
                }
                containsPoint(e) {
                    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
                }
                containsBox(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                }
                getParameter(e, t) {
                    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(e) {
                    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
                }
                intersectsSphere(e) {
                    return this.clampPoint(e.center, $n),
                    $n.distanceToSquared(e.center) <= e.radius * e.radius
                }
                intersectsPlane(e) {
                    let t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                    n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                    n = e.normal.x * this.min.x),
                    e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                    n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                    n += e.normal.y * this.min.y),
                    e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                    n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                    n += e.normal.z * this.min.z),
                    t <= -e.constant && n >= -e.constant
                }
                intersectsTriangle(e) {
                    if (this.isEmpty())
                        return !1;
                    this.getCenter(oi),
                    li.subVectors(this.max, oi),
                    ti.subVectors(e.a, oi),
                    ni.subVectors(e.b, oi),
                    ii.subVectors(e.c, oi),
                    ri.subVectors(ni, ti),
                    ai.subVectors(ii, ni),
                    si.subVectors(ti, ii);
                    let t = [0, -ri.z, ri.y, 0, -ai.z, ai.y, 0, -si.z, si.y, ri.z, 0, -ri.x, ai.z, 0, -ai.x, si.z, 0, -si.x, -ri.y, ri.x, 0, -ai.y, ai.x, 0, -si.y, si.x, 0];
                    return !!di(t, ti, ni, ii, li) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                    !!di(t, ti, ni, ii, li) && (ci.crossVectors(ri, ai),
                    t = [ci.x, ci.y, ci.z],
                    di(t, ti, ni, ii, li)))
                }
                clampPoint(e, t) {
                    return t.copy(e).clamp(this.min, this.max)
                }
                distanceToPoint(e) {
                    return this.clampPoint(e, $n).distanceTo(e)
                }
                getBoundingSphere(e) {
                    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                    e.radius = .5 * this.getSize($n).length()),
                    e
                }
                intersect(e) {
                    return this.min.max(e.min),
                    this.max.min(e.max),
                    this.isEmpty() && this.makeEmpty(),
                    this
                }
                union(e) {
                    return this.min.min(e.min),
                    this.max.max(e.max),
                    this
                }
                applyMatrix4(e) {
                    return this.isEmpty() || (Zn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                    Zn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                    Zn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                    Zn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                    Zn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                    Zn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                    Zn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                    Zn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                    this.setFromPoints(Zn)),
                    this
                }
                translate(e) {
                    return this.min.add(e),
                    this.max.add(e),
                    this
                }
                equals(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
                toJSON() {
                    return {
                        min: this.min.toArray(),
                        max: this.max.toArray()
                    }
                }
                fromJSON(e) {
                    return this.min.fromArray(e.min),
                    this.max.fromArray(e.max),
                    this
                }
            }
            const Zn = [new Mn, new Mn, new Mn, new Mn, new Mn, new Mn, new Mn, new Mn]
              , $n = new Mn
              , ei = new Yn
              , ti = new Mn
              , ni = new Mn
              , ii = new Mn
              , ri = new Mn
              , ai = new Mn
              , si = new Mn
              , oi = new Mn
              , li = new Mn
              , ci = new Mn
              , hi = new Mn;
            function di(e, t, n, i, r) {
                for (let a = 0, s = e.length - 3; a <= s; a += 3) {
                    hi.fromArray(e, a);
                    const s = r.x * Math.abs(hi.x) + r.y * Math.abs(hi.y) + r.z * Math.abs(hi.z)
                      , o = t.dot(hi)
                      , l = n.dot(hi)
                      , c = i.dot(hi);
                    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s)
                        return !1
                }
                return !0
            }
            const ui = new Yn
              , pi = new Mn
              , fi = new Mn;
            class gi {
                constructor(e=new Mn, t=-1) {
                    this.isSphere = !0,
                    this.center = e,
                    this.radius = t
                }
                set(e, t) {
                    return this.center.copy(e),
                    this.radius = t,
                    this
                }
                setFromPoints(e, t) {
                    const n = this.center;
                    void 0 !== t ? n.copy(t) : ui.setFromPoints(e).getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.length; t < r; t++)
                        i = Math.max(i, n.distanceToSquared(e[t]));
                    return this.radius = Math.sqrt(i),
                    this
                }
                copy(e) {
                    return this.center.copy(e.center),
                    this.radius = e.radius,
                    this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0),
                    this.radius = -1,
                    this
                }
                containsPoint(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(e) {
                    return e.distanceTo(this.center) - this.radius
                }
                intersectsSphere(e) {
                    const t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                }
                intersectsBox(e) {
                    return e.intersectsSphere(this)
                }
                intersectsPlane(e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(e, t) {
                    const n = this.center.distanceToSquared(e);
                    return t.copy(e),
                    n > this.radius * this.radius && (t.sub(this.center).normalize(),
                    t.multiplyScalar(this.radius).add(this.center)),
                    t
                }
                getBoundingBox(e) {
                    return this.isEmpty() ? (e.makeEmpty(),
                    e) : (e.set(this.center, this.center),
                    e.expandByScalar(this.radius),
                    e)
                }
                applyMatrix4(e) {
                    return this.center.applyMatrix4(e),
                    this.radius = this.radius * e.getMaxScaleOnAxis(),
                    this
                }
                translate(e) {
                    return this.center.add(e),
                    this
                }
                expandByPoint(e) {
                    if (this.isEmpty())
                        return this.center.copy(e),
                        this.radius = 0,
                        this;
                    pi.subVectors(e, this.center);
                    const t = pi.lengthSq();
                    if (t > this.radius * this.radius) {
                        const e = Math.sqrt(t)
                          , n = .5 * (e - this.radius);
                        this.center.addScaledVector(pi, n / e),
                        this.radius += n
                    }
                    return this
                }
                union(e) {
                    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                    this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (fi.subVectors(e.center, this.center).setLength(e.radius),
                    this.expandByPoint(pi.copy(e.center).add(fi)),
                    this.expandByPoint(pi.copy(e.center).sub(fi))),
                    this)
                }
                equals(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    return {
                        radius: this.radius,
                        center: this.center.toArray()
                    }
                }
                fromJSON(e) {
                    return this.radius = e.radius,
                    this.center.fromArray(e.center),
                    this
                }
            }
            const mi = new Mn
              , Ai = new Mn
              , vi = new Mn
              , yi = new Mn
              , wi = new Mn
              , bi = new Mn
              , xi = new Mn;
            class Si {
                constructor(e=new Mn, t=new Mn(0,0,-1)) {
                    this.origin = e,
                    this.direction = t
                }
                set(e, t) {
                    return this.origin.copy(e),
                    this.direction.copy(t),
                    this
                }
                copy(e) {
                    return this.origin.copy(e.origin),
                    this.direction.copy(e.direction),
                    this
                }
                at(e, t) {
                    return t.copy(this.origin).addScaledVector(this.direction, e)
                }
                lookAt(e) {
                    return this.direction.copy(e).sub(this.origin).normalize(),
                    this
                }
                recast(e) {
                    return this.origin.copy(this.at(e, mi)),
                    this
                }
                closestPointToPoint(e, t) {
                    t.subVectors(e, this.origin);
                    const n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                }
                distanceToPoint(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                }
                distanceSqToPoint(e) {
                    const t = mi.subVectors(e, this.origin).dot(this.direction);
                    return t < 0 ? this.origin.distanceToSquared(e) : (mi.copy(this.origin).addScaledVector(this.direction, t),
                    mi.distanceToSquared(e))
                }
                distanceSqToSegment(e, t, n, i) {
                    Ai.copy(e).add(t).multiplyScalar(.5),
                    vi.copy(t).sub(e).normalize(),
                    yi.copy(this.origin).sub(Ai);
                    const r = .5 * e.distanceTo(t)
                      , a = -this.direction.dot(vi)
                      , s = yi.dot(this.direction)
                      , o = -yi.dot(vi)
                      , l = yi.lengthSq()
                      , c = Math.abs(1 - a * a);
                    let h, d, u, p;
                    if (c > 0)
                        if (h = a * o - s,
                        d = a * s - o,
                        p = r * c,
                        h >= 0)
                            if (d >= -p)
                                if (d <= p) {
                                    const e = 1 / c;
                                    h *= e,
                                    d *= e,
                                    u = h * (h + a * d + 2 * s) + d * (a * h + d + 2 * o) + l
                                } else
                                    d = r,
                                    h = Math.max(0, -(a * d + s)),
                                    u = -h * h + d * (d + 2 * o) + l;
                            else
                                d = -r,
                                h = Math.max(0, -(a * d + s)),
                                u = -h * h + d * (d + 2 * o) + l;
                        else
                            d <= -p ? (h = Math.max(0, -(-a * r + s)),
                            d = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                            u = -h * h + d * (d + 2 * o) + l) : d <= p ? (h = 0,
                            d = Math.min(Math.max(-r, -o), r),
                            u = d * (d + 2 * o) + l) : (h = Math.max(0, -(a * r + s)),
                            d = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                            u = -h * h + d * (d + 2 * o) + l);
                    else
                        d = a > 0 ? -r : r,
                        h = Math.max(0, -(a * d + s)),
                        u = -h * h + d * (d + 2 * o) + l;
                    return n && n.copy(this.origin).addScaledVector(this.direction, h),
                    i && i.copy(Ai).addScaledVector(vi, d),
                    u
                }
                intersectSphere(e, t) {
                    mi.subVectors(e.center, this.origin);
                    const n = mi.dot(this.direction)
                      , i = mi.dot(mi) - n * n
                      , r = e.radius * e.radius;
                    if (i > r)
                        return null;
                    const a = Math.sqrt(r - i)
                      , s = n - a
                      , o = n + a;
                    return o < 0 ? null : s < 0 ? this.at(o, t) : this.at(s, t)
                }
                intersectsSphere(e) {
                    return !(e.radius < 0) && this.distanceSqToPoint(e.center) <= e.radius * e.radius
                }
                distanceToPlane(e) {
                    const t = e.normal.dot(this.direction);
                    if (0 === t)
                        return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                }
                intersectPlane(e, t) {
                    const n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                }
                intersectsPlane(e) {
                    const t = e.distanceToPoint(this.origin);
                    if (0 === t)
                        return !0;
                    return e.normal.dot(this.direction) * t < 0
                }
                intersectBox(e, t) {
                    let n, i, r, a, s, o;
                    const l = 1 / this.direction.x
                      , c = 1 / this.direction.y
                      , h = 1 / this.direction.z
                      , d = this.origin;
                    return l >= 0 ? (n = (e.min.x - d.x) * l,
                    i = (e.max.x - d.x) * l) : (n = (e.max.x - d.x) * l,
                    i = (e.min.x - d.x) * l),
                    c >= 0 ? (r = (e.min.y - d.y) * c,
                    a = (e.max.y - d.y) * c) : (r = (e.max.y - d.y) * c,
                    a = (e.min.y - d.y) * c),
                    n > a || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                    (a < i || isNaN(i)) && (i = a),
                    h >= 0 ? (s = (e.min.z - d.z) * h,
                    o = (e.max.z - d.z) * h) : (s = (e.max.z - d.z) * h,
                    o = (e.min.z - d.z) * h),
                    n > o || s > i ? null : ((s > n || n != n) && (n = s),
                    (o < i || i != i) && (i = o),
                    i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                }
                intersectsBox(e) {
                    return null !== this.intersectBox(e, mi)
                }
                intersectTriangle(e, t, n, i, r) {
                    wi.subVectors(t, e),
                    bi.subVectors(n, e),
                    xi.crossVectors(wi, bi);
                    let a, s = this.direction.dot(xi);
                    if (s > 0) {
                        if (i)
                            return null;
                        a = 1
                    } else {
                        if (!(s < 0))
                            return null;
                        a = -1,
                        s = -s
                    }
                    yi.subVectors(this.origin, e);
                    const o = a * this.direction.dot(bi.crossVectors(yi, bi));
                    if (o < 0)
                        return null;
                    const l = a * this.direction.dot(wi.cross(yi));
                    if (l < 0)
                        return null;
                    if (o + l > s)
                        return null;
                    const c = -a * yi.dot(xi);
                    return c < 0 ? null : this.at(c / s, r)
                }
                applyMatrix4(e) {
                    return this.origin.applyMatrix4(e),
                    this.direction.transformDirection(e),
                    this
                }
                equals(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Ei {
                constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g) {
                    Ei.prototype.isMatrix4 = !0,
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                    void 0 !== e && this.set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g)
                }
                set(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g) {
                    const m = this.elements;
                    return m[0] = e,
                    m[4] = t,
                    m[8] = n,
                    m[12] = i,
                    m[1] = r,
                    m[5] = a,
                    m[9] = s,
                    m[13] = o,
                    m[2] = l,
                    m[6] = c,
                    m[10] = h,
                    m[14] = d,
                    m[3] = u,
                    m[7] = p,
                    m[11] = f,
                    m[15] = g,
                    this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                }
                clone() {
                    return (new Ei).fromArray(this.elements)
                }
                copy(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[0] = n[0],
                    t[1] = n[1],
                    t[2] = n[2],
                    t[3] = n[3],
                    t[4] = n[4],
                    t[5] = n[5],
                    t[6] = n[6],
                    t[7] = n[7],
                    t[8] = n[8],
                    t[9] = n[9],
                    t[10] = n[10],
                    t[11] = n[11],
                    t[12] = n[12],
                    t[13] = n[13],
                    t[14] = n[14],
                    t[15] = n[15],
                    this
                }
                copyPosition(e) {
                    const t = this.elements
                      , n = e.elements;
                    return t[12] = n[12],
                    t[13] = n[13],
                    t[14] = n[14],
                    this
                }
                setFromMatrix3(e) {
                    const t = e.elements;
                    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                    this
                }
                extractBasis(e, t, n) {
                    return 0 === this.determinant() ? (e.set(1, 0, 0),
                    t.set(0, 1, 0),
                    n.set(0, 0, 1),
                    this) : (e.setFromMatrixColumn(this, 0),
                    t.setFromMatrixColumn(this, 1),
                    n.setFromMatrixColumn(this, 2),
                    this)
                }
                makeBasis(e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                    this
                }
                extractRotation(e) {
                    if (0 === e.determinant())
                        return this.identity();
                    const t = this.elements
                      , n = e.elements
                      , i = 1 / Ti.setFromMatrixColumn(e, 0).length()
                      , r = 1 / Ti.setFromMatrixColumn(e, 1).length()
                      , a = 1 / Ti.setFromMatrixColumn(e, 2).length();
                    return t[0] = n[0] * i,
                    t[1] = n[1] * i,
                    t[2] = n[2] * i,
                    t[3] = 0,
                    t[4] = n[4] * r,
                    t[5] = n[5] * r,
                    t[6] = n[6] * r,
                    t[7] = 0,
                    t[8] = n[8] * a,
                    t[9] = n[9] * a,
                    t[10] = n[10] * a,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    this
                }
                makeRotationFromEuler(e) {
                    const t = this.elements
                      , n = e.x
                      , i = e.y
                      , r = e.z
                      , a = Math.cos(n)
                      , s = Math.sin(n)
                      , o = Math.cos(i)
                      , l = Math.sin(i)
                      , c = Math.cos(r)
                      , h = Math.sin(r);
                    if ("XYZ" === e.order) {
                        const e = a * c
                          , n = a * h
                          , i = s * c
                          , r = s * h;
                        t[0] = o * c,
                        t[4] = -o * h,
                        t[8] = l,
                        t[1] = n + i * l,
                        t[5] = e - r * l,
                        t[9] = -s * o,
                        t[2] = r - e * l,
                        t[6] = i + n * l,
                        t[10] = a * o
                    } else if ("YXZ" === e.order) {
                        const e = o * c
                          , n = o * h
                          , i = l * c
                          , r = l * h;
                        t[0] = e + r * s,
                        t[4] = i * s - n,
                        t[8] = a * l,
                        t[1] = a * h,
                        t[5] = a * c,
                        t[9] = -s,
                        t[2] = n * s - i,
                        t[6] = r + e * s,
                        t[10] = a * o
                    } else if ("ZXY" === e.order) {
                        const e = o * c
                          , n = o * h
                          , i = l * c
                          , r = l * h;
                        t[0] = e - r * s,
                        t[4] = -a * h,
                        t[8] = i + n * s,
                        t[1] = n + i * s,
                        t[5] = a * c,
                        t[9] = r - e * s,
                        t[2] = -a * l,
                        t[6] = s,
                        t[10] = a * o
                    } else if ("ZYX" === e.order) {
                        const e = a * c
                          , n = a * h
                          , i = s * c
                          , r = s * h;
                        t[0] = o * c,
                        t[4] = i * l - n,
                        t[8] = e * l + r,
                        t[1] = o * h,
                        t[5] = r * l + e,
                        t[9] = n * l - i,
                        t[2] = -l,
                        t[6] = s * o,
                        t[10] = a * o
                    } else if ("YZX" === e.order) {
                        const e = a * o
                          , n = a * l
                          , i = s * o
                          , r = s * l;
                        t[0] = o * c,
                        t[4] = r - e * h,
                        t[8] = i * h + n,
                        t[1] = h,
                        t[5] = a * c,
                        t[9] = -s * c,
                        t[2] = -l * c,
                        t[6] = n * h + i,
                        t[10] = e - r * h
                    } else if ("XZY" === e.order) {
                        const e = a * o
                          , n = a * l
                          , i = s * o
                          , r = s * l;
                        t[0] = o * c,
                        t[4] = -h,
                        t[8] = l * c,
                        t[1] = e * h + r,
                        t[5] = a * c,
                        t[9] = n * h - i,
                        t[2] = i * h - n,
                        t[6] = s * c,
                        t[10] = r * h + e
                    }
                    return t[3] = 0,
                    t[7] = 0,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    this
                }
                makeRotationFromQuaternion(e) {
                    return this.compose(Mi, e, _i)
                }
                lookAt(e, t, n) {
                    const i = this.elements;
                    return Pi.subVectors(e, t),
                    0 === Pi.lengthSq() && (Pi.z = 1),
                    Pi.normalize(),
                    Ci.crossVectors(n, Pi),
                    0 === Ci.lengthSq() && (1 === Math.abs(n.z) ? Pi.x += 1e-4 : Pi.z += 1e-4,
                    Pi.normalize(),
                    Ci.crossVectors(n, Pi)),
                    Ci.normalize(),
                    Ri.crossVectors(Pi, Ci),
                    i[0] = Ci.x,
                    i[4] = Ri.x,
                    i[8] = Pi.x,
                    i[1] = Ci.y,
                    i[5] = Ri.y,
                    i[9] = Pi.y,
                    i[2] = Ci.z,
                    i[6] = Ri.z,
                    i[10] = Pi.z,
                    this
                }
                multiply(e) {
                    return this.multiplyMatrices(this, e)
                }
                premultiply(e) {
                    return this.multiplyMatrices(e, this)
                }
                multiplyMatrices(e, t) {
                    const n = e.elements
                      , i = t.elements
                      , r = this.elements
                      , a = n[0]
                      , s = n[4]
                      , o = n[8]
                      , l = n[12]
                      , c = n[1]
                      , h = n[5]
                      , d = n[9]
                      , u = n[13]
                      , p = n[2]
                      , f = n[6]
                      , g = n[10]
                      , m = n[14]
                      , A = n[3]
                      , v = n[7]
                      , y = n[11]
                      , w = n[15]
                      , b = i[0]
                      , x = i[4]
                      , S = i[8]
                      , E = i[12]
                      , T = i[1]
                      , k = i[5]
                      , M = i[9]
                      , _ = i[13]
                      , C = i[2]
                      , R = i[6]
                      , P = i[10]
                      , I = i[14]
                      , L = i[3]
                      , N = i[7]
                      , z = i[11]
                      , U = i[15];
                    return r[0] = a * b + s * T + o * C + l * L,
                    r[4] = a * x + s * k + o * R + l * N,
                    r[8] = a * S + s * M + o * P + l * z,
                    r[12] = a * E + s * _ + o * I + l * U,
                    r[1] = c * b + h * T + d * C + u * L,
                    r[5] = c * x + h * k + d * R + u * N,
                    r[9] = c * S + h * M + d * P + u * z,
                    r[13] = c * E + h * _ + d * I + u * U,
                    r[2] = p * b + f * T + g * C + m * L,
                    r[6] = p * x + f * k + g * R + m * N,
                    r[10] = p * S + f * M + g * P + m * z,
                    r[14] = p * E + f * _ + g * I + m * U,
                    r[3] = A * b + v * T + y * C + w * L,
                    r[7] = A * x + v * k + y * R + w * N,
                    r[11] = A * S + v * M + y * P + w * z,
                    r[15] = A * E + v * _ + y * I + w * U,
                    this
                }
                multiplyScalar(e) {
                    const t = this.elements;
                    return t[0] *= e,
                    t[4] *= e,
                    t[8] *= e,
                    t[12] *= e,
                    t[1] *= e,
                    t[5] *= e,
                    t[9] *= e,
                    t[13] *= e,
                    t[2] *= e,
                    t[6] *= e,
                    t[10] *= e,
                    t[14] *= e,
                    t[3] *= e,
                    t[7] *= e,
                    t[11] *= e,
                    t[15] *= e,
                    this
                }
                determinant() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[4]
                      , i = e[8]
                      , r = e[12]
                      , a = e[1]
                      , s = e[5]
                      , o = e[9]
                      , l = e[13]
                      , c = e[2]
                      , h = e[6]
                      , d = e[10]
                      , u = e[14]
                      , p = e[3]
                      , f = e[7]
                      , g = e[11]
                      , m = e[15]
                      , A = o * u - l * d
                      , v = s * u - l * h
                      , y = s * d - o * h
                      , w = a * u - l * c
                      , b = a * d - o * c
                      , x = a * h - s * c;
                    return t * (f * A - g * v + m * y) - n * (p * A - g * w + m * b) + i * (p * v - f * w + m * x) - r * (p * y - f * b + g * x)
                }
                transpose() {
                    const e = this.elements;
                    let t;
                    return t = e[1],
                    e[1] = e[4],
                    e[4] = t,
                    t = e[2],
                    e[2] = e[8],
                    e[8] = t,
                    t = e[6],
                    e[6] = e[9],
                    e[9] = t,
                    t = e[3],
                    e[3] = e[12],
                    e[12] = t,
                    t = e[7],
                    e[7] = e[13],
                    e[13] = t,
                    t = e[11],
                    e[11] = e[14],
                    e[14] = t,
                    this
                }
                setPosition(e, t, n) {
                    const i = this.elements;
                    return e.isVector3 ? (i[12] = e.x,
                    i[13] = e.y,
                    i[14] = e.z) : (i[12] = e,
                    i[13] = t,
                    i[14] = n),
                    this
                }
                invert() {
                    const e = this.elements
                      , t = e[0]
                      , n = e[1]
                      , i = e[2]
                      , r = e[3]
                      , a = e[4]
                      , s = e[5]
                      , o = e[6]
                      , l = e[7]
                      , c = e[8]
                      , h = e[9]
                      , d = e[10]
                      , u = e[11]
                      , p = e[12]
                      , f = e[13]
                      , g = e[14]
                      , m = e[15]
                      , A = h * g * l - f * d * l + f * o * u - s * g * u - h * o * m + s * d * m
                      , v = p * d * l - c * g * l - p * o * u + a * g * u + c * o * m - a * d * m
                      , y = c * f * l - p * h * l + p * s * u - a * f * u - c * s * m + a * h * m
                      , w = p * h * o - c * f * o - p * s * d + a * f * d + c * s * g - a * h * g
                      , b = t * A + n * v + i * y + r * w;
                    if (0 === b)
                        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const x = 1 / b;
                    return e[0] = A * x,
                    e[1] = (f * d * r - h * g * r - f * i * u + n * g * u + h * i * m - n * d * m) * x,
                    e[2] = (s * g * r - f * o * r + f * i * l - n * g * l - s * i * m + n * o * m) * x,
                    e[3] = (h * o * r - s * d * r - h * i * l + n * d * l + s * i * u - n * o * u) * x,
                    e[4] = v * x,
                    e[5] = (c * g * r - p * d * r + p * i * u - t * g * u - c * i * m + t * d * m) * x,
                    e[6] = (p * o * r - a * g * r - p * i * l + t * g * l + a * i * m - t * o * m) * x,
                    e[7] = (a * d * r - c * o * r + c * i * l - t * d * l - a * i * u + t * o * u) * x,
                    e[8] = y * x,
                    e[9] = (p * h * r - c * f * r - p * n * u + t * f * u + c * n * m - t * h * m) * x,
                    e[10] = (a * f * r - p * s * r + p * n * l - t * f * l - a * n * m + t * s * m) * x,
                    e[11] = (c * s * r - a * h * r - c * n * l + t * h * l + a * n * u - t * s * u) * x,
                    e[12] = w * x,
                    e[13] = (c * f * i - p * h * i + p * n * d - t * f * d - c * n * g + t * h * g) * x,
                    e[14] = (p * s * i - a * f * i - p * n * o + t * f * o + a * n * g - t * s * g) * x,
                    e[15] = (a * h * i - c * s * i + c * n * o - t * h * o - a * n * d + t * s * d) * x,
                    this
                }
                scale(e) {
                    const t = this.elements
                      , n = e.x
                      , i = e.y
                      , r = e.z;
                    return t[0] *= n,
                    t[4] *= i,
                    t[8] *= r,
                    t[1] *= n,
                    t[5] *= i,
                    t[9] *= r,
                    t[2] *= n,
                    t[6] *= i,
                    t[10] *= r,
                    t[3] *= n,
                    t[7] *= i,
                    t[11] *= r,
                    this
                }
                getMaxScaleOnAxis() {
                    const e = this.elements
                      , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                      , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                      , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                }
                makeTranslation(e, t, n) {
                    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                    this
                }
                makeRotationX(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationY(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationZ(e) {
                    const t = Math.cos(e)
                      , n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                    this
                }
                makeRotationAxis(e, t) {
                    const n = Math.cos(t)
                      , i = Math.sin(t)
                      , r = 1 - n
                      , a = e.x
                      , s = e.y
                      , o = e.z
                      , l = r * a
                      , c = r * s;
                    return this.set(l * a + n, l * s - i * o, l * o + i * s, 0, l * s + i * o, c * s + n, c * o - i * a, 0, l * o - i * s, c * o + i * a, r * o * o + n, 0, 0, 0, 0, 1),
                    this
                }
                makeScale(e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                    this
                }
                makeShear(e, t, n, i, r, a) {
                    return this.set(1, n, r, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1),
                    this
                }
                compose(e, t, n) {
                    const i = this.elements
                      , r = t._x
                      , a = t._y
                      , s = t._z
                      , o = t._w
                      , l = r + r
                      , c = a + a
                      , h = s + s
                      , d = r * l
                      , u = r * c
                      , p = r * h
                      , f = a * c
                      , g = a * h
                      , m = s * h
                      , A = o * l
                      , v = o * c
                      , y = o * h
                      , w = n.x
                      , b = n.y
                      , x = n.z;
                    return i[0] = (1 - (f + m)) * w,
                    i[1] = (u + y) * w,
                    i[2] = (p - v) * w,
                    i[3] = 0,
                    i[4] = (u - y) * b,
                    i[5] = (1 - (d + m)) * b,
                    i[6] = (g + A) * b,
                    i[7] = 0,
                    i[8] = (p + v) * x,
                    i[9] = (g - A) * x,
                    i[10] = (1 - (d + f)) * x,
                    i[11] = 0,
                    i[12] = e.x,
                    i[13] = e.y,
                    i[14] = e.z,
                    i[15] = 1,
                    this
                }
                decompose(e, t, n) {
                    const i = this.elements;
                    if (e.x = i[12],
                    e.y = i[13],
                    e.z = i[14],
                    0 === this.determinant())
                        return n.set(1, 1, 1),
                        t.identity(),
                        this;
                    let r = Ti.set(i[0], i[1], i[2]).length();
                    const a = Ti.set(i[4], i[5], i[6]).length()
                      , s = Ti.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r),
                    ki.copy(this);
                    const o = 1 / r
                      , l = 1 / a
                      , c = 1 / s;
                    return ki.elements[0] *= o,
                    ki.elements[1] *= o,
                    ki.elements[2] *= o,
                    ki.elements[4] *= l,
                    ki.elements[5] *= l,
                    ki.elements[6] *= l,
                    ki.elements[8] *= c,
                    ki.elements[9] *= c,
                    ki.elements[10] *= c,
                    t.setFromRotationMatrix(ki),
                    n.x = r,
                    n.y = a,
                    n.z = s,
                    this
                }
                makePerspective(e, t, n, i, r, a, s=$t, o=!1) {
                    const l = this.elements
                      , c = 2 * r / (t - e)
                      , h = 2 * r / (n - i)
                      , d = (t + e) / (t - e)
                      , u = (n + i) / (n - i);
                    let p, f;
                    if (o)
                        p = r / (a - r),
                        f = a * r / (a - r);
                    else if (s === $t)
                        p = -(a + r) / (a - r),
                        f = -2 * a * r / (a - r);
                    else {
                        if (s !== en)
                            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                        p = -a / (a - r),
                        f = -a * r / (a - r)
                    }
                    return l[0] = c,
                    l[4] = 0,
                    l[8] = d,
                    l[12] = 0,
                    l[1] = 0,
                    l[5] = h,
                    l[9] = u,
                    l[13] = 0,
                    l[2] = 0,
                    l[6] = 0,
                    l[10] = p,
                    l[14] = f,
                    l[3] = 0,
                    l[7] = 0,
                    l[11] = -1,
                    l[15] = 0,
                    this
                }
                makeOrthographic(e, t, n, i, r, a, s=$t, o=!1) {
                    const l = this.elements
                      , c = 2 / (t - e)
                      , h = 2 / (n - i)
                      , d = -(t + e) / (t - e)
                      , u = -(n + i) / (n - i);
                    let p, f;
                    if (o)
                        p = 1 / (a - r),
                        f = a / (a - r);
                    else if (s === $t)
                        p = -2 / (a - r),
                        f = -(a + r) / (a - r);
                    else {
                        if (s !== en)
                            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                        p = -1 / (a - r),
                        f = -r / (a - r)
                    }
                    return l[0] = c,
                    l[4] = 0,
                    l[8] = 0,
                    l[12] = d,
                    l[1] = 0,
                    l[5] = h,
                    l[9] = 0,
                    l[13] = u,
                    l[2] = 0,
                    l[6] = 0,
                    l[10] = p,
                    l[14] = f,
                    l[3] = 0,
                    l[7] = 0,
                    l[11] = 0,
                    l[15] = 1,
                    this
                }
                equals(e) {
                    const t = this.elements
                      , n = e.elements;
                    for (let e = 0; e < 16; e++)
                        if (t[e] !== n[e])
                            return !1;
                    return !0
                }
                fromArray(e, t=0) {
                    for (let n = 0; n < 16; n++)
                        this.elements[n] = e[n + t];
                    return this
                }
                toArray(e=[], t=0) {
                    const n = this.elements;
                    return e[t] = n[0],
                    e[t + 1] = n[1],
                    e[t + 2] = n[2],
                    e[t + 3] = n[3],
                    e[t + 4] = n[4],
                    e[t + 5] = n[5],
                    e[t + 6] = n[6],
                    e[t + 7] = n[7],
                    e[t + 8] = n[8],
                    e[t + 9] = n[9],
                    e[t + 10] = n[10],
                    e[t + 11] = n[11],
                    e[t + 12] = n[12],
                    e[t + 13] = n[13],
                    e[t + 14] = n[14],
                    e[t + 15] = n[15],
                    e
                }
            }
            const Ti = new Mn
              , ki = new Ei
              , Mi = new Mn(0,0,0)
              , _i = new Mn(1,1,1)
              , Ci = new Mn
              , Ri = new Mn
              , Pi = new Mn
              , Ii = new Ei
              , Li = new kn;
            class Ni {
                constructor(e=0, t=0, n=0, i=Ni.DEFAULT_ORDER) {
                    this.isEuler = !0,
                    this._x = e,
                    this._y = t,
                    this._z = n,
                    this._order = i
                }
                get x() {
                    return this._x
                }
                set x(e) {
                    this._x = e,
                    this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(e) {
                    this._y = e,
                    this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(e) {
                    this._z = e,
                    this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(e) {
                    this._order = e,
                    this._onChangeCallback()
                }
                set(e, t, n, i=this._order) {
                    return this._x = e,
                    this._y = t,
                    this._z = n,
                    this._order = i,
                    this._onChangeCallback(),
                    this
                }
                clone() {
                    return new this.constructor(this._x,this._y,this._z,this._order)
                }
                copy(e) {
                    return this._x = e._x,
                    this._y = e._y,
                    this._z = e._z,
                    this._order = e._order,
                    this._onChangeCallback(),
                    this
                }
                setFromRotationMatrix(e, t=this._order, n=!0) {
                    const i = e.elements
                      , r = i[0]
                      , a = i[4]
                      , s = i[8]
                      , o = i[1]
                      , l = i[5]
                      , c = i[9]
                      , h = i[2]
                      , d = i[6]
                      , u = i[10];
                    switch (t) {
                    case "XYZ":
                        this._y = Math.asin(yn(s, -1, 1)),
                        Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u),
                        this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(d, l),
                        this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-yn(c, -1, 1)),
                        Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u),
                        this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
                        this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(yn(d, -1, 1)),
                        Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, u),
                        this._z = Math.atan2(-a, l)) : (this._y = 0,
                        this._z = Math.atan2(o, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-yn(h, -1, 1)),
                        Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, u),
                        this._z = Math.atan2(o, r)) : (this._x = 0,
                        this._z = Math.atan2(-a, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(yn(o, -1, 1)),
                        Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                        this._y = Math.atan2(-h, r)) : (this._x = 0,
                        this._y = Math.atan2(s, u));
                        break;
                    case "XZY":
                        this._z = Math.asin(-yn(a, -1, 1)),
                        Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                        this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u),
                        this._y = 0);
                        break;
                    default:
                        cn("Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                    }
                    return this._order = t,
                    !0 === n && this._onChangeCallback(),
                    this
                }
                setFromQuaternion(e, t, n) {
                    return Ii.makeRotationFromQuaternion(e),
                    this.setFromRotationMatrix(Ii, t, n)
                }
                setFromVector3(e, t=this._order) {
                    return this.set(e.x, e.y, e.z, t)
                }
                reorder(e) {
                    return Li.setFromEuler(this),
                    this.setFromQuaternion(Li, e)
                }
                equals(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                }
                fromArray(e) {
                    return this._x = e[0],
                    this._y = e[1],
                    this._z = e[2],
                    void 0 !== e[3] && (this._order = e[3]),
                    this._onChangeCallback(),
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this._x,
                    e[t + 1] = this._y,
                    e[t + 2] = this._z,
                    e[t + 3] = this._order,
                    e
                }
                _onChange(e) {
                    return this._onChangeCallback = e,
                    this
                }
                _onChangeCallback() {}
                *[Symbol.iterator]() {
                    yield this._x,
                    yield this._y,
                    yield this._z,
                    yield this._order
                }
            }
            Ni.DEFAULT_ORDER = "XYZ";
            class zi {
                constructor() {
                    this.mask = 1
                }
                set(e) {
                    this.mask = 1 << e >>> 0
                }
                enable(e) {
                    this.mask |= 1 << e
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(e) {
                    this.mask ^= 1 << e
                }
                disable(e) {
                    this.mask &= ~(1 << e)
                }
                disableAll() {
                    this.mask = 0
                }
                test(e) {
                    return !!(this.mask & e.mask)
                }
                isEnabled(e) {
                    return !!(this.mask & 1 << e)
                }
            }
            let Ui = 0;
            const Di = new Mn
              , Bi = new kn
              , Gi = new Ei
              , Fi = new Mn
              , Oi = new Mn
              , Wi = new Mn
              , Vi = new kn
              , Hi = new Mn(1,0,0)
              , ji = new Mn(0,1,0)
              , Ki = new Mn(0,0,1)
              , qi = {
                type: "added"
            }
              , Qi = {
                type: "removed"
            }
              , Ji = {
                type: "childadded",
                child: null
            }
              , Xi = {
                type: "childremoved",
                child: null
            };
            class Yi extends pn {
                constructor() {
                    super(),
                    this.isObject3D = !0,
                    Object.defineProperty(this, "id", {
                        value: Ui++
                    }),
                    this.uuid = vn(),
                    this.name = "",
                    this.type = "Object3D",
                    this.parent = null,
                    this.children = [],
                    this.up = Yi.DEFAULT_UP.clone();
                    const e = new Mn
                      , t = new Ni
                      , n = new kn
                      , i = new Mn(1,1,1);
                    t._onChange((function() {
                        n.setFromEuler(t, !1)
                    }
                    )),
                    n._onChange((function() {
                        t.setFromQuaternion(n, void 0, !1)
                    }
                    )),
                    Object.defineProperties(this, {
                        position: {
                            configurable: !0,
                            enumerable: !0,
                            value: e
                        },
                        rotation: {
                            configurable: !0,
                            enumerable: !0,
                            value: t
                        },
                        quaternion: {
                            configurable: !0,
                            enumerable: !0,
                            value: n
                        },
                        scale: {
                            configurable: !0,
                            enumerable: !0,
                            value: i
                        },
                        modelViewMatrix: {
                            value: new Ei
                        },
                        normalMatrix: {
                            value: new Rn
                        }
                    }),
                    this.matrix = new Ei,
                    this.matrixWorld = new Ei,
                    this.matrixAutoUpdate = Yi.DEFAULT_MATRIX_AUTO_UPDATE,
                    this.matrixWorldAutoUpdate = Yi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                    this.matrixWorldNeedsUpdate = !1,
                    this.layers = new zi,
                    this.visible = !0,
                    this.castShadow = !1,
                    this.receiveShadow = !1,
                    this.frustumCulled = !0,
                    this.renderOrder = 0,
                    this.animations = [],
                    this.customDepthMaterial = void 0,
                    this.customDistanceMaterial = void 0,
                    this.userData = {}
                }
                onBeforeShadow() {}
                onAfterShadow() {}
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(e) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                    this.matrix.premultiply(e),
                    this.matrix.decompose(this.position, this.quaternion, this.scale)
                }
                applyQuaternion(e) {
                    return this.quaternion.premultiply(e),
                    this
                }
                setRotationFromAxisAngle(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                }
                setRotationFromEuler(e) {
                    this.quaternion.setFromEuler(e, !0)
                }
                setRotationFromMatrix(e) {
                    this.quaternion.setFromRotationMatrix(e)
                }
                setRotationFromQuaternion(e) {
                    this.quaternion.copy(e)
                }
                rotateOnAxis(e, t) {
                    return Bi.setFromAxisAngle(e, t),
                    this.quaternion.multiply(Bi),
                    this
                }
                rotateOnWorldAxis(e, t) {
                    return Bi.setFromAxisAngle(e, t),
                    this.quaternion.premultiply(Bi),
                    this
                }
                rotateX(e) {
                    return this.rotateOnAxis(Hi, e)
                }
                rotateY(e) {
                    return this.rotateOnAxis(ji, e)
                }
                rotateZ(e) {
                    return this.rotateOnAxis(Ki, e)
                }
                translateOnAxis(e, t) {
                    return Di.copy(e).applyQuaternion(this.quaternion),
                    this.position.add(Di.multiplyScalar(t)),
                    this
                }
                translateX(e) {
                    return this.translateOnAxis(Hi, e)
                }
                translateY(e) {
                    return this.translateOnAxis(ji, e)
                }
                translateZ(e) {
                    return this.translateOnAxis(Ki, e)
                }
                localToWorld(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.applyMatrix4(this.matrixWorld)
                }
                worldToLocal(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.applyMatrix4(Gi.copy(this.matrixWorld).invert())
                }
                lookAt(e, t, n) {
                    e.isVector3 ? Fi.copy(e) : Fi.set(e, t, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1),
                    Oi.setFromMatrixPosition(this.matrixWorld),
                    this.isCamera || this.isLight ? Gi.lookAt(Oi, Fi, this.up) : Gi.lookAt(Fi, Oi, this.up),
                    this.quaternion.setFromRotationMatrix(Gi),
                    i && (Gi.extractRotation(i.matrixWorld),
                    Bi.setFromRotationMatrix(Gi),
                    this.quaternion.premultiply(Bi.invert()))
                }
                add(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++)
                            this.add(arguments[e]);
                        return this
                    }
                    return e === this ? (hn("Object3D.add: object can't be added as a child of itself.", e),
                    this) : (e && e.isObject3D ? (e.removeFromParent(),
                    e.parent = this,
                    this.children.push(e),
                    e.dispatchEvent(qi),
                    Ji.child = e,
                    this.dispatchEvent(Ji),
                    Ji.child = null) : hn("Object3D.add: object not an instance of THREE.Object3D.", e),
                    this)
                }
                remove(e) {
                    if (arguments.length > 1) {
                        for (let e = 0; e < arguments.length; e++)
                            this.remove(arguments[e]);
                        return this
                    }
                    const t = this.children.indexOf(e);
                    return -1 !== t && (e.parent = null,
                    this.children.splice(t, 1),
                    e.dispatchEvent(Qi),
                    Xi.child = e,
                    this.dispatchEvent(Xi),
                    Xi.child = null),
                    this
                }
                removeFromParent() {
                    const e = this.parent;
                    return null !== e && e.remove(this),
                    this
                }
                clear() {
                    return this.remove(...this.children)
                }
                attach(e) {
                    return this.updateWorldMatrix(!0, !1),
                    Gi.copy(this.matrixWorld).invert(),
                    null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                    Gi.multiply(e.parent.matrixWorld)),
                    e.applyMatrix4(Gi),
                    e.removeFromParent(),
                    e.parent = this,
                    this.children.push(e),
                    e.updateWorldMatrix(!1, !0),
                    e.dispatchEvent(qi),
                    Ji.child = e,
                    this.dispatchEvent(Ji),
                    Ji.child = null,
                    this
                }
                getObjectById(e) {
                    return this.getObjectByProperty("id", e)
                }
                getObjectByName(e) {
                    return this.getObjectByProperty("name", e)
                }
                getObjectByProperty(e, t) {
                    if (this[e] === t)
                        return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(e, t);
                        if (void 0 !== i)
                            return i
                    }
                }
                getObjectsByProperty(e, t, n=[]) {
                    this[e] === t && n.push(this);
                    const i = this.children;
                    for (let r = 0, a = i.length; r < a; r++)
                        i[r].getObjectsByProperty(e, t, n);
                    return n
                }
                getWorldPosition(e) {
                    return this.updateWorldMatrix(!0, !1),
                    e.setFromMatrixPosition(this.matrixWorld)
                }
                getWorldQuaternion(e) {
                    return this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(Oi, e, Wi),
                    e
                }
                getWorldScale(e) {
                    return this.updateWorldMatrix(!0, !1),
                    this.matrixWorld.decompose(Oi, Vi, e),
                    e
                }
                getWorldDirection(e) {
                    this.updateWorldMatrix(!0, !1);
                    const t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                }
                raycast() {}
                traverse(e) {
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++)
                        t[n].traverse(e)
                }
                traverseVisible(e) {
                    if (!1 === this.visible)
                        return;
                    e(this);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++)
                        t[n].traverseVisible(e)
                }
                traverseAncestors(e) {
                    const t = this.parent;
                    null !== t && (e(t),
                    t.traverseAncestors(e))
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale),
                    this.matrixWorldNeedsUpdate = !0
                }
                updateMatrixWorld(e) {
                    this.matrixAutoUpdate && this.updateMatrix(),
                    (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                    this.matrixWorldNeedsUpdate = !1,
                    e = !0);
                    const t = this.children;
                    for (let n = 0, i = t.length; n < i; n++) {
                        t[n].updateMatrixWorld(e)
                    }
                }
                updateWorldMatrix(e, t) {
                    const n = this.parent;
                    if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                    this.matrixAutoUpdate && this.updateMatrix(),
                    !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                    !0 === t) {
                        const e = this.children;
                        for (let t = 0, n = e.length; t < n; t++) {
                            e[t].updateWorldMatrix(!1, !0)
                        }
                    }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e
                      , n = {};
                    t && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {},
                        nodes: {}
                    },
                    n.metadata = {
                        version: 4.7,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};
                    function r(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                        n.uuid
                    }
                    if (i.uuid = this.uuid,
                    i.type = this.type,
                    "" !== this.name && (i.name = this.name),
                    !0 === this.castShadow && (i.castShadow = !0),
                    !0 === this.receiveShadow && (i.receiveShadow = !0),
                    !1 === this.visible && (i.visible = !1),
                    !1 === this.frustumCulled && (i.frustumCulled = !1),
                    0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                    Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                    i.layers = this.layers.mask,
                    i.matrix = this.matrix.toArray(),
                    i.up = this.up.toArray(),
                    !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                    this.isInstancedMesh && (i.type = "InstancedMesh",
                    i.count = this.count,
                    i.instanceMatrix = this.instanceMatrix.toJSON(),
                    null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                    this.isBatchedMesh && (i.type = "BatchedMesh",
                    i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                    i.sortObjects = this.sortObjects,
                    i.drawRanges = this._drawRanges,
                    i.reservedRanges = this._reservedRanges,
                    i.geometryInfo = this._geometryInfo.map((e => ({
                        ...e,
                        boundingBox: e.boundingBox ? e.boundingBox.toJSON() : void 0,
                        boundingSphere: e.boundingSphere ? e.boundingSphere.toJSON() : void 0
                    }))),
                    i.instanceInfo = this._instanceInfo.map((e => ({
                        ...e
                    }))),
                    i.availableInstanceIds = this._availableInstanceIds.slice(),
                    i.availableGeometryIds = this._availableGeometryIds.slice(),
                    i.nextIndexStart = this._nextIndexStart,
                    i.nextVertexStart = this._nextVertexStart,
                    i.geometryCount = this._geometryCount,
                    i.maxInstanceCount = this._maxInstanceCount,
                    i.maxVertexCount = this._maxVertexCount,
                    i.maxIndexCount = this._maxIndexCount,
                    i.geometryInitialized = this._geometryInitialized,
                    i.matricesTexture = this._matricesTexture.toJSON(e),
                    i.indirectTexture = this._indirectTexture.toJSON(e),
                    null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)),
                    null !== this.boundingSphere && (i.boundingSphere = this.boundingSphere.toJSON()),
                    null !== this.boundingBox && (i.boundingBox = this.boundingBox.toJSON())),
                    this.isScene)
                        this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                        this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(e.geometries, this.geometry);
                        const t = this.geometry.parameters;
                        if (void 0 !== t && void 0 !== t.shapes) {
                            const n = t.shapes;
                            if (Array.isArray(n))
                                for (let t = 0, i = n.length; t < i; t++) {
                                    const i = n[t];
                                    r(e.shapes, i)
                                }
                            else
                                r(e.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                    i.bindMatrix = this.bindMatrix.toArray(),
                    void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
                    i.skeleton = this.skeleton.uuid)),
                    void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const t = [];
                            for (let n = 0, i = this.material.length; n < i; n++)
                                t.push(r(e.materials, this.material[n]));
                            i.material = t
                        } else
                            i.material = r(e.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let t = 0; t < this.children.length; t++)
                            i.children.push(this.children[t].toJSON(e).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let t = 0; t < this.animations.length; t++) {
                            const n = this.animations[t];
                            i.animations.push(r(e.animations, n))
                        }
                    }
                    if (t) {
                        const t = a(e.geometries)
                          , i = a(e.materials)
                          , r = a(e.textures)
                          , s = a(e.images)
                          , o = a(e.shapes)
                          , l = a(e.skeletons)
                          , c = a(e.animations)
                          , h = a(e.nodes);
                        t.length > 0 && (n.geometries = t),
                        i.length > 0 && (n.materials = i),
                        r.length > 0 && (n.textures = r),
                        s.length > 0 && (n.images = s),
                        o.length > 0 && (n.shapes = o),
                        l.length > 0 && (n.skeletons = l),
                        c.length > 0 && (n.animations = c),
                        h.length > 0 && (n.nodes = h)
                    }
                    return n.object = i,
                    n;
                    function a(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata,
                            t.push(i)
                        }
                        return t
                    }
                }
                clone(e) {
                    return (new this.constructor).copy(this, e)
                }
                copy(e, t=!0) {
                    if (this.name = e.name,
                    this.up.copy(e.up),
                    this.position.copy(e.position),
                    this.rotation.order = e.rotation.order,
                    this.quaternion.copy(e.quaternion),
                    this.scale.copy(e.scale),
                    this.matrix.copy(e.matrix),
                    this.matrixWorld.copy(e.matrixWorld),
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                    this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                    this.layers.mask = e.layers.mask,
                    this.visible = e.visible,
                    this.castShadow = e.castShadow,
                    this.receiveShadow = e.receiveShadow,
                    this.frustumCulled = e.frustumCulled,
                    this.renderOrder = e.renderOrder,
                    this.animations = e.animations.slice(),
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    !0 === t)
                        for (let t = 0; t < e.children.length; t++) {
                            const n = e.children[t];
                            this.add(n.clone())
                        }
                    return this
                }
            }
            Yi.DEFAULT_UP = new Mn(0,1,0),
            Yi.DEFAULT_MATRIX_AUTO_UPDATE = !0,
            Yi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            const Zi = new Mn
              , $i = new Mn
              , er = new Mn
              , tr = new Mn
              , nr = new Mn
              , ir = new Mn
              , rr = new Mn
              , ar = new Mn
              , sr = new Mn
              , or = new Mn
              , lr = new Kn
              , cr = new Kn
              , hr = new Kn;
            class dr {
                constructor(e=new Mn, t=new Mn, n=new Mn) {
                    this.a = e,
                    this.b = t,
                    this.c = n
                }
                static getNormal(e, t, n, i) {
                    i.subVectors(n, t),
                    Zi.subVectors(e, t),
                    i.cross(Zi);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(e, t, n, i, r) {
                    Zi.subVectors(i, t),
                    $i.subVectors(n, t),
                    er.subVectors(e, t);
                    const a = Zi.dot(Zi)
                      , s = Zi.dot($i)
                      , o = Zi.dot(er)
                      , l = $i.dot($i)
                      , c = $i.dot(er)
                      , h = a * l - s * s;
                    if (0 === h)
                        return r.set(0, 0, 0),
                        null;
                    const d = 1 / h
                      , u = (l * o - s * c) * d
                      , p = (a * c - s * o) * d;
                    return r.set(1 - u - p, p, u)
                }
                static containsPoint(e, t, n, i) {
                    return null !== this.getBarycoord(e, t, n, i, tr) && (tr.x >= 0 && tr.y >= 0 && tr.x + tr.y <= 1)
                }
                static getInterpolation(e, t, n, i, r, a, s, o) {
                    return null === this.getBarycoord(e, t, n, i, tr) ? (o.x = 0,
                    o.y = 0,
                    "z"in o && (o.z = 0),
                    "w"in o && (o.w = 0),
                    null) : (o.setScalar(0),
                    o.addScaledVector(r, tr.x),
                    o.addScaledVector(a, tr.y),
                    o.addScaledVector(s, tr.z),
                    o)
                }
                static getInterpolatedAttribute(e, t, n, i, r, a) {
                    return lr.setScalar(0),
                    cr.setScalar(0),
                    hr.setScalar(0),
                    lr.fromBufferAttribute(e, t),
                    cr.fromBufferAttribute(e, n),
                    hr.fromBufferAttribute(e, i),
                    a.setScalar(0),
                    a.addScaledVector(lr, r.x),
                    a.addScaledVector(cr, r.y),
                    a.addScaledVector(hr, r.z),
                    a
                }
                static isFrontFacing(e, t, n, i) {
                    return Zi.subVectors(n, t),
                    $i.subVectors(e, t),
                    Zi.cross($i).dot(i) < 0
                }
                set(e, t, n) {
                    return this.a.copy(e),
                    this.b.copy(t),
                    this.c.copy(n),
                    this
                }
                setFromPointsAndIndices(e, t, n, i) {
                    return this.a.copy(e[t]),
                    this.b.copy(e[n]),
                    this.c.copy(e[i]),
                    this
                }
                setFromAttributeAndIndices(e, t, n, i) {
                    return this.a.fromBufferAttribute(e, t),
                    this.b.fromBufferAttribute(e, n),
                    this.c.fromBufferAttribute(e, i),
                    this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.a.copy(e.a),
                    this.b.copy(e.b),
                    this.c.copy(e.c),
                    this
                }
                getArea() {
                    return Zi.subVectors(this.c, this.b),
                    $i.subVectors(this.a, this.b),
                    .5 * Zi.cross($i).length()
                }
                getMidpoint(e) {
                    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(e) {
                    return dr.getNormal(this.a, this.b, this.c, e)
                }
                getPlane(e) {
                    return e.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(e, t) {
                    return dr.getBarycoord(e, this.a, this.b, this.c, t)
                }
                getInterpolation(e, t, n, i, r) {
                    return dr.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
                }
                containsPoint(e) {
                    return dr.containsPoint(e, this.a, this.b, this.c)
                }
                isFrontFacing(e) {
                    return dr.isFrontFacing(this.a, this.b, this.c, e)
                }
                intersectsBox(e) {
                    return e.intersectsTriangle(this)
                }
                closestPointToPoint(e, t) {
                    const n = this.a
                      , i = this.b
                      , r = this.c;
                    let a, s;
                    nr.subVectors(i, n),
                    ir.subVectors(r, n),
                    ar.subVectors(e, n);
                    const o = nr.dot(ar)
                      , l = ir.dot(ar);
                    if (o <= 0 && l <= 0)
                        return t.copy(n);
                    sr.subVectors(e, i);
                    const c = nr.dot(sr)
                      , h = ir.dot(sr);
                    if (c >= 0 && h <= c)
                        return t.copy(i);
                    const d = o * h - c * l;
                    if (d <= 0 && o >= 0 && c <= 0)
                        return a = o / (o - c),
                        t.copy(n).addScaledVector(nr, a);
                    or.subVectors(e, r);
                    const u = nr.dot(or)
                      , p = ir.dot(or);
                    if (p >= 0 && u <= p)
                        return t.copy(r);
                    const f = u * l - o * p;
                    if (f <= 0 && l >= 0 && p <= 0)
                        return s = l / (l - p),
                        t.copy(n).addScaledVector(ir, s);
                    const g = c * p - u * h;
                    if (g <= 0 && h - c >= 0 && u - p >= 0)
                        return rr.subVectors(r, i),
                        s = (h - c) / (h - c + (u - p)),
                        t.copy(i).addScaledVector(rr, s);
                    const m = 1 / (g + f + d);
                    return a = f * m,
                    s = d * m,
                    t.copy(n).addScaledVector(nr, a).addScaledVector(ir, s)
                }
                equals(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }
            const ur = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            }
              , pr = {
                h: 0,
                s: 0,
                l: 0
            }
              , fr = {
                h: 0,
                s: 0,
                l: 0
            };
            function gr(e, t, n) {
                return n < 0 && (n += 1),
                n > 1 && (n -= 1),
                n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            class mr {
                constructor(e, t, n) {
                    return this.isColor = !0,
                    this.r = 1,
                    this.g = 1,
                    this.b = 1,
                    this.set(e, t, n)
                }
                set(e, t, n) {
                    if (void 0 === t && void 0 === n) {
                        const t = e;
                        t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                    } else
                        this.setRGB(e, t, n);
                    return this
                }
                setScalar(e) {
                    return this.r = e,
                    this.g = e,
                    this.b = e,
                    this
                }
                setHex(e, t=Bt) {
                    return e = Math.floor(e),
                    this.r = (e >> 16 & 255) / 255,
                    this.g = (e >> 8 & 255) / 255,
                    this.b = (255 & e) / 255,
                    zn.colorSpaceToWorking(this, t),
                    this
                }
                setRGB(e, t, n, i=zn.workingColorSpace) {
                    return this.r = e,
                    this.g = t,
                    this.b = n,
                    zn.colorSpaceToWorking(this, i),
                    this
                }
                setHSL(e, t, n, i=zn.workingColorSpace) {
                    if (e = wn(e, 1),
                    t = yn(t, 0, 1),
                    n = yn(n, 0, 1),
                    0 === t)
                        this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + t) : n + t - n * t
                          , r = 2 * n - i;
                        this.r = gr(r, i, e + 1 / 3),
                        this.g = gr(r, i, e),
                        this.b = gr(r, i, e - 1 / 3)
                    }
                    return zn.colorSpaceToWorking(this, i),
                    this
                }
                setStyle(e, t=Bt) {
                    function n(t) {
                        void 0 !== t && parseFloat(t) < 1 && cn("Color: Alpha component of " + e + " will be ignored.")
                    }
                    let i;
                    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                        let r;
                        const a = i[1]
                          , s = i[2];
                        switch (a) {
                        case "rgb":
                        case "rgba":
                            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(r[4]),
                                this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(r[4]),
                                this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                            break;
                        case "hsl":
                        case "hsla":
                            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                                return n(r[4]),
                                this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                            break;
                        default:
                            cn("Color: Unknown color model " + e)
                        }
                    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                        const n = i[1]
                          , r = n.length;
                        if (3 === r)
                            return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                        if (6 === r)
                            return this.setHex(parseInt(n, 16), t);
                        cn("Color: Invalid hex color " + e)
                    } else if (e && e.length > 0)
                        return this.setColorName(e, t);
                    return this
                }
                setColorName(e, t=Bt) {
                    const n = ur[e.toLowerCase()];
                    return void 0 !== n ? this.setHex(n, t) : cn("Color: Unknown color " + e),
                    this
                }
                clone() {
                    return new this.constructor(this.r,this.g,this.b)
                }
                copy(e) {
                    return this.r = e.r,
                    this.g = e.g,
                    this.b = e.b,
                    this
                }
                copySRGBToLinear(e) {
                    return this.r = Un(e.r),
                    this.g = Un(e.g),
                    this.b = Un(e.b),
                    this
                }
                copyLinearToSRGB(e) {
                    return this.r = Dn(e.r),
                    this.g = Dn(e.g),
                    this.b = Dn(e.b),
                    this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this),
                    this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this),
                    this
                }
                getHex(e=Bt) {
                    return zn.workingToColorSpace(Ar.copy(this), e),
                    65536 * Math.round(yn(255 * Ar.r, 0, 255)) + 256 * Math.round(yn(255 * Ar.g, 0, 255)) + Math.round(yn(255 * Ar.b, 0, 255))
                }
                getHexString(e=Bt) {
                    return ("000000" + this.getHex(e).toString(16)).slice(-6)
                }
                getHSL(e, t=zn.workingColorSpace) {
                    zn.workingToColorSpace(Ar.copy(this), t);
                    const n = Ar.r
                      , i = Ar.g
                      , r = Ar.b
                      , a = Math.max(n, i, r)
                      , s = Math.min(n, i, r);
                    let o, l;
                    const c = (s + a) / 2;
                    if (s === a)
                        o = 0,
                        l = 0;
                    else {
                        const e = a - s;
                        switch (l = c <= .5 ? e / (a + s) : e / (2 - a - s),
                        a) {
                        case n:
                            o = (i - r) / e + (i < r ? 6 : 0);
                            break;
                        case i:
                            o = (r - n) / e + 2;
                            break;
                        case r:
                            o = (n - i) / e + 4
                        }
                        o /= 6
                    }
                    return e.h = o,
                    e.s = l,
                    e.l = c,
                    e
                }
                getRGB(e, t=zn.workingColorSpace) {
                    return zn.workingToColorSpace(Ar.copy(this), t),
                    e.r = Ar.r,
                    e.g = Ar.g,
                    e.b = Ar.b,
                    e
                }
                getStyle(e=Bt) {
                    zn.workingToColorSpace(Ar.copy(this), e);
                    const t = Ar.r
                      , n = Ar.g
                      , i = Ar.b;
                    return e !== Bt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})`
                }
                offsetHSL(e, t, n) {
                    return this.getHSL(pr),
                    this.setHSL(pr.h + e, pr.s + t, pr.l + n)
                }
                add(e) {
                    return this.r += e.r,
                    this.g += e.g,
                    this.b += e.b,
                    this
                }
                addColors(e, t) {
                    return this.r = e.r + t.r,
                    this.g = e.g + t.g,
                    this.b = e.b + t.b,
                    this
                }
                addScalar(e) {
                    return this.r += e,
                    this.g += e,
                    this.b += e,
                    this
                }
                sub(e) {
                    return this.r = Math.max(0, this.r - e.r),
                    this.g = Math.max(0, this.g - e.g),
                    this.b = Math.max(0, this.b - e.b),
                    this
                }
                multiply(e) {
                    return this.r *= e.r,
                    this.g *= e.g,
                    this.b *= e.b,
                    this
                }
                multiplyScalar(e) {
                    return this.r *= e,
                    this.g *= e,
                    this.b *= e,
                    this
                }
                lerp(e, t) {
                    return this.r += (e.r - this.r) * t,
                    this.g += (e.g - this.g) * t,
                    this.b += (e.b - this.b) * t,
                    this
                }
                lerpColors(e, t, n) {
                    return this.r = e.r + (t.r - e.r) * n,
                    this.g = e.g + (t.g - e.g) * n,
                    this.b = e.b + (t.b - e.b) * n,
                    this
                }
                lerpHSL(e, t) {
                    this.getHSL(pr),
                    e.getHSL(fr);
                    const n = bn(pr.h, fr.h, t)
                      , i = bn(pr.s, fr.s, t)
                      , r = bn(pr.l, fr.l, t);
                    return this.setHSL(n, i, r),
                    this
                }
                setFromVector3(e) {
                    return this.r = e.x,
                    this.g = e.y,
                    this.b = e.z,
                    this
                }
                applyMatrix3(e) {
                    const t = this.r
                      , n = this.g
                      , i = this.b
                      , r = e.elements;
                    return this.r = r[0] * t + r[3] * n + r[6] * i,
                    this.g = r[1] * t + r[4] * n + r[7] * i,
                    this.b = r[2] * t + r[5] * n + r[8] * i,
                    this
                }
                equals(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                }
                fromArray(e, t=0) {
                    return this.r = e[t],
                    this.g = e[t + 1],
                    this.b = e[t + 2],
                    this
                }
                toArray(e=[], t=0) {
                    return e[t] = this.r,
                    e[t + 1] = this.g,
                    e[t + 2] = this.b,
                    e
                }
                fromBufferAttribute(e, t) {
                    return this.r = e.getX(t),
                    this.g = e.getY(t),
                    this.b = e.getZ(t),
                    this
                }
                toJSON() {
                    return this.getHex()
                }
                *[Symbol.iterator]() {
                    yield this.r,
                    yield this.g,
                    yield this.b
                }
            }
            const Ar = new mr;
            mr.NAMES = ur;
            let vr = 0;
            class yr extends pn {
                constructor() {
                    super(),
                    this.isMaterial = !0,
                    Object.defineProperty(this, "id", {
                        value: vr++
                    }),
                    this.uuid = vn(),
                    this.name = "",
                    this.type = "Material",
                    this.blending = m,
                    this.side = u,
                    this.vertexColors = !1,
                    this.opacity = 1,
                    this.transparent = !1,
                    this.alphaHash = !1,
                    this.blendSrc = R,
                    this.blendDst = P,
                    this.blendEquation = b,
                    this.blendSrcAlpha = null,
                    this.blendDstAlpha = null,
                    this.blendEquationAlpha = null,
                    this.blendColor = new mr(0,0,0),
                    this.blendAlpha = 0,
                    this.depthFunc = H,
                    this.depthTest = !0,
                    this.depthWrite = !0,
                    this.stencilWriteMask = 255,
                    this.stencilFunc = 519,
                    this.stencilRef = 0,
                    this.stencilFuncMask = 255,
                    this.stencilFail = Wt,
                    this.stencilZFail = Wt,
                    this.stencilZPass = Wt,
                    this.stencilWrite = !1,
                    this.clippingPlanes = null,
                    this.clipIntersection = !1,
                    this.clipShadows = !1,
                    this.shadowSide = null,
                    this.colorWrite = !0,
                    this.precision = null,
                    this.polygonOffset = !1,
                    this.polygonOffsetFactor = 0,
                    this.polygonOffsetUnits = 0,
                    this.dithering = !1,
                    this.alphaToCoverage = !1,
                    this.premultipliedAlpha = !1,
                    this.forceSinglePass = !1,
                    this.allowOverride = !0,
                    this.visible = !0,
                    this.toneMapped = !0,
                    this.userData = {},
                    this.version = 0,
                    this._alphaTest = 0
                }
                get alphaTest() {
                    return this._alphaTest
                }
                set alphaTest(e) {
                    this._alphaTest > 0 != e > 0 && this.version++,
                    this._alphaTest = e
                }
                onBeforeRender() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString()
                }
                setValues(e) {
                    if (void 0 !== e)
                        for (const t in e) {
                            const n = e[t];
                            if (void 0 === n) {
                                cn(`Material: parameter '${t}' has value of undefined.`);
                                continue
                            }
                            const i = this[t];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : cn(`Material: '${t}' is not a property of THREE.${this.type}.`)
                        }
                }
                toJSON(e) {
                    const t = void 0 === e || "string" == typeof e;
                    t && (e = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.7,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    function i(e) {
                        const t = [];
                        for (const n in e) {
                            const i = e[n];
                            delete i.metadata,
                            t.push(i)
                        }
                        return t
                    }
                    if (n.uuid = this.uuid,
                    n.type = this.type,
                    "" !== this.name && (n.name = this.name),
                    this.color && this.color.isColor && (n.color = this.color.getHex()),
                    void 0 !== this.roughness && (n.roughness = this.roughness),
                    void 0 !== this.metalness && (n.metalness = this.metalness),
                    void 0 !== this.sheen && (n.sheen = this.sheen),
                    this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                    void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                    this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                    void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                    this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                    void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                    this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                    void 0 !== this.shininess && (n.shininess = this.shininess),
                    void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                    void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                    this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                    this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                    this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                    n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                    this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid),
                    this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid),
                    void 0 !== this.dispersion && (n.dispersion = this.dispersion),
                    void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                    void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                    void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                    this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                    this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                    void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                    void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                    this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                    this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                    this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                    this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                    this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                    n.lightMapIntensity = this.lightMapIntensity),
                    this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                    n.aoMapIntensity = this.aoMapIntensity),
                    this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                    n.bumpScale = this.bumpScale),
                    this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                    n.normalMapType = this.normalMapType,
                    n.normalScale = this.normalScale.toArray()),
                    this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                    n.displacementScale = this.displacementScale,
                    n.displacementBias = this.displacementBias),
                    this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                    this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                    this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                    this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                    this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                    this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                    this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                    void 0 !== this.combine && (n.combine = this.combine)),
                    void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                    void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                    void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                    void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                    this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                    void 0 !== this.transmission && (n.transmission = this.transmission),
                    this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                    void 0 !== this.thickness && (n.thickness = this.thickness),
                    this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                    void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                    void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                    void 0 !== this.size && (n.size = this.size),
                    null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                    void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                    this.blending !== m && (n.blending = this.blending),
                    this.side !== u && (n.side = this.side),
                    !0 === this.vertexColors && (n.vertexColors = !0),
                    this.opacity < 1 && (n.opacity = this.opacity),
                    !0 === this.transparent && (n.transparent = !0),
                    this.blendSrc !== R && (n.blendSrc = this.blendSrc),
                    this.blendDst !== P && (n.blendDst = this.blendDst),
                    this.blendEquation !== b && (n.blendEquation = this.blendEquation),
                    null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                    null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                    null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                    this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                    0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                    this.depthFunc !== H && (n.depthFunc = this.depthFunc),
                    !1 === this.depthTest && (n.depthTest = this.depthTest),
                    !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                    !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                    255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                    519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                    0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                    255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                    this.stencilFail !== Wt && (n.stencilFail = this.stencilFail),
                    this.stencilZFail !== Wt && (n.stencilZFail = this.stencilZFail),
                    this.stencilZPass !== Wt && (n.stencilZPass = this.stencilZPass),
                    !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                    void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                    !0 === this.polygonOffset && (n.polygonOffset = !0),
                    0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                    0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                    void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                    void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                    void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                    void 0 !== this.scale && (n.scale = this.scale),
                    !0 === this.dithering && (n.dithering = !0),
                    this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                    !0 === this.alphaHash && (n.alphaHash = !0),
                    !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                    !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                    !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                    !1 === this.allowOverride && (n.allowOverride = !1),
                    !0 === this.wireframe && (n.wireframe = !0),
                    this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                    "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                    "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                    !0 === this.flatShading && (n.flatShading = !0),
                    !1 === this.visible && (n.visible = !1),
                    !1 === this.toneMapped && (n.toneMapped = !1),
                    !1 === this.fog && (n.fog = !1),
                    Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                    t) {
                        const t = i(e.textures)
                          , r = i(e.images);
                        t.length > 0 && (n.textures = t),
                        r.length > 0 && (n.images = r)
                    }
                    return n
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.name = e.name,
                    this.blending = e.blending,
                    this.side = e.side,
                    this.vertexColors = e.vertexColors,
                    this.opacity = e.opacity,
                    this.transparent = e.transparent,
                    this.blendSrc = e.blendSrc,
                    this.blendDst = e.blendDst,
                    this.blendEquation = e.blendEquation,
                    this.blendSrcAlpha = e.blendSrcAlpha,
                    this.blendDstAlpha = e.blendDstAlpha,
                    this.blendEquationAlpha = e.blendEquationAlpha,
                    this.blendColor.copy(e.blendColor),
                    this.blendAlpha = e.blendAlpha,
                    this.depthFunc = e.depthFunc,
                    this.depthTest = e.depthTest,
                    this.depthWrite = e.depthWrite,
                    this.stencilWriteMask = e.stencilWriteMask,
                    this.stencilFunc = e.stencilFunc,
                    this.stencilRef = e.stencilRef,
                    this.stencilFuncMask = e.stencilFuncMask,
                    this.stencilFail = e.stencilFail,
                    this.stencilZFail = e.stencilZFail,
                    this.stencilZPass = e.stencilZPass,
                    this.stencilWrite = e.stencilWrite;
                    const t = e.clippingPlanes;
                    let n = null;
                    if (null !== t) {
                        const e = t.length;
                        n = new Array(e);
                        for (let i = 0; i !== e; ++i)
                            n[i] = t[i].clone()
                    }
                    return this.clippingPlanes = n,
                    this.clipIntersection = e.clipIntersection,
                    this.clipShadows = e.clipShadows,
                    this.shadowSide = e.shadowSide,
                    this.colorWrite = e.colorWrite,
                    this.precision = e.precision,
                    this.polygonOffset = e.polygonOffset,
                    this.polygonOffsetFactor = e.polygonOffsetFactor,
                    this.polygonOffsetUnits = e.polygonOffsetUnits,
                    this.dithering = e.dithering,
                    this.alphaTest = e.alphaTest,
                    this.alphaHash = e.alphaHash,
                    this.alphaToCoverage = e.alphaToCoverage,
                    this.premultipliedAlpha = e.premultipliedAlpha,
                    this.forceSinglePass = e.forceSinglePass,
                    this.allowOverride = e.allowOverride,
                    this.visible = e.visible,
                    this.toneMapped = e.toneMapped,
                    this.userData = JSON.parse(JSON.stringify(e.userData)),
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
            }
            class wr extends yr {
                constructor(e) {
                    super(),
                    this.isMeshBasicMaterial = !0,
                    this.type = "MeshBasicMaterial",
                    this.color = new mr(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapRotation = new Ni,
                    this.combine = J,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.envMapRotation.copy(e.envMapRotation),
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.fog = e.fog,
                    this
                }
            }
            const br = new Mn
              , xr = new Tn;
            let Sr = 0;
            class Er {
                constructor(e, t, n=!1) {
                    if (Array.isArray(e))
                        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    this.isBufferAttribute = !0,
                    Object.defineProperty(this, "id", {
                        value: Sr++
                    }),
                    this.name = "",
                    this.array = e,
                    this.itemSize = t,
                    this.count = void 0 !== e ? e.length / t : 0,
                    this.normalized = n,
                    this.usage = Yt,
                    this.updateRanges = [],
                    this.gpuType = Me,
                    this.version = 0
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e,
                    this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.name = e.name,
                    this.array = new e.array.constructor(e.array),
                    this.itemSize = e.itemSize,
                    this.count = e.count,
                    this.normalized = e.normalized,
                    this.usage = e.usage,
                    this.gpuType = e.gpuType,
                    this
                }
                copyAt(e, t, n) {
                    e *= this.itemSize,
                    n *= t.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++)
                        this.array[e + i] = t.array[n + i];
                    return this
                }
                copyArray(e) {
                    return this.array.set(e),
                    this
                }
                applyMatrix3(e) {
                    if (2 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++)
                            xr.fromBufferAttribute(this, t),
                            xr.applyMatrix3(e),
                            this.setXY(t, xr.x, xr.y);
                    else if (3 === this.itemSize)
                        for (let t = 0, n = this.count; t < n; t++)
                            br.fromBufferAttribute(this, t),
                            br.applyMatrix3(e),
                            this.setXYZ(t, br.x, br.y, br.z);
                    return this
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        br.fromBufferAttribute(this, t),
                        br.applyMatrix4(e),
                        this.setXYZ(t, br.x, br.y, br.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        br.fromBufferAttribute(this, t),
                        br.applyNormalMatrix(e),
                        this.setXYZ(t, br.x, br.y, br.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        br.fromBufferAttribute(this, t),
                        br.transformDirection(e),
                        this.setXYZ(t, br.x, br.y, br.z);
                    return this
                }
                set(e, t=0) {
                    return this.array.set(e, t),
                    this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.itemSize + t];
                    return this.normalized && (n = xn(n, this.array)),
                    n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = Sn(n, this.array)),
                    this.array[e * this.itemSize + t] = n,
                    this
                }
                getX(e) {
                    let t = this.array[e * this.itemSize];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                setX(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.array[e * this.itemSize] = t,
                    this
                }
                getY(e) {
                    let t = this.array[e * this.itemSize + 1];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                setY(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.array[e * this.itemSize + 1] = t,
                    this
                }
                getZ(e) {
                    let t = this.array[e * this.itemSize + 2];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                setZ(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.array[e * this.itemSize + 2] = t,
                    this
                }
                getW(e) {
                    let t = this.array[e * this.itemSize + 3];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                setW(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.array[e * this.itemSize + 3] = t,
                    this
                }
                setXY(e, t, n) {
                    return e *= this.itemSize,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this
                }
                setXYZ(e, t, n, i) {
                    return e *= this.itemSize,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array),
                    i = Sn(i, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this.array[e + 2] = i,
                    this
                }
                setXYZW(e, t, n, i, r) {
                    return e *= this.itemSize,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array),
                    i = Sn(i, this.array),
                    r = Sn(r, this.array)),
                    this.array[e + 0] = t,
                    this.array[e + 1] = n,
                    this.array[e + 2] = i,
                    this.array[e + 3] = r,
                    this
                }
                onUpload(e) {
                    return this.onUploadCallback = e,
                    this
                }
                clone() {
                    return new this.constructor(this.array,this.itemSize).copy(this)
                }
                toJSON() {
                    const e = {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.from(this.array),
                        normalized: this.normalized
                    };
                    return "" !== this.name && (e.name = this.name),
                    this.usage !== Yt && (e.usage = this.usage),
                    e
                }
            }
            class Tr extends Er {
                constructor(e, t, n) {
                    super(new Uint16Array(e), t, n)
                }
            }
            class kr extends Er {
                constructor(e, t, n) {
                    super(new Uint32Array(e), t, n)
                }
            }
            class Mr extends Er {
                constructor(e, t, n) {
                    super(new Float32Array(e), t, n)
                }
            }
            let _r = 0;
            const Cr = new Ei
              , Rr = new Yi
              , Pr = new Mn
              , Ir = new Yn
              , Lr = new Yn
              , Nr = new Mn;
            class zr extends pn {
                constructor() {
                    super(),
                    this.isBufferGeometry = !0,
                    Object.defineProperty(this, "id", {
                        value: _r++
                    }),
                    this.uuid = vn(),
                    this.name = "",
                    this.type = "BufferGeometry",
                    this.index = null,
                    this.indirect = null,
                    this.indirectOffset = 0,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.morphTargetsRelative = !1,
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.drawRange = {
                        start: 0,
                        count: 1 / 0
                    },
                    this.userData = {}
                }
                getIndex() {
                    return this.index
                }
                setIndex(e) {
                    return Array.isArray(e) ? this.index = new (tn(e) ? kr : Tr)(e,1) : this.index = e,
                    this
                }
                setIndirect(e, t=0) {
                    return this.indirect = e,
                    this.indirectOffset = t,
                    this
                }
                getIndirect() {
                    return this.indirect
                }
                getAttribute(e) {
                    return this.attributes[e]
                }
                setAttribute(e, t) {
                    return this.attributes[e] = t,
                    this
                }
                deleteAttribute(e) {
                    return delete this.attributes[e],
                    this
                }
                hasAttribute(e) {
                    return void 0 !== this.attributes[e]
                }
                addGroup(e, t, n=0) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: n
                    })
                }
                clearGroups() {
                    this.groups = []
                }
                setDrawRange(e, t) {
                    this.drawRange.start = e,
                    this.drawRange.count = t
                }
                applyMatrix4(e) {
                    const t = this.attributes.position;
                    void 0 !== t && (t.applyMatrix4(e),
                    t.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const t = (new Rn).getNormalMatrix(e);
                        n.applyNormalMatrix(t),
                        n.needsUpdate = !0
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(e),
                    i.needsUpdate = !0),
                    null !== this.boundingBox && this.computeBoundingBox(),
                    null !== this.boundingSphere && this.computeBoundingSphere(),
                    this
                }
                applyQuaternion(e) {
                    return Cr.makeRotationFromQuaternion(e),
                    this.applyMatrix4(Cr),
                    this
                }
                rotateX(e) {
                    return Cr.makeRotationX(e),
                    this.applyMatrix4(Cr),
                    this
                }
                rotateY(e) {
                    return Cr.makeRotationY(e),
                    this.applyMatrix4(Cr),
                    this
                }
                rotateZ(e) {
                    return Cr.makeRotationZ(e),
                    this.applyMatrix4(Cr),
                    this
                }
                translate(e, t, n) {
                    return Cr.makeTranslation(e, t, n),
                    this.applyMatrix4(Cr),
                    this
                }
                scale(e, t, n) {
                    return Cr.makeScale(e, t, n),
                    this.applyMatrix4(Cr),
                    this
                }
                lookAt(e) {
                    return Rr.lookAt(e),
                    Rr.updateMatrix(),
                    this.applyMatrix4(Rr.matrix),
                    this
                }
                center() {
                    return this.computeBoundingBox(),
                    this.boundingBox.getCenter(Pr).negate(),
                    this.translate(Pr.x, Pr.y, Pr.z),
                    this
                }
                setFromPoints(e) {
                    const t = this.getAttribute("position");
                    if (void 0 === t) {
                        const t = [];
                        for (let n = 0, i = e.length; n < i; n++) {
                            const i = e[n];
                            t.push(i.x, i.y, i.z || 0)
                        }
                        this.setAttribute("position", new Mr(t,3))
                    } else {
                        const n = Math.min(e.length, t.count);
                        for (let i = 0; i < n; i++) {
                            const n = e[i];
                            t.setXYZ(i, n.x, n.y, n.z || 0)
                        }
                        e.length > t.count && cn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                        t.needsUpdate = !0
                    }
                    return this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new Yn);
                    const e = this.attributes.position
                      , t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute)
                        return hn("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                        void this.boundingBox.set(new Mn(-1 / 0,-1 / 0,-1 / 0), new Mn(1 / 0,1 / 0,1 / 0));
                    if (void 0 !== e) {
                        if (this.boundingBox.setFromBufferAttribute(e),
                        t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Ir.setFromBufferAttribute(n),
                                this.morphTargetsRelative ? (Nr.addVectors(this.boundingBox.min, Ir.min),
                                this.boundingBox.expandByPoint(Nr),
                                Nr.addVectors(this.boundingBox.max, Ir.max),
                                this.boundingBox.expandByPoint(Nr)) : (this.boundingBox.expandByPoint(Ir.min),
                                this.boundingBox.expandByPoint(Ir.max))
                            }
                    } else
                        this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && hn('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new gi);
                    const e = this.attributes.position
                      , t = this.morphAttributes.position;
                    if (e && e.isGLBufferAttribute)
                        return hn("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                        void this.boundingSphere.set(new Mn, 1 / 0);
                    if (e) {
                        const n = this.boundingSphere.center;
                        if (Ir.setFromBufferAttribute(e),
                        t)
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                Lr.setFromBufferAttribute(n),
                                this.morphTargetsRelative ? (Nr.addVectors(Ir.min, Lr.min),
                                Ir.expandByPoint(Nr),
                                Nr.addVectors(Ir.max, Lr.max),
                                Ir.expandByPoint(Nr)) : (Ir.expandByPoint(Lr.min),
                                Ir.expandByPoint(Lr.max))
                            }
                        Ir.getCenter(n);
                        let i = 0;
                        for (let t = 0, r = e.count; t < r; t++)
                            Nr.fromBufferAttribute(e, t),
                            i = Math.max(i, n.distanceToSquared(Nr));
                        if (t)
                            for (let r = 0, a = t.length; r < a; r++) {
                                const a = t[r]
                                  , s = this.morphTargetsRelative;
                                for (let t = 0, r = a.count; t < r; t++)
                                    Nr.fromBufferAttribute(a, t),
                                    s && (Pr.fromBufferAttribute(e, t),
                                    Nr.add(Pr)),
                                    i = Math.max(i, n.distanceToSquared(Nr))
                            }
                        this.boundingSphere.radius = Math.sqrt(i),
                        isNaN(this.boundingSphere.radius) && hn('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
                computeTangents() {
                    const e = this.index
                      , t = this.attributes;
                    if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                        return void hn("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const n = t.position
                      , i = t.normal
                      , r = t.uv;
                    !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Er(new Float32Array(4 * n.count),4));
                    const a = this.getAttribute("tangent")
                      , s = []
                      , o = [];
                    for (let e = 0; e < n.count; e++)
                        s[e] = new Mn,
                        o[e] = new Mn;
                    const l = new Mn
                      , c = new Mn
                      , h = new Mn
                      , d = new Tn
                      , u = new Tn
                      , p = new Tn
                      , f = new Mn
                      , g = new Mn;
                    function m(e, t, i) {
                        l.fromBufferAttribute(n, e),
                        c.fromBufferAttribute(n, t),
                        h.fromBufferAttribute(n, i),
                        d.fromBufferAttribute(r, e),
                        u.fromBufferAttribute(r, t),
                        p.fromBufferAttribute(r, i),
                        c.sub(l),
                        h.sub(l),
                        u.sub(d),
                        p.sub(d);
                        const a = 1 / (u.x * p.y - p.x * u.y);
                        isFinite(a) && (f.copy(c).multiplyScalar(p.y).addScaledVector(h, -u.y).multiplyScalar(a),
                        g.copy(h).multiplyScalar(u.x).addScaledVector(c, -p.x).multiplyScalar(a),
                        s[e].add(f),
                        s[t].add(f),
                        s[i].add(f),
                        o[e].add(g),
                        o[t].add(g),
                        o[i].add(g))
                    }
                    let A = this.groups;
                    0 === A.length && (A = [{
                        start: 0,
                        count: e.count
                    }]);
                    for (let t = 0, n = A.length; t < n; ++t) {
                        const n = A[t]
                          , i = n.start;
                        for (let t = i, r = i + n.count; t < r; t += 3)
                            m(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                    }
                    const v = new Mn
                      , y = new Mn
                      , w = new Mn
                      , b = new Mn;
                    function x(e) {
                        w.fromBufferAttribute(i, e),
                        b.copy(w);
                        const t = s[e];
                        v.copy(t),
                        v.sub(w.multiplyScalar(w.dot(t))).normalize(),
                        y.crossVectors(b, t);
                        const n = y.dot(o[e]) < 0 ? -1 : 1;
                        a.setXYZW(e, v.x, v.y, v.z, n)
                    }
                    for (let t = 0, n = A.length; t < n; ++t) {
                        const n = A[t]
                          , i = n.start;
                        for (let t = i, r = i + n.count; t < r; t += 3)
                            x(e.getX(t + 0)),
                            x(e.getX(t + 1)),
                            x(e.getX(t + 2))
                    }
                }
                computeVertexNormals() {
                    const e = this.index
                      , t = this.getAttribute("position");
                    if (void 0 !== t) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n)
                            n = new Er(new Float32Array(3 * t.count),3),
                            this.setAttribute("normal", n);
                        else
                            for (let e = 0, t = n.count; e < t; e++)
                                n.setXYZ(e, 0, 0, 0);
                        const i = new Mn
                          , r = new Mn
                          , a = new Mn
                          , s = new Mn
                          , o = new Mn
                          , l = new Mn
                          , c = new Mn
                          , h = new Mn;
                        if (e)
                            for (let d = 0, u = e.count; d < u; d += 3) {
                                const u = e.getX(d + 0)
                                  , p = e.getX(d + 1)
                                  , f = e.getX(d + 2);
                                i.fromBufferAttribute(t, u),
                                r.fromBufferAttribute(t, p),
                                a.fromBufferAttribute(t, f),
                                c.subVectors(a, r),
                                h.subVectors(i, r),
                                c.cross(h),
                                s.fromBufferAttribute(n, u),
                                o.fromBufferAttribute(n, p),
                                l.fromBufferAttribute(n, f),
                                s.add(c),
                                o.add(c),
                                l.add(c),
                                n.setXYZ(u, s.x, s.y, s.z),
                                n.setXYZ(p, o.x, o.y, o.z),
                                n.setXYZ(f, l.x, l.y, l.z)
                            }
                        else
                            for (let e = 0, s = t.count; e < s; e += 3)
                                i.fromBufferAttribute(t, e + 0),
                                r.fromBufferAttribute(t, e + 1),
                                a.fromBufferAttribute(t, e + 2),
                                c.subVectors(a, r),
                                h.subVectors(i, r),
                                c.cross(h),
                                n.setXYZ(e + 0, c.x, c.y, c.z),
                                n.setXYZ(e + 1, c.x, c.y, c.z),
                                n.setXYZ(e + 2, c.x, c.y, c.z);
                        this.normalizeNormals(),
                        n.needsUpdate = !0
                    }
                }
                normalizeNormals() {
                    const e = this.attributes.normal;
                    for (let t = 0, n = e.count; t < n; t++)
                        Nr.fromBufferAttribute(e, t),
                        Nr.normalize(),
                        e.setXYZ(t, Nr.x, Nr.y, Nr.z)
                }
                toNonIndexed() {
                    function e(e, t) {
                        const n = e.array
                          , i = e.itemSize
                          , r = e.normalized
                          , a = new n.constructor(t.length * i);
                        let s = 0
                          , o = 0;
                        for (let r = 0, l = t.length; r < l; r++) {
                            s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                            for (let e = 0; e < i; e++)
                                a[o++] = n[s++]
                        }
                        return new Er(a,i,r)
                    }
                    if (null === this.index)
                        return cn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                        this;
                    const t = new zr
                      , n = this.index.array
                      , i = this.attributes;
                    for (const r in i) {
                        const a = e(i[r], n);
                        t.setAttribute(r, a)
                    }
                    const r = this.morphAttributes;
                    for (const i in r) {
                        const a = []
                          , s = r[i];
                        for (let t = 0, i = s.length; t < i; t++) {
                            const i = e(s[t], n);
                            a.push(i)
                        }
                        t.morphAttributes[i] = a
                    }
                    t.morphTargetsRelative = this.morphTargetsRelative;
                    const a = this.groups;
                    for (let e = 0, n = a.length; e < n; e++) {
                        const n = a[e];
                        t.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return t
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.7,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid,
                    e.type = this.type,
                    "" !== this.name && (e.name = this.name),
                    Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                    void 0 !== this.parameters) {
                        const t = this.parameters;
                        for (const n in t)
                            void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    const t = this.index;
                    null !== t && (e.data.index = {
                        type: t.array.constructor.name,
                        array: Array.prototype.slice.call(t.array)
                    });
                    const n = this.attributes;
                    for (const t in n) {
                        const i = n[t];
                        e.data.attributes[t] = i.toJSON(e.data)
                    }
                    const i = {};
                    let r = !1;
                    for (const t in this.morphAttributes) {
                        const n = this.morphAttributes[t]
                          , a = [];
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            a.push(i.toJSON(e.data))
                        }
                        a.length > 0 && (i[t] = a,
                        r = !0)
                    }
                    r && (e.data.morphAttributes = i,
                    e.data.morphTargetsRelative = this.morphTargetsRelative);
                    const a = this.groups;
                    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
                    const s = this.boundingSphere;
                    return null !== s && (e.data.boundingSphere = s.toJSON()),
                    e
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    this.index = null,
                    this.attributes = {},
                    this.morphAttributes = {},
                    this.groups = [],
                    this.boundingBox = null,
                    this.boundingSphere = null;
                    const t = {};
                    this.name = e.name;
                    const n = e.index;
                    null !== n && this.setIndex(n.clone());
                    const i = e.attributes;
                    for (const e in i) {
                        const n = i[e];
                        this.setAttribute(e, n.clone(t))
                    }
                    const r = e.morphAttributes;
                    for (const e in r) {
                        const n = []
                          , i = r[e];
                        for (let e = 0, r = i.length; e < r; e++)
                            n.push(i[e].clone(t));
                        this.morphAttributes[e] = n
                    }
                    this.morphTargetsRelative = e.morphTargetsRelative;
                    const a = e.groups;
                    for (let e = 0, t = a.length; e < t; e++) {
                        const t = a[e];
                        this.addGroup(t.start, t.count, t.materialIndex)
                    }
                    const s = e.boundingBox;
                    null !== s && (this.boundingBox = s.clone());
                    const o = e.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()),
                    this.drawRange.start = e.drawRange.start,
                    this.drawRange.count = e.drawRange.count,
                    this.userData = e.userData,
                    this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            const Ur = new Ei
              , Dr = new Si
              , Br = new gi
              , Gr = new Mn
              , Fr = new Mn
              , Or = new Mn
              , Wr = new Mn
              , Vr = new Mn
              , Hr = new Mn
              , jr = new Mn
              , Kr = new Mn;
            class qr extends Yi {
                constructor(e=new zr, t=new wr) {
                    super(),
                    this.isMesh = !0,
                    this.type = "Mesh",
                    this.geometry = e,
                    this.material = t,
                    this.morphTargetDictionary = void 0,
                    this.morphTargetInfluences = void 0,
                    this.count = 1,
                    this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                    void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                    this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                    this.geometry = e.geometry,
                    this
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes
                      , t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
                getVertexPosition(e, t) {
                    const n = this.geometry
                      , i = n.attributes.position
                      , r = n.morphAttributes.position
                      , a = n.morphTargetsRelative;
                    t.fromBufferAttribute(i, e);
                    const s = this.morphTargetInfluences;
                    if (r && s) {
                        Hr.set(0, 0, 0);
                        for (let n = 0, i = r.length; n < i; n++) {
                            const i = s[n]
                              , o = r[n];
                            0 !== i && (Vr.fromBufferAttribute(o, e),
                            a ? Hr.addScaledVector(Vr, i) : Hr.addScaledVector(Vr.sub(t), i))
                        }
                        t.add(Hr)
                    }
                    return t
                }
                raycast(e, t) {
                    const n = this.geometry
                      , i = this.material
                      , r = this.matrixWorld;
                    if (void 0 !== i) {
                        if (null === n.boundingSphere && n.computeBoundingSphere(),
                        Br.copy(n.boundingSphere),
                        Br.applyMatrix4(r),
                        Dr.copy(e.ray).recast(e.near),
                        !1 === Br.containsPoint(Dr.origin)) {
                            if (null === Dr.intersectSphere(Br, Gr))
                                return;
                            if (Dr.origin.distanceToSquared(Gr) > (e.far - e.near) ** 2)
                                return
                        }
                        Ur.copy(r).invert(),
                        Dr.copy(e.ray).applyMatrix4(Ur),
                        null !== n.boundingBox && !1 === Dr.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Dr)
                    }
                }
                _computeIntersections(e, t, n) {
                    let i;
                    const r = this.geometry
                      , a = this.material
                      , s = r.index
                      , o = r.attributes.position
                      , l = r.attributes.uv
                      , c = r.attributes.uv1
                      , h = r.attributes.normal
                      , d = r.groups
                      , u = r.drawRange;
                    if (null !== s)
                        if (Array.isArray(a))
                            for (let r = 0, o = d.length; r < o; r++) {
                                const o = d[r]
                                  , p = a[o.materialIndex];
                                for (let r = Math.max(o.start, u.start), a = Math.min(s.count, Math.min(o.start + o.count, u.start + u.count)); r < a; r += 3) {
                                    i = Qr(this, p, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                    i && (i.faceIndex = Math.floor(r / 3),
                                    i.face.materialIndex = o.materialIndex,
                                    t.push(i))
                                }
                            }
                        else {
                            for (let r = Math.max(0, u.start), o = Math.min(s.count, u.start + u.count); r < o; r += 3) {
                                i = Qr(this, a, e, n, l, c, h, s.getX(r), s.getX(r + 1), s.getX(r + 2)),
                                i && (i.faceIndex = Math.floor(r / 3),
                                t.push(i))
                            }
                        }
                    else if (void 0 !== o)
                        if (Array.isArray(a))
                            for (let r = 0, s = d.length; r < s; r++) {
                                const s = d[r]
                                  , p = a[s.materialIndex];
                                for (let r = Math.max(s.start, u.start), a = Math.min(o.count, Math.min(s.start + s.count, u.start + u.count)); r < a; r += 3) {
                                    i = Qr(this, p, e, n, l, c, h, r, r + 1, r + 2),
                                    i && (i.faceIndex = Math.floor(r / 3),
                                    i.face.materialIndex = s.materialIndex,
                                    t.push(i))
                                }
                            }
                        else {
                            for (let r = Math.max(0, u.start), s = Math.min(o.count, u.start + u.count); r < s; r += 3) {
                                i = Qr(this, a, e, n, l, c, h, r, r + 1, r + 2),
                                i && (i.faceIndex = Math.floor(r / 3),
                                t.push(i))
                            }
                        }
                }
            }
            function Qr(e, t, n, i, r, a, s, o, l, c) {
                e.getVertexPosition(o, Fr),
                e.getVertexPosition(l, Or),
                e.getVertexPosition(c, Wr);
                const h = function(e, t, n, i, r, a, s, o) {
                    let l;
                    if (l = t.side === p ? i.intersectTriangle(s, a, r, !0, o) : i.intersectTriangle(r, a, s, t.side === u, o),
                    null === l)
                        return null;
                    Kr.copy(o),
                    Kr.applyMatrix4(e.matrixWorld);
                    const c = n.ray.origin.distanceTo(Kr);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: Kr.clone(),
                        object: e
                    }
                }(e, t, n, i, Fr, Or, Wr, jr);
                if (h) {
                    const e = new Mn;
                    dr.getBarycoord(jr, Fr, Or, Wr, e),
                    r && (h.uv = dr.getInterpolatedAttribute(r, o, l, c, e, new Tn)),
                    a && (h.uv1 = dr.getInterpolatedAttribute(a, o, l, c, e, new Tn)),
                    s && (h.normal = dr.getInterpolatedAttribute(s, o, l, c, e, new Mn),
                    h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
                    const t = {
                        a: o,
                        b: l,
                        c,
                        normal: new Mn,
                        materialIndex: 0
                    };
                    dr.getNormal(Fr, Or, Wr, t.normal),
                    h.face = t,
                    h.barycoord = e
                }
                return h
            }
            class Jr extends zr {
                constructor(e=1, t=1, n=1, i=1, r=1, a=1) {
                    super(),
                    this.type = "BoxGeometry",
                    this.parameters = {
                        width: e,
                        height: t,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: a
                    };
                    const s = this;
                    i = Math.floor(i),
                    r = Math.floor(r),
                    a = Math.floor(a);
                    const o = []
                      , l = []
                      , c = []
                      , h = [];
                    let d = 0
                      , u = 0;
                    function p(e, t, n, i, r, a, p, f, g, m, A) {
                        const v = a / g
                          , y = p / m
                          , w = a / 2
                          , b = p / 2
                          , x = f / 2
                          , S = g + 1
                          , E = m + 1;
                        let T = 0
                          , k = 0;
                        const M = new Mn;
                        for (let a = 0; a < E; a++) {
                            const s = a * y - b;
                            for (let o = 0; o < S; o++) {
                                const d = o * v - w;
                                M[e] = d * i,
                                M[t] = s * r,
                                M[n] = x,
                                l.push(M.x, M.y, M.z),
                                M[e] = 0,
                                M[t] = 0,
                                M[n] = f > 0 ? 1 : -1,
                                c.push(M.x, M.y, M.z),
                                h.push(o / g),
                                h.push(1 - a / m),
                                T += 1
                            }
                        }
                        for (let e = 0; e < m; e++)
                            for (let t = 0; t < g; t++) {
                                const n = d + t + S * e
                                  , i = d + t + S * (e + 1)
                                  , r = d + (t + 1) + S * (e + 1)
                                  , a = d + (t + 1) + S * e;
                                o.push(n, i, a),
                                o.push(i, r, a),
                                k += 6
                            }
                        s.addGroup(u, k, A),
                        u += k,
                        d += T
                    }
                    p("z", "y", "x", -1, -1, n, t, e, a, r, 0),
                    p("z", "y", "x", 1, -1, n, t, -e, a, r, 1),
                    p("x", "z", "y", 1, 1, e, n, t, i, a, 2),
                    p("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
                    p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                    p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                    this.setIndex(o),
                    this.setAttribute("position", new Mr(l,3)),
                    this.setAttribute("normal", new Mr(c,3)),
                    this.setAttribute("uv", new Mr(h,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                static fromJSON(e) {
                    return new Jr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
                }
            }
            function Xr(e) {
                const t = {};
                for (const n in e) {
                    t[n] = {};
                    for (const i in e[n]) {
                        const r = e[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (cn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                        t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                    }
                }
                return t
            }
            function Yr(e) {
                const t = {};
                for (let n = 0; n < e.length; n++) {
                    const i = Xr(e[n]);
                    for (const e in i)
                        t[e] = i[e]
                }
                return t
            }
            function Zr(e) {
                const t = e.getRenderTarget();
                return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : zn.workingColorSpace
            }
            const $r = {
                clone: Xr,
                merge: Yr
            };
            class ea extends yr {
                constructor(e) {
                    super(),
                    this.isShaderMaterial = !0,
                    this.type = "ShaderMaterial",
                    this.defines = {},
                    this.uniforms = {},
                    this.uniformsGroups = [],
                    this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                    this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                    this.linewidth = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.fog = !1,
                    this.lights = !1,
                    this.clipping = !1,
                    this.forceSinglePass = !0,
                    this.extensions = {
                        clipCullDistance: !1,
                        multiDraw: !1
                    },
                    this.defaultAttributeValues = {
                        color: [1, 1, 1],
                        uv: [0, 0],
                        uv1: [0, 0]
                    },
                    this.index0AttributeName = void 0,
                    this.uniformsNeedUpdate = !1,
                    this.glslVersion = null,
                    void 0 !== e && this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.fragmentShader = e.fragmentShader,
                    this.vertexShader = e.vertexShader,
                    this.uniforms = Xr(e.uniforms),
                    this.uniformsGroups = function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; n++)
                            t.push(e[n].clone());
                        return t
                    }(e.uniformsGroups),
                    this.defines = Object.assign({}, e.defines),
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.fog = e.fog,
                    this.lights = e.lights,
                    this.clipping = e.clipping,
                    this.extensions = Object.assign({}, e.extensions),
                    this.glslVersion = e.glslVersion,
                    this.defaultAttributeValues = Object.assign({}, e.defaultAttributeValues),
                    this.index0AttributeName = e.index0AttributeName,
                    this.uniformsNeedUpdate = e.uniformsNeedUpdate,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    t.glslVersion = this.glslVersion,
                    t.uniforms = {};
                    for (const n in this.uniforms) {
                        const i = this.uniforms[n].value;
                        i && i.isTexture ? t.uniforms[n] = {
                            type: "t",
                            value: i.toJSON(e).uuid
                        } : i && i.isColor ? t.uniforms[n] = {
                            type: "c",
                            value: i.getHex()
                        } : i && i.isVector2 ? t.uniforms[n] = {
                            type: "v2",
                            value: i.toArray()
                        } : i && i.isVector3 ? t.uniforms[n] = {
                            type: "v3",
                            value: i.toArray()
                        } : i && i.isVector4 ? t.uniforms[n] = {
                            type: "v4",
                            value: i.toArray()
                        } : i && i.isMatrix3 ? t.uniforms[n] = {
                            type: "m3",
                            value: i.toArray()
                        } : i && i.isMatrix4 ? t.uniforms[n] = {
                            type: "m4",
                            value: i.toArray()
                        } : t.uniforms[n] = {
                            value: i
                        }
                    }
                    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                    t.vertexShader = this.vertexShader,
                    t.fragmentShader = this.fragmentShader,
                    t.lights = this.lights,
                    t.clipping = this.clipping;
                    const n = {};
                    for (const e in this.extensions)
                        !0 === this.extensions[e] && (n[e] = !0);
                    return Object.keys(n).length > 0 && (t.extensions = n),
                    t
                }
            }
            class ta extends Yi {
                constructor() {
                    super(),
                    this.isCamera = !0,
                    this.type = "Camera",
                    this.matrixWorldInverse = new Ei,
                    this.projectionMatrix = new Ei,
                    this.projectionMatrixInverse = new Ei,
                    this.coordinateSystem = $t,
                    this._reversedDepth = !1
                }
                get reversedDepth() {
                    return this._reversedDepth
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.matrixWorldInverse.copy(e.matrixWorldInverse),
                    this.projectionMatrix.copy(e.projectionMatrix),
                    this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                    this.coordinateSystem = e.coordinateSystem,
                    this
                }
                getWorldDirection(e) {
                    return super.getWorldDirection(e).negate()
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                updateWorldMatrix(e, t) {
                    super.updateWorldMatrix(e, t),
                    this.matrixWorldInverse.copy(this.matrixWorld).invert()
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const na = new Mn
              , ia = new Tn
              , ra = new Tn;
            class aa extends ta {
                constructor(e=50, t=1, n=.1, i=2e3) {
                    super(),
                    this.isPerspectiveCamera = !0,
                    this.type = "PerspectiveCamera",
                    this.fov = e,
                    this.zoom = 1,
                    this.near = n,
                    this.far = i,
                    this.focus = 10,
                    this.aspect = t,
                    this.view = null,
                    this.filmGauge = 35,
                    this.filmOffset = 0,
                    this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.fov = e.fov,
                    this.zoom = e.zoom,
                    this.near = e.near,
                    this.far = e.far,
                    this.focus = e.focus,
                    this.aspect = e.aspect,
                    this.view = null === e.view ? null : Object.assign({}, e.view),
                    this.filmGauge = e.filmGauge,
                    this.filmOffset = e.filmOffset,
                    this
                }
                setFocalLength(e) {
                    const t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * An * Math.atan(t),
                    this.updateProjectionMatrix()
                }
                getFocalLength() {
                    const e = Math.tan(.5 * mn * this.fov);
                    return .5 * this.getFilmHeight() / e
                }
                getEffectiveFOV() {
                    return 2 * An * Math.atan(Math.tan(.5 * mn * this.fov) / this.zoom)
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                }
                getViewBounds(e, t, n) {
                    na.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                    t.set(na.x, na.y).multiplyScalar(-e / na.z),
                    na.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                    n.set(na.x, na.y).multiplyScalar(-e / na.z)
                }
                getViewSize(e, t) {
                    return this.getViewBounds(e, ia, ra),
                    t.subVectors(ra, ia)
                }
                setViewOffset(e, t, n, i, r, a) {
                    this.aspect = e / t,
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }),
                    this.view.enabled = !0,
                    this.view.fullWidth = e,
                    this.view.fullHeight = t,
                    this.view.offsetX = n,
                    this.view.offsetY = i,
                    this.view.width = r,
                    this.view.height = a,
                    this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = this.near;
                    let t = e * Math.tan(.5 * mn * this.fov) / this.zoom
                      , n = 2 * t
                      , i = this.aspect * n
                      , r = -.5 * i;
                    const a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const e = a.fullWidth
                          , s = a.fullHeight;
                        r += a.offsetX * i / e,
                        t -= a.offsetY * n / s,
                        i *= a.width / e,
                        n *= a.height / s
                    }
                    const s = this.filmOffset;
                    0 !== s && (r += e * s / this.getFilmWidth()),
                    this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth),
                    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.fov = this.fov,
                    t.object.zoom = this.zoom,
                    t.object.near = this.near,
                    t.object.far = this.far,
                    t.object.focus = this.focus,
                    t.object.aspect = this.aspect,
                    null !== this.view && (t.object.view = Object.assign({}, this.view)),
                    t.object.filmGauge = this.filmGauge,
                    t.object.filmOffset = this.filmOffset,
                    t
                }
            }
            const sa = -90;
            class oa extends Yi {
                constructor(e, t, n) {
                    super(),
                    this.type = "CubeCamera",
                    this.renderTarget = n,
                    this.coordinateSystem = null,
                    this.activeMipmapLevel = 0;
                    const i = new aa(sa,1,e,t);
                    i.layers = this.layers,
                    this.add(i);
                    const r = new aa(sa,1,e,t);
                    r.layers = this.layers,
                    this.add(r);
                    const a = new aa(sa,1,e,t);
                    a.layers = this.layers,
                    this.add(a);
                    const s = new aa(sa,1,e,t);
                    s.layers = this.layers,
                    this.add(s);
                    const o = new aa(sa,1,e,t);
                    o.layers = this.layers,
                    this.add(o);
                    const l = new aa(sa,1,e,t);
                    l.layers = this.layers,
                    this.add(l)
                }
                updateCoordinateSystem() {
                    const e = this.coordinateSystem
                      , t = this.children.concat()
                      , [n,i,r,a,s,o] = t;
                    for (const e of t)
                        this.remove(e);
                    if (e === $t)
                        n.up.set(0, 1, 0),
                        n.lookAt(1, 0, 0),
                        i.up.set(0, 1, 0),
                        i.lookAt(-1, 0, 0),
                        r.up.set(0, 0, -1),
                        r.lookAt(0, 1, 0),
                        a.up.set(0, 0, 1),
                        a.lookAt(0, -1, 0),
                        s.up.set(0, 1, 0),
                        s.lookAt(0, 0, 1),
                        o.up.set(0, 1, 0),
                        o.lookAt(0, 0, -1);
                    else {
                        if (e !== en)
                            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                        n.up.set(0, -1, 0),
                        n.lookAt(-1, 0, 0),
                        i.up.set(0, -1, 0),
                        i.lookAt(1, 0, 0),
                        r.up.set(0, 0, 1),
                        r.lookAt(0, 1, 0),
                        a.up.set(0, 0, -1),
                        a.lookAt(0, -1, 0),
                        s.up.set(0, -1, 0),
                        s.lookAt(0, 0, 1),
                        o.up.set(0, -1, 0),
                        o.lookAt(0, 0, -1)
                    }
                    for (const e of t)
                        this.add(e),
                        e.updateMatrixWorld()
                }
                update(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    const {renderTarget: n, activeMipmapLevel: i} = this;
                    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                    this.updateCoordinateSystem());
                    const [r,a,s,o,l,c] = this.children
                      , h = e.getRenderTarget()
                      , d = e.getActiveCubeFace()
                      , u = e.getActiveMipmapLevel()
                      , p = e.xr.enabled;
                    e.xr.enabled = !1;
                    const f = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1,
                    e.setRenderTarget(n, 0, i),
                    e.render(t, r),
                    e.setRenderTarget(n, 1, i),
                    e.render(t, a),
                    e.setRenderTarget(n, 2, i),
                    e.render(t, s),
                    e.setRenderTarget(n, 3, i),
                    e.render(t, o),
                    e.setRenderTarget(n, 4, i),
                    e.render(t, l),
                    n.texture.generateMipmaps = f,
                    e.setRenderTarget(n, 5, i),
                    e.render(t, c),
                    e.setRenderTarget(h, d, u),
                    e.xr.enabled = p,
                    n.texture.needsPMREMUpdate = !0
                }
            }
            class la extends jn {
                constructor(e=[], t=oe, n, i, r, a, s, o, l, c) {
                    super(e, t, n, i, r, a, s, o, l, c),
                    this.isCubeTexture = !0,
                    this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class ca extends Qn {
                constructor(e=1, t={}) {
                    super(e, e, t),
                    this.isWebGLCubeRenderTarget = !0;
                    const n = {
                        width: e,
                        height: e,
                        depth: 1
                    }
                      , i = [n, n, n, n, n, n];
                    this.texture = new la(i),
                    this._setTextureOptions(t),
                    this.texture.isRenderTargetTexture = !0
                }
                fromEquirectangularTexture(e, t) {
                    this.texture.type = t.type,
                    this.texture.colorSpace = t.colorSpace,
                    this.texture.generateMipmaps = t.generateMipmaps,
                    this.texture.minFilter = t.minFilter,
                    this.texture.magFilter = t.magFilter;
                    const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    }
                      , i = new Jr(5,5,5)
                      , r = new ea({
                        name: "CubemapFromEquirect",
                        uniforms: Xr(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: p,
                        blending: g
                    });
                    r.uniforms.tEquirect.value = t;
                    const a = new qr(i,r)
                      , s = t.minFilter;
                    t.minFilter === we && (t.minFilter = ve);
                    return new oa(1,10,this).update(e, a),
                    t.minFilter = s,
                    a.geometry.dispose(),
                    a.material.dispose(),
                    this
                }
                clear(e, t=!0, n=!0, i=!0) {
                    const r = e.getRenderTarget();
                    for (let r = 0; r < 6; r++)
                        e.setRenderTarget(this, r),
                        e.clear(t, n, i);
                    e.setRenderTarget(r)
                }
            }
            class ha extends Yi {
                constructor() {
                    super(),
                    this.isGroup = !0,
                    this.type = "Group"
                }
            }
            const da = {
                type: "move"
            };
            class ua {
                constructor() {
                    this._targetRay = null,
                    this._grip = null,
                    this._hand = null
                }
                getHandSpace() {
                    return null === this._hand && (this._hand = new ha,
                    this._hand.matrixAutoUpdate = !1,
                    this._hand.visible = !1,
                    this._hand.joints = {},
                    this._hand.inputState = {
                        pinching: !1
                    }),
                    this._hand
                }
                getTargetRaySpace() {
                    return null === this._targetRay && (this._targetRay = new ha,
                    this._targetRay.matrixAutoUpdate = !1,
                    this._targetRay.visible = !1,
                    this._targetRay.hasLinearVelocity = !1,
                    this._targetRay.linearVelocity = new Mn,
                    this._targetRay.hasAngularVelocity = !1,
                    this._targetRay.angularVelocity = new Mn),
                    this._targetRay
                }
                getGripSpace() {
                    return null === this._grip && (this._grip = new ha,
                    this._grip.matrixAutoUpdate = !1,
                    this._grip.visible = !1,
                    this._grip.hasLinearVelocity = !1,
                    this._grip.linearVelocity = new Mn,
                    this._grip.hasAngularVelocity = !1,
                    this._grip.angularVelocity = new Mn),
                    this._grip
                }
                dispatchEvent(e) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                    null !== this._grip && this._grip.dispatchEvent(e),
                    null !== this._hand && this._hand.dispatchEvent(e),
                    this
                }
                connect(e) {
                    if (e && e.hand) {
                        const t = this._hand;
                        if (t)
                            for (const n of e.hand.values())
                                this._getHandJoint(t, n)
                    }
                    return this.dispatchEvent({
                        type: "connected",
                        data: e
                    }),
                    this
                }
                disconnect(e) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: e
                    }),
                    null !== this._targetRay && (this._targetRay.visible = !1),
                    null !== this._grip && (this._grip.visible = !1),
                    null !== this._hand && (this._hand.visible = !1),
                    this
                }
                update(e, t, n) {
                    let i = null
                      , r = null
                      , a = null;
                    const s = this._targetRay
                      , o = this._grip
                      , l = this._hand;
                    if (e && "visible-blurred" !== t.session.visibilityState) {
                        if (l && e.hand) {
                            a = !0;
                            for (const i of e.hand.values()) {
                                const e = t.getJointPose(i, n)
                                  , r = this._getHandJoint(l, i);
                                null !== e && (r.matrix.fromArray(e.transform.matrix),
                                r.matrix.decompose(r.position, r.rotation, r.scale),
                                r.matrixWorldNeedsUpdate = !0,
                                r.jointRadius = e.radius),
                                r.visible = null !== e
                            }
                            const i = l.joints["index-finger-tip"]
                              , r = l.joints["thumb-tip"]
                              , s = i.position.distanceTo(r.position)
                              , o = .02
                              , c = .005;
                            l.inputState.pinching && s > o + c ? (l.inputState.pinching = !1,
                            this.dispatchEvent({
                                type: "pinchend",
                                handedness: e.handedness,
                                target: this
                            })) : !l.inputState.pinching && s <= o - c && (l.inputState.pinching = !0,
                            this.dispatchEvent({
                                type: "pinchstart",
                                handedness: e.handedness,
                                target: this
                            }))
                        } else
                            null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                            null !== r && (o.matrix.fromArray(r.transform.matrix),
                            o.matrix.decompose(o.position, o.rotation, o.scale),
                            o.matrixWorldNeedsUpdate = !0,
                            r.linearVelocity ? (o.hasLinearVelocity = !0,
                            o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                            r.angularVelocity ? (o.hasAngularVelocity = !0,
                            o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                        null !== s && (i = t.getPose(e.targetRaySpace, n),
                        null === i && null !== r && (i = r),
                        null !== i && (s.matrix.fromArray(i.transform.matrix),
                        s.matrix.decompose(s.position, s.rotation, s.scale),
                        s.matrixWorldNeedsUpdate = !0,
                        i.linearVelocity ? (s.hasLinearVelocity = !0,
                        s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1,
                        i.angularVelocity ? (s.hasAngularVelocity = !0,
                        s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1,
                        this.dispatchEvent(da)))
                    }
                    return null !== s && (s.visible = null !== i),
                    null !== o && (o.visible = null !== r),
                    null !== l && (l.visible = null !== a),
                    this
                }
                _getHandJoint(e, t) {
                    if (void 0 === e.joints[t.jointName]) {
                        const n = new ha;
                        n.matrixAutoUpdate = !1,
                        n.visible = !1,
                        e.joints[t.jointName] = n,
                        e.add(n)
                    }
                    return e.joints[t.jointName]
                }
            }
            class pa {
                constructor(e, t=1, n=1e3) {
                    this.isFog = !0,
                    this.name = "",
                    this.color = new mr(e),
                    this.near = t,
                    this.far = n
                }
                clone() {
                    return new pa(this.color,this.near,this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        name: this.name,
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            class fa extends Yi {
                constructor() {
                    super(),
                    this.isScene = !0,
                    this.type = "Scene",
                    this.background = null,
                    this.environment = null,
                    this.fog = null,
                    this.backgroundBlurriness = 0,
                    this.backgroundIntensity = 1,
                    this.backgroundRotation = new Ni,
                    this.environmentIntensity = 1,
                    this.environmentRotation = new Ni,
                    this.overrideMaterial = null,
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                        detail: this
                    }))
                }
                copy(e, t) {
                    return super.copy(e, t),
                    null !== e.background && (this.background = e.background.clone()),
                    null !== e.environment && (this.environment = e.environment.clone()),
                    null !== e.fog && (this.fog = e.fog.clone()),
                    this.backgroundBlurriness = e.backgroundBlurriness,
                    this.backgroundIntensity = e.backgroundIntensity,
                    this.backgroundRotation.copy(e.backgroundRotation),
                    this.environmentIntensity = e.environmentIntensity,
                    this.environmentRotation.copy(e.environmentRotation),
                    null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                    this.matrixAutoUpdate = e.matrixAutoUpdate,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                    this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                    1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                    t.object.backgroundRotation = this.backgroundRotation.toArray(),
                    1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity),
                    t.object.environmentRotation = this.environmentRotation.toArray(),
                    t
                }
            }
            class ga {
                constructor(e, t) {
                    this.isInterleavedBuffer = !0,
                    this.array = e,
                    this.stride = t,
                    this.count = void 0 !== e ? e.length / t : 0,
                    this.usage = Yt,
                    this.updateRanges = [],
                    this.version = 0,
                    this.uuid = vn()
                }
                onUploadCallback() {}
                set needsUpdate(e) {
                    !0 === e && this.version++
                }
                setUsage(e) {
                    return this.usage = e,
                    this
                }
                addUpdateRange(e, t) {
                    this.updateRanges.push({
                        start: e,
                        count: t
                    })
                }
                clearUpdateRanges() {
                    this.updateRanges.length = 0
                }
                copy(e) {
                    return this.array = new e.array.constructor(e.array),
                    this.count = e.count,
                    this.stride = e.stride,
                    this.usage = e.usage,
                    this
                }
                copyAt(e, t, n) {
                    e *= this.stride,
                    n *= t.stride;
                    for (let i = 0, r = this.stride; i < r; i++)
                        this.array[e + i] = t.array[n + i];
                    return this
                }
                set(e, t=0) {
                    return this.array.set(e, t),
                    this
                }
                clone(e) {
                    void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = vn()),
                    void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                      , n = new this.constructor(t,this.stride);
                    return n.setUsage(this.usage),
                    n
                }
                onUpload(e) {
                    return this.onUploadCallback = e,
                    this
                }
                toJSON(e) {
                    return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                    void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = vn()),
                    void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                    {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            }
            const ma = new Mn;
            class Aa {
                constructor(e, t, n, i=!1) {
                    this.isInterleavedBufferAttribute = !0,
                    this.name = "",
                    this.data = e,
                    this.itemSize = t,
                    this.offset = n,
                    this.normalized = i
                }
                get count() {
                    return this.data.count
                }
                get array() {
                    return this.data.array
                }
                set needsUpdate(e) {
                    this.data.needsUpdate = e
                }
                applyMatrix4(e) {
                    for (let t = 0, n = this.data.count; t < n; t++)
                        ma.fromBufferAttribute(this, t),
                        ma.applyMatrix4(e),
                        this.setXYZ(t, ma.x, ma.y, ma.z);
                    return this
                }
                applyNormalMatrix(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        ma.fromBufferAttribute(this, t),
                        ma.applyNormalMatrix(e),
                        this.setXYZ(t, ma.x, ma.y, ma.z);
                    return this
                }
                transformDirection(e) {
                    for (let t = 0, n = this.count; t < n; t++)
                        ma.fromBufferAttribute(this, t),
                        ma.transformDirection(e),
                        this.setXYZ(t, ma.x, ma.y, ma.z);
                    return this
                }
                getComponent(e, t) {
                    let n = this.array[e * this.data.stride + this.offset + t];
                    return this.normalized && (n = xn(n, this.array)),
                    n
                }
                setComponent(e, t, n) {
                    return this.normalized && (n = Sn(n, this.array)),
                    this.data.array[e * this.data.stride + this.offset + t] = n,
                    this
                }
                setX(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.data.array[e * this.data.stride + this.offset] = t,
                    this
                }
                setY(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.data.array[e * this.data.stride + this.offset + 1] = t,
                    this
                }
                setZ(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.data.array[e * this.data.stride + this.offset + 2] = t,
                    this
                }
                setW(e, t) {
                    return this.normalized && (t = Sn(t, this.array)),
                    this.data.array[e * this.data.stride + this.offset + 3] = t,
                    this
                }
                getX(e) {
                    let t = this.data.array[e * this.data.stride + this.offset];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                getY(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 1];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                getZ(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 2];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                getW(e) {
                    let t = this.data.array[e * this.data.stride + this.offset + 3];
                    return this.normalized && (t = xn(t, this.array)),
                    t
                }
                setXY(e, t, n) {
                    return e = e * this.data.stride + this.offset,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array)),
                    this.data.array[e + 0] = t,
                    this.data.array[e + 1] = n,
                    this
                }
                setXYZ(e, t, n, i) {
                    return e = e * this.data.stride + this.offset,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array),
                    i = Sn(i, this.array)),
                    this.data.array[e + 0] = t,
                    this.data.array[e + 1] = n,
                    this.data.array[e + 2] = i,
                    this
                }
                setXYZW(e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset,
                    this.normalized && (t = Sn(t, this.array),
                    n = Sn(n, this.array),
                    i = Sn(i, this.array),
                    r = Sn(r, this.array)),
                    this.data.array[e + 0] = t,
                    this.data.array[e + 1] = n,
                    this.data.array[e + 2] = i,
                    this.data.array[e + 3] = r,
                    this
                }
                clone(e) {
                    if (void 0 === e) {
                        ln("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++)
                                e.push(this.data.array[n + t])
                        }
                        return new Er(new this.array.constructor(e),this.itemSize,this.normalized)
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                    void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                    new Aa(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
                }
                toJSON(e) {
                    if (void 0 === e) {
                        ln("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                        const e = [];
                        for (let t = 0; t < this.count; t++) {
                            const n = t * this.data.stride + this.offset;
                            for (let t = 0; t < this.itemSize; t++)
                                e.push(this.data.array[n + t])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: e,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                    void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                    {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            }
            const va = new Mn
              , ya = new Kn
              , wa = new Kn
              , ba = new Mn
              , xa = new Ei
              , Sa = new Mn
              , Ea = new gi
              , Ta = new Ei
              , ka = new Si;
            class Ma extends qr {
                constructor(e, t) {
                    super(e, t),
                    this.isSkinnedMesh = !0,
                    this.type = "SkinnedMesh",
                    this.bindMode = se,
                    this.bindMatrix = new Ei,
                    this.bindMatrixInverse = new Ei,
                    this.boundingBox = null,
                    this.boundingSphere = null
                }
                computeBoundingBox() {
                    const e = this.geometry;
                    null === this.boundingBox && (this.boundingBox = new Yn),
                    this.boundingBox.makeEmpty();
                    const t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++)
                        this.getVertexPosition(e, Sa),
                        this.boundingBox.expandByPoint(Sa)
                }
                computeBoundingSphere() {
                    const e = this.geometry;
                    null === this.boundingSphere && (this.boundingSphere = new gi),
                    this.boundingSphere.makeEmpty();
                    const t = e.getAttribute("position");
                    for (let e = 0; e < t.count; e++)
                        this.getVertexPosition(e, Sa),
                        this.boundingSphere.expandByPoint(Sa)
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.bindMode = e.bindMode,
                    this.bindMatrix.copy(e.bindMatrix),
                    this.bindMatrixInverse.copy(e.bindMatrixInverse),
                    this.skeleton = e.skeleton,
                    null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                    this
                }
                raycast(e, t) {
                    const n = this.material
                      , i = this.matrixWorld;
                    void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                    Ea.copy(this.boundingSphere),
                    Ea.applyMatrix4(i),
                    !1 !== e.ray.intersectsSphere(Ea) && (Ta.copy(i).invert(),
                    ka.copy(e.ray).applyMatrix4(Ta),
                    null !== this.boundingBox && !1 === ka.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, ka)))
                }
                getVertexPosition(e, t) {
                    return super.getVertexPosition(e, t),
                    this.applyBoneTransform(e, t),
                    t
                }
                bind(e, t) {
                    this.skeleton = e,
                    void 0 === t && (this.updateMatrixWorld(!0),
                    this.skeleton.calculateInverses(),
                    t = this.matrixWorld),
                    this.bindMatrix.copy(t),
                    this.bindMatrixInverse.copy(t).invert()
                }
                pose() {
                    this.skeleton.pose()
                }
                normalizeSkinWeights() {
                    const e = new Kn
                      , t = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = t.count; n < i; n++) {
                        e.fromBufferAttribute(t, n);
                        const i = 1 / e.manhattanLength();
                        i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                        t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                }
                updateMatrixWorld(e) {
                    super.updateMatrixWorld(e),
                    this.bindMode === se ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : cn("SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                }
                applyBoneTransform(e, t) {
                    const n = this.skeleton
                      , i = this.geometry;
                    ya.fromBufferAttribute(i.attributes.skinIndex, e),
                    wa.fromBufferAttribute(i.attributes.skinWeight, e),
                    va.copy(t).applyMatrix4(this.bindMatrix),
                    t.set(0, 0, 0);
                    for (let e = 0; e < 4; e++) {
                        const i = wa.getComponent(e);
                        if (0 !== i) {
                            const r = ya.getComponent(e);
                            xa.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                            t.addScaledVector(ba.copy(va).applyMatrix4(xa), i)
                        }
                    }
                    return t.applyMatrix4(this.bindMatrixInverse)
                }
            }
            class _a extends Yi {
                constructor() {
                    super(),
                    this.isBone = !0,
                    this.type = "Bone"
                }
            }
            class Ca extends jn {
                constructor(e=null, t=1, n=1, i, r, a, s, o, l=ge, c=ge, h, d) {
                    super(null, a, s, o, l, c, i, r, h, d),
                    this.isDataTexture = !0,
                    this.image = {
                        data: e,
                        width: t,
                        height: n
                    },
                    this.generateMipmaps = !1,
                    this.flipY = !1,
                    this.unpackAlignment = 1
                }
            }
            const Ra = new Ei
              , Pa = new Ei;
            class Ia {
                constructor(e=[], t=[]) {
                    this.uuid = vn(),
                    this.bones = e.slice(0),
                    this.boneInverses = t,
                    this.boneMatrices = null,
                    this.previousBoneMatrices = null,
                    this.boneTexture = null,
                    this.init()
                }
                init() {
                    const e = this.bones
                      , t = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * e.length),
                    0 === t.length)
                        this.calculateInverses();
                    else if (e.length !== t.length) {
                        cn("Skeleton: Number of inverse bone matrices does not match amount of bones."),
                        this.boneInverses = [];
                        for (let e = 0, t = this.bones.length; e < t; e++)
                            this.boneInverses.push(new Ei)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = new Ei;
                        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                        this.boneInverses.push(t)
                    }
                }
                pose() {
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                    }
                    for (let e = 0, t = this.bones.length; e < t; e++) {
                        const t = this.bones[e];
                        t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                        t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                        t.matrix.decompose(t.position, t.quaternion, t.scale))
                    }
                }
                update() {
                    const e = this.bones
                      , t = this.boneInverses
                      , n = this.boneMatrices
                      , i = this.boneTexture;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i] ? e[i].matrixWorld : Pa;
                        Ra.multiplyMatrices(r, t[i]),
                        Ra.toArray(n, 16 * i)
                    }
                    null !== i && (i.needsUpdate = !0)
                }
                clone() {
                    return new Ia(this.bones,this.boneInverses)
                }
                computeBoneTexture() {
                    let e = Math.sqrt(4 * this.bones.length);
                    e = 4 * Math.ceil(e / 4),
                    e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4);
                    t.set(this.boneMatrices);
                    const n = new Ca(t,e,e,Ue,Me);
                    return n.needsUpdate = !0,
                    this.boneMatrices = t,
                    this.boneTexture = n,
                    this
                }
                getBoneByName(e) {
                    for (let t = 0, n = this.bones.length; t < n; t++) {
                        const n = this.bones[t];
                        if (n.name === e)
                            return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(),
                    this.boneTexture = null)
                }
                fromJSON(e, t) {
                    this.uuid = e.uuid;
                    for (let n = 0, i = e.bones.length; n < i; n++) {
                        const i = e.bones[n];
                        let r = t[i];
                        void 0 === r && (cn("Skeleton: No bone found with UUID:", i),
                        r = new _a),
                        this.bones.push(r),
                        this.boneInverses.push((new Ei).fromArray(e.boneInverses[n]))
                    }
                    return this.init(),
                    this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.7,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    e.uuid = this.uuid;
                    const t = this.bones
                      , n = this.boneInverses;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i];
                        e.bones.push(r.uuid);
                        const a = n[i];
                        e.boneInverses.push(a.toArray())
                    }
                    return e
                }
            }
            class La extends Er {
                constructor(e, t, n, i=1) {
                    super(e, t, n),
                    this.isInstancedBufferAttribute = !0,
                    this.meshPerAttribute = i
                }
                copy(e) {
                    return super.copy(e),
                    this.meshPerAttribute = e.meshPerAttribute,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.meshPerAttribute = this.meshPerAttribute,
                    e.isInstancedBufferAttribute = !0,
                    e
                }
            }
            const Na = new Ei
              , za = new Ei
              , Ua = []
              , Da = new Yn
              , Ba = new Ei
              , Ga = new qr
              , Fa = new gi;
            class Oa extends qr {
                constructor(e, t, n) {
                    super(e, t),
                    this.isInstancedMesh = !0,
                    this.instanceMatrix = new La(new Float32Array(16 * n),16),
                    this.instanceColor = null,
                    this.morphTexture = null,
                    this.count = n,
                    this.boundingBox = null,
                    this.boundingSphere = null;
                    for (let e = 0; e < n; e++)
                        this.setMatrixAt(e, Ba)
                }
                computeBoundingBox() {
                    const e = this.geometry
                      , t = this.count;
                    null === this.boundingBox && (this.boundingBox = new Yn),
                    null === e.boundingBox && e.computeBoundingBox(),
                    this.boundingBox.makeEmpty();
                    for (let n = 0; n < t; n++)
                        this.getMatrixAt(n, Na),
                        Da.copy(e.boundingBox).applyMatrix4(Na),
                        this.boundingBox.union(Da)
                }
                computeBoundingSphere() {
                    const e = this.geometry
                      , t = this.count;
                    null === this.boundingSphere && (this.boundingSphere = new gi),
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    this.boundingSphere.makeEmpty();
                    for (let n = 0; n < t; n++)
                        this.getMatrixAt(n, Na),
                        Fa.copy(e.boundingSphere).applyMatrix4(Na),
                        this.boundingSphere.union(Fa)
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.instanceMatrix.copy(e.instanceMatrix),
                    null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()),
                    null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                    this.count = e.count,
                    null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                    this
                }
                getColorAt(e, t) {
                    t.fromArray(this.instanceColor.array, 3 * e)
                }
                getMatrixAt(e, t) {
                    t.fromArray(this.instanceMatrix.array, 16 * e)
                }
                getMorphAt(e, t) {
                    const n = t.morphTargetInfluences
                      , i = this.morphTexture.source.data.data
                      , r = e * (n.length + 1) + 1;
                    for (let e = 0; e < n.length; e++)
                        n[e] = i[r + e]
                }
                raycast(e, t) {
                    const n = this.matrixWorld
                      , i = this.count;
                    if (Ga.geometry = this.geometry,
                    Ga.material = this.material,
                    void 0 !== Ga.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                    Fa.copy(this.boundingSphere),
                    Fa.applyMatrix4(n),
                    !1 !== e.ray.intersectsSphere(Fa)))
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, Na),
                            za.multiplyMatrices(n, Na),
                            Ga.matrixWorld = za,
                            Ga.raycast(e, Ua);
                            for (let e = 0, n = Ua.length; e < n; e++) {
                                const n = Ua[e];
                                n.instanceId = r,
                                n.object = this,
                                t.push(n)
                            }
                            Ua.length = 0
                        }
                }
                setColorAt(e, t) {
                    null === this.instanceColor && (this.instanceColor = new La(new Float32Array(3 * this.instanceMatrix.count).fill(1),3)),
                    t.toArray(this.instanceColor.array, 3 * e)
                }
                setMatrixAt(e, t) {
                    t.toArray(this.instanceMatrix.array, 16 * e)
                }
                setMorphAt(e, t) {
                    const n = t.morphTargetInfluences
                      , i = n.length + 1;
                    null === this.morphTexture && (this.morphTexture = new Ca(new Float32Array(i * this.count),i,this.count,Ge,Me));
                    const r = this.morphTexture.source.data.data;
                    let a = 0;
                    for (let e = 0; e < n.length; e++)
                        a += n[e];
                    const s = this.geometry.morphTargetsRelative ? 1 : 1 - a
                      , o = i * e;
                    r[o] = s,
                    r.set(n, o + 1)
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    }),
                    null !== this.morphTexture && (this.morphTexture.dispose(),
                    this.morphTexture = null)
                }
            }
            const Wa = new Mn
              , Va = new Mn
              , Ha = new Rn;
            class ja {
                constructor(e=new Mn(1,0,0), t=0) {
                    this.isPlane = !0,
                    this.normal = e,
                    this.constant = t
                }
                set(e, t) {
                    return this.normal.copy(e),
                    this.constant = t,
                    this
                }
                setComponents(e, t, n, i) {
                    return this.normal.set(e, t, n),
                    this.constant = i,
                    this
                }
                setFromNormalAndCoplanarPoint(e, t) {
                    return this.normal.copy(e),
                    this.constant = -t.dot(this.normal),
                    this
                }
                setFromCoplanarPoints(e, t, n) {
                    const i = Wa.subVectors(n, t).cross(Va.subVectors(e, t)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, e),
                    this
                }
                copy(e) {
                    return this.normal.copy(e.normal),
                    this.constant = e.constant,
                    this
                }
                normalize() {
                    const e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e),
                    this.constant *= e,
                    this
                }
                negate() {
                    return this.constant *= -1,
                    this.normal.negate(),
                    this
                }
                distanceToPoint(e) {
                    return this.normal.dot(e) + this.constant
                }
                distanceToSphere(e) {
                    return this.distanceToPoint(e.center) - e.radius
                }
                projectPoint(e, t) {
                    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                }
                intersectLine(e, t) {
                    const n = e.delta(Wa)
                      , i = this.normal.dot(n);
                    if (0 === i)
                        return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                    const r = -(e.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
                }
                intersectsLine(e) {
                    const t = this.distanceToPoint(e.start)
                      , n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                }
                intersectsBox(e) {
                    return e.intersectsPlane(this)
                }
                intersectsSphere(e) {
                    return e.intersectsPlane(this)
                }
                coplanarPoint(e) {
                    return e.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(e, t) {
                    const n = t || Ha.getNormalMatrix(e)
                      , i = this.coplanarPoint(Wa).applyMatrix4(e)
                      , r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r),
                    this
                }
                translate(e) {
                    return this.constant -= e.dot(this.normal),
                    this
                }
                equals(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Ka = new gi
              , qa = new Tn(.5,.5)
              , Qa = new Mn;
            class Ja {
                constructor(e=new ja, t=new ja, n=new ja, i=new ja, r=new ja, a=new ja) {
                    this.planes = [e, t, n, i, r, a]
                }
                set(e, t, n, i, r, a) {
                    const s = this.planes;
                    return s[0].copy(e),
                    s[1].copy(t),
                    s[2].copy(n),
                    s[3].copy(i),
                    s[4].copy(r),
                    s[5].copy(a),
                    this
                }
                copy(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        t[n].copy(e.planes[n]);
                    return this
                }
                setFromProjectionMatrix(e, t=$t, n=!1) {
                    const i = this.planes
                      , r = e.elements
                      , a = r[0]
                      , s = r[1]
                      , o = r[2]
                      , l = r[3]
                      , c = r[4]
                      , h = r[5]
                      , d = r[6]
                      , u = r[7]
                      , p = r[8]
                      , f = r[9]
                      , g = r[10]
                      , m = r[11]
                      , A = r[12]
                      , v = r[13]
                      , y = r[14]
                      , w = r[15];
                    if (i[0].setComponents(l - a, u - c, m - p, w - A).normalize(),
                    i[1].setComponents(l + a, u + c, m + p, w + A).normalize(),
                    i[2].setComponents(l + s, u + h, m + f, w + v).normalize(),
                    i[3].setComponents(l - s, u - h, m - f, w - v).normalize(),
                    n)
                        i[4].setComponents(o, d, g, y).normalize(),
                        i[5].setComponents(l - o, u - d, m - g, w - y).normalize();
                    else if (i[4].setComponents(l - o, u - d, m - g, w - y).normalize(),
                    t === $t)
                        i[5].setComponents(l + o, u + d, m + g, w + y).normalize();
                    else {
                        if (t !== en)
                            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                        i[5].setComponents(o, d, g, y).normalize()
                    }
                    return this
                }
                intersectsObject(e) {
                    if (void 0 !== e.boundingSphere)
                        null === e.boundingSphere && e.computeBoundingSphere(),
                        Ka.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                    else {
                        const t = e.geometry;
                        null === t.boundingSphere && t.computeBoundingSphere(),
                        Ka.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                    }
                    return this.intersectsSphere(Ka)
                }
                intersectsSprite(e) {
                    Ka.center.set(0, 0, 0);
                    const t = qa.distanceTo(e.center);
                    return Ka.radius = .7071067811865476 + t,
                    Ka.applyMatrix4(e.matrixWorld),
                    this.intersectsSphere(Ka)
                }
                intersectsSphere(e) {
                    const t = this.planes
                      , n = e.center
                      , i = -e.radius;
                    for (let e = 0; e < 6; e++) {
                        if (t[e].distanceToPoint(n) < i)
                            return !1
                    }
                    return !0
                }
                intersectsBox(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = t[n];
                        if (Qa.x = i.normal.x > 0 ? e.max.x : e.min.x,
                        Qa.y = i.normal.y > 0 ? e.max.y : e.min.y,
                        Qa.z = i.normal.z > 0 ? e.max.z : e.min.z,
                        i.distanceToPoint(Qa) < 0)
                            return !1
                    }
                    return !0
                }
                containsPoint(e) {
                    const t = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0)
                            return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Xa = new Ei
              , Ya = new Ja;
            class Za {
                constructor() {
                    this.coordinateSystem = $t
                }
                intersectsObject(e, t) {
                    if (!t.isArrayCamera || 0 === t.cameras.length)
                        return !1;
                    for (let n = 0; n < t.cameras.length; n++) {
                        const i = t.cameras[n];
                        if (Xa.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                        Ya.setFromProjectionMatrix(Xa, i.coordinateSystem, i.reversedDepth),
                        Ya.intersectsObject(e))
                            return !0
                    }
                    return !1
                }
                intersectsSprite(e, t) {
                    if (!t || !t.cameras || 0 === t.cameras.length)
                        return !1;
                    for (let n = 0; n < t.cameras.length; n++) {
                        const i = t.cameras[n];
                        if (Xa.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                        Ya.setFromProjectionMatrix(Xa, i.coordinateSystem, i.reversedDepth),
                        Ya.intersectsSprite(e))
                            return !0
                    }
                    return !1
                }
                intersectsSphere(e, t) {
                    if (!t || !t.cameras || 0 === t.cameras.length)
                        return !1;
                    for (let n = 0; n < t.cameras.length; n++) {
                        const i = t.cameras[n];
                        if (Xa.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                        Ya.setFromProjectionMatrix(Xa, i.coordinateSystem, i.reversedDepth),
                        Ya.intersectsSphere(e))
                            return !0
                    }
                    return !1
                }
                intersectsBox(e, t) {
                    if (!t || !t.cameras || 0 === t.cameras.length)
                        return !1;
                    for (let n = 0; n < t.cameras.length; n++) {
                        const i = t.cameras[n];
                        if (Xa.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                        Ya.setFromProjectionMatrix(Xa, i.coordinateSystem, i.reversedDepth),
                        Ya.intersectsBox(e))
                            return !0
                    }
                    return !1
                }
                containsPoint(e, t) {
                    if (!t || !t.cameras || 0 === t.cameras.length)
                        return !1;
                    for (let n = 0; n < t.cameras.length; n++) {
                        const i = t.cameras[n];
                        if (Xa.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
                        Ya.setFromProjectionMatrix(Xa, i.coordinateSystem, i.reversedDepth),
                        Ya.containsPoint(e))
                            return !0
                    }
                    return !1
                }
                clone() {
                    return new Za
                }
            }
            function $a(e, t) {
                return e - t
            }
            function es(e, t) {
                return e.z - t.z
            }
            function ts(e, t) {
                return t.z - e.z
            }
            class ns {
                constructor() {
                    this.index = 0,
                    this.pool = [],
                    this.list = []
                }
                push(e, t, n, i) {
                    const r = this.pool
                      , a = this.list;
                    this.index >= r.length && r.push({
                        start: -1,
                        count: -1,
                        z: -1,
                        index: -1
                    });
                    const s = r[this.index];
                    a.push(s),
                    this.index++,
                    s.start = e,
                    s.count = t,
                    s.z = n,
                    s.index = i
                }
                reset() {
                    this.list.length = 0,
                    this.index = 0
                }
            }
            const is = new Ei
              , rs = new mr(1,1,1)
              , as = new Ja
              , ss = new Za
              , os = new Yn
              , ls = new gi
              , cs = new Mn
              , hs = new Mn
              , ds = new Mn
              , us = new ns
              , ps = new qr
              , fs = [];
            function gs(e, t, n=0) {
                const i = t.itemSize;
                if (e.isInterleavedBufferAttribute || e.array.constructor !== t.array.constructor) {
                    const r = e.count;
                    for (let a = 0; a < r; a++)
                        for (let r = 0; r < i; r++)
                            t.setComponent(a + n, r, e.getComponent(a, r))
                } else
                    t.array.set(e.array, n * i);
                t.needsUpdate = !0
            }
            function ms(e, t) {
                if (e.constructor !== t.constructor) {
                    const n = Math.min(e.length, t.length);
                    for (let i = 0; i < n; i++)
                        t[i] = e[i]
                } else {
                    const n = Math.min(e.length, t.length);
                    t.set(new e.constructor(e.buffer,0,n))
                }
            }
            class As extends qr {
                constructor(e, t, n=2 * t, i) {
                    super(new zr, i),
                    this.isBatchedMesh = !0,
                    this.perObjectFrustumCulled = !0,
                    this.sortObjects = !0,
                    this.boundingBox = null,
                    this.boundingSphere = null,
                    this.customSort = null,
                    this._instanceInfo = [],
                    this._geometryInfo = [],
                    this._availableInstanceIds = [],
                    this._availableGeometryIds = [],
                    this._nextIndexStart = 0,
                    this._nextVertexStart = 0,
                    this._geometryCount = 0,
                    this._visibilityChanged = !0,
                    this._geometryInitialized = !1,
                    this._maxInstanceCount = e,
                    this._maxVertexCount = t,
                    this._maxIndexCount = n,
                    this._multiDrawCounts = new Int32Array(e),
                    this._multiDrawStarts = new Int32Array(e),
                    this._multiDrawCount = 0,
                    this._multiDrawInstances = null,
                    this._matricesTexture = null,
                    this._indirectTexture = null,
                    this._colorsTexture = null,
                    this._initMatricesTexture(),
                    this._initIndirectTexture()
                }
                get maxInstanceCount() {
                    return this._maxInstanceCount
                }
                get instanceCount() {
                    return this._instanceInfo.length - this._availableInstanceIds.length
                }
                get unusedVertexCount() {
                    return this._maxVertexCount - this._nextVertexStart
                }
                get unusedIndexCount() {
                    return this._maxIndexCount - this._nextIndexStart
                }
                _initMatricesTexture() {
                    let e = Math.sqrt(4 * this._maxInstanceCount);
                    e = 4 * Math.ceil(e / 4),
                    e = Math.max(e, 4);
                    const t = new Float32Array(e * e * 4)
                      , n = new Ca(t,e,e,Ue,Me);
                    this._matricesTexture = n
                }
                _initIndirectTexture() {
                    let e = Math.sqrt(this._maxInstanceCount);
                    e = Math.ceil(e);
                    const t = new Uint32Array(e * e)
                      , n = new Ca(t,e,e,Fe,ke);
                    this._indirectTexture = n
                }
                _initColorsTexture() {
                    let e = Math.sqrt(this._maxInstanceCount);
                    e = Math.ceil(e);
                    const t = new Float32Array(e * e * 4).fill(1)
                      , n = new Ca(t,e,e,Ue,Me);
                    n.colorSpace = zn.workingColorSpace,
                    this._colorsTexture = n
                }
                _initializeGeometry(e) {
                    const t = this.geometry
                      , n = this._maxVertexCount
                      , i = this._maxIndexCount;
                    if (!1 === this._geometryInitialized) {
                        for (const i in e.attributes) {
                            const r = e.getAttribute(i)
                              , {array: a, itemSize: s, normalized: o} = r
                              , l = new a.constructor(n * s)
                              , c = new Er(l,s,o);
                            t.setAttribute(i, c)
                        }
                        if (null !== e.getIndex()) {
                            const e = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                            t.setIndex(new Er(e,1))
                        }
                        this._geometryInitialized = !0
                    }
                }
                _validateGeometry(e) {
                    const t = this.geometry;
                    if (Boolean(e.getIndex()) !== Boolean(t.getIndex()))
                        throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
                    for (const n in t.attributes) {
                        if (!e.hasAttribute(n))
                            throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
                        const i = e.getAttribute(n)
                          , r = t.getAttribute(n);
                        if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
                            throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
                    }
                }
                validateInstanceId(e) {
                    const t = this._instanceInfo;
                    if (e < 0 || e >= t.length || !1 === t[e].active)
                        throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
                }
                validateGeometryId(e) {
                    const t = this._geometryInfo;
                    if (e < 0 || e >= t.length || !1 === t[e].active)
                        throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
                }
                setCustomSort(e) {
                    return this.customSort = e,
                    this
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new Yn);
                    const e = this.boundingBox
                      , t = this._instanceInfo;
                    e.makeEmpty();
                    for (let n = 0, i = t.length; n < i; n++) {
                        if (!1 === t[n].active)
                            continue;
                        const i = t[n].geometryIndex;
                        this.getMatrixAt(n, is),
                        this.getBoundingBoxAt(i, os).applyMatrix4(is),
                        e.union(os)
                    }
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new gi);
                    const e = this.boundingSphere
                      , t = this._instanceInfo;
                    e.makeEmpty();
                    for (let n = 0, i = t.length; n < i; n++) {
                        if (!1 === t[n].active)
                            continue;
                        const i = t[n].geometryIndex;
                        this.getMatrixAt(n, is),
                        this.getBoundingSphereAt(i, ls).applyMatrix4(is),
                        e.union(ls)
                    }
                }
                addInstance(e) {
                    if (this._instanceInfo.length >= this.maxInstanceCount && 0 === this._availableInstanceIds.length)
                        throw new Error("THREE.BatchedMesh: Maximum item count reached.");
                    const t = {
                        visible: !0,
                        active: !0,
                        geometryIndex: e
                    };
                    let n = null;
                    this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort($a),
                    n = this._availableInstanceIds.shift(),
                    this._instanceInfo[n] = t) : (n = this._instanceInfo.length,
                    this._instanceInfo.push(t));
                    const i = this._matricesTexture;
                    is.identity().toArray(i.image.data, 16 * n),
                    i.needsUpdate = !0;
                    const r = this._colorsTexture;
                    return r && (rs.toArray(r.image.data, 4 * n),
                    r.needsUpdate = !0),
                    this._visibilityChanged = !0,
                    n
                }
                addGeometry(e, t=-1, n=-1) {
                    this._initializeGeometry(e),
                    this._validateGeometry(e);
                    const i = {
                        vertexStart: -1,
                        vertexCount: -1,
                        reservedVertexCount: -1,
                        indexStart: -1,
                        indexCount: -1,
                        reservedIndexCount: -1,
                        start: -1,
                        count: -1,
                        boundingBox: null,
                        boundingSphere: null,
                        active: !0
                    }
                      , r = this._geometryInfo;
                    i.vertexStart = this._nextVertexStart,
                    i.reservedVertexCount = -1 === t ? e.getAttribute("position").count : t;
                    const a = e.getIndex();
                    if (null !== a && (i.indexStart = this._nextIndexStart,
                    i.reservedIndexCount = -1 === n ? a.count : n),
                    -1 !== i.indexStart && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
                        throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
                    let s;
                    return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort($a),
                    s = this._availableGeometryIds.shift(),
                    r[s] = i) : (s = this._geometryCount,
                    this._geometryCount++,
                    r.push(i)),
                    this.setGeometryAt(s, e),
                    this._nextIndexStart = i.indexStart + i.reservedIndexCount,
                    this._nextVertexStart = i.vertexStart + i.reservedVertexCount,
                    s
                }
                setGeometryAt(e, t) {
                    if (e >= this._geometryCount)
                        throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
                    this._validateGeometry(t);
                    const n = this.geometry
                      , i = null !== n.getIndex()
                      , r = n.getIndex()
                      , a = t.getIndex()
                      , s = this._geometryInfo[e];
                    if (i && a.count > s.reservedIndexCount || t.attributes.position.count > s.reservedVertexCount)
                        throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
                    const o = s.vertexStart
                      , l = s.reservedVertexCount;
                    s.vertexCount = t.getAttribute("position").count;
                    for (const e in n.attributes) {
                        const i = t.getAttribute(e)
                          , r = n.getAttribute(e);
                        gs(i, r, o);
                        const a = i.itemSize;
                        for (let e = i.count, t = l; e < t; e++) {
                            const t = o + e;
                            for (let e = 0; e < a; e++)
                                r.setComponent(t, e, 0)
                        }
                        r.needsUpdate = !0,
                        r.addUpdateRange(o * a, l * a)
                    }
                    if (i) {
                        const e = s.indexStart
                          , n = s.reservedIndexCount;
                        s.indexCount = t.getIndex().count;
                        for (let t = 0; t < a.count; t++)
                            r.setX(e + t, o + a.getX(t));
                        for (let t = a.count, i = n; t < i; t++)
                            r.setX(e + t, o);
                        r.needsUpdate = !0,
                        r.addUpdateRange(e, s.reservedIndexCount)
                    }
                    return s.start = i ? s.indexStart : s.vertexStart,
                    s.count = i ? s.indexCount : s.vertexCount,
                    s.boundingBox = null,
                    null !== t.boundingBox && (s.boundingBox = t.boundingBox.clone()),
                    s.boundingSphere = null,
                    null !== t.boundingSphere && (s.boundingSphere = t.boundingSphere.clone()),
                    this._visibilityChanged = !0,
                    e
                }
                deleteGeometry(e) {
                    const t = this._geometryInfo;
                    if (e >= t.length || !1 === t[e].active)
                        return this;
                    const n = this._instanceInfo;
                    for (let t = 0, i = n.length; t < i; t++)
                        n[t].active && n[t].geometryIndex === e && this.deleteInstance(t);
                    return t[e].active = !1,
                    this._availableGeometryIds.push(e),
                    this._visibilityChanged = !0,
                    this
                }
                deleteInstance(e) {
                    return this.validateInstanceId(e),
                    this._instanceInfo[e].active = !1,
                    this._availableInstanceIds.push(e),
                    this._visibilityChanged = !0,
                    this
                }
                optimize() {
                    let e = 0
                      , t = 0;
                    const n = this._geometryInfo
                      , i = n.map(( (e, t) => t)).sort(( (e, t) => n[e].vertexStart - n[t].vertexStart))
                      , r = this.geometry;
                    for (let a = 0, s = n.length; a < s; a++) {
                        const s = i[a]
                          , o = n[s];
                        if (!1 !== o.active) {
                            if (null !== r.index) {
                                if (o.indexStart !== t) {
                                    const {indexStart: n, vertexStart: i, reservedIndexCount: a} = o
                                      , s = r.index
                                      , l = s.array
                                      , c = e - i;
                                    for (let e = n; e < n + a; e++)
                                        l[e] = l[e] + c;
                                    s.array.copyWithin(t, n, n + a),
                                    s.addUpdateRange(t, a),
                                    s.needsUpdate = !0,
                                    o.indexStart = t
                                }
                                t += o.reservedIndexCount
                            }
                            if (o.vertexStart !== e) {
                                const {vertexStart: t, reservedVertexCount: n} = o
                                  , i = r.attributes;
                                for (const r in i) {
                                    const a = i[r]
                                      , {array: s, itemSize: o} = a;
                                    s.copyWithin(e * o, t * o, (t + n) * o),
                                    a.addUpdateRange(e * o, n * o),
                                    a.needsUpdate = !0
                                }
                                o.vertexStart = e
                            }
                            e += o.reservedVertexCount,
                            o.start = r.index ? o.indexStart : o.vertexStart,
                            this._nextIndexStart = r.index ? o.indexStart + o.reservedIndexCount : 0,
                            this._nextVertexStart = o.vertexStart + o.reservedVertexCount
                        }
                    }
                    return this._visibilityChanged = !0,
                    this
                }
                getBoundingBoxAt(e, t) {
                    if (e >= this._geometryCount)
                        return null;
                    const n = this.geometry
                      , i = this._geometryInfo[e];
                    if (null === i.boundingBox) {
                        const e = new Yn
                          , t = n.index
                          , r = n.attributes.position;
                        for (let n = i.start, a = i.start + i.count; n < a; n++) {
                            let i = n;
                            t && (i = t.getX(i)),
                            e.expandByPoint(cs.fromBufferAttribute(r, i))
                        }
                        i.boundingBox = e
                    }
                    return t.copy(i.boundingBox),
                    t
                }
                getBoundingSphereAt(e, t) {
                    if (e >= this._geometryCount)
                        return null;
                    const n = this.geometry
                      , i = this._geometryInfo[e];
                    if (null === i.boundingSphere) {
                        const t = new gi;
                        this.getBoundingBoxAt(e, os),
                        os.getCenter(t.center);
                        const r = n.index
                          , a = n.attributes.position;
                        let s = 0;
                        for (let e = i.start, n = i.start + i.count; e < n; e++) {
                            let n = e;
                            r && (n = r.getX(n)),
                            cs.fromBufferAttribute(a, n),
                            s = Math.max(s, t.center.distanceToSquared(cs))
                        }
                        t.radius = Math.sqrt(s),
                        i.boundingSphere = t
                    }
                    return t.copy(i.boundingSphere),
                    t
                }
                setMatrixAt(e, t) {
                    this.validateInstanceId(e);
                    const n = this._matricesTexture
                      , i = this._matricesTexture.image.data;
                    return t.toArray(i, 16 * e),
                    n.needsUpdate = !0,
                    this
                }
                getMatrixAt(e, t) {
                    return this.validateInstanceId(e),
                    t.fromArray(this._matricesTexture.image.data, 16 * e)
                }
                setColorAt(e, t) {
                    return this.validateInstanceId(e),
                    null === this._colorsTexture && this._initColorsTexture(),
                    t.toArray(this._colorsTexture.image.data, 4 * e),
                    this._colorsTexture.needsUpdate = !0,
                    this
                }
                getColorAt(e, t) {
                    return this.validateInstanceId(e),
                    t.fromArray(this._colorsTexture.image.data, 4 * e)
                }
                setVisibleAt(e, t) {
                    return this.validateInstanceId(e),
                    this._instanceInfo[e].visible === t || (this._instanceInfo[e].visible = t,
                    this._visibilityChanged = !0),
                    this
                }
                getVisibleAt(e) {
                    return this.validateInstanceId(e),
                    this._instanceInfo[e].visible
                }
                setGeometryIdAt(e, t) {
                    return this.validateInstanceId(e),
                    this.validateGeometryId(t),
                    this._instanceInfo[e].geometryIndex = t,
                    this
                }
                getGeometryIdAt(e) {
                    return this.validateInstanceId(e),
                    this._instanceInfo[e].geometryIndex
                }
                getGeometryRangeAt(e, t={}) {
                    this.validateGeometryId(e);
                    const n = this._geometryInfo[e];
                    return t.vertexStart = n.vertexStart,
                    t.vertexCount = n.vertexCount,
                    t.reservedVertexCount = n.reservedVertexCount,
                    t.indexStart = n.indexStart,
                    t.indexCount = n.indexCount,
                    t.reservedIndexCount = n.reservedIndexCount,
                    t.start = n.start,
                    t.count = n.count,
                    t
                }
                setInstanceCount(e) {
                    const t = this._availableInstanceIds
                      , n = this._instanceInfo;
                    for (t.sort($a); t[t.length - 1] === n.length - 1; )
                        n.pop(),
                        t.pop();
                    if (e < n.length)
                        throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
                    const i = new Int32Array(e)
                      , r = new Int32Array(e);
                    ms(this._multiDrawCounts, i),
                    ms(this._multiDrawStarts, r),
                    this._multiDrawCounts = i,
                    this._multiDrawStarts = r,
                    this._maxInstanceCount = e;
                    const a = this._indirectTexture
                      , s = this._matricesTexture
                      , o = this._colorsTexture;
                    a.dispose(),
                    this._initIndirectTexture(),
                    ms(a.image.data, this._indirectTexture.image.data),
                    s.dispose(),
                    this._initMatricesTexture(),
                    ms(s.image.data, this._matricesTexture.image.data),
                    o && (o.dispose(),
                    this._initColorsTexture(),
                    ms(o.image.data, this._colorsTexture.image.data))
                }
                setGeometrySize(e, t) {
                    const n = [...this._geometryInfo].filter((e => e.active));
                    if (Math.max(...n.map((e => e.vertexStart + e.reservedVertexCount))) > e)
                        throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
                    if (this.geometry.index) {
                        if (Math.max(...n.map((e => e.indexStart + e.reservedIndexCount))) > t)
                            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`)
                    }
                    const i = this.geometry;
                    i.dispose(),
                    this._maxVertexCount = e,
                    this._maxIndexCount = t,
                    this._geometryInitialized && (this._geometryInitialized = !1,
                    this.geometry = new zr,
                    this._initializeGeometry(i));
                    const r = this.geometry;
                    i.index && ms(i.index.array, r.index.array);
                    for (const e in i.attributes)
                        ms(i.attributes[e].array, r.attributes[e].array)
                }
                raycast(e, t) {
                    const n = this._instanceInfo
                      , i = this._geometryInfo
                      , r = this.matrixWorld
                      , a = this.geometry;
                    ps.material = this.material,
                    ps.geometry.index = a.index,
                    ps.geometry.attributes = a.attributes,
                    null === ps.geometry.boundingBox && (ps.geometry.boundingBox = new Yn),
                    null === ps.geometry.boundingSphere && (ps.geometry.boundingSphere = new gi);
                    for (let a = 0, s = n.length; a < s; a++) {
                        if (!n[a].visible || !n[a].active)
                            continue;
                        const s = n[a].geometryIndex
                          , o = i[s];
                        ps.geometry.setDrawRange(o.start, o.count),
                        this.getMatrixAt(a, ps.matrixWorld).premultiply(r),
                        this.getBoundingBoxAt(s, ps.geometry.boundingBox),
                        this.getBoundingSphereAt(s, ps.geometry.boundingSphere),
                        ps.raycast(e, fs);
                        for (let e = 0, n = fs.length; e < n; e++) {
                            const n = fs[e];
                            n.object = this,
                            n.batchId = a,
                            t.push(n)
                        }
                        fs.length = 0
                    }
                    ps.material = null,
                    ps.geometry.index = null,
                    ps.geometry.attributes = {},
                    ps.geometry.setDrawRange(0, 1 / 0)
                }
                copy(e) {
                    return super.copy(e),
                    this.geometry = e.geometry.clone(),
                    this.perObjectFrustumCulled = e.perObjectFrustumCulled,
                    this.sortObjects = e.sortObjects,
                    this.boundingBox = null !== e.boundingBox ? e.boundingBox.clone() : null,
                    this.boundingSphere = null !== e.boundingSphere ? e.boundingSphere.clone() : null,
                    this._geometryInfo = e._geometryInfo.map((e => ({
                        ...e,
                        boundingBox: null !== e.boundingBox ? e.boundingBox.clone() : null,
                        boundingSphere: null !== e.boundingSphere ? e.boundingSphere.clone() : null
                    }))),
                    this._instanceInfo = e._instanceInfo.map((e => ({
                        ...e
                    }))),
                    this._availableInstanceIds = e._availableInstanceIds.slice(),
                    this._availableGeometryIds = e._availableGeometryIds.slice(),
                    this._nextIndexStart = e._nextIndexStart,
                    this._nextVertexStart = e._nextVertexStart,
                    this._geometryCount = e._geometryCount,
                    this._maxInstanceCount = e._maxInstanceCount,
                    this._maxVertexCount = e._maxVertexCount,
                    this._maxIndexCount = e._maxIndexCount,
                    this._geometryInitialized = e._geometryInitialized,
                    this._multiDrawCounts = e._multiDrawCounts.slice(),
                    this._multiDrawStarts = e._multiDrawStarts.slice(),
                    this._indirectTexture = e._indirectTexture.clone(),
                    this._indirectTexture.image.data = this._indirectTexture.image.data.slice(),
                    this._matricesTexture = e._matricesTexture.clone(),
                    this._matricesTexture.image.data = this._matricesTexture.image.data.slice(),
                    null !== this._colorsTexture && (this._colorsTexture = e._colorsTexture.clone(),
                    this._colorsTexture.image.data = this._colorsTexture.image.data.slice()),
                    this
                }
                dispose() {
                    this.geometry.dispose(),
                    this._matricesTexture.dispose(),
                    this._matricesTexture = null,
                    this._indirectTexture.dispose(),
                    this._indirectTexture = null,
                    null !== this._colorsTexture && (this._colorsTexture.dispose(),
                    this._colorsTexture = null)
                }
                onBeforeRender(e, t, n, i, r) {
                    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
                        return;
                    const a = i.getIndex()
                      , s = null === a ? 1 : a.array.BYTES_PER_ELEMENT
                      , o = this._instanceInfo
                      , l = this._multiDrawStarts
                      , c = this._multiDrawCounts
                      , h = this._geometryInfo
                      , d = this.perObjectFrustumCulled
                      , u = this._indirectTexture
                      , p = u.image.data
                      , f = n.isArrayCamera ? ss : as;
                    d && !n.isArrayCamera && (is.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
                    as.setFromProjectionMatrix(is, n.coordinateSystem, n.reversedDepth));
                    let g = 0;
                    if (this.sortObjects) {
                        is.copy(this.matrixWorld).invert(),
                        cs.setFromMatrixPosition(n.matrixWorld).applyMatrix4(is),
                        hs.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(is);
                        for (let e = 0, t = o.length; e < t; e++)
                            if (o[e].visible && o[e].active) {
                                const t = o[e].geometryIndex;
                                this.getMatrixAt(e, is),
                                this.getBoundingSphereAt(t, ls).applyMatrix4(is);
                                let i = !1;
                                if (d && (i = !f.intersectsSphere(ls, n)),
                                !i) {
                                    const n = h[t]
                                      , i = ds.subVectors(ls.center, cs).dot(hs);
                                    us.push(n.start, n.count, i, e)
                                }
                            }
                        const e = us.list
                          , t = this.customSort;
                        null === t ? e.sort(r.transparent ? ts : es) : t.call(this, e, n);
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t];
                            l[g] = n.start * s,
                            c[g] = n.count,
                            p[g] = n.index,
                            g++
                        }
                        us.reset()
                    } else
                        for (let e = 0, t = o.length; e < t; e++)
                            if (o[e].visible && o[e].active) {
                                const t = o[e].geometryIndex;
                                let i = !1;
                                if (d && (this.getMatrixAt(e, is),
                                this.getBoundingSphereAt(t, ls).applyMatrix4(is),
                                i = !f.intersectsSphere(ls, n)),
                                !i) {
                                    const n = h[t];
                                    l[g] = n.start * s,
                                    c[g] = n.count,
                                    p[g] = e,
                                    g++
                                }
                            }
                    u.needsUpdate = !0,
                    this._multiDrawCount = g,
                    this._visibilityChanged = !1
                }
                onBeforeShadow(e, t, n, i, r, a) {
                    this.onBeforeRender(e, null, i, r, a)
                }
            }
            class vs extends yr {
                constructor(e) {
                    super(),
                    this.isLineBasicMaterial = !0,
                    this.type = "LineBasicMaterial",
                    this.color = new mr(16777215),
                    this.map = null,
                    this.linewidth = 1,
                    this.linecap = "round",
                    this.linejoin = "round",
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.linewidth = e.linewidth,
                    this.linecap = e.linecap,
                    this.linejoin = e.linejoin,
                    this.fog = e.fog,
                    this
                }
            }
            const ys = new Mn
              , ws = new Mn
              , bs = new Ei
              , xs = new Si
              , Ss = new gi
              , Es = new Mn
              , Ts = new Mn;
            class ks extends Yi {
                constructor(e=new zr, t=new vs) {
                    super(),
                    this.isLine = !0,
                    this.type = "Line",
                    this.geometry = e,
                    this.material = t,
                    this.morphTargetDictionary = void 0,
                    this.morphTargetInfluences = void 0,
                    this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                    this.geometry = e.geometry,
                    this
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position
                          , n = [0];
                        for (let e = 1, i = t.count; e < i; e++)
                            ys.fromBufferAttribute(t, e - 1),
                            ws.fromBufferAttribute(t, e),
                            n[e] = n[e - 1],
                            n[e] += ys.distanceTo(ws);
                        e.setAttribute("lineDistance", new Mr(n,1))
                    } else
                        cn("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
                raycast(e, t) {
                    const n = this.geometry
                      , i = this.matrixWorld
                      , r = e.params.Line.threshold
                      , a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    Ss.copy(n.boundingSphere),
                    Ss.applyMatrix4(i),
                    Ss.radius += r,
                    !1 === e.ray.intersectsSphere(Ss))
                        return;
                    bs.copy(i).invert(),
                    xs.copy(e.ray).applyMatrix4(bs);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , o = s * s
                      , l = this.isLineSegments ? 2 : 1
                      , c = n.index
                      , h = n.attributes.position;
                    if (null !== c) {
                        const n = Math.max(0, a.start)
                          , i = Math.min(c.count, a.start + a.count);
                        for (let r = n, a = i - 1; r < a; r += l) {
                            const n = c.getX(r)
                              , i = c.getX(r + 1)
                              , a = Ms(this, e, xs, o, n, i, r);
                            a && t.push(a)
                        }
                        if (this.isLineLoop) {
                            const r = c.getX(i - 1)
                              , a = c.getX(n)
                              , s = Ms(this, e, xs, o, r, a, i - 1);
                            s && t.push(s)
                        }
                    } else {
                        const n = Math.max(0, a.start)
                          , i = Math.min(h.count, a.start + a.count);
                        for (let r = n, a = i - 1; r < a; r += l) {
                            const n = Ms(this, e, xs, o, r, r + 1, r);
                            n && t.push(n)
                        }
                        if (this.isLineLoop) {
                            const r = Ms(this, e, xs, o, i - 1, n, i - 1);
                            r && t.push(r)
                        }
                    }
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes
                      , t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }
            function Ms(e, t, n, i, r, a, s) {
                const o = e.geometry.attributes.position;
                ys.fromBufferAttribute(o, r),
                ws.fromBufferAttribute(o, a);
                if (n.distanceSqToSegment(ys, ws, Es, Ts) > i)
                    return;
                Es.applyMatrix4(e.matrixWorld);
                const l = t.ray.origin.distanceTo(Es);
                return l < t.near || l > t.far ? void 0 : {
                    distance: l,
                    point: Ts.clone().applyMatrix4(e.matrixWorld),
                    index: s,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: e
                }
            }
            const _s = new Mn
              , Cs = new Mn;
            class Rs extends ks {
                constructor(e, t) {
                    super(e, t),
                    this.isLineSegments = !0,
                    this.type = "LineSegments"
                }
                computeLineDistances() {
                    const e = this.geometry;
                    if (null === e.index) {
                        const t = e.attributes.position
                          , n = [];
                        for (let e = 0, i = t.count; e < i; e += 2)
                            _s.fromBufferAttribute(t, e),
                            Cs.fromBufferAttribute(t, e + 1),
                            n[e] = 0 === e ? 0 : n[e - 1],
                            n[e + 1] = n[e] + _s.distanceTo(Cs);
                        e.setAttribute("lineDistance", new Mr(n,1))
                    } else
                        cn("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    return this
                }
            }
            class Ps extends ks {
                constructor(e, t) {
                    super(e, t),
                    this.isLineLoop = !0,
                    this.type = "LineLoop"
                }
            }
            class Is extends yr {
                constructor(e) {
                    super(),
                    this.isPointsMaterial = !0,
                    this.type = "PointsMaterial",
                    this.color = new mr(16777215),
                    this.map = null,
                    this.alphaMap = null,
                    this.size = 1,
                    this.sizeAttenuation = !0,
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.size = e.size,
                    this.sizeAttenuation = e.sizeAttenuation,
                    this.fog = e.fog,
                    this
                }
            }
            const Ls = new Ei
              , Ns = new Si
              , zs = new gi
              , Us = new Mn;
            class Ds extends Yi {
                constructor(e=new zr, t=new Is) {
                    super(),
                    this.isPoints = !0,
                    this.type = "Points",
                    this.geometry = e,
                    this.material = t,
                    this.morphTargetDictionary = void 0,
                    this.morphTargetInfluences = void 0,
                    this.updateMorphTargets()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                    this.geometry = e.geometry,
                    this
                }
                raycast(e, t) {
                    const n = this.geometry
                      , i = this.matrixWorld
                      , r = e.params.Points.threshold
                      , a = n.drawRange;
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    zs.copy(n.boundingSphere),
                    zs.applyMatrix4(i),
                    zs.radius += r,
                    !1 === e.ray.intersectsSphere(zs))
                        return;
                    Ls.copy(i).invert(),
                    Ns.copy(e.ray).applyMatrix4(Ls);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                      , o = s * s
                      , l = n.index
                      , c = n.attributes.position;
                    if (null !== l) {
                        for (let n = Math.max(0, a.start), r = Math.min(l.count, a.start + a.count); n < r; n++) {
                            const r = l.getX(n);
                            Us.fromBufferAttribute(c, r),
                            Bs(Us, r, o, i, e, t, this)
                        }
                    } else {
                        for (let n = Math.max(0, a.start), r = Math.min(c.count, a.start + a.count); n < r; n++)
                            Us.fromBufferAttribute(c, n),
                            Bs(Us, n, o, i, e, t, this)
                    }
                }
                updateMorphTargets() {
                    const e = this.geometry.morphAttributes
                      , t = Object.keys(e);
                    if (t.length > 0) {
                        const n = e[t[0]];
                        if (void 0 !== n) {
                            this.morphTargetInfluences = [],
                            this.morphTargetDictionary = {};
                            for (let e = 0, t = n.length; e < t; e++) {
                                const t = n[e].name || String(e);
                                this.morphTargetInfluences.push(0),
                                this.morphTargetDictionary[t] = e
                            }
                        }
                    }
                }
            }
            function Bs(e, t, n, i, r, a, s) {
                const o = Ns.distanceSqToPoint(e);
                if (o < n) {
                    const n = new Mn;
                    Ns.closestPointToPoint(e, n),
                    n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far)
                        return;
                    a.push({
                        distance: l,
                        distanceToRay: Math.sqrt(o),
                        point: n,
                        index: t,
                        face: null,
                        faceIndex: null,
                        barycoord: null,
                        object: s
                    })
                }
            }
            class Gs extends jn {
                constructor(e, t, n=ke, i, r, a, s=ge, o=ge, l, c=De, h=1) {
                    if (c !== De && c !== Be)
                        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    super({
                        width: e,
                        height: t,
                        depth: h
                    }, i, r, a, s, o, c, n, l),
                    this.isDepthTexture = !0,
                    this.flipY = !1,
                    this.generateMipmaps = !1,
                    this.compareFunction = null
                }
                copy(e) {
                    return super.copy(e),
                    this.source = new On(Object.assign({}, e.image)),
                    this.compareFunction = e.compareFunction,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                    t
                }
            }
            class Fs extends Gs {
                constructor(e, t=ke, n=oe, i, r, a=ge, s=ge, o, l=De) {
                    const c = {
                        width: e,
                        height: e,
                        depth: 1
                    }
                      , h = [c, c, c, c, c, c];
                    super(e, e, t, n, i, r, a, s, o, l),
                    this.image = h,
                    this.isCubeDepthTexture = !0,
                    this.isCubeTexture = !0
                }
                get images() {
                    return this.image
                }
                set images(e) {
                    this.image = e
                }
            }
            class Os extends jn {
                constructor(e=null) {
                    super(),
                    this.sourceTexture = e,
                    this.isExternalTexture = !0
                }
                copy(e) {
                    return super.copy(e),
                    this.sourceTexture = e.sourceTexture,
                    this
                }
            }
            class Ws {
                constructor() {
                    this.type = "Curve",
                    this.arcLengthDivisions = 200,
                    this.needsUpdate = !1,
                    this.cacheArcLengths = null
                }
                getPoint() {
                    cn("Curve: .getPoint() not implemented.")
                }
                getPointAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                }
                getPoints(e=5) {
                    const t = [];
                    for (let n = 0; n <= e; n++)
                        t.push(this.getPoint(n / e));
                    return t
                }
                getSpacedPoints(e=5) {
                    const t = [];
                    for (let n = 0; n <= e; n++)
                        t.push(this.getPointAt(n / e));
                    return t
                }
                getLength() {
                    const e = this.getLengths();
                    return e[e.length - 1]
                }
                getLengths(e=this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                        return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const t = [];
                    let n, i = this.getPoint(0), r = 0;
                    t.push(0);
                    for (let a = 1; a <= e; a++)
                        n = this.getPoint(a / e),
                        r += n.distanceTo(i),
                        t.push(r),
                        i = n;
                    return this.cacheArcLengths = t,
                    t
                }
                updateArcLengths() {
                    this.needsUpdate = !0,
                    this.getLengths()
                }
                getUtoTmapping(e, t=null) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let a;
                    a = t || e * n[r - 1];
                    let s, o = 0, l = r - 1;
                    for (; o <= l; )
                        if (i = Math.floor(o + (l - o) / 2),
                        s = n[i] - a,
                        s < 0)
                            o = i + 1;
                        else {
                            if (!(s > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        }
                    if (i = l,
                    n[i] === a)
                        return i / (r - 1);
                    const c = n[i];
                    return (i + (a - c) / (n[i + 1] - c)) / (r - 1)
                }
                getTangent(e, t) {
                    const n = 1e-4;
                    let i = e - n
                      , r = e + n;
                    i < 0 && (i = 0),
                    r > 1 && (r = 1);
                    const a = this.getPoint(i)
                      , s = this.getPoint(r)
                      , o = t || (a.isVector2 ? new Tn : new Mn);
                    return o.copy(s).sub(a).normalize(),
                    o
                }
                getTangentAt(e, t) {
                    const n = this.getUtoTmapping(e);
                    return this.getTangent(n, t)
                }
                computeFrenetFrames(e, t=!1) {
                    const n = new Mn
                      , i = []
                      , r = []
                      , a = []
                      , s = new Mn
                      , o = new Ei;
                    for (let t = 0; t <= e; t++) {
                        const n = t / e;
                        i[t] = this.getTangentAt(n, new Mn)
                    }
                    r[0] = new Mn,
                    a[0] = new Mn;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x)
                      , h = Math.abs(i[0].y)
                      , d = Math.abs(i[0].z);
                    c <= l && (l = c,
                    n.set(1, 0, 0)),
                    h <= l && (l = h,
                    n.set(0, 1, 0)),
                    d <= l && n.set(0, 0, 1),
                    s.crossVectors(i[0], n).normalize(),
                    r[0].crossVectors(i[0], s),
                    a[0].crossVectors(i[0], r[0]);
                    for (let t = 1; t <= e; t++) {
                        if (r[t] = r[t - 1].clone(),
                        a[t] = a[t - 1].clone(),
                        s.crossVectors(i[t - 1], i[t]),
                        s.length() > Number.EPSILON) {
                            s.normalize();
                            const e = Math.acos(yn(i[t - 1].dot(i[t]), -1, 1));
                            r[t].applyMatrix4(o.makeRotationAxis(s, e))
                        }
                        a[t].crossVectors(i[t], r[t])
                    }
                    if (!0 === t) {
                        let t = Math.acos(yn(r[0].dot(r[e]), -1, 1));
                        t /= e,
                        i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
                        for (let n = 1; n <= e; n++)
                            r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                            a[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: a
                    }
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions,
                    this
                }
                toJSON() {
                    const e = {
                        metadata: {
                            version: 4.7,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions,
                    e.type = this.type,
                    e
                }
                fromJSON(e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions,
                    this
                }
            }
            class Vs extends Ws {
                constructor(e=0, t=0, n=1, i=1, r=0, a=2 * Math.PI, s=!1, o=0) {
                    super(),
                    this.isEllipseCurve = !0,
                    this.type = "EllipseCurve",
                    this.aX = e,
                    this.aY = t,
                    this.xRadius = n,
                    this.yRadius = i,
                    this.aStartAngle = r,
                    this.aEndAngle = a,
                    this.aClockwise = s,
                    this.aRotation = o
                }
                getPoint(e, t=new Tn) {
                    const n = t
                      , i = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const a = Math.abs(r) < Number.EPSILON;
                    for (; r < 0; )
                        r += i;
                    for (; r > i; )
                        r -= i;
                    r < Number.EPSILON && (r = a ? 0 : i),
                    !0 !== this.aClockwise || a || (r === i ? r = -i : r -= i);
                    const s = this.aStartAngle + e * r;
                    let o = this.aX + this.xRadius * Math.cos(s)
                      , l = this.aY + this.yRadius * Math.sin(s);
                    if (0 !== this.aRotation) {
                        const e = Math.cos(this.aRotation)
                          , t = Math.sin(this.aRotation)
                          , n = o - this.aX
                          , i = l - this.aY;
                        o = n * e - i * t + this.aX,
                        l = n * t + i * e + this.aY
                    }
                    return n.set(o, l)
                }
                copy(e) {
                    return super.copy(e),
                    this.aX = e.aX,
                    this.aY = e.aY,
                    this.xRadius = e.xRadius,
                    this.yRadius = e.yRadius,
                    this.aStartAngle = e.aStartAngle,
                    this.aEndAngle = e.aEndAngle,
                    this.aClockwise = e.aClockwise,
                    this.aRotation = e.aRotation,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.aX = this.aX,
                    e.aY = this.aY,
                    e.xRadius = this.xRadius,
                    e.yRadius = this.yRadius,
                    e.aStartAngle = this.aStartAngle,
                    e.aEndAngle = this.aEndAngle,
                    e.aClockwise = this.aClockwise,
                    e.aRotation = this.aRotation,
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.aX = e.aX,
                    this.aY = e.aY,
                    this.xRadius = e.xRadius,
                    this.yRadius = e.yRadius,
                    this.aStartAngle = e.aStartAngle,
                    this.aEndAngle = e.aEndAngle,
                    this.aClockwise = e.aClockwise,
                    this.aRotation = e.aRotation,
                    this
                }
            }
            function Hs() {
                let e = 0
                  , t = 0
                  , n = 0
                  , i = 0;
                function r(r, a, s, o) {
                    e = r,
                    t = s,
                    n = -3 * r + 3 * a - 2 * s - o,
                    i = 2 * r - 2 * a + s + o
                }
                return {
                    initCatmullRom: function(e, t, n, i, a) {
                        r(t, n, a * (n - e), a * (i - t))
                    },
                    initNonuniformCatmullRom: function(e, t, n, i, a, s, o) {
                        let l = (t - e) / a - (n - e) / (a + s) + (n - t) / s
                          , c = (n - t) / s - (i - t) / (s + o) + (i - n) / o;
                        l *= s,
                        c *= s,
                        r(t, n, l, c)
                    },
                    calc: function(r) {
                        const a = r * r;
                        return e + t * r + n * a + i * (a * r)
                    }
                }
            }
            const js = new Mn
              , Ks = new Hs
              , qs = new Hs
              , Qs = new Hs;
            function Js(e, t, n, i, r) {
                const a = .5 * (i - t)
                  , s = .5 * (r - n)
                  , o = e * e;
                return (2 * n - 2 * i + a + s) * (e * o) + (-3 * n + 3 * i - 2 * a - s) * o + a * e + n
            }
            function Xs(e, t, n, i) {
                return function(e, t) {
                    const n = 1 - e;
                    return n * n * t
                }(e, t) + function(e, t) {
                    return 2 * (1 - e) * e * t
                }(e, n) + function(e, t) {
                    return e * e * t
                }(e, i)
            }
            function Ys(e, t, n, i, r) {
                return function(e, t) {
                    const n = 1 - e;
                    return n * n * n * t
                }(e, t) + function(e, t) {
                    const n = 1 - e;
                    return 3 * n * n * e * t
                }(e, n) + function(e, t) {
                    return 3 * (1 - e) * e * e * t
                }(e, i) + function(e, t) {
                    return e * e * e * t
                }(e, r)
            }
            class Zs extends Ws {
                constructor(e=new Tn, t=new Tn, n=new Tn, i=new Tn) {
                    super(),
                    this.isCubicBezierCurve = !0,
                    this.type = "CubicBezierCurve",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n,
                    this.v3 = i
                }
                getPoint(e, t=new Tn) {
                    const n = t
                      , i = this.v0
                      , r = this.v1
                      , a = this.v2
                      , s = this.v3;
                    return n.set(Ys(e, i.x, r.x, a.x, s.x), Ys(e, i.y, r.y, a.y, s.y)),
                    n
                }
                copy(e) {
                    return super.copy(e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this.v3.copy(e.v3),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e.v3 = this.v3.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this.v3.fromArray(e.v3),
                    this
                }
            }
            class $s extends Ws {
                constructor(e=new Tn, t=new Tn) {
                    super(),
                    this.isLineCurve = !0,
                    this.type = "LineCurve",
                    this.v1 = e,
                    this.v2 = t
                }
                getPoint(e, t=new Tn) {
                    const n = t;
                    return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                    n.multiplyScalar(e).add(this.v1)),
                    n
                }
                getPointAt(e, t) {
                    return this.getPoint(e, t)
                }
                getTangent(e, t=new Tn) {
                    return t.subVectors(this.v2, this.v1).normalize()
                }
                getTangentAt(e, t) {
                    return this.getTangent(e, t)
                }
                copy(e) {
                    return super.copy(e),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
            }
            class eo extends Ws {
                constructor(e=new Tn, t=new Tn, n=new Tn) {
                    super(),
                    this.isQuadraticBezierCurve = !0,
                    this.type = "QuadraticBezierCurve",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n
                }
                getPoint(e, t=new Tn) {
                    const n = t
                      , i = this.v0
                      , r = this.v1
                      , a = this.v2;
                    return n.set(Xs(e, i.x, r.x, a.x), Xs(e, i.y, r.y, a.y)),
                    n
                }
                copy(e) {
                    return super.copy(e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
            }
            class to extends Ws {
                constructor(e=new Mn, t=new Mn, n=new Mn) {
                    super(),
                    this.isQuadraticBezierCurve3 = !0,
                    this.type = "QuadraticBezierCurve3",
                    this.v0 = e,
                    this.v1 = t,
                    this.v2 = n
                }
                getPoint(e, t=new Mn) {
                    const n = t
                      , i = this.v0
                      , r = this.v1
                      , a = this.v2;
                    return n.set(Xs(e, i.x, r.x, a.x), Xs(e, i.y, r.y, a.y), Xs(e, i.z, r.z, a.z)),
                    n
                }
                copy(e) {
                    return super.copy(e),
                    this.v0.copy(e.v0),
                    this.v1.copy(e.v1),
                    this.v2.copy(e.v2),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.v0 = this.v0.toArray(),
                    e.v1 = this.v1.toArray(),
                    e.v2 = this.v2.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.v0.fromArray(e.v0),
                    this.v1.fromArray(e.v1),
                    this.v2.fromArray(e.v2),
                    this
                }
            }
            class no extends Ws {
                constructor(e=[]) {
                    super(),
                    this.isSplineCurve = !0,
                    this.type = "SplineCurve",
                    this.points = e
                }
                getPoint(e, t=new Tn) {
                    const n = t
                      , i = this.points
                      , r = (i.length - 1) * e
                      , a = Math.floor(r)
                      , s = r - a
                      , o = i[0 === a ? a : a - 1]
                      , l = i[a]
                      , c = i[a > i.length - 2 ? i.length - 1 : a + 1]
                      , h = i[a > i.length - 3 ? i.length - 1 : a + 2];
                    return n.set(Js(s, o.x, l.x, c.x, h.x), Js(s, o.y, l.y, c.y, h.y)),
                    n
                }
                copy(e) {
                    super.copy(e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.points = [];
                    for (let t = 0, n = this.points.length; t < n; t++) {
                        const n = this.points[t];
                        e.points.push(n.toArray())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e),
                    this.points = [];
                    for (let t = 0, n = e.points.length; t < n; t++) {
                        const n = e.points[t];
                        this.points.push((new Tn).fromArray(n))
                    }
                    return this
                }
            }
            var io = Object.freeze({
                __proto__: null,
                ArcCurve: class extends Vs {
                    constructor(e, t, n, i, r, a) {
                        super(e, t, n, n, i, r, a),
                        this.isArcCurve = !0,
                        this.type = "ArcCurve"
                    }
                }
                ,
                CatmullRomCurve3: class extends Ws {
                    constructor(e=[], t=!1, n="centripetal", i=.5) {
                        super(),
                        this.isCatmullRomCurve3 = !0,
                        this.type = "CatmullRomCurve3",
                        this.points = e,
                        this.closed = t,
                        this.curveType = n,
                        this.tension = i
                    }
                    getPoint(e, t=new Mn) {
                        const n = t
                          , i = this.points
                          , r = i.length
                          , a = (r - (this.closed ? 0 : 1)) * e;
                        let s, o, l = Math.floor(a), c = a - l;
                        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
                        c = 1),
                        this.closed || l > 0 ? s = i[(l - 1) % r] : (js.subVectors(i[0], i[1]).add(i[0]),
                        s = js);
                        const h = i[l % r]
                          , d = i[(l + 1) % r];
                        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (js.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
                        o = js),
                        "centripetal" === this.curveType || "chordal" === this.curveType) {
                            const e = "chordal" === this.curveType ? .5 : .25;
                            let t = Math.pow(s.distanceToSquared(h), e)
                              , n = Math.pow(h.distanceToSquared(d), e)
                              , i = Math.pow(d.distanceToSquared(o), e);
                            n < 1e-4 && (n = 1),
                            t < 1e-4 && (t = n),
                            i < 1e-4 && (i = n),
                            Ks.initNonuniformCatmullRom(s.x, h.x, d.x, o.x, t, n, i),
                            qs.initNonuniformCatmullRom(s.y, h.y, d.y, o.y, t, n, i),
                            Qs.initNonuniformCatmullRom(s.z, h.z, d.z, o.z, t, n, i)
                        } else
                            "catmullrom" === this.curveType && (Ks.initCatmullRom(s.x, h.x, d.x, o.x, this.tension),
                            qs.initCatmullRom(s.y, h.y, d.y, o.y, this.tension),
                            Qs.initCatmullRom(s.z, h.z, d.z, o.z, this.tension));
                        return n.set(Ks.calc(c), qs.calc(c), Qs.calc(c)),
                        n
                    }
                    copy(e) {
                        super.copy(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const n = e.points[t];
                            this.points.push(n.clone())
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        e.points = [];
                        for (let t = 0, n = this.points.length; t < n; t++) {
                            const n = this.points[t];
                            e.points.push(n.toArray())
                        }
                        return e.closed = this.closed,
                        e.curveType = this.curveType,
                        e.tension = this.tension,
                        e
                    }
                    fromJSON(e) {
                        super.fromJSON(e),
                        this.points = [];
                        for (let t = 0, n = e.points.length; t < n; t++) {
                            const n = e.points[t];
                            this.points.push((new Mn).fromArray(n))
                        }
                        return this.closed = e.closed,
                        this.curveType = e.curveType,
                        this.tension = e.tension,
                        this
                    }
                }
                ,
                CubicBezierCurve: Zs,
                CubicBezierCurve3: class extends Ws {
                    constructor(e=new Mn, t=new Mn, n=new Mn, i=new Mn) {
                        super(),
                        this.isCubicBezierCurve3 = !0,
                        this.type = "CubicBezierCurve3",
                        this.v0 = e,
                        this.v1 = t,
                        this.v2 = n,
                        this.v3 = i
                    }
                    getPoint(e, t=new Mn) {
                        const n = t
                          , i = this.v0
                          , r = this.v1
                          , a = this.v2
                          , s = this.v3;
                        return n.set(Ys(e, i.x, r.x, a.x, s.x), Ys(e, i.y, r.y, a.y, s.y), Ys(e, i.z, r.z, a.z, s.z)),
                        n
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v0.copy(e.v0),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this.v3.copy(e.v3),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v0 = this.v0.toArray(),
                        e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e.v3 = this.v3.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v0.fromArray(e.v0),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this.v3.fromArray(e.v3),
                        this
                    }
                }
                ,
                EllipseCurve: Vs,
                LineCurve: $s,
                LineCurve3: class extends Ws {
                    constructor(e=new Mn, t=new Mn) {
                        super(),
                        this.isLineCurve3 = !0,
                        this.type = "LineCurve3",
                        this.v1 = e,
                        this.v2 = t
                    }
                    getPoint(e, t=new Mn) {
                        const n = t;
                        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
                        n.multiplyScalar(e).add(this.v1)),
                        n
                    }
                    getPointAt(e, t) {
                        return this.getPoint(e, t)
                    }
                    getTangent(e, t=new Mn) {
                        return t.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(e, t) {
                        return this.getTangent(e, t)
                    }
                    copy(e) {
                        return super.copy(e),
                        this.v1.copy(e.v1),
                        this.v2.copy(e.v2),
                        this
                    }
                    toJSON() {
                        const e = super.toJSON();
                        return e.v1 = this.v1.toArray(),
                        e.v2 = this.v2.toArray(),
                        e
                    }
                    fromJSON(e) {
                        return super.fromJSON(e),
                        this.v1.fromArray(e.v1),
                        this.v2.fromArray(e.v2),
                        this
                    }
                }
                ,
                QuadraticBezierCurve: eo,
                QuadraticBezierCurve3: to,
                SplineCurve: no
            });
            class ro extends Ws {
                constructor() {
                    super(),
                    this.type = "CurvePath",
                    this.curves = [],
                    this.autoClose = !1
                }
                add(e) {
                    this.curves.push(e)
                }
                closePath() {
                    const e = this.curves[0].getPoint(0)
                      , t = this.curves[this.curves.length - 1].getPoint(1);
                    if (!e.equals(t)) {
                        const n = !0 === e.isVector2 ? "LineCurve" : "LineCurve3";
                        this.curves.push(new io[n](t,e))
                    }
                    return this
                }
                getPoint(e, t) {
                    const n = e * this.getLength()
                      , i = this.getCurveLengths();
                    let r = 0;
                    for (; r < i.length; ) {
                        if (i[r] >= n) {
                            const e = i[r] - n
                              , a = this.curves[r]
                              , s = a.getLength()
                              , o = 0 === s ? 0 : 1 - e / s;
                            return a.getPointAt(o, t)
                        }
                        r++
                    }
                    return null
                }
                getLength() {
                    const e = this.getCurveLengths();
                    return e[e.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0,
                    this.cacheLengths = null,
                    this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                        return this.cacheLengths;
                    const e = [];
                    let t = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++)
                        t += this.curves[n].getLength(),
                        e.push(t);
                    return this.cacheLengths = e,
                    e
                }
                getSpacedPoints(e=40) {
                    const t = [];
                    for (let n = 0; n <= e; n++)
                        t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]),
                    t
                }
                getPoints(e=12) {
                    const t = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const a = r[i]
                          , s = a.isEllipseCurve ? 2 * e : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e
                          , o = a.getPoints(s);
                        for (let e = 0; e < o.length; e++) {
                            const i = o[e];
                            n && n.equals(i) || (t.push(i),
                            n = i)
                        }
                    }
                    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
                    t
                }
                copy(e) {
                    super.copy(e),
                    this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = e.autoClose,
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.autoClose = this.autoClose,
                    e.curves = [];
                    for (let t = 0, n = this.curves.length; t < n; t++) {
                        const n = this.curves[t];
                        e.curves.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e),
                    this.autoClose = e.autoClose,
                    this.curves = [];
                    for (let t = 0, n = e.curves.length; t < n; t++) {
                        const n = e.curves[t];
                        this.curves.push((new io[n.type]).fromJSON(n))
                    }
                    return this
                }
            }
            class ao extends ro {
                constructor(e) {
                    super(),
                    this.type = "Path",
                    this.currentPoint = new Tn,
                    e && this.setFromPoints(e)
                }
                setFromPoints(e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (let t = 1, n = e.length; t < n; t++)
                        this.lineTo(e[t].x, e[t].y);
                    return this
                }
                moveTo(e, t) {
                    return this.currentPoint.set(e, t),
                    this
                }
                lineTo(e, t) {
                    const n = new $s(this.currentPoint.clone(),new Tn(e,t));
                    return this.curves.push(n),
                    this.currentPoint.set(e, t),
                    this
                }
                quadraticCurveTo(e, t, n, i) {
                    const r = new eo(this.currentPoint.clone(),new Tn(e,t),new Tn(n,i));
                    return this.curves.push(r),
                    this.currentPoint.set(n, i),
                    this
                }
                bezierCurveTo(e, t, n, i, r, a) {
                    const s = new Zs(this.currentPoint.clone(),new Tn(e,t),new Tn(n,i),new Tn(r,a));
                    return this.curves.push(s),
                    this.currentPoint.set(r, a),
                    this
                }
                splineThru(e) {
                    const t = [this.currentPoint.clone()].concat(e)
                      , n = new no(t);
                    return this.curves.push(n),
                    this.currentPoint.copy(e[e.length - 1]),
                    this
                }
                arc(e, t, n, i, r, a) {
                    const s = this.currentPoint.x
                      , o = this.currentPoint.y;
                    return this.absarc(e + s, t + o, n, i, r, a),
                    this
                }
                absarc(e, t, n, i, r, a) {
                    return this.absellipse(e, t, n, n, i, r, a),
                    this
                }
                ellipse(e, t, n, i, r, a, s, o) {
                    const l = this.currentPoint.x
                      , c = this.currentPoint.y;
                    return this.absellipse(e + l, t + c, n, i, r, a, s, o),
                    this
                }
                absellipse(e, t, n, i, r, a, s, o) {
                    const l = new Vs(e,t,n,i,r,a,s,o);
                    if (this.curves.length > 0) {
                        const e = l.getPoint(0);
                        e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c),
                    this
                }
                copy(e) {
                    return super.copy(e),
                    this.currentPoint.copy(e.currentPoint),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return e.currentPoint = this.currentPoint.toArray(),
                    e
                }
                fromJSON(e) {
                    return super.fromJSON(e),
                    this.currentPoint.fromArray(e.currentPoint),
                    this
                }
            }
            class so extends ao {
                constructor(e) {
                    super(e),
                    this.uuid = vn(),
                    this.type = "Shape",
                    this.holes = []
                }
                getPointsHoles(e) {
                    const t = [];
                    for (let n = 0, i = this.holes.length; n < i; n++)
                        t[n] = this.holes[n].getPoints(e);
                    return t
                }
                extractPoints(e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                }
                copy(e) {
                    super.copy(e),
                    this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const e = super.toJSON();
                    e.uuid = this.uuid,
                    e.holes = [];
                    for (let t = 0, n = this.holes.length; t < n; t++) {
                        const n = this.holes[t];
                        e.holes.push(n.toJSON())
                    }
                    return e
                }
                fromJSON(e) {
                    super.fromJSON(e),
                    this.uuid = e.uuid,
                    this.holes = [];
                    for (let t = 0, n = e.holes.length; t < n; t++) {
                        const n = e.holes[t];
                        this.holes.push((new ao).fromJSON(n))
                    }
                    return this
                }
            }
            function oo(e, t, n=2) {
                const i = t && t.length
                  , r = i ? t[0] * n : e.length;
                let a = lo(e, 0, r, n, !0);
                const s = [];
                if (!a || a.next === a.prev)
                    return s;
                let o, l, c;
                if (i && (a = function(e, t, n, i) {
                    const r = [];
                    for (let n = 0, a = t.length; n < a; n++) {
                        const s = lo(e, t[n] * i, n < a - 1 ? t[n + 1] * i : e.length, i, !1);
                        s === s.next && (s.steiner = !0),
                        r.push(wo(s))
                    }
                    r.sort(mo);
                    for (let e = 0; e < r.length; e++)
                        n = Ao(r[e], n);
                    return n
                }(e, t, a, n)),
                e.length > 80 * n) {
                    o = e[0],
                    l = e[1];
                    let t = o
                      , i = l;
                    for (let a = n; a < r; a += n) {
                        const n = e[a]
                          , r = e[a + 1];
                        n < o && (o = n),
                        r < l && (l = r),
                        n > t && (t = n),
                        r > i && (i = r)
                    }
                    c = Math.max(t - o, i - l),
                    c = 0 !== c ? 32767 / c : 0
                }
                return ho(a, s, n, o, l, c, 0),
                s
            }
            function lo(e, t, n, i, r) {
                let a;
                if (r === function(e, t, n, i) {
                    let r = 0;
                    for (let a = t, s = n - i; a < n; a += i)
                        r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]),
                        s = a;
                    return r
                }(e, t, n, i) > 0)
                    for (let r = t; r < n; r += i)
                        a = Po(r / i | 0, e[r], e[r + 1], a);
                else
                    for (let r = n - i; r >= t; r -= i)
                        a = Po(r / i | 0, e[r], e[r + 1], a);
                return a && To(a, a.next) && (Io(a),
                a = a.next),
                a
            }
            function co(e, t) {
                if (!e)
                    return e;
                t || (t = e);
                let n, i = e;
                do {
                    if (n = !1,
                    i.steiner || !To(i, i.next) && 0 !== Eo(i.prev, i, i.next))
                        i = i.next;
                    else {
                        if (Io(i),
                        i = t = i.prev,
                        i === i.next)
                            break;
                        n = !0
                    }
                } while (n || i !== t);
                return t
            }
            function ho(e, t, n, i, r, a, s) {
                if (!e)
                    return;
                !s && a && function(e, t, n, i) {
                    let r = e;
                    do {
                        0 === r.z && (r.z = yo(r.x, r.y, t, n, i)),
                        r.prevZ = r.prev,
                        r.nextZ = r.next,
                        r = r.next
                    } while (r !== e);
                    r.prevZ.nextZ = null,
                    r.prevZ = null,
                    function(e) {
                        let t, n = 1;
                        do {
                            let i, r = e;
                            e = null;
                            let a = null;
                            for (t = 0; r; ) {
                                t++;
                                let s = r
                                  , o = 0;
                                for (let e = 0; e < n && (o++,
                                s = s.nextZ,
                                s); e++)
                                    ;
                                let l = n;
                                for (; o > 0 || l > 0 && s; )
                                    0 !== o && (0 === l || !s || r.z <= s.z) ? (i = r,
                                    r = r.nextZ,
                                    o--) : (i = s,
                                    s = s.nextZ,
                                    l--),
                                    a ? a.nextZ = i : e = i,
                                    i.prevZ = a,
                                    a = i;
                                r = s
                            }
                            a.nextZ = null,
                            n *= 2
                        } while (t > 1)
                    }(r)
                }(e, i, r, a);
                let o = e;
                for (; e.prev !== e.next; ) {
                    const l = e.prev
                      , c = e.next;
                    if (a ? po(e, i, r, a) : uo(e))
                        t.push(l.i, e.i, c.i),
                        Io(e),
                        e = c.next,
                        o = c.next;
                    else if ((e = c) === o) {
                        s ? 1 === s ? ho(e = fo(co(e), t), t, n, i, r, a, 2) : 2 === s && go(e, t, n, i, r, a) : ho(co(e), t, n, i, r, a, 1);
                        break
                    }
                }
            }
            function uo(e) {
                const t = e.prev
                  , n = e
                  , i = e.next;
                if (Eo(t, n, i) >= 0)
                    return !1;
                const r = t.x
                  , a = n.x
                  , s = i.x
                  , o = t.y
                  , l = n.y
                  , c = i.y
                  , h = Math.min(r, a, s)
                  , d = Math.min(o, l, c)
                  , u = Math.max(r, a, s)
                  , p = Math.max(o, l, c);
                let f = i.next;
                for (; f !== t; ) {
                    if (f.x >= h && f.x <= u && f.y >= d && f.y <= p && xo(r, o, a, l, s, c, f.x, f.y) && Eo(f.prev, f, f.next) >= 0)
                        return !1;
                    f = f.next
                }
                return !0
            }
            function po(e, t, n, i) {
                const r = e.prev
                  , a = e
                  , s = e.next;
                if (Eo(r, a, s) >= 0)
                    return !1;
                const o = r.x
                  , l = a.x
                  , c = s.x
                  , h = r.y
                  , d = a.y
                  , u = s.y
                  , p = Math.min(o, l, c)
                  , f = Math.min(h, d, u)
                  , g = Math.max(o, l, c)
                  , m = Math.max(h, d, u)
                  , A = yo(p, f, t, n, i)
                  , v = yo(g, m, t, n, i);
                let y = e.prevZ
                  , w = e.nextZ;
                for (; y && y.z >= A && w && w.z <= v; ) {
                    if (y.x >= p && y.x <= g && y.y >= f && y.y <= m && y !== r && y !== s && xo(o, h, l, d, c, u, y.x, y.y) && Eo(y.prev, y, y.next) >= 0)
                        return !1;
                    if (y = y.prevZ,
                    w.x >= p && w.x <= g && w.y >= f && w.y <= m && w !== r && w !== s && xo(o, h, l, d, c, u, w.x, w.y) && Eo(w.prev, w, w.next) >= 0)
                        return !1;
                    w = w.nextZ
                }
                for (; y && y.z >= A; ) {
                    if (y.x >= p && y.x <= g && y.y >= f && y.y <= m && y !== r && y !== s && xo(o, h, l, d, c, u, y.x, y.y) && Eo(y.prev, y, y.next) >= 0)
                        return !1;
                    y = y.prevZ
                }
                for (; w && w.z <= v; ) {
                    if (w.x >= p && w.x <= g && w.y >= f && w.y <= m && w !== r && w !== s && xo(o, h, l, d, c, u, w.x, w.y) && Eo(w.prev, w, w.next) >= 0)
                        return !1;
                    w = w.nextZ
                }
                return !0
            }
            function fo(e, t) {
                let n = e;
                do {
                    const i = n.prev
                      , r = n.next.next;
                    !To(i, r) && ko(i, n, n.next, r) && Co(i, r) && Co(r, i) && (t.push(i.i, n.i, r.i),
                    Io(n),
                    Io(n.next),
                    n = e = r),
                    n = n.next
                } while (n !== e);
                return co(n)
            }
            function go(e, t, n, i, r, a) {
                let s = e;
                do {
                    let e = s.next.next;
                    for (; e !== s.prev; ) {
                        if (s.i !== e.i && So(s, e)) {
                            let o = Ro(s, e);
                            return s = co(s, s.next),
                            o = co(o, o.next),
                            ho(s, t, n, i, r, a, 0),
                            void ho(o, t, n, i, r, a, 0)
                        }
                        e = e.next
                    }
                    s = s.next
                } while (s !== e)
            }
            function mo(e, t) {
                let n = e.x - t.x;
                if (0 === n && (n = e.y - t.y,
                0 === n)) {
                    n = (e.next.y - e.y) / (e.next.x - e.x) - (t.next.y - t.y) / (t.next.x - t.x)
                }
                return n
            }
            function Ao(e, t) {
                const n = function(e, t) {
                    let n = t;
                    const i = e.x
                      , r = e.y;
                    let a, s = -1 / 0;
                    if (To(e, n))
                        return n;
                    do {
                        if (To(e, n.next))
                            return n.next;
                        if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                            const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (e <= i && e > s && (s = e,
                            a = n.x < n.next.x ? n : n.next,
                            e === i))
                                return a
                        }
                        n = n.next
                    } while (n !== t);
                    if (!a)
                        return null;
                    const o = a
                      , l = a.x
                      , c = a.y;
                    let h = 1 / 0;
                    n = a;
                    do {
                        if (i >= n.x && n.x >= l && i !== n.x && bo(r < c ? i : s, r, l, c, r < c ? s : i, r, n.x, n.y)) {
                            const t = Math.abs(r - n.y) / (i - n.x);
                            Co(n, e) && (t < h || t === h && (n.x > a.x || n.x === a.x && vo(a, n))) && (a = n,
                            h = t)
                        }
                        n = n.next
                    } while (n !== o);
                    return a
                }(e, t);
                if (!n)
                    return t;
                const i = Ro(n, e);
                return co(i, i.next),
                co(n, n.next)
            }
            function vo(e, t) {
                return Eo(e.prev, e, t.prev) < 0 && Eo(t.next, e, e.next) < 0
            }
            function yo(e, t, n, i, r) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }
            function wo(e) {
                let t = e
                  , n = e;
                do {
                    (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                    t = t.next
                } while (t !== e);
                return n
            }
            function bo(e, t, n, i, r, a, s, o) {
                return (r - s) * (t - o) >= (e - s) * (a - o) && (e - s) * (i - o) >= (n - s) * (t - o) && (n - s) * (a - o) >= (r - s) * (i - o)
            }
            function xo(e, t, n, i, r, a, s, o) {
                return !(e === s && t === o) && bo(e, t, n, i, r, a, s, o)
            }
            function So(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                    let n = e;
                    do {
                        if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && ko(n, n.next, e, t))
                            return !0;
                        n = n.next
                    } while (n !== e);
                    return !1
                }(e, t) && (Co(e, t) && Co(t, e) && function(e, t) {
                    let n = e
                      , i = !1;
                    const r = (e.x + t.x) / 2
                      , a = (e.y + t.y) / 2;
                    do {
                        n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                        n = n.next
                    } while (n !== e);
                    return i
                }(e, t) && (Eo(e.prev, e, t.prev) || Eo(e, t.prev, t)) || To(e, t) && Eo(e.prev, e, e.next) > 0 && Eo(t.prev, t, t.next) > 0)
            }
            function Eo(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }
            function To(e, t) {
                return e.x === t.x && e.y === t.y
            }
            function ko(e, t, n, i) {
                const r = _o(Eo(e, t, n))
                  , a = _o(Eo(e, t, i))
                  , s = _o(Eo(n, i, e))
                  , o = _o(Eo(n, i, t));
                return r !== a && s !== o || (!(0 !== r || !Mo(e, n, t)) || (!(0 !== a || !Mo(e, i, t)) || (!(0 !== s || !Mo(n, e, i)) || !(0 !== o || !Mo(n, t, i)))))
            }
            function Mo(e, t, n) {
                return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
            }
            function _o(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }
            function Co(e, t) {
                return Eo(e.prev, e, e.next) < 0 ? Eo(e, t, e.next) >= 0 && Eo(e, e.prev, t) >= 0 : Eo(e, t, e.prev) < 0 || Eo(e, e.next, t) < 0
            }
            function Ro(e, t) {
                const n = Lo(e.i, e.x, e.y)
                  , i = Lo(t.i, t.x, t.y)
                  , r = e.next
                  , a = t.prev;
                return e.next = t,
                t.prev = e,
                n.next = r,
                r.prev = n,
                i.next = n,
                n.prev = i,
                a.next = i,
                i.prev = a,
                i
            }
            function Po(e, t, n, i) {
                const r = Lo(e, t, n);
                return i ? (r.next = i.next,
                r.prev = i,
                i.next.prev = r,
                i.next = r) : (r.prev = r,
                r.next = r),
                r
            }
            function Io(e) {
                e.next.prev = e.prev,
                e.prev.next = e.next,
                e.prevZ && (e.prevZ.nextZ = e.nextZ),
                e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }
            function Lo(e, t, n) {
                return {
                    i: e,
                    x: t,
                    y: n,
                    prev: null,
                    next: null,
                    z: 0,
                    prevZ: null,
                    nextZ: null,
                    steiner: !1
                }
            }
            class No {
                static triangulate(e, t, n=2) {
                    return oo(e, t, n)
                }
            }
            class zo {
                static area(e) {
                    const t = e.length;
                    let n = 0;
                    for (let i = t - 1, r = 0; r < t; i = r++)
                        n += e[i].x * e[r].y - e[r].x * e[i].y;
                    return .5 * n
                }
                static isClockWise(e) {
                    return zo.area(e) < 0
                }
                static triangulateShape(e, t) {
                    const n = []
                      , i = []
                      , r = [];
                    Uo(e),
                    Do(n, e);
                    let a = e.length;
                    t.forEach(Uo);
                    for (let e = 0; e < t.length; e++)
                        i.push(a),
                        a += t[e].length,
                        Do(n, t[e]);
                    const s = No.triangulate(n, i);
                    for (let e = 0; e < s.length; e += 3)
                        r.push(s.slice(e, e + 3));
                    return r
                }
            }
            function Uo(e) {
                const t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }
            function Do(e, t) {
                for (let n = 0; n < t.length; n++)
                    e.push(t[n].x),
                    e.push(t[n].y)
            }
            class Bo extends zr {
                constructor(e=1, t=1, n=1, i=1) {
                    super(),
                    this.type = "PlaneGeometry",
                    this.parameters = {
                        width: e,
                        height: t,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = e / 2
                      , a = t / 2
                      , s = Math.floor(n)
                      , o = Math.floor(i)
                      , l = s + 1
                      , c = o + 1
                      , h = e / s
                      , d = t / o
                      , u = []
                      , p = []
                      , f = []
                      , g = [];
                    for (let e = 0; e < c; e++) {
                        const t = e * d - a;
                        for (let n = 0; n < l; n++) {
                            const i = n * h - r;
                            p.push(i, -t, 0),
                            f.push(0, 0, 1),
                            g.push(n / s),
                            g.push(1 - e / o)
                        }
                    }
                    for (let e = 0; e < o; e++)
                        for (let t = 0; t < s; t++) {
                            const n = t + l * e
                              , i = t + l * (e + 1)
                              , r = t + 1 + l * (e + 1)
                              , a = t + 1 + l * e;
                            u.push(n, i, a),
                            u.push(i, r, a)
                        }
                    this.setIndex(u),
                    this.setAttribute("position", new Mr(p,3)),
                    this.setAttribute("normal", new Mr(f,3)),
                    this.setAttribute("uv", new Mr(g,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                static fromJSON(e) {
                    return new Bo(e.width,e.height,e.widthSegments,e.heightSegments)
                }
            }
            class Go extends zr {
                constructor(e=new so([new Tn(0,.5), new Tn(-.5,-.5), new Tn(.5,-.5)]), t=12) {
                    super(),
                    this.type = "ShapeGeometry",
                    this.parameters = {
                        shapes: e,
                        curveSegments: t
                    };
                    const n = []
                      , i = []
                      , r = []
                      , a = [];
                    let s = 0
                      , o = 0;
                    if (!1 === Array.isArray(e))
                        l(e);
                    else
                        for (let t = 0; t < e.length; t++)
                            l(e[t]),
                            this.addGroup(s, o, t),
                            s += o,
                            o = 0;
                    function l(e) {
                        const s = i.length / 3
                          , l = e.extractPoints(t);
                        let c = l.shape;
                        const h = l.holes;
                        !1 === zo.isClockWise(c) && (c = c.reverse());
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e];
                            !0 === zo.isClockWise(t) && (h[e] = t.reverse())
                        }
                        const d = zo.triangulateShape(c, h);
                        for (let e = 0, t = h.length; e < t; e++) {
                            const t = h[e];
                            c = c.concat(t)
                        }
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            i.push(t.x, t.y, 0),
                            r.push(0, 0, 1),
                            a.push(t.x, t.y)
                        }
                        for (let e = 0, t = d.length; e < t; e++) {
                            const t = d[e]
                              , i = t[0] + s
                              , r = t[1] + s
                              , a = t[2] + s;
                            n.push(i, r, a),
                            o += 3
                        }
                    }
                    this.setIndex(n),
                    this.setAttribute("position", new Mr(i,3)),
                    this.setAttribute("normal", new Mr(r,3)),
                    this.setAttribute("uv", new Mr(a,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                toJSON() {
                    const e = super.toJSON();
                    return function(e, t) {
                        if (t.shapes = [],
                        Array.isArray(e))
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n];
                                t.shapes.push(i.uuid)
                            }
                        else
                            t.shapes.push(e.uuid);
                        return t
                    }(this.parameters.shapes, e)
                }
                static fromJSON(e, t) {
                    const n = [];
                    for (let i = 0, r = e.shapes.length; i < r; i++) {
                        const r = t[e.shapes[i]];
                        n.push(r)
                    }
                    return new Go(n,e.curveSegments)
                }
            }
            class Fo extends zr {
                constructor(e=1, t=32, n=16, i=0, r=2 * Math.PI, a=0, s=Math.PI) {
                    super(),
                    this.type = "SphereGeometry",
                    this.parameters = {
                        radius: e,
                        widthSegments: t,
                        heightSegments: n,
                        phiStart: i,
                        phiLength: r,
                        thetaStart: a,
                        thetaLength: s
                    },
                    t = Math.max(3, Math.floor(t)),
                    n = Math.max(2, Math.floor(n));
                    const o = Math.min(a + s, Math.PI);
                    let l = 0;
                    const c = []
                      , h = new Mn
                      , d = new Mn
                      , u = []
                      , p = []
                      , f = []
                      , g = [];
                    for (let u = 0; u <= n; u++) {
                        const m = []
                          , A = u / n;
                        let v = 0;
                        0 === u && 0 === a ? v = .5 / t : u === n && o === Math.PI && (v = -.5 / t);
                        for (let n = 0; n <= t; n++) {
                            const o = n / t;
                            h.x = -e * Math.cos(i + o * r) * Math.sin(a + A * s),
                            h.y = e * Math.cos(a + A * s),
                            h.z = e * Math.sin(i + o * r) * Math.sin(a + A * s),
                            p.push(h.x, h.y, h.z),
                            d.copy(h).normalize(),
                            f.push(d.x, d.y, d.z),
                            g.push(o + v, 1 - A),
                            m.push(l++)
                        }
                        c.push(m)
                    }
                    for (let e = 0; e < n; e++)
                        for (let i = 0; i < t; i++) {
                            const t = c[e][i + 1]
                              , r = c[e][i]
                              , s = c[e + 1][i]
                              , l = c[e + 1][i + 1];
                            (0 !== e || a > 0) && u.push(t, r, l),
                            (e !== n - 1 || o < Math.PI) && u.push(r, s, l)
                        }
                    this.setIndex(u),
                    this.setAttribute("position", new Mr(p,3)),
                    this.setAttribute("normal", new Mr(f,3)),
                    this.setAttribute("uv", new Mr(g,2))
                }
                copy(e) {
                    return super.copy(e),
                    this.parameters = Object.assign({}, e.parameters),
                    this
                }
                static fromJSON(e) {
                    return new Fo(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
                }
            }
            class Oo extends ea {
                constructor(e) {
                    super(e),
                    this.isRawShaderMaterial = !0,
                    this.type = "RawShaderMaterial"
                }
            }
            class Wo extends yr {
                constructor(e) {
                    super(),
                    this.isMeshStandardMaterial = !0,
                    this.type = "MeshStandardMaterial",
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color = new mr(16777215),
                    this.roughness = 1,
                    this.metalness = 0,
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new mr(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = zt,
                    this.normalScale = new Tn(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.roughnessMap = null,
                    this.metalnessMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapRotation = new Ni,
                    this.envMapIntensity = 1,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.flatShading = !1,
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.defines = {
                        STANDARD: ""
                    },
                    this.color.copy(e.color),
                    this.roughness = e.roughness,
                    this.metalness = e.metalness,
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.roughnessMap = e.roughnessMap,
                    this.metalnessMap = e.metalnessMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.envMapRotation.copy(e.envMapRotation),
                    this.envMapIntensity = e.envMapIntensity,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.flatShading = e.flatShading,
                    this.fog = e.fog,
                    this
                }
            }
            class Vo extends Wo {
                constructor(e) {
                    super(),
                    this.isMeshPhysicalMaterial = !0,
                    this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    },
                    this.type = "MeshPhysicalMaterial",
                    this.anisotropyRotation = 0,
                    this.anisotropyMap = null,
                    this.clearcoatMap = null,
                    this.clearcoatRoughness = 0,
                    this.clearcoatRoughnessMap = null,
                    this.clearcoatNormalScale = new Tn(1,1),
                    this.clearcoatNormalMap = null,
                    this.ior = 1.5,
                    Object.defineProperty(this, "reflectivity", {
                        get: function() {
                            return yn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                        },
                        set: function(e) {
                            this.ior = (1 + .4 * e) / (1 - .4 * e)
                        }
                    }),
                    this.iridescenceMap = null,
                    this.iridescenceIOR = 1.3,
                    this.iridescenceThicknessRange = [100, 400],
                    this.iridescenceThicknessMap = null,
                    this.sheenColor = new mr(0),
                    this.sheenColorMap = null,
                    this.sheenRoughness = 1,
                    this.sheenRoughnessMap = null,
                    this.transmissionMap = null,
                    this.thickness = 0,
                    this.thicknessMap = null,
                    this.attenuationDistance = 1 / 0,
                    this.attenuationColor = new mr(1,1,1),
                    this.specularIntensity = 1,
                    this.specularIntensityMap = null,
                    this.specularColor = new mr(1,1,1),
                    this.specularColorMap = null,
                    this._anisotropy = 0,
                    this._clearcoat = 0,
                    this._dispersion = 0,
                    this._iridescence = 0,
                    this._sheen = 0,
                    this._transmission = 0,
                    this.setValues(e)
                }
                get anisotropy() {
                    return this._anisotropy
                }
                set anisotropy(e) {
                    this._anisotropy > 0 != e > 0 && this.version++,
                    this._anisotropy = e
                }
                get clearcoat() {
                    return this._clearcoat
                }
                set clearcoat(e) {
                    this._clearcoat > 0 != e > 0 && this.version++,
                    this._clearcoat = e
                }
                get iridescence() {
                    return this._iridescence
                }
                set iridescence(e) {
                    this._iridescence > 0 != e > 0 && this.version++,
                    this._iridescence = e
                }
                get dispersion() {
                    return this._dispersion
                }
                set dispersion(e) {
                    this._dispersion > 0 != e > 0 && this.version++,
                    this._dispersion = e
                }
                get sheen() {
                    return this._sheen
                }
                set sheen(e) {
                    this._sheen > 0 != e > 0 && this.version++,
                    this._sheen = e
                }
                get transmission() {
                    return this._transmission
                }
                set transmission(e) {
                    this._transmission > 0 != e > 0 && this.version++,
                    this._transmission = e
                }
                copy(e) {
                    return super.copy(e),
                    this.defines = {
                        STANDARD: "",
                        PHYSICAL: ""
                    },
                    this.anisotropy = e.anisotropy,
                    this.anisotropyRotation = e.anisotropyRotation,
                    this.anisotropyMap = e.anisotropyMap,
                    this.clearcoat = e.clearcoat,
                    this.clearcoatMap = e.clearcoatMap,
                    this.clearcoatRoughness = e.clearcoatRoughness,
                    this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                    this.clearcoatNormalMap = e.clearcoatNormalMap,
                    this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                    this.dispersion = e.dispersion,
                    this.ior = e.ior,
                    this.iridescence = e.iridescence,
                    this.iridescenceMap = e.iridescenceMap,
                    this.iridescenceIOR = e.iridescenceIOR,
                    this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                    this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                    this.sheen = e.sheen,
                    this.sheenColor.copy(e.sheenColor),
                    this.sheenColorMap = e.sheenColorMap,
                    this.sheenRoughness = e.sheenRoughness,
                    this.sheenRoughnessMap = e.sheenRoughnessMap,
                    this.transmission = e.transmission,
                    this.transmissionMap = e.transmissionMap,
                    this.thickness = e.thickness,
                    this.thicknessMap = e.thicknessMap,
                    this.attenuationDistance = e.attenuationDistance,
                    this.attenuationColor.copy(e.attenuationColor),
                    this.specularIntensity = e.specularIntensity,
                    this.specularIntensityMap = e.specularIntensityMap,
                    this.specularColor.copy(e.specularColor),
                    this.specularColorMap = e.specularColorMap,
                    this
                }
            }
            class Ho extends yr {
                constructor(e) {
                    super(),
                    this.isMeshLambertMaterial = !0,
                    this.type = "MeshLambertMaterial",
                    this.color = new mr(16777215),
                    this.map = null,
                    this.lightMap = null,
                    this.lightMapIntensity = 1,
                    this.aoMap = null,
                    this.aoMapIntensity = 1,
                    this.emissive = new mr(0),
                    this.emissiveIntensity = 1,
                    this.emissiveMap = null,
                    this.bumpMap = null,
                    this.bumpScale = 1,
                    this.normalMap = null,
                    this.normalMapType = zt,
                    this.normalScale = new Tn(1,1),
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.specularMap = null,
                    this.alphaMap = null,
                    this.envMap = null,
                    this.envMapRotation = new Ni,
                    this.combine = J,
                    this.reflectivity = 1,
                    this.refractionRatio = .98,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.wireframeLinecap = "round",
                    this.wireframeLinejoin = "round",
                    this.flatShading = !1,
                    this.fog = !0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.color.copy(e.color),
                    this.map = e.map,
                    this.lightMap = e.lightMap,
                    this.lightMapIntensity = e.lightMapIntensity,
                    this.aoMap = e.aoMap,
                    this.aoMapIntensity = e.aoMapIntensity,
                    this.emissive.copy(e.emissive),
                    this.emissiveMap = e.emissiveMap,
                    this.emissiveIntensity = e.emissiveIntensity,
                    this.bumpMap = e.bumpMap,
                    this.bumpScale = e.bumpScale,
                    this.normalMap = e.normalMap,
                    this.normalMapType = e.normalMapType,
                    this.normalScale.copy(e.normalScale),
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.specularMap = e.specularMap,
                    this.alphaMap = e.alphaMap,
                    this.envMap = e.envMap,
                    this.envMapRotation.copy(e.envMapRotation),
                    this.combine = e.combine,
                    this.reflectivity = e.reflectivity,
                    this.refractionRatio = e.refractionRatio,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this.wireframeLinecap = e.wireframeLinecap,
                    this.wireframeLinejoin = e.wireframeLinejoin,
                    this.flatShading = e.flatShading,
                    this.fog = e.fog,
                    this
                }
            }
            class jo extends yr {
                constructor(e) {
                    super(),
                    this.isMeshDepthMaterial = !0,
                    this.type = "MeshDepthMaterial",
                    this.depthPacking = 3200,
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.wireframe = !1,
                    this.wireframeLinewidth = 1,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.depthPacking = e.depthPacking,
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this.wireframe = e.wireframe,
                    this.wireframeLinewidth = e.wireframeLinewidth,
                    this
                }
            }
            class Ko extends yr {
                constructor(e) {
                    super(),
                    this.isMeshDistanceMaterial = !0,
                    this.type = "MeshDistanceMaterial",
                    this.map = null,
                    this.alphaMap = null,
                    this.displacementMap = null,
                    this.displacementScale = 1,
                    this.displacementBias = 0,
                    this.setValues(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.map = e.map,
                    this.alphaMap = e.alphaMap,
                    this.displacementMap = e.displacementMap,
                    this.displacementScale = e.displacementScale,
                    this.displacementBias = e.displacementBias,
                    this
                }
            }
            function qo(e, t) {
                return e && e.constructor !== t ? "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) : e
            }
            function Qo(e) {
                const t = e.length
                  , n = new Array(t);
                for (let e = 0; e !== t; ++e)
                    n[e] = e;
                return n.sort((function(t, n) {
                    return e[t] - e[n]
                }
                )),
                n
            }
            function Jo(e, t, n) {
                const i = e.length
                  , r = new e.constructor(i);
                for (let a = 0, s = 0; s !== i; ++a) {
                    const i = n[a] * t;
                    for (let n = 0; n !== t; ++n)
                        r[s++] = e[i + n]
                }
                return r
            }
            function Xo(e, t, n, i) {
                let r = 1
                  , a = e[0];
                for (; void 0 !== a && void 0 === a[i]; )
                    a = e[r++];
                if (void 0 === a)
                    return;
                let s = a[i];
                if (void 0 !== s)
                    if (Array.isArray(s))
                        do {
                            s = a[i],
                            void 0 !== s && (t.push(a.time),
                            n.push(...s)),
                            a = e[r++]
                        } while (void 0 !== a);
                    else if (void 0 !== s.toArray)
                        do {
                            s = a[i],
                            void 0 !== s && (t.push(a.time),
                            s.toArray(n, n.length)),
                            a = e[r++]
                        } while (void 0 !== a);
                    else
                        do {
                            s = a[i],
                            void 0 !== s && (t.push(a.time),
                            n.push(s)),
                            a = e[r++]
                        } while (void 0 !== a)
            }
            class Yo {
                constructor(e, t, n, i) {
                    this.parameterPositions = e,
                    this._cachedIndex = 0,
                    this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
                    this.sampleValues = t,
                    this.valueSize = n,
                    this.settings = null,
                    this.DefaultSettings_ = {}
                }
                evaluate(e) {
                    const t = this.parameterPositions;
                    let n = this._cachedIndex
                      , i = t[n]
                      , r = t[n - 1];
                    e: {
                        t: {
                            let a;
                            n: {
                                i: if (!(e < i)) {
                                    for (let a = n + 2; ; ) {
                                        if (void 0 === i) {
                                            if (e < r)
                                                break i;
                                            return n = t.length,
                                            this._cachedIndex = n,
                                            this.copySampleValue_(n - 1)
                                        }
                                        if (n === a)
                                            break;
                                        if (r = i,
                                        i = t[++n],
                                        e < i)
                                            break t
                                    }
                                    a = t.length;
                                    break n
                                }
                                if (e >= r)
                                    break e;
                                {
                                    const s = t[1];
                                    e < s && (n = 2,
                                    r = s);
                                    for (let a = n - 2; ; ) {
                                        if (void 0 === r)
                                            return this._cachedIndex = 0,
                                            this.copySampleValue_(0);
                                        if (n === a)
                                            break;
                                        if (i = r,
                                        r = t[--n - 1],
                                        e >= r)
                                            break t
                                    }
                                    a = n,
                                    n = 0
                                }
                            }
                            for (; n < a; ) {
                                const i = n + a >>> 1;
                                e < t[i] ? a = i : n = i + 1
                            }
                            if (i = t[n],
                            r = t[n - 1],
                            void 0 === r)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (void 0 === i)
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer
                      , n = this.sampleValues
                      , i = this.valueSize
                      , r = e * i;
                    for (let e = 0; e !== i; ++e)
                        t[e] = n[r + e];
                    return t
                }
                interpolate_() {
                    throw new Error("call to abstract method")
                }
                intervalChanged_() {}
            }
            class Zo extends Yo {
                constructor(e, t, n, i) {
                    super(e, t, n, i),
                    this._weightPrev = -0,
                    this._offsetPrev = -0,
                    this._weightNext = -0,
                    this._offsetNext = -0,
                    this.DefaultSettings_ = {
                        endingStart: Ct,
                        endingEnd: Ct
                    }
                }
                intervalChanged_(e, t, n) {
                    const i = this.parameterPositions;
                    let r = e - 2
                      , a = e + 1
                      , s = i[r]
                      , o = i[a];
                    if (void 0 === s)
                        switch (this.getSettings_().endingStart) {
                        case Rt:
                            r = e,
                            s = 2 * t - n;
                            break;
                        case Pt:
                            r = i.length - 2,
                            s = t + i[r] - i[r + 1];
                            break;
                        default:
                            r = e,
                            s = n
                        }
                    if (void 0 === o)
                        switch (this.getSettings_().endingEnd) {
                        case Rt:
                            a = e,
                            o = 2 * n - t;
                            break;
                        case Pt:
                            a = 1,
                            o = n + i[1] - i[0];
                            break;
                        default:
                            a = e - 1,
                            o = t
                        }
                    const l = .5 * (n - t)
                      , c = this.valueSize;
                    this._weightPrev = l / (t - s),
                    this._weightNext = l / (o - n),
                    this._offsetPrev = r * c,
                    this._offsetNext = a * c
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = e * s
                      , l = o - s
                      , c = this._offsetPrev
                      , h = this._offsetNext
                      , d = this._weightPrev
                      , u = this._weightNext
                      , p = (n - t) / (i - t)
                      , f = p * p
                      , g = f * p
                      , m = -d * g + 2 * d * f - d * p
                      , A = (1 + d) * g + (-1.5 - 2 * d) * f + (-.5 + d) * p + 1
                      , v = (-1 - u) * g + (1.5 + u) * f + .5 * p
                      , y = u * g - u * f;
                    for (let e = 0; e !== s; ++e)
                        r[e] = m * a[c + e] + A * a[l + e] + v * a[o + e] + y * a[h + e];
                    return r
                }
            }
            class $o extends Yo {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = e * s
                      , l = o - s
                      , c = (n - t) / (i - t)
                      , h = 1 - c;
                    for (let e = 0; e !== s; ++e)
                        r[e] = a[l + e] * h + a[o + e] * c;
                    return r
                }
            }
            class el extends Yo {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e) {
                    return this.copySampleValue_(e - 1)
                }
            }
            class tl {
                constructor(e, t, n, i) {
                    if (void 0 === e)
                        throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === t || 0 === t.length)
                        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                    this.name = e,
                    this.times = qo(t, this.TimeBufferType),
                    this.values = qo(n, this.ValueBufferType),
                    this.setInterpolation(i || this.DefaultInterpolation)
                }
                static toJSON(e) {
                    const t = e.constructor;
                    let n;
                    if (t.toJSON !== this.toJSON)
                        n = t.toJSON(e);
                    else {
                        n = {
                            name: e.name,
                            times: qo(e.times, Array),
                            values: qo(e.values, Array)
                        };
                        const t = e.getInterpolation();
                        t !== e.DefaultInterpolation && (n.interpolation = t)
                    }
                    return n.type = e.ValueTypeName,
                    n
                }
                InterpolantFactoryMethodDiscrete(e) {
                    return new el(this.times,this.values,this.getValueSize(),e)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new $o(this.times,this.values,this.getValueSize(),e)
                }
                InterpolantFactoryMethodSmooth(e) {
                    return new Zo(this.times,this.values,this.getValueSize(),e)
                }
                setInterpolation(e) {
                    let t;
                    switch (e) {
                    case kt:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Mt:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case _t:
                        t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation)
                                throw new Error(t);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return cn("KeyframeTrack:", t),
                        this
                    }
                    return this.createInterpolant = t,
                    this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return kt;
                    case this.InterpolantFactoryMethodLinear:
                        return Mt;
                    case this.InterpolantFactoryMethodSmooth:
                        return _t
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(e) {
                    if (0 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n)
                            t[n] += e
                    }
                    return this
                }
                scale(e) {
                    if (1 !== e) {
                        const t = this.times;
                        for (let n = 0, i = t.length; n !== i; ++n)
                            t[n] *= e
                    }
                    return this
                }
                trim(e, t) {
                    const n = this.times
                      , i = n.length;
                    let r = 0
                      , a = i - 1;
                    for (; r !== i && n[r] < e; )
                        ++r;
                    for (; -1 !== a && n[a] > t; )
                        --a;
                    if (++a,
                    0 !== r || a !== i) {
                        r >= a && (a = Math.max(a, 1),
                        r = a - 1);
                        const e = this.getValueSize();
                        this.times = n.slice(r, a),
                        this.values = this.values.slice(r * e, a * e)
                    }
                    return this
                }
                validate() {
                    let e = !0;
                    const t = this.getValueSize();
                    t - Math.floor(t) != 0 && (hn("KeyframeTrack: Invalid value size in track.", this),
                    e = !1);
                    const n = this.times
                      , i = this.values
                      , r = n.length;
                    0 === r && (hn("KeyframeTrack: Track is empty.", this),
                    e = !1);
                    let a = null;
                    for (let t = 0; t !== r; t++) {
                        const i = n[t];
                        if ("number" == typeof i && isNaN(i)) {
                            hn("KeyframeTrack: Time is not a valid number.", this, t, i),
                            e = !1;
                            break
                        }
                        if (null !== a && a > i) {
                            hn("KeyframeTrack: Out of order keys.", this, t, i, a),
                            e = !1;
                            break
                        }
                        a = i
                    }
                    if (void 0 !== i && nn(i))
                        for (let t = 0, n = i.length; t !== n; ++t) {
                            const n = i[t];
                            if (isNaN(n)) {
                                hn("KeyframeTrack: Value is not a valid number.", this, t, n),
                                e = !1;
                                break
                            }
                        }
                    return e
                }
                optimize() {
                    const e = this.times.slice()
                      , t = this.values.slice()
                      , n = this.getValueSize()
                      , i = this.getInterpolation() === _t
                      , r = e.length - 1;
                    let a = 1;
                    for (let s = 1; s < r; ++s) {
                        let r = !1;
                        const o = e[s];
                        if (o !== e[s + 1] && (1 !== s || o !== e[0]))
                            if (i)
                                r = !0;
                            else {
                                const e = s * n
                                  , i = e - n
                                  , a = e + n;
                                for (let s = 0; s !== n; ++s) {
                                    const n = t[e + s];
                                    if (n !== t[i + s] || n !== t[a + s]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (s !== a) {
                                e[a] = e[s];
                                const i = s * n
                                  , r = a * n;
                                for (let e = 0; e !== n; ++e)
                                    t[r + e] = t[i + e]
                            }
                            ++a
                        }
                    }
                    if (r > 0) {
                        e[a] = e[r];
                        for (let e = r * n, i = a * n, s = 0; s !== n; ++s)
                            t[i + s] = t[e + s];
                        ++a
                    }
                    return a !== e.length ? (this.times = e.slice(0, a),
                    this.values = t.slice(0, a * n)) : (this.times = e,
                    this.values = t),
                    this
                }
                clone() {
                    const e = this.times.slice()
                      , t = this.values.slice()
                      , n = new (0,
                    this.constructor)(this.name,e,t);
                    return n.createInterpolant = this.createInterpolant,
                    n
                }
            }
            tl.prototype.ValueTypeName = "",
            tl.prototype.TimeBufferType = Float32Array,
            tl.prototype.ValueBufferType = Float32Array,
            tl.prototype.DefaultInterpolation = Mt;
            class nl extends tl {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            nl.prototype.ValueTypeName = "bool",
            nl.prototype.ValueBufferType = Array,
            nl.prototype.DefaultInterpolation = kt,
            nl.prototype.InterpolantFactoryMethodLinear = void 0,
            nl.prototype.InterpolantFactoryMethodSmooth = void 0;
            class il extends tl {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
            }
            il.prototype.ValueTypeName = "color";
            class rl extends tl {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
            }
            rl.prototype.ValueTypeName = "number";
            class al extends Yo {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = (n - t) / (i - t);
                    let l = e * s;
                    for (let e = l + s; l !== e; l += 4)
                        kn.slerpFlat(r, 0, a, l - s, a, l, o);
                    return r
                }
            }
            class sl extends tl {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                InterpolantFactoryMethodLinear(e) {
                    return new al(this.times,this.values,this.getValueSize(),e)
                }
            }
            sl.prototype.ValueTypeName = "quaternion",
            sl.prototype.InterpolantFactoryMethodSmooth = void 0;
            class ol extends tl {
                constructor(e, t, n) {
                    super(e, t, n)
                }
            }
            ol.prototype.ValueTypeName = "string",
            ol.prototype.ValueBufferType = Array,
            ol.prototype.DefaultInterpolation = kt,
            ol.prototype.InterpolantFactoryMethodLinear = void 0,
            ol.prototype.InterpolantFactoryMethodSmooth = void 0;
            class ll extends tl {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
            }
            ll.prototype.ValueTypeName = "vector";
            class cl {
                constructor(e="", t=-1, n=[], i=2500) {
                    this.name = e,
                    this.tracks = n,
                    this.duration = t,
                    this.blendMode = i,
                    this.uuid = vn(),
                    this.userData = {},
                    this.duration < 0 && this.resetDuration()
                }
                static parse(e) {
                    const t = []
                      , n = e.tracks
                      , i = 1 / (e.fps || 1);
                    for (let e = 0, r = n.length; e !== r; ++e)
                        t.push(hl(n[e]).scale(i));
                    const r = new this(e.name,e.duration,t,e.blendMode);
                    return r.uuid = e.uuid,
                    r.userData = JSON.parse(e.userData || "{}"),
                    r
                }
                static toJSON(e) {
                    const t = []
                      , n = e.tracks
                      , i = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode,
                        userData: JSON.stringify(e.userData)
                    };
                    for (let e = 0, i = n.length; e !== i; ++e)
                        t.push(tl.toJSON(n[e]));
                    return i
                }
                static CreateFromMorphTargetSequence(e, t, n, i) {
                    const r = t.length
                      , a = [];
                    for (let e = 0; e < r; e++) {
                        let s = []
                          , o = [];
                        s.push((e + r - 1) % r, e, (e + 1) % r),
                        o.push(0, 1, 0);
                        const l = Qo(s);
                        s = Jo(s, 1, l),
                        o = Jo(o, 1, l),
                        i || 0 !== s[0] || (s.push(r),
                        o.push(o[0])),
                        a.push(new rl(".morphTargetInfluences[" + t[e].name + "]",s,o).scale(1 / n))
                    }
                    return new this(e,-1,a)
                }
                static findByName(e, t) {
                    let n = e;
                    if (!Array.isArray(e)) {
                        const t = e;
                        n = t.geometry && t.geometry.animations || t.animations
                    }
                    for (let e = 0; e < n.length; e++)
                        if (n[e].name === t)
                            return n[e];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(e, t, n) {
                    const i = {}
                      , r = /^([\w-]*?)([\d]+)$/;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t]
                          , a = n.name.match(r);
                        if (a && a.length > 1) {
                            const e = a[1];
                            let t = i[e];
                            t || (i[e] = t = []),
                            t.push(n)
                        }
                    }
                    const a = [];
                    for (const e in i)
                        a.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                    return a
                }
                static parseAnimation(e, t) {
                    if (cn("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),
                    !e)
                        return hn("AnimationClip: No animation in JSONLoader data."),
                        null;
                    const n = function(e, t, n, i, r) {
                        if (0 !== n.length) {
                            const a = []
                              , s = [];
                            Xo(n, a, s, i),
                            0 !== a.length && r.push(new e(t,a,s))
                        }
                    }
                      , i = []
                      , r = e.name || "default"
                      , a = e.fps || 30
                      , s = e.blendMode;
                    let o = e.length || -1;
                    const l = e.hierarchy || [];
                    for (let e = 0; e < l.length; e++) {
                        const r = l[e].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const e = {};
                                let t;
                                for (t = 0; t < r.length; t++)
                                    if (r[t].morphTargets)
                                        for (let n = 0; n < r[t].morphTargets.length; n++)
                                            e[r[t].morphTargets[n]] = -1;
                                for (const n in e) {
                                    const e = []
                                      , a = [];
                                    for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                        const i = r[t];
                                        e.push(i.time),
                                        a.push(i.morphTarget === n ? 1 : 0)
                                    }
                                    i.push(new rl(".morphTargetInfluence[" + n + "]",e,a))
                                }
                                o = e.length * a
                            } else {
                                const a = ".bones[" + t[e].name + "]";
                                n(ll, a + ".position", r, "pos", i),
                                n(sl, a + ".quaternion", r, "rot", i),
                                n(ll, a + ".scale", r, "scl", i)
                            }
                    }
                    if (0 === i.length)
                        return null;
                    return new this(r,o,i,s)
                }
                resetDuration() {
                    let e = 0;
                    for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                        const n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1])
                    }
                    return this.duration = e,
                    this
                }
                trim() {
                    for (let e = 0; e < this.tracks.length; e++)
                        this.tracks[e].trim(0, this.duration);
                    return this
                }
                validate() {
                    let e = !0;
                    for (let t = 0; t < this.tracks.length; t++)
                        e = e && this.tracks[t].validate();
                    return e
                }
                optimize() {
                    for (let e = 0; e < this.tracks.length; e++)
                        this.tracks[e].optimize();
                    return this
                }
                clone() {
                    const e = [];
                    for (let t = 0; t < this.tracks.length; t++)
                        e.push(this.tracks[t].clone());
                    const t = new this.constructor(this.name,this.duration,e,this.blendMode);
                    return t.userData = JSON.parse(JSON.stringify(this.userData)),
                    t
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }
            function hl(e) {
                if (void 0 === e.type)
                    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const t = function(e) {
                    switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return rl;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return ll;
                    case "color":
                        return il;
                    case "quaternion":
                        return sl;
                    case "bool":
                    case "boolean":
                        return nl;
                    case "string":
                        return ol
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    const t = []
                      , n = [];
                    Xo(e.keys, t, n, "value"),
                    e.times = t,
                    e.values = n
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
            }
            const dl = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    !1 !== this.enabled && (this.files[e] = t)
                },
                get: function(e) {
                    if (!1 !== this.enabled)
                        return this.files[e]
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            };
            class ul {
                constructor(e, t, n) {
                    const i = this;
                    let r, a = !1, s = 0, o = 0;
                    const l = [];
                    this.onStart = void 0,
                    this.onLoad = e,
                    this.onProgress = t,
                    this.onError = n,
                    this._abortController = null,
                    this.itemStart = function(e) {
                        o++,
                        !1 === a && void 0 !== i.onStart && i.onStart(e, s, o),
                        a = !0
                    }
                    ,
                    this.itemEnd = function(e) {
                        s++,
                        void 0 !== i.onProgress && i.onProgress(e, s, o),
                        s === o && (a = !1,
                        void 0 !== i.onLoad && i.onLoad())
                    }
                    ,
                    this.itemError = function(e) {
                        void 0 !== i.onError && i.onError(e)
                    }
                    ,
                    this.resolveURL = function(e) {
                        return r ? r(e) : e
                    }
                    ,
                    this.setURLModifier = function(e) {
                        return r = e,
                        this
                    }
                    ,
                    this.addHandler = function(e, t) {
                        return l.push(e, t),
                        this
                    }
                    ,
                    this.removeHandler = function(e) {
                        const t = l.indexOf(e);
                        return -1 !== t && l.splice(t, 2),
                        this
                    }
                    ,
                    this.getHandler = function(e) {
                        for (let t = 0, n = l.length; t < n; t += 2) {
                            const n = l[t]
                              , i = l[t + 1];
                            if (n.global && (n.lastIndex = 0),
                            n.test(e))
                                return i
                        }
                        return null
                    }
                    ,
                    this.abort = function() {
                        return this.abortController.abort(),
                        this._abortController = null,
                        this
                    }
                }
                get abortController() {
                    return this._abortController || (this._abortController = new AbortController),
                    this._abortController
                }
            }
            const pl = new ul;
            class fl {
                constructor(e) {
                    this.manager = void 0 !== e ? e : pl,
                    this.crossOrigin = "anonymous",
                    this.withCredentials = !1,
                    this.path = "",
                    this.resourcePath = "",
                    this.requestHeader = {}
                }
                load() {}
                loadAsync(e, t) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.load(e, i, t, r)
                    }
                    ))
                }
                parse() {}
                setCrossOrigin(e) {
                    return this.crossOrigin = e,
                    this
                }
                setWithCredentials(e) {
                    return this.withCredentials = e,
                    this
                }
                setPath(e) {
                    return this.path = e,
                    this
                }
                setResourcePath(e) {
                    return this.resourcePath = e,
                    this
                }
                setRequestHeader(e) {
                    return this.requestHeader = e,
                    this
                }
                abort() {
                    return this
                }
            }
            fl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            const gl = {};
            class ml extends Error {
                constructor(e, t) {
                    super(e),
                    this.response = t
                }
            }
            class Al extends fl {
                constructor(e) {
                    super(e),
                    this.mimeType = "",
                    this.responseType = "",
                    this._abortController = new AbortController
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""),
                    void 0 !== this.path && (e = this.path + e),
                    e = this.manager.resolveURL(e);
                    const r = dl.get(`file:${e}`);
                    if (void 0 !== r)
                        return this.manager.itemStart(e),
                        setTimeout(( () => {
                            t && t(r),
                            this.manager.itemEnd(e)
                        }
                        ), 0),
                        r;
                    if (void 0 !== gl[e])
                        return void gl[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                    gl[e] = [],
                    gl[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    const a = new Request(e,{
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin",
                        signal: "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
                    })
                      , s = this.mimeType
                      , o = this.responseType;
                    fetch(a).then((t => {
                        if (200 === t.status || 0 === t.status) {
                            if (0 === t.status && cn("FileLoader: HTTP Status 0 received."),
                            "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                                return t;
                            const n = gl[e]
                              , i = t.body.getReader()
                              , r = t.headers.get("X-File-Size") || t.headers.get("Content-Length")
                              , a = r ? parseInt(r) : 0
                              , s = 0 !== a;
                            let o = 0;
                            const l = new ReadableStream({
                                start(e) {
                                    !function t() {
                                        i.read().then(( ({done: i, value: r}) => {
                                            if (i)
                                                e.close();
                                            else {
                                                o += r.byteLength;
                                                const i = new ProgressEvent("progress",{
                                                    lengthComputable: s,
                                                    loaded: o,
                                                    total: a
                                                });
                                                for (let e = 0, t = n.length; e < t; e++) {
                                                    const t = n[e];
                                                    t.onProgress && t.onProgress(i)
                                                }
                                                e.enqueue(r),
                                                t()
                                            }
                                        }
                                        ), (t => {
                                            e.error(t)
                                        }
                                        ))
                                    }()
                                }
                            });
                            return new Response(l)
                        }
                        throw new ml(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                    }
                    )).then((e => {
                        switch (o) {
                        case "arraybuffer":
                            return e.arrayBuffer();
                        case "blob":
                            return e.blob();
                        case "document":
                            return e.text().then((e => (new DOMParser).parseFromString(e, s)));
                        case "json":
                            return e.json();
                        default:
                            if ("" === s)
                                return e.text();
                            {
                                const t = /charset="?([^;"\s]*)"?/i.exec(s)
                                  , n = t && t[1] ? t[1].toLowerCase() : void 0
                                  , i = new TextDecoder(n);
                                return e.arrayBuffer().then((e => i.decode(e)))
                            }
                        }
                    }
                    )).then((t => {
                        dl.add(`file:${e}`, t);
                        const n = gl[e];
                        delete gl[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onLoad && i.onLoad(t)
                        }
                    }
                    )).catch((t => {
                        const n = gl[e];
                        if (void 0 === n)
                            throw this.manager.itemError(e),
                            t;
                        delete gl[e];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e];
                            i.onError && i.onError(t)
                        }
                        this.manager.itemError(e)
                    }
                    )).finally(( () => {
                        this.manager.itemEnd(e)
                    }
                    )),
                    this.manager.itemStart(e)
                }
                setResponseType(e) {
                    return this.responseType = e,
                    this
                }
                setMimeType(e) {
                    return this.mimeType = e,
                    this
                }
                abort() {
                    return this._abortController.abort(),
                    this._abortController = new AbortController,
                    this
                }
            }
            const vl = new WeakMap;
            class yl extends fl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    void 0 !== this.path && (e = this.path + e),
                    e = this.manager.resolveURL(e);
                    const r = this
                      , a = dl.get(`image:${e}`);
                    if (void 0 !== a) {
                        if (!0 === a.complete)
                            r.manager.itemStart(e),
                            setTimeout((function() {
                                t && t(a),
                                r.manager.itemEnd(e)
                            }
                            ), 0);
                        else {
                            let e = vl.get(a);
                            void 0 === e && (e = [],
                            vl.set(a, e)),
                            e.push({
                                onLoad: t,
                                onError: i
                            })
                        }
                        return a
                    }
                    const s = rn("img");
                    function o() {
                        c(),
                        t && t(this);
                        const n = vl.get(this) || [];
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e];
                            t.onLoad && t.onLoad(this)
                        }
                        vl.delete(this),
                        r.manager.itemEnd(e)
                    }
                    function l(t) {
                        c(),
                        i && i(t),
                        dl.remove(`image:${e}`);
                        const n = vl.get(this) || [];
                        for (let e = 0; e < n.length; e++) {
                            const i = n[e];
                            i.onError && i.onError(t)
                        }
                        vl.delete(this),
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }
                    function c() {
                        s.removeEventListener("load", o, !1),
                        s.removeEventListener("error", l, !1)
                    }
                    return s.addEventListener("load", o, !1),
                    s.addEventListener("error", l, !1),
                    "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
                    dl.add(`image:${e}`, s),
                    r.manager.itemStart(e),
                    s.src = e,
                    s
                }
            }
            class wl extends fl {
                constructor(e) {
                    super(e)
                }
                load(e, t, n, i) {
                    const r = new jn
                      , a = new yl(this.manager);
                    return a.setCrossOrigin(this.crossOrigin),
                    a.setPath(this.path),
                    a.load(e, (function(e) {
                        r.image = e,
                        r.needsUpdate = !0,
                        void 0 !== t && t(r)
                    }
                    ), n, i),
                    r
                }
            }
            class bl extends Yi {
                constructor(e, t=1) {
                    super(),
                    this.isLight = !0,
                    this.type = "Light",
                    this.color = new mr(e),
                    this.intensity = t
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.color.copy(e.color),
                    this.intensity = e.intensity,
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.color = this.color.getHex(),
                    t.object.intensity = this.intensity,
                    t
                }
            }
            class xl extends bl {
                constructor(e, t, n) {
                    super(e, n),
                    this.isHemisphereLight = !0,
                    this.type = "HemisphereLight",
                    this.position.copy(Yi.DEFAULT_UP),
                    this.updateMatrix(),
                    this.groundColor = new mr(t)
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.groundColor.copy(e.groundColor),
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.groundColor = this.groundColor.getHex(),
                    t
                }
            }
            const Sl = new Ei
              , El = new Mn
              , Tl = new Mn;
            class kl {
                constructor(e) {
                    this.camera = e,
                    this.intensity = 1,
                    this.bias = 0,
                    this.normalBias = 0,
                    this.radius = 1,
                    this.blurSamples = 8,
                    this.mapSize = new Tn(512,512),
                    this.mapType = be,
                    this.map = null,
                    this.mapPass = null,
                    this.matrix = new Ei,
                    this.autoUpdate = !0,
                    this.needsUpdate = !1,
                    this._frustum = new Ja,
                    this._frameExtents = new Tn(1,1),
                    this._viewportCount = 1,
                    this._viewports = [new Kn(0,0,1,1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(e) {
                    const t = this.camera
                      , n = this.matrix;
                    El.setFromMatrixPosition(e.matrixWorld),
                    t.position.copy(El),
                    Tl.setFromMatrixPosition(e.target.matrixWorld),
                    t.lookAt(Tl),
                    t.updateMatrixWorld(),
                    Sl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    this._frustum.setFromProjectionMatrix(Sl, t.coordinateSystem, t.reversedDepth),
                    t.reversedDepth ? n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, 1, 0, 0, 0, 0, 1) : n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                    n.multiply(Sl)
                }
                getViewport(e) {
                    return this._viewports[e]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                dispose() {
                    this.map && this.map.dispose(),
                    this.mapPass && this.mapPass.dispose()
                }
                copy(e) {
                    return this.camera = e.camera.clone(),
                    this.intensity = e.intensity,
                    this.bias = e.bias,
                    this.radius = e.radius,
                    this.autoUpdate = e.autoUpdate,
                    this.needsUpdate = e.needsUpdate,
                    this.normalBias = e.normalBias,
                    this.blurSamples = e.blurSamples,
                    this.mapSize.copy(e.mapSize),
                    this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const e = {};
                    return 1 !== this.intensity && (e.intensity = this.intensity),
                    0 !== this.bias && (e.bias = this.bias),
                    0 !== this.normalBias && (e.normalBias = this.normalBias),
                    1 !== this.radius && (e.radius = this.radius),
                    512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                    e.camera = this.camera.toJSON(!1).object,
                    delete e.camera.matrix,
                    e
                }
            }
            class Ml extends kl {
                constructor() {
                    super(new aa(50,1,.5,500)),
                    this.isSpotLightShadow = !0,
                    this.focus = 1,
                    this.aspect = 1
                }
                updateMatrices(e) {
                    const t = this.camera
                      , n = 2 * An * e.angle * this.focus
                      , i = this.mapSize.width / this.mapSize.height * this.aspect
                      , r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
                    t.aspect = i,
                    t.far = r,
                    t.updateProjectionMatrix()),
                    super.updateMatrices(e)
                }
                copy(e) {
                    return super.copy(e),
                    this.focus = e.focus,
                    this
                }
            }
            class _l extends bl {
                constructor(e, t, n=0, i=Math.PI / 3, r=0, a=2) {
                    super(e, t),
                    this.isSpotLight = !0,
                    this.type = "SpotLight",
                    this.position.copy(Yi.DEFAULT_UP),
                    this.updateMatrix(),
                    this.target = new Yi,
                    this.distance = n,
                    this.angle = i,
                    this.penumbra = r,
                    this.decay = a,
                    this.map = null,
                    this.shadow = new Ml
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / Math.PI
                }
                dispose() {
                    super.dispose(),
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.distance = e.distance,
                    this.angle = e.angle,
                    this.penumbra = e.penumbra,
                    this.decay = e.decay,
                    this.target = e.target.clone(),
                    this.map = e.map,
                    this.shadow = e.shadow.clone(),
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.distance = this.distance,
                    t.object.angle = this.angle,
                    t.object.decay = this.decay,
                    t.object.penumbra = this.penumbra,
                    t.object.target = this.target.uuid,
                    this.map && this.map.isTexture && (t.object.map = this.map.toJSON(e).uuid),
                    t.object.shadow = this.shadow.toJSON(),
                    t
                }
            }
            class Cl extends kl {
                constructor() {
                    super(new aa(90,1,.5,500)),
                    this.isPointLightShadow = !0
                }
            }
            class Rl extends bl {
                constructor(e, t, n=0, i=2) {
                    super(e, t),
                    this.isPointLight = !0,
                    this.type = "PointLight",
                    this.distance = n,
                    this.decay = i,
                    this.shadow = new Cl
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(e) {
                    this.intensity = e / (4 * Math.PI)
                }
                dispose() {
                    super.dispose(),
                    this.shadow.dispose()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.distance = e.distance,
                    this.decay = e.decay,
                    this.shadow = e.shadow.clone(),
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.distance = this.distance,
                    t.object.decay = this.decay,
                    t.object.shadow = this.shadow.toJSON(),
                    t
                }
            }
            class Pl extends ta {
                constructor(e=-1, t=1, n=1, i=-1, r=.1, a=2e3) {
                    super(),
                    this.isOrthographicCamera = !0,
                    this.type = "OrthographicCamera",
                    this.zoom = 1,
                    this.view = null,
                    this.left = e,
                    this.right = t,
                    this.top = n,
                    this.bottom = i,
                    this.near = r,
                    this.far = a,
                    this.updateProjectionMatrix()
                }
                copy(e, t) {
                    return super.copy(e, t),
                    this.left = e.left,
                    this.right = e.right,
                    this.top = e.top,
                    this.bottom = e.bottom,
                    this.near = e.near,
                    this.far = e.far,
                    this.zoom = e.zoom,
                    this.view = null === e.view ? null : Object.assign({}, e.view),
                    this
                }
                setViewOffset(e, t, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }),
                    this.view.enabled = !0,
                    this.view.fullWidth = e,
                    this.view.fullHeight = t,
                    this.view.offsetX = n,
                    this.view.offsetY = i,
                    this.view.width = r,
                    this.view.height = a,
                    this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1),
                    this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const e = (this.right - this.left) / (2 * this.zoom)
                      , t = (this.top - this.bottom) / (2 * this.zoom)
                      , n = (this.right + this.left) / 2
                      , i = (this.top + this.bottom) / 2;
                    let r = n - e
                      , a = n + e
                      , s = i + t
                      , o = i - t;
                    if (null !== this.view && this.view.enabled) {
                        const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                          , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += e * this.view.offsetX,
                        a = r + e * this.view.width,
                        s -= t * this.view.offsetY,
                        o = s - t * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far, this.coordinateSystem, this.reversedDepth),
                    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.zoom = this.zoom,
                    t.object.left = this.left,
                    t.object.right = this.right,
                    t.object.top = this.top,
                    t.object.bottom = this.bottom,
                    t.object.near = this.near,
                    t.object.far = this.far,
                    null !== this.view && (t.object.view = Object.assign({}, this.view)),
                    t
                }
            }
            class Il extends kl {
                constructor() {
                    super(new Pl(-5,5,5,-5,.5,500)),
                    this.isDirectionalLightShadow = !0
                }
            }
            class Ll extends bl {
                constructor(e, t) {
                    super(e, t),
                    this.isDirectionalLight = !0,
                    this.type = "DirectionalLight",
                    this.position.copy(Yi.DEFAULT_UP),
                    this.updateMatrix(),
                    this.target = new Yi,
                    this.shadow = new Il
                }
                dispose() {
                    super.dispose(),
                    this.shadow.dispose()
                }
                copy(e) {
                    return super.copy(e),
                    this.target = e.target.clone(),
                    this.shadow = e.shadow.clone(),
                    this
                }
                toJSON(e) {
                    const t = super.toJSON(e);
                    return t.object.shadow = this.shadow.toJSON(),
                    t.object.target = this.target.uuid,
                    t
                }
            }
            class Nl {
                static extractUrlBase(e) {
                    const t = e.lastIndexOf("/");
                    return -1 === t ? "./" : e.slice(0, t + 1)
                }
                static resolveURL(e, t) {
                    return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                    /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                }
            }
            const zl = new WeakMap;
            class Ul extends fl {
                constructor(e) {
                    super(e),
                    this.isImageBitmapLoader = !0,
                    "undefined" == typeof createImageBitmap && cn("ImageBitmapLoader: createImageBitmap() not supported."),
                    "undefined" == typeof fetch && cn("ImageBitmapLoader: fetch() not supported."),
                    this.options = {
                        premultiplyAlpha: "none"
                    },
                    this._abortController = new AbortController
                }
                setOptions(e) {
                    return this.options = e,
                    this
                }
                load(e, t, n, i) {
                    void 0 === e && (e = ""),
                    void 0 !== this.path && (e = this.path + e),
                    e = this.manager.resolveURL(e);
                    const r = this
                      , a = dl.get(`image-bitmap:${e}`);
                    if (void 0 !== a)
                        return r.manager.itemStart(e),
                        a.then ? void a.then((n => {
                            if (!0 !== zl.has(a))
                                return t && t(n),
                                r.manager.itemEnd(e),
                                n;
                            i && i(zl.get(a)),
                            r.manager.itemError(e),
                            r.manager.itemEnd(e)
                        }
                        )) : (setTimeout((function() {
                            t && t(a),
                            r.manager.itemEnd(e)
                        }
                        ), 0),
                        a);
                    const s = {};
                    s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                    s.headers = this.requestHeader,
                    s.signal = "function" == typeof AbortSignal.any ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
                    const o = fetch(e, s).then((function(e) {
                        return e.blob()
                    }
                    )).then((function(e) {
                        return createImageBitmap(e, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    }
                    )).then((function(n) {
                        return dl.add(`image-bitmap:${e}`, n),
                        t && t(n),
                        r.manager.itemEnd(e),
                        n
                    }
                    )).catch((function(t) {
                        i && i(t),
                        zl.set(o, t),
                        dl.remove(`image-bitmap:${e}`),
                        r.manager.itemError(e),
                        r.manager.itemEnd(e)
                    }
                    ));
                    dl.add(`image-bitmap:${e}`, o),
                    r.manager.itemStart(e)
                }
                abort() {
                    return this._abortController.abort(),
                    this._abortController = new AbortController,
                    this
                }
            }
            class Dl extends aa {
                constructor(e=[]) {
                    super(),
                    this.isArrayCamera = !0,
                    this.isMultiViewCamera = !1,
                    this.cameras = e
                }
            }
            const Bl = "\\[\\]\\.:\\/"
              , Gl = new RegExp("[" + Bl + "]","g")
              , Fl = "[^" + Bl + "]"
              , Ol = "[^" + Bl.replace("\\.", "") + "]"
              , Wl = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Fl) + /(WCOD+)?/.source.replace("WCOD", Ol) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Fl) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Fl) + "$")
              , Vl = ["material", "materials", "bones", "map"];
            class Hl {
                constructor(e, t, n) {
                    this.path = t,
                    this.parsedPath = n || Hl.parseTrackName(t),
                    this.node = Hl.findNode(e, this.parsedPath.nodeName),
                    this.rootNode = e,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
                }
                static create(e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Hl.Composite(e,t,n) : new Hl(e,t,n)
                }
                static sanitizeNodeName(e) {
                    return e.replace(/\s/g, "_").replace(Gl, "")
                }
                static parseTrackName(e) {
                    const t = Wl.exec(e);
                    if (null === t)
                        throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                    const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    }
                      , i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const e = n.nodeName.substring(i + 1);
                        -1 !== Vl.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
                        n.objectName = e)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length)
                        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                    return n
                }
                static findNode(e, t) {
                    if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                        return e;
                    if (e.skeleton) {
                        const n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n)
                            return n
                    }
                    if (e.children) {
                        const n = function(e) {
                            for (let i = 0; i < e.length; i++) {
                                const r = e[i];
                                if (r.name === t || r.uuid === t)
                                    return r;
                                const a = n(r.children);
                                if (a)
                                    return a
                            }
                            return null
                        }
                          , i = n(e.children);
                        if (i)
                            return i
                    }
                    return null
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(e, t) {
                    e[t] = this.targetObject[this.propertyName]
                }
                _getValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i)
                        e[t++] = n[i]
                }
                _getValue_arrayElement(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }
                _getValue_toArray(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }
                _setValue_direct(e, t) {
                    this.targetObject[this.propertyName] = e[t]
                }
                _setValue_direct_setNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t],
                    this.targetObject.needsUpdate = !0
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                    this.targetObject[this.propertyName] = e[t],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_array(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i)
                        n[i] = e[t++]
                }
                _setValue_array_setNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i)
                        n[i] = e[t++];
                    this.targetObject.needsUpdate = !0
                }
                _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i)
                        n[i] = e[t++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_arrayElement(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t]
                }
                _setValue_arrayElement_setNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t],
                    this.targetObject.needsUpdate = !0
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty[this.propertyIndex] = e[t],
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _setValue_fromArray(e, t) {
                    this.resolvedProperty.fromArray(e, t)
                }
                _setValue_fromArray_setNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t),
                    this.targetObject.needsUpdate = !0
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                    this.resolvedProperty.fromArray(e, t),
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }
                _getValue_unbound(e, t) {
                    this.bind(),
                    this.getValue(e, t)
                }
                _setValue_unbound(e, t) {
                    this.bind(),
                    this.setValue(e, t)
                }
                bind() {
                    let e = this.node;
                    const t = this.parsedPath
                      , n = t.objectName
                      , i = t.propertyName;
                    let r = t.propertyIndex;
                    if (e || (e = Hl.findNode(this.rootNode, t.nodeName),
                    this.node = e),
                    this.getValue = this._getValue_unavailable,
                    this.setValue = this._setValue_unavailable,
                    !e)
                        return void cn("PropertyBinding: No target node found for track: " + this.path + ".");
                    if (n) {
                        let i = t.objectIndex;
                        switch (n) {
                        case "materials":
                            if (!e.material)
                                return void hn("PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials)
                                return void hn("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton)
                                return void hn("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === i) {
                                    i = t;
                                    break
                                }
                            break;
                        case "map":
                            if ("map"in e) {
                                e = e.map;
                                break
                            }
                            if (!e.material)
                                return void hn("PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.map)
                                return void hn("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            e = e.material.map;
                            break;
                        default:
                            if (void 0 === e[n])
                                return void hn("PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === e[i])
                                return void hn("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[i]
                        }
                    }
                    const a = e[i];
                    if (void 0 === a) {
                        return void hn("PropertyBinding: Trying to update property for track: " + t.nodeName + "." + i + " but it wasn't found.", e)
                    }
                    let s = this.Versioning.None;
                    this.targetObject = e,
                    !0 === e.isMaterial ? s = this.Versioning.NeedsUpdate : !0 === e.isObject3D && (s = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry)
                                return void hn("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!e.geometry.morphAttributes)
                                return void hn("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                        }
                        o = this.BindingType.ArrayElement,
                        this.resolvedProperty = a,
                        this.propertyIndex = r
                    } else
                        void 0 !== a.fromArray && void 0 !== a.toArray ? (o = this.BindingType.HasFromToArray,
                        this.resolvedProperty = a) : Array.isArray(a) ? (o = this.BindingType.EntireArray,
                        this.resolvedProperty = a) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[o],
                    this.setValue = this.SetterByBindingTypeAndVersioning[o][s]
                }
                unbind() {
                    this.node = null,
                    this.getValue = this._getValue_unbound,
                    this.setValue = this._setValue_unbound
                }
            }
            Hl.Composite = class {
                constructor(e, t, n) {
                    const i = n || Hl.parseTrackName(t);
                    this._targetGroup = e,
                    this._bindings = e.subscribe_(t, i)
                }
                getValue(e, t) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_
                      , i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                }
                setValue(e, t) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                        n[i].setValue(e, t)
                }
                bind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                        e[t].bind()
                }
                unbind() {
                    const e = this._bindings;
                    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                        e[t].unbind()
                }
            }
            ,
            Hl.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Hl.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            Hl.prototype.GetterByBindingType = [Hl.prototype._getValue_direct, Hl.prototype._getValue_array, Hl.prototype._getValue_arrayElement, Hl.prototype._getValue_toArray],
            Hl.prototype.SetterByBindingTypeAndVersioning = [[Hl.prototype._setValue_direct, Hl.prototype._setValue_direct_setNeedsUpdate, Hl.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Hl.prototype._setValue_array, Hl.prototype._setValue_array_setNeedsUpdate, Hl.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Hl.prototype._setValue_arrayElement, Hl.prototype._setValue_arrayElement_setNeedsUpdate, Hl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Hl.prototype._setValue_fromArray, Hl.prototype._setValue_fromArray_setNeedsUpdate, Hl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
            new Float32Array(1);
            const jl = new Ei;
            class Kl {
                constructor(e, t, n=0, i=1 / 0) {
                    this.ray = new Si(e,t),
                    this.near = n,
                    this.far = i,
                    this.camera = null,
                    this.layers = new zi,
                    this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                set(e, t) {
                    this.ray.set(e, t)
                }
                setFromCamera(e, t) {
                    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                    this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                    this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                    this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                    this.camera = t) : hn("Raycaster: Unsupported camera type: " + t.type)
                }
                setFromXRController(e) {
                    return jl.identity().extractRotation(e.matrixWorld),
                    this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                    this.ray.direction.set(0, 0, -1).applyMatrix4(jl),
                    this
                }
                intersectObject(e, t=!0, n=[]) {
                    return Ql(e, this, n, t),
                    n.sort(ql),
                    n
                }
                intersectObjects(e, t=!0, n=[]) {
                    for (let i = 0, r = e.length; i < r; i++)
                        Ql(e[i], this, n, t);
                    return n.sort(ql),
                    n
                }
            }
            function ql(e, t) {
                return e.distance - t.distance
            }
            function Ql(e, t, n, i) {
                let r = !0;
                if (e.layers.test(t.layers)) {
                    !1 === e.raycast(t, n) && (r = !1)
                }
                if (!0 === r && !0 === i) {
                    const i = e.children;
                    for (let e = 0, r = i.length; e < r; e++)
                        Ql(i[e], t, n, !0)
                }
            }
            class Jl {
                constructor(e=1, t=0, n=0) {
                    this.radius = e,
                    this.phi = t,
                    this.theta = n
                }
                set(e, t, n) {
                    return this.radius = e,
                    this.phi = t,
                    this.theta = n,
                    this
                }
                copy(e) {
                    return this.radius = e.radius,
                    this.phi = e.phi,
                    this.theta = e.theta,
                    this
                }
                makeSafe() {
                    const e = 1e-6;
                    return this.phi = yn(this.phi, e, Math.PI - e),
                    this
                }
                setFromVector3(e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                }
                setFromCartesianCoords(e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n),
                    0 === this.radius ? (this.theta = 0,
                    this.phi = 0) : (this.theta = Math.atan2(e, n),
                    this.phi = Math.acos(yn(t / this.radius, -1, 1))),
                    this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class Xl extends Rs {
                constructor(e, t=16776960) {
                    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                      , i = new zr;
                    i.setIndex(new Er(n,1)),
                    i.setAttribute("position", new Mr([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
                    super(i, new vs({
                        color: t,
                        toneMapped: !1
                    })),
                    this.box = e,
                    this.type = "Box3Helper",
                    this.geometry.computeBoundingSphere()
                }
                updateMatrixWorld(e) {
                    const t = this.box;
                    t.isEmpty() || (t.getCenter(this.position),
                    t.getSize(this.scale),
                    this.scale.multiplyScalar(.5),
                    super.updateMatrixWorld(e))
                }
                dispose() {
                    this.geometry.dispose(),
                    this.material.dispose()
                }
            }
            class Yl {
                constructor() {
                    this.type = "ShapePath",
                    this.color = new mr,
                    this.subPaths = [],
                    this.currentPath = null
                }
                moveTo(e, t) {
                    return this.currentPath = new ao,
                    this.subPaths.push(this.currentPath),
                    this.currentPath.moveTo(e, t),
                    this
                }
                lineTo(e, t) {
                    return this.currentPath.lineTo(e, t),
                    this
                }
                quadraticCurveTo(e, t, n, i) {
                    return this.currentPath.quadraticCurveTo(e, t, n, i),
                    this
                }
                bezierCurveTo(e, t, n, i, r, a) {
                    return this.currentPath.bezierCurveTo(e, t, n, i, r, a),
                    this
                }
                splineThru(e) {
                    return this.currentPath.splineThru(e),
                    this
                }
                toShapes(e) {
                    function t(e, t) {
                        const n = t.length;
                        let i = !1;
                        for (let r = n - 1, a = 0; a < n; r = a++) {
                            let n = t[r]
                              , s = t[a]
                              , o = s.x - n.x
                              , l = s.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = t[a],
                                o = -o,
                                s = t[r],
                                l = -l),
                                e.y < n.y || e.y > s.y)
                                    continue;
                                if (e.y === n.y) {
                                    if (e.x === n.x)
                                        return !0
                                } else {
                                    const t = l * (e.x - n.x) - o * (e.y - n.y);
                                    if (0 === t)
                                        return !0;
                                    if (t < 0)
                                        continue;
                                    i = !i
                                }
                            } else {
                                if (e.y !== n.y)
                                    continue;
                                if (s.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= s.x)
                                    return !0
                            }
                        }
                        return i
                    }
                    const n = zo.isClockWise
                      , i = this.subPaths;
                    if (0 === i.length)
                        return [];
                    let r, a, s;
                    const o = [];
                    if (1 === i.length)
                        return a = i[0],
                        s = new so,
                        s.curves = a.curves,
                        o.push(s),
                        o;
                    let l = !n(i[0].getPoints());
                    l = e ? !l : l;
                    const c = []
                      , h = [];
                    let d, u, p = [], f = 0;
                    h[f] = void 0,
                    p[f] = [];
                    for (let t = 0, s = i.length; t < s; t++)
                        a = i[t],
                        d = a.getPoints(),
                        r = n(d),
                        r = e ? !r : r,
                        r ? (!l && h[f] && f++,
                        h[f] = {
                            s: new so,
                            p: d
                        },
                        h[f].s.curves = a.curves,
                        l && f++,
                        p[f] = []) : p[f].push({
                            h: a,
                            p: d[0]
                        });
                    if (!h[0])
                        return function(e) {
                            const t = [];
                            for (let n = 0, i = e.length; n < i; n++) {
                                const i = e[n]
                                  , r = new so;
                                r.curves = i.curves,
                                t.push(r)
                            }
                            return t
                        }(i);
                    if (h.length > 1) {
                        let e = !1
                          , n = 0;
                        for (let e = 0, t = h.length; e < t; e++)
                            c[e] = [];
                        for (let i = 0, r = h.length; i < r; i++) {
                            const r = p[i];
                            for (let a = 0; a < r.length; a++) {
                                const s = r[a];
                                let o = !0;
                                for (let r = 0; r < h.length; r++)
                                    t(s.p, h[r].p) && (i !== r && n++,
                                    o ? (o = !1,
                                    c[r].push(s)) : e = !0);
                                o && c[i].push(s)
                            }
                        }
                        n > 0 && !1 === e && (p = c)
                    }
                    for (let e = 0, t = h.length; e < t; e++) {
                        s = h[e].s,
                        o.push(s),
                        u = p[e];
                        for (let e = 0, t = u.length; e < t; e++)
                            s.holes.push(u[e].h)
                    }
                    return o
                }
            }
            class Zl extends pn {
                constructor(e, t=null) {
                    super(),
                    this.object = e,
                    this.domElement = t,
                    this.enabled = !0,
                    this.state = -1,
                    this.keys = {},
                    this.mouseButtons = {
                        LEFT: null,
                        MIDDLE: null,
                        RIGHT: null
                    },
                    this.touches = {
                        ONE: null,
                        TWO: null
                    }
                }
                connect(e) {
                    void 0 !== e ? (null !== this.domElement && this.disconnect(),
                    this.domElement = e) : cn("Controls: connect() now requires an element.")
                }
                disconnect() {}
                dispose() {}
                update() {}
            }
            function $l(e, t, n, i) {
                const r = function(e) {
                    switch (e) {
                    case be:
                    case xe:
                        return {
                            byteLength: 1,
                            components: 1
                        };
                    case Ee:
                    case Se:
                    case _e:
                        return {
                            byteLength: 2,
                            components: 1
                        };
                    case Ce:
                    case Re:
                        return {
                            byteLength: 2,
                            components: 4
                        };
                    case ke:
                    case Te:
                    case Me:
                        return {
                            byteLength: 4,
                            components: 1
                        };
                    case Ie:
                    case Le:
                        return {
                            byteLength: 4,
                            components: 3
                        }
                    }
                    throw new Error(`Unknown texture type ${e}.`)
                }(i);
                switch (n) {
                case Ne:
                    return e * t;
                case Ge:
                case Fe:
                    return e * t / r.components * r.byteLength;
                case Oe:
                case We:
                    return e * t * 2 / r.components * r.byteLength;
                case ze:
                    return e * t * 3 / r.components * r.byteLength;
                case Ue:
                case Ve:
                    return e * t * 4 / r.components * r.byteLength;
                case He:
                case je:
                    return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                case Ke:
                case qe:
                    return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                case Je:
                case Ye:
                    return Math.max(e, 16) * Math.max(t, 8) / 4;
                case Qe:
                case Xe:
                    return Math.max(e, 8) * Math.max(t, 8) / 2;
                case Ze:
                case $e:
                case tt:
                case nt:
                    return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
                case et:
                case it:
                case rt:
                case at:
                    return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
                case st:
                    return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
                case ot:
                    return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
                case lt:
                    return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
                case ct:
                    return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
                case ht:
                    return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
                case dt:
                    return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
                case ut:
                    return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
                case pt:
                    return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
                case ft:
                    return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
                case gt:
                    return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
                case mt:
                    return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
                case At:
                    return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
                case vt:
                    return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
                case yt:
                case wt:
                case bt:
                    return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
                case xt:
                case St:
                    return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
                case Et:
                case Tt:
                    return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
                }
                throw new Error(`Unable to determine texture byte length for ${n} format.`)
            }
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
                detail: {
                    revision: i
                }
            })),
            "undefined" != typeof window && (window.__THREE__ ? cn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
        }
        ,
        4930: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/grid_small.svg"
        }
        ,
        4942: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/redo.svg"
        }
        ,
        5001: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_x_negative.svg"
        }
        ,
        5010: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/winter_colored.svg"
        }
        ,
        5031: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/help.svg"
        }
        ,
        5051: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_circle.svg"
        }
        ,
        5056: (e, t, n) => {
            "use strict";
            e.exports = function(e) {
                var t = n.nc;
                t && e.setAttribute("nonce", t)
            }
        }
        ,
        5072: e => {
            "use strict";
            var t = [];
            function n(e) {
                for (var n = -1, i = 0; i < t.length; i++)
                    if (t[i].identifier === e) {
                        n = i;
                        break
                    }
                return n
            }
            function i(e, i) {
                for (var a = {}, s = [], o = 0; o < e.length; o++) {
                    var l = e[o]
                      , c = i.base ? l[0] + i.base : l[0]
                      , h = a[c] || 0
                      , d = "".concat(c, " ").concat(h);
                    a[c] = h + 1;
                    var u = n(d)
                      , p = {
                        css: l[1],
                        media: l[2],
                        sourceMap: l[3],
                        supports: l[4],
                        layer: l[5]
                    };
                    if (-1 !== u)
                        t[u].references++,
                        t[u].updater(p);
                    else {
                        var f = r(p, i);
                        i.byIndex = o,
                        t.splice(o, 0, {
                            identifier: d,
                            updater: f,
                            references: 1
                        })
                    }
                    s.push(d)
                }
                return s
            }
            function r(e, t) {
                var n = t.domAPI(t);
                n.update(e);
                return function(t) {
                    if (t) {
                        if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap && t.supports === e.supports && t.layer === e.layer)
                            return;
                        n.update(e = t)
                    } else
                        n.remove()
                }
            }
            e.exports = function(e, r) {
                var a = i(e = e || [], r = r || {});
                return function(e) {
                    e = e || [];
                    for (var s = 0; s < a.length; s++) {
                        var o = n(a[s]);
                        t[o].references--
                    }
                    for (var l = i(e, r), c = 0; c < a.length; c++) {
                        var h = n(a[c]);
                        0 === t[h].references && (t[h].updater(),
                        t.splice(h, 1))
                    }
                    a = l
                }
            }
        }
        ,
        5143: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_gradient.svg"
        }
        ,
        5148: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/checkpoint.svg"
        }
        ,
        5169: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.Summer = 0] = "Summer",
                e[e.Winter = 1] = "Winter",
                e[e.Desert = 2] = "Desert"
            }(i || (i = {}));
            const r = i
        }
        ,
        5302: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => w
            });
            var i = n(1635)
              , r = n(5072)
              , a = n.n(r)
              , s = n(7825)
              , o = n.n(s)
              , l = n(7659)
              , c = n.n(l)
              , h = n(5056)
              , d = n.n(h)
              , u = n(540)
              , p = n.n(u)
              , f = n(1113)
              , g = n.n(f)
              , m = n(4464)
              , A = {};
            A.styleTagTransform = g(),
            A.setAttributes = d(),
            A.insert = c().bind(null, "head"),
            A.domAPI = o(),
            A.insertStyleElement = p();
            a()(m.A, A);
            m.A && m.A.locals && m.A.locals;
            var v, y;
            v = new WeakMap,
            y = new WeakMap;
            const w = class {
                constructor(e) {
                    v.set(this, void 0),
                    y.set(this, void 0);
                    const t = document.getElementById("ui");
                    if (null == t)
                        throw new Error("UI element not found");
                    (0,
                    i.GG)(this, v, t, "f"),
                    (0,
                    i.GG)(this, y, document.createElement("div"), "f"),
                    (0,
                    i.gn)(this, y, "f").className = "loading-screen-ui",
                    e && (0,
                    i.gn)(this, y, "f").classList.add("background"),
                    (0,
                    i.gn)(this, v, "f").appendChild((0,
                    i.gn)(this, y, "f"));
                    const n = document.createElement("div");
                    n.className = "loading-spinner-container",
                    (0,
                    i.gn)(this, y, "f").appendChild(n);
                    const r = document.createElement("div");
                    r.className = "loading-spinner-ui",
                    n.appendChild(r)
                }
                dispose() {
                    (0,
                    i.gn)(this, v, "f").removeChild((0,
                    i.gn)(this, y, "f"))
                }
            }
        }
        ,
        5343: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => p,
                _: () => u
            });
            var i = n(3075)
              , r = n(7415)
              , a = n(8438)
              , s = n(2203)
              , o = n(4183)
              , l = n(5169)
              , c = n(8566)
              , h = n(7680)
              , d = n(405);
            function u(e) {
                const t = r.D(e);
                if (null == t)
                    return null;
                const n = new i.Ay.Inflate;
                if (n.push(t, !0),
                n.err)
                    return null;
                const u = n.result;
                if (!(u instanceof Uint8Array))
                    return null;
                const p = new a.A(l.A.Summer,new h.A);
                let f = 0;
                for (; f < u.length; ) {
                    if (u.length - f < 2)
                        return null;
                    let e = u[f + 0] | u[f + 1] << 8;
                    f += 2;
                    let t = null;
                    if (40 == e && (e = s.A.Slope,
                    t = s.A.PillarTopSlope),
                    !(e in s.A))
                        return null;
                    if (u.length - f < 4)
                        return null;
                    const n = u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16 | u[f + 3] << 24;
                    f += 4;
                    for (let i = 0; i < n; ++i) {
                        if (u.length - f < 3)
                            return null;
                        const n = (u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16) - 2 ** 23;
                        if (f += 3,
                        u.length - f < 3)
                            return null;
                        const i = u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16;
                        if (f += 3,
                        u.length - f < 3)
                            return null;
                        const r = (u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16) - 2 ** 23;
                        if (f += 3,
                        u.length - f < 1)
                            return null;
                        const a = u[f + 0];
                        if (f += 1,
                        a < 0 || a > 3)
                            return null;
                        let s = null;
                        if (d.bK.includes(e)) {
                            if (u.length - f < 2)
                                return null;
                            s = u[f + 0] | u[f + 1] << 8,
                            f += 2
                        }
                        let l = null;
                        d.l1.includes(e) && (l = 0),
                        null != t && p.addPart(4 * n, i, 4 * r, t, a, c.A.YPositive, o.A.Default, null, null),
                        p.addPart(4 * n, i, 4 * r, e, a, c.A.YPositive, o.A.Default, s, l)
                    }
                }
                return p
            }
            function p(e) {
                if (!e.startsWith("v2"))
                    return null;
                const t = e.substring(2, 4)
                  , n = r.D(t);
                if (null == n)
                    return null;
                if (1 != n.length)
                    return null;
                const i = n[0]
                  , a = Math.ceil(i / 3 * 4)
                  , s = e.substring(4, 4 + a)
                  , o = r.D(s);
                if (null == o)
                    return null;
                let l;
                try {
                    l = new TextDecoder("utf-8").decode(o)
                } catch {
                    return null
                }
                const c = u(e.substring(4 + a));
                return null == c ? null : {
                    trackMetadata: {
                        name: l,
                        author: null,
                        lastModified: null
                    },
                    trackData: c
                }
            }
        }
        ,
        5408: (e, t, n) => {
            "use strict";
            function i(e) {
                return new Blob([e]).size
            }
            n.d(t, {
                k: () => i
            })
        }
        ,
        5440: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => f,
                _: () => p
            });
            var i = n(3075)
              , r = n(7415)
              , a = n(8438)
              , s = n(2203)
              , o = n(4183)
              , l = n(5169)
              , c = n(8566)
              , h = n(7680)
              , d = n(405);
            function u(e, t) {
                let n = e;
                if (t.length - n < 1)
                    return null;
                const i = t[n];
                if (n += 1,
                !(i in l.A))
                    return null;
                if (t.length - n < 1)
                    return null;
                const r = t[n];
                if (n += 1,
                !Number.isSafeInteger(r) || r < 0 || r >= 180)
                    return null;
                const u = new a.A(i,new h.A(r));
                if (t.length - n < 9)
                    return null;
                const p = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const f = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const g = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const m = 3 & t[n]
                  , A = t[n] >> 2 & 3
                  , v = t[n] >> 4 & 3;
                if (n += 1,
                m < 1 || m > 4 || A < 1 || A > 4 || v < 1 || v > 4)
                    return null;
                for (; n < t.length; ) {
                    if (t.length - n < 1)
                        return null;
                    let e = t[n + 0];
                    n += 1;
                    let i = null;
                    if (40 == e ? (e = s.A.Slope,
                    i = s.A.PillarTopSlope) : 84 == e ? (e = s.A.Slope,
                    i = s.A.PillarShortSlope) : 99 == e ? (e = s.A.PlaneSlope,
                    i = s.A.PillarTopSlope) : 100 == e && (e = s.A.PlaneSlope,
                    i = s.A.PillarShortSlope),
                    !(e in s.A))
                        return null;
                    if (t.length - n < 4)
                        return null;
                    const r = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                    n += 4;
                    for (let a = 0; a < r; ++a) {
                        if (t.length - n < m)
                            return null;
                        let r = 0;
                        for (let e = 0; e < m; ++e)
                            r |= t[n + e] << 8 * e;
                        if (r += p,
                        n += m,
                        t.length - n < A)
                            return null;
                        let a = 0;
                        for (let e = 0; e < A; ++e)
                            a |= t[n + e] << 8 * e;
                        if (a += f,
                        n += A,
                        t.length - n < v)
                            return null;
                        let s = 0;
                        for (let e = 0; e < v; ++e)
                            s |= t[n + e] << 8 * e;
                        if (s += g,
                        n += v,
                        t.length - n < 1)
                            return null;
                        const l = t[n + 0];
                        if (n += 1,
                        l < 0 || l > 3)
                            return null;
                        if (t.length - n < 1)
                            return null;
                        const h = t[n + 0];
                        if (n += 1,
                        !(h in c.A))
                            return null;
                        if (t.length - n < 1)
                            return null;
                        const y = t[n + 0];
                        if (n += 1,
                        !(y in o.A))
                            return null;
                        let w = null;
                        if (d.bK.includes(e)) {
                            if (t.length - n < 2)
                                return null;
                            w = t[n + 0] | t[n + 1] << 8,
                            n += 2
                        }
                        let b = null;
                        if (d.l1.includes(e)) {
                            if (t.length - n < 4)
                                return null;
                            b = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24,
                            n += 4
                        }
                        null != i && u.addPart(r, a, s, i, l, h, y, null, null),
                        u.addPart(r, a, s, e, l, h, y, w, b)
                    }
                }
                return u
            }
            function p(e) {
                const t = r.D(e);
                if (null == t)
                    return null;
                const n = new i.Ay.Inflate({
                    to: "string"
                });
                if (n.push(t, !0),
                n.err)
                    return null;
                const a = n.result;
                if ("string" != typeof a)
                    return null;
                const s = r.D(a);
                if (null == s)
                    return null;
                const o = new i.Ay.Inflate;
                if (o.push(s, !0),
                o.err)
                    return null;
                const l = o.result;
                return l instanceof Uint8Array ? u(0, l) : null
            }
            function f(e) {
                const t = "PolyTrack1";
                if (!e.startsWith(t))
                    return null;
                const n = r.D(e.substring(10));
                if (null == n)
                    return null;
                const a = new i.Ay.Inflate({
                    to: "string"
                });
                if (a.push(n, !0),
                a.err)
                    return null;
                const s = a.result;
                if ("string" != typeof s)
                    return null;
                const o = r.D(s);
                if (null == o)
                    return null;
                const l = new i.Ay.Inflate;
                if (l.push(o, !0),
                l.err)
                    return null;
                const c = l.result;
                if (!(c instanceof Uint8Array))
                    return null;
                const h = c[0];
                if (c.length < 1 + h)
                    return null;
                const d = new TextDecoder("utf-8").decode(c.subarray(1, 1 + h))
                  , p = c[1 + h];
                if (c.length < 1 + h + 1 + p)
                    return null;
                let f;
                f = p > 0 ? new TextDecoder("utf-8").decode(c.subarray(1 + h + 1, 1 + h + 1 + p)) : null;
                const g = u(1 + h + 1 + p, c);
                return null == g ? null : {
                    trackMetadata: {
                        name: d,
                        author: f,
                        lastModified: null
                    },
                    trackData: g
                }
            }
        }
        ,
        5499: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/refresh.svg"
        }
        ,
        5577: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/invite.svg"
        }
        ,
        5671: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".preview-toolbar-ui {\n\tposition: absolute;\n\tleft: var(--safe-area-horizontal);\n\ttop: 0;\n\tpadding: 8px 10px 8px 8px;\n\tbackground-color: var(--surface-color);\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n#ui.has-safe-area-horizontal .preview-toolbar-ui {\n\tpadding-left: 16px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n", ""]);
            const o = s
        }
        ,
        5734: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, '.settings-menu-ui {\n\tposition: absolute;\n\tleft: calc(50% - 800px / 2);\n\ttop: 0;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 800px;\n\theight: 100%;\n\ttext-align: left;\n\tdisplay: flex;\n\tflex-direction: column;\n\tbackground-color: var(--surface-color);\n}\n\n.settings-menu-ui > h2 {\n\tmargin: 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.settings-menu-ui > .container {\n\tmargin: 0;\n\tpadding: 0;\n\tflex-grow: 1;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-y: scroll;\n\tpointer-events: auto;\n}\n\n.settings-menu-ui > .container > h2 {\n\tmargin: 10px;\n\tpadding: 4px;\n\tfont-weight: normal;\n\tfont-size: 24px;\n\tcolor: var(--text-color);\n\tborder-bottom: 2px solid var(--text-color);\n}\n\n.settings-menu-ui > .container > h3 {\n\tmargin: 10px 10px 10px 15px;\n\tpadding: 4px;\n\tfont-weight: normal;\n\tfont-size: 22px;\n\tcolor: var(--text-color);\n\tborder-bottom: 2px solid var(--text-color);\n}\n\n.settings-menu-ui > .container > .setting {\n\tmargin: 10px;\n\tdisplay: flex;\n}\n\n.settings-menu-ui > .container > .setting > p {\n\tdisplay: inline-block;\n\tmargin: 10px;\n\tpadding: 0;\n\tmin-width: 0;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tflex-grow: 1;\n\tflex-shrink: 0;\n\tfont-size: 28px;\n\ttext-align: left;\n\tcolor: var(--text-color);\n}\n.settings-menu-ui > .container > .setting.key-binding > p {\n\tflex-shrink: 1;\n}\n\n.settings-menu-ui > .container > .setting > .button-wrapper {\n\tmargin-bottom: -8px;\n\tdisplay: flex;\n\tjustify-content: end;\n}\n.settings-menu-ui > .container > .setting:not(.key-binding) > .button-wrapper {\n\tflex-wrap: wrap;\n}\n.settings-menu-ui > .container > .setting.wrappable > .button-wrapper {\n\twhite-space: normal;\n}\n.settings-menu-ui > .container > .setting.wrappable > .button-wrapper > button {\n\twidth: calc(100% / 4);\n\tfont-size: 23px;\n}\n\n.settings-menu-ui > .container > .setting > .button-wrapper > button {\n\tmargin-bottom: 8px;\n\theight: 48px;\n\twhite-space: nowrap;\n}\n.settings-menu-ui > .container > .setting > .button-wrapper > button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n.settings-menu-ui > .container > .setting.key-binding > .button-wrapper > button {\n\twidth: 210px;\n\tfont-size: 22px;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tvertical-align: top;\n}\n\n.settings-menu-ui > .container > .setting > input[type="range"] {\n\tmargin: 0 20px;\n\twidth: 390px;\n}\n\n.settings-menu-ui > .button-wrapper > .button {\n\tmargin: 10px 0;\n}\n\n.settings-menu-ui > .button-wrapper > .button:first-of-type {\n\tmargin-left: 10px;\n}\n\n.settings-menu-ui > .button-wrapper > .button:last-of-type {\n\tmargin-right: 10px;\n}\n\n.settings-menu-ui > .button-wrapper > .button > img {\n\tmargin-top: -3px;\n}\n\n.settings-menu-ui > .button-wrapper > .apply {\n\tfloat: right;\n}\n', ""]);
            const o = s
        }
        ,
        5735: (e, t, n) => {
            "use strict";
            n.d(t, {
                Dr: () => c,
                hT: () => s,
                sR: () => o,
                yV: () => l
            });
            var i = n(4922)
              , r = n(8566);
            const a = [[new i.PTz(0,0,0,1), new i.PTz(0,.7071067811865475,0,.7071067811865476), new i.PTz(0,1,0,0), new i.PTz(0,.7071067811865476,0,-.7071067811865475)], [new i.PTz(0,0,1,0), new i.PTz(.7071067811865475,0,.7071067811865476,0), new i.PTz(1,0,0,0), new i.PTz(.7071067811865476,0,-.7071067811865475,0)], [new i.PTz(0,0,-.7071067811865477,.7071067811865475), new i.PTz(.5,.5,-.5,.5), new i.PTz(.7071067811865475,.7071067811865477,0,0), new i.PTz(.5,.5,.5,-.5)], [new i.PTz(0,0,.7071067811865475,.7071067811865476), new i.PTz(.5,-.5,.5,.5), new i.PTz(.7071067811865476,-.7071067811865475,0,0), new i.PTz(.5,-.5,-.5,-.5)], [new i.PTz(.7071067811865475,0,0,.7071067811865476), new i.PTz(.5,.5,.5,.5), new i.PTz(0,.7071067811865476,.7071067811865475,0), new i.PTz(-.5,.5,.5,-.5)], [new i.PTz(-.7071067811865477,0,0,.7071067811865475), new i.PTz(-.5,-.5,.5,.5), new i.PTz(0,-.7071067811865475,.7071067811865477,0), new i.PTz(.5,-.5,.5,-.5)]];
            function s(e, t) {
                return a[t][e].clone()
            }
            function o(e, t, n, i, a) {
                if (a == r.A.YNegative || a == r.A.XNegative || a == r.A.ZNegative)
                    switch (i) {
                    case 0:
                        break;
                    case 1:
                        [e,n] = [-n - 1, e];
                        break;
                    case 2:
                        [e,n] = [-e - 1, -n - 1];
                        break;
                    case 3:
                        [e,n] = [n, -e - 1];
                        break;
                    default:
                        throw new Error("Invalid rotation")
                    }
                else
                    switch (i) {
                    case 0:
                        break;
                    case 1:
                        [e,n] = [n, -e - 1];
                        break;
                    case 2:
                        [e,n] = [-e - 1, -n - 1];
                        break;
                    case 3:
                        [e,n] = [-n - 1, e];
                        break;
                    default:
                        throw new Error("Invalid rotation")
                    }
                return a == r.A.YPositive || (a == r.A.YNegative ? [e,t] = [-e - 1, -t - 1] : a == r.A.XPositive ? [e,t] = [t, -e - 1] : a == r.A.XNegative ? [e,t] = [-t - 1, e] : a == r.A.ZPositive ? [t,n] = [-n - 1, t] : [t,n] = [n, -t - 1]),
                [e, t, n]
            }
            function l(e, t, n, i, a) {
                if (a == r.A.YNegative || a == r.A.XNegative || a == r.A.ZNegative)
                    switch (i) {
                    case 0:
                        break;
                    case 1:
                        [e,n] = [-n, e];
                        break;
                    case 2:
                        [e,n] = [-e, -n];
                        break;
                    case 3:
                        [e,n] = [n, -e];
                        break;
                    default:
                        throw new Error("Invalid rotation")
                    }
                else
                    switch (i) {
                    case 0:
                        break;
                    case 1:
                        [e,n] = [n, -e];
                        break;
                    case 2:
                        [e,n] = [-e, -n];
                        break;
                    case 3:
                        [e,n] = [-n, e];
                        break;
                    default:
                        throw new Error("Invalid rotation")
                    }
                return a == r.A.YPositive || (a == r.A.YNegative ? [e,t] = [-e, -t] : a == r.A.XPositive ? [e,t] = [t, -e] : a == r.A.XNegative ? [e,t] = [-t, e] : a == r.A.ZPositive ? [t,n] = [-n, t] : [t,n] = [n, -t]),
                [e, t, n]
            }
            function c(e, t, n, i) {
                let a, s;
                switch (i) {
                case r.A.YPositive:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.YPositive;
                        break;
                    case r.A.YNegative:
                        s = r.A.YNegative;
                        break;
                    case r.A.XPositive:
                        s = [r.A.XPositive, r.A.ZNegative, r.A.XNegative, r.A.ZPositive][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.XNegative, r.A.ZPositive, r.A.XPositive, r.A.ZNegative][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.ZPositive, r.A.XPositive, r.A.ZNegative, r.A.XNegative][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.ZNegative, r.A.XNegative, r.A.ZPositive, r.A.XPositive][n]
                    }
                    a = s == r.A.XNegative || s == r.A.ZNegative ? -n : n;
                    break;
                case r.A.YNegative:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.YNegative;
                        break;
                    case r.A.YNegative:
                        s = r.A.YPositive;
                        break;
                    case r.A.XPositive:
                        s = [r.A.XNegative, r.A.ZPositive, r.A.XPositive, r.A.ZNegative][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.XPositive, r.A.ZNegative, r.A.XNegative, r.A.ZPositive][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.ZPositive, r.A.XPositive, r.A.ZNegative, r.A.XNegative][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.ZNegative, r.A.XNegative, r.A.ZPositive, r.A.XPositive][n]
                    }
                    a = n,
                    t != r.A.XPositive && t != r.A.XNegative || s != r.A.ZNegative ? (t == r.A.ZPositive && s != r.A.XNegative || t == r.A.ZNegative && s != r.A.XPositive) && (a += 2) : a += 2;
                    break;
                case r.A.XPositive:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.XPositive;
                        break;
                    case r.A.YNegative:
                        s = r.A.XNegative;
                        break;
                    case r.A.XPositive:
                        s = [r.A.YNegative, r.A.ZNegative, r.A.YPositive, r.A.ZPositive][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.YPositive, r.A.ZPositive, r.A.YNegative, r.A.ZNegative][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.ZPositive, r.A.YNegative, r.A.ZNegative, r.A.YPositive][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.ZNegative, r.A.YPositive, r.A.ZPositive, r.A.YNegative][n]
                    }
                    a = n,
                    s == r.A.ZPositive ? a -= 1 : s == r.A.ZNegative && (a += 1),
                    (t != r.A.ZPositive && t != r.A.ZNegative || s != r.A.YNegative) && (t != r.A.ZPositive && t != r.A.ZNegative || s != r.A.ZNegative) || (a += 2);
                    break;
                case r.A.XNegative:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.XNegative;
                        break;
                    case r.A.YNegative:
                        s = r.A.XPositive;
                        break;
                    case r.A.XPositive:
                        s = [r.A.YPositive, r.A.ZPositive, r.A.YNegative, r.A.ZNegative][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.YNegative, r.A.ZNegative, r.A.YPositive, r.A.ZPositive][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.ZPositive, r.A.YNegative, r.A.ZNegative, r.A.YPositive][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.ZNegative, r.A.YPositive, r.A.ZPositive, r.A.YNegative][n]
                    }
                    a = n,
                    s == r.A.ZPositive ? a -= 1 : s == r.A.ZNegative && (a += 1),
                    (t != r.A.ZPositive && t != r.A.ZNegative || s != r.A.YPositive) && (t != r.A.ZPositive && t != r.A.ZNegative || s != r.A.ZPositive) || (a += 2);
                    break;
                case r.A.ZPositive:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.ZPositive;
                        break;
                    case r.A.YNegative:
                        s = r.A.ZNegative;
                        break;
                    case r.A.XPositive:
                        s = [r.A.XPositive, r.A.YPositive, r.A.XNegative, r.A.YNegative][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.XNegative, r.A.YNegative, r.A.XPositive, r.A.YPositive][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.YNegative, r.A.XPositive, r.A.YPositive, r.A.XNegative][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.YPositive, r.A.XNegative, r.A.YNegative, r.A.XPositive][n]
                    }
                    a = n,
                    t != r.A.XPositive || s != r.A.XPositive && s != r.A.XNegative || (a += 1),
                    t != r.A.XNegative || s != r.A.XPositive && s != r.A.XNegative || (a += 1),
                    t != r.A.ZPositive && t != r.A.ZNegative || (s == r.A.YNegative ? a += 2 : s == r.A.XPositive ? a += 1 : s == r.A.XNegative && (a -= 1)),
                    t == r.A.YNegative && (a += 2);
                    break;
                case r.A.ZNegative:
                    switch (t) {
                    case r.A.YPositive:
                        s = r.A.ZNegative;
                        break;
                    case r.A.YNegative:
                        s = r.A.ZPositive;
                        break;
                    case r.A.XPositive:
                        s = [r.A.XPositive, r.A.YPositive, r.A.XNegative, r.A.YNegative][n];
                        break;
                    case r.A.XNegative:
                        s = [r.A.XNegative, r.A.YNegative, r.A.XPositive, r.A.YPositive][n];
                        break;
                    case r.A.ZPositive:
                        s = [r.A.YPositive, r.A.XNegative, r.A.YNegative, r.A.XPositive][n];
                        break;
                    case r.A.ZNegative:
                        s = [r.A.YNegative, r.A.XPositive, r.A.YPositive, r.A.XNegative][n]
                    }
                    a = n,
                    t != r.A.XPositive && t != r.A.XNegative || (s == r.A.YPositive || s == r.A.YNegative ? a += 2 : (s == r.A.XPositive || s == r.A.XNegative) && (a -= 1)),
                    t != r.A.ZPositive && t != r.A.ZNegative || (s == r.A.YNegative ? a += 2 : s == r.A.XPositive ? a += 1 : s == r.A.XNegative && (a -= 1)),
                    t == r.A.YNegative && (a += 2)
                }
                return (t == r.A.YNegative || t == r.A.XNegative || t == r.A.ZNegative) == (s == r.A.YNegative || s == r.A.XNegative || s == r.A.ZNegative) ? a += e : a -= e,
                {
                    rotation: (a % 4 + 4) % 4,
                    rotationAxis: s
                }
            }
        }
        ,
        5739: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/quit.svg"
        }
        ,
        5769: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/state_pending.svg"
        }
        ,
        5794: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/list.svg"
        }
        ,
        5798: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_y_negative.svg"
        }
        ,
        5811: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".checkpoint-ui {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: var(--safe-area-horizontal);\n\tmargin: 0;\n\tpadding: 8px 10px;\n\tline-height: 0;\n\tfont-size: 40px;\n\tcolor: var(--text-color);\n\ttext-align: left;\n\topacity: 0.9;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-color);\n}\n.checkpoint-ui.up {\n\tposition: absolute;\n\tbottom: auto;\n\ttop: 0;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.checkpoint-ui.hidden {\n\tdisplay: none;\n}\n\n\n#ui.has-safe-area-horizontal .checkpoint-ui {\n\tclip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n#ui.has-safe-area-horizontal .checkpoint-ui.up {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n\n.checkpoint-ui > div {\n\tmargin: 0;\n\tpadding: 0 16px;\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-tertiary-color);\n}\n.checkpoint-ui.up > div {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\n}\n\n#ui.has-safe-area-horizontal .checkpoint-ui > div {\n\tclip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n#ui.has-safe-area-horizontal > .checkpoint-ui.up > div {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 6px 100%);\n}\n\n.checkpoint-ui > div > img {\n\tmargin: 0 12px 5px 0;\n\tpadding: 0;\n\twidth: 24px;\n\theight: 24px;\n\tvertical-align: middle;\n}\n", ""]);
            const o = s
        }
        ,
        5818: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.VehicleAccelerate = 0] = "VehicleAccelerate",
                e[e.VehicleTurnRight = 1] = "VehicleTurnRight",
                e[e.VehicleBrake = 2] = "VehicleBrake",
                e[e.VehicleTurnLeft = 3] = "VehicleTurnLeft",
                e[e.VehicleCheckpointReset = 4] = "VehicleCheckpointReset",
                e[e.VehicleStartReset = 5] = "VehicleStartReset",
                e[e.VehicleCockpitCamera = 6] = "VehicleCockpitCamera",
                e[e.ToggleUI = 7] = "ToggleUI",
                e[e.Pause = 8] = "Pause",
                e[e.EditorRotatePart = 9] = "EditorRotatePart",
                e[e.EditorHeightModifier = 10] = "EditorHeightModifier",
                e[e.EditorDelete = 11] = "EditorDelete",
                e[e.EditorMoveForwards = 12] = "EditorMoveForwards",
                e[e.EditorMoveRight = 13] = "EditorMoveRight",
                e[e.EditorMoveBackwards = 14] = "EditorMoveBackwards",
                e[e.EditorMoveLeft = 15] = "EditorMoveLeft",
                e[e.EditorRotateViewUp = 16] = "EditorRotateViewUp",
                e[e.EditorRotateViewDown = 17] = "EditorRotateViewDown",
                e[e.EditorRotateViewLeft = 18] = "EditorRotateViewLeft",
                e[e.EditorRotateViewRight = 19] = "EditorRotateViewRight",
                e[e.EditorMoveDown = 20] = "EditorMoveDown",
                e[e.EditorMoveUp = 21] = "EditorMoveUp",
                e[e.EditorTest = 22] = "EditorTest",
                e[e.EditorPick = 23] = "EditorPick",
                e[e.ToggleFpsCounter = 24] = "ToggleFpsCounter",
                e[e.ToggleSpectatorCamera = 25] = "ToggleSpectatorCamera",
                e[e.SpectatorMoveForwards = 26] = "SpectatorMoveForwards",
                e[e.SpectatorMoveRight = 27] = "SpectatorMoveRight",
                e[e.SpectatorMoveBackwards = 28] = "SpectatorMoveBackwards",
                e[e.SpectatorMoveLeft = 29] = "SpectatorMoveLeft",
                e[e.SpectatorSpeedModifier = 30] = "SpectatorSpeedModifier",
                e[e.PreviewStepForward = 31] = "PreviewStepForward",
                e[e.PreviewStepBack = 32] = "PreviewStepBack"
            }(i || (i = {}));
            const r = i
        }
        ,
        5839: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => D
            });
            var i = n(1635)
              , r = n(5072)
              , a = n.n(r)
              , s = n(7825)
              , o = n.n(s)
              , l = n(7659)
              , c = n.n(l)
              , h = n(5056)
              , d = n.n(h)
              , u = n(540)
              , p = n.n(u)
              , f = n(1113)
              , g = n.n(f)
              , m = n(9178)
              , A = {};
            A.styleTagTransform = g(),
            A.setAttributes = d(),
            A.insert = c().bind(null, "head"),
            A.domAPI = o(),
            A.insertStyleElement = p();
            a()(m.A, A);
            m.A && m.A.locals && m.A.locals;
            var v, y, w, b, x, S, E, T, k, M, _, C, R, P, I, L, N, z = n(3476);
            class U {
                constructor(e, t, n, r=!1) {
                    if (v.set(this, void 0),
                    y.set(this, void 0),
                    w.set(this, void 0),
                    b.set(this, void 0),
                    x.set(this, null),
                    S.set(this, void 0),
                    E.set(this, null),
                    T.set(this, null),
                    k.set(this, void 0),
                    M.set(this, null),
                    _.set(this, []),
                    C.set(this, void 0),
                    R.set(this, void 0),
                    P.set(this, void 0),
                    I.set(this, null),
                    L.set(this, null),
                    N.set(this, null),
                    this.record = null,
                    (0,
                    i.GG)(this, v, e, "f"),
                    (0,
                    i.GG)(this, y, t, "f"),
                    (0,
                    i.GG)(this, w, n, "f"),
                    (0,
                    i.GG)(this, b, document.createElement("div"), "f"),
                    "off" == n.getSetting(z.A.Timer) ? (0,
                    i.gn)(this, b, "f").className = "timer-ui hidden" : "top" == n.getSetting(z.A.Timer) ? (0,
                    i.gn)(this, b, "f").className = "timer-ui up" : (0,
                    i.gn)(this, b, "f").className = "timer-ui",
                    r)
                        (0,
                        i.GG)(this, C, null, "f");
                    else {
                        const e = document.createElement("div");
                        e.className = "left",
                        (0,
                        i.gn)(this, b, "f").appendChild(e);
                        const n = document.createElement("div");
                        n.className = "title-container",
                        e.appendChild(n),
                        (0,
                        i.GG)(this, x, document.createElement("h2"), "f"),
                        (0,
                        i.gn)(this, x, "f").className = "title",
                        (0,
                        i.gn)(this, x, "f").textContent = t.get("Record"),
                        n.appendChild((0,
                        i.gn)(this, x, "f")),
                        (0,
                        i.GG)(this, T, document.createElement("h2"), "f"),
                        (0,
                        i.gn)(this, T, "f").className = "checkpoint-time",
                        n.appendChild((0,
                        i.gn)(this, T, "f"));
                        const r = document.createElement("div");
                        r.className = "time",
                        e.appendChild(r),
                        (0,
                        i.GG)(this, C, document.createElement("p"), "f"),
                        (0,
                        i.gn)(this, C, "f").className = "small",
                        (0,
                        i.gn)(this, C, "f").textContent = "- - -",
                        r.appendChild((0,
                        i.gn)(this, C, "f"))
                    }
                    const a = document.createElement("div");
                    a.className = "center",
                    (0,
                    i.gn)(this, b, "f").appendChild(a);
                    const s = document.createElement("div");
                    s.className = "title-container",
                    a.appendChild(s),
                    (0,
                    i.GG)(this, S, document.createElement("h2"), "f"),
                    (0,
                    i.gn)(this, S, "f").className = "title",
                    (0,
                    i.gn)(this, S, "f").textContent = t.get("Current"),
                    s.appendChild((0,
                    i.gn)(this, S, "f")),
                    (0,
                    i.GG)(this, k, document.createElement("h2"), "f"),
                    (0,
                    i.gn)(this, k, "f").className = "checkpoint-time",
                    s.appendChild((0,
                    i.gn)(this, k, "f"));
                    const o = document.createElement("div");
                    if (o.className = "time",
                    a.appendChild(o),
                    (0,
                    i.GG)(this, R, document.createElement("p"), "f"),
                    (0,
                    i.gn)(this, R, "f").textContent = "- - -",
                    o.appendChild((0,
                    i.gn)(this, R, "f")),
                    r)
                        (0,
                        i.GG)(this, P, null, "f");
                    else {
                        const e = document.createElement("div");
                        e.className = "right",
                        (0,
                        i.gn)(this, b, "f").appendChild(e);
                        const n = document.createElement("div");
                        n.className = "title-container",
                        e.appendChild(n),
                        (0,
                        i.GG)(this, E, document.createElement("h2"), "f"),
                        (0,
                        i.gn)(this, E, "f").className = "title",
                        (0,
                        i.gn)(this, E, "f").textContent = t.get("Difference"),
                        n.appendChild((0,
                        i.gn)(this, E, "f")),
                        (0,
                        i.GG)(this, M, document.createElement("h2"), "f"),
                        (0,
                        i.gn)(this, M, "f").className = "checkpoint-time",
                        n.appendChild((0,
                        i.gn)(this, M, "f"));
                        const r = document.createElement("div");
                        r.className = "time",
                        e.appendChild(r),
                        (0,
                        i.GG)(this, P, document.createElement("p"), "f"),
                        (0,
                        i.gn)(this, P, "f").className = "small",
                        (0,
                        i.gn)(this, P, "f").textContent = "- - -",
                        r.appendChild((0,
                        i.gn)(this, P, "f"))
                    }
                    (0,
                    i.gn)(this, v, "f").appendChild((0,
                    i.gn)(this, b, "f"))
                }
                dispose() {
                    (0,
                    i.gn)(this, b, "f").parentElement == (0,
                    i.gn)(this, v, "f") && (0,
                    i.gn)(this, v, "f").removeChild((0,
                    i.gn)(this, b, "f"))
                }
                setOverridePosition(e) {
                    const t = (0,
                    i.gn)(this, w, "f").getSetting(z.A.Timer);
                    (0,
                    i.gn)(this, b, "f").className = "off" == t ? "timer-ui hidden" : e ?? "top" == t ? "timer-ui up" : "timer-ui"
                }
                setBottomOffset(e) {
                    (0,
                    i.gn)(this, b, "f").style.bottom = e.toString() + "px"
                }
                hideCheckpointTime() {
                    for (const e of (0,
                    i.gn)(this, _, "f"))
                        e.cancel();
                    (0,
                    i.gn)(this, _, "f").length = 0
                }
                showCheckpointTime(e, t) {
                    if (this.hideCheckpointTime(),
                    null != (0,
                    i.gn)(this, T, "f") && null != t && ((0,
                    i.gn)(this, T, "f").textContent = U.formatTimeString(t, !1),
                    (0,
                    i.gn)(this, _, "f").push((0,
                    i.gn)(this, T, "f").animate([{
                        opacity: 0,
                        transform: "translateX(20px)",
                        offset: 0,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        transform: "translateX(0)",
                        offset: 1 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        transform: "translateX(0)",
                        offset: 27 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        transform: "translateX(-10px)",
                        offset: 1,
                        easing: "ease-in-out"
                    }], {
                        duration: 3500
                    }))),
                    (0,
                    i.gn)(this, k, "f").textContent = U.formatTimeString(e, !1),
                    (0,
                    i.gn)(this, _, "f").push((0,
                    i.gn)(this, k, "f").animate([{
                        opacity: 0,
                        transform: "translateX(20px)",
                        offset: 0,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        transform: "translateX(0)",
                        offset: 1 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        transform: "translateX(0)",
                        offset: 27 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        transform: "translateX(-10px)",
                        offset: 1,
                        easing: "ease-in-out"
                    }], {
                        duration: 3500
                    })),
                    null != (0,
                    i.gn)(this, M, "f") && null != t) {
                        const n = e.difference(t);
                        (0,
                        i.gn)(this, M, "f").textContent = U.formatTimeString(n, !0),
                        n.isNegative() ? ((0,
                        i.gn)(this, M, "f").classList.remove("red"),
                        (0,
                        i.gn)(this, M, "f").classList.add("green")) : ((0,
                        i.gn)(this, M, "f").classList.add("red"),
                        (0,
                        i.gn)(this, M, "f").classList.remove("green")),
                        (0,
                        i.gn)(this, _, "f").push((0,
                        i.gn)(this, M, "f").animate([{
                            opacity: 0,
                            transform: "translateX(20px)",
                            offset: 0,
                            easing: "ease-in-out"
                        }, {
                            opacity: 1,
                            transform: "translateX(0)",
                            offset: 1 / 28,
                            easing: "ease-in-out"
                        }, {
                            opacity: 1,
                            transform: "translateX(0)",
                            offset: 27 / 28,
                            easing: "ease-in-out"
                        }, {
                            opacity: 0,
                            transform: "translateX(-10px)",
                            offset: 1,
                            easing: "ease-in-out"
                        }], {
                            duration: 3500
                        }))
                    }
                    null != (0,
                    i.gn)(this, x, "f") && null != t && (0,
                    i.gn)(this, _, "f").push((0,
                    i.gn)(this, x, "f").animate([{
                        opacity: 1,
                        offset: 0,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 1 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 27 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        offset: 1,
                        easing: "ease-in-out"
                    }], {
                        duration: 3500
                    })),
                    (0,
                    i.gn)(this, _, "f").push((0,
                    i.gn)(this, S, "f").animate([{
                        opacity: 1,
                        offset: 0,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 1 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 27 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        offset: 1,
                        easing: "ease-in-out"
                    }], {
                        duration: 3500
                    })),
                    null != (0,
                    i.gn)(this, E, "f") && null != t && (0,
                    i.gn)(this, _, "f").push((0,
                    i.gn)(this, E, "f").animate([{
                        opacity: 1,
                        offset: 0,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 1 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 0,
                        offset: 27 / 28,
                        easing: "ease-in-out"
                    }, {
                        opacity: 1,
                        offset: 1,
                        easing: "ease-in-out"
                    }], {
                        duration: 3500
                    }))
                }
                static formatTimeString(e, t=!1) {
                    if (null == e)
                        return "---";
                    {
                        const n = Math.abs(e.numberOfFrames)
                          , i = Math.floor(n / 6e4)
                          , r = Math.floor((n - 6e4 * i) / 1e3)
                          , a = n - 6e4 * i - 1e3 * r;
                        let s;
                        return s = t ? e.isNegative() ? "-" : "+" : "",
                        s + i.toString().padStart(2, "0") + ":" + r.toString().padStart(2, "0") + "." + a.toString().padStart(3, "0")
                    }
                }
                update(e) {
                    const t = e.getFinishTime() ?? e.getTime();
                    let n;
                    if (n = null != this.record ? t.difference(this.record) : null,
                    null != (0,
                    i.gn)(this, C, "f")) {
                        const e = U.formatTimeString(this.record, !1);
                        if (e != (0,
                        i.gn)(this, I, "f")) {
                            (0,
                            i.gn)(this, C, "f").innerHTML = "";
                            for (const t of e) {
                                const e = document.createElement("span");
                                e.textContent = t,
                                (0,
                                i.gn)(this, C, "f").appendChild(e)
                            }
                            (0,
                            i.GG)(this, I, e, "f")
                        }
                        null == this.record ? "small center" != (0,
                        i.gn)(this, C, "f").className && ((0,
                        i.gn)(this, C, "f").className = "small center") : "small" != (0,
                        i.gn)(this, C, "f").className && ((0,
                        i.gn)(this, C, "f").className = "small")
                    }
                    const r = U.formatTimeString(t, !1);
                    if (r != (0,
                    i.gn)(this, L, "f")) {
                        (0,
                        i.gn)(this, R, "f").innerHTML = "";
                        for (const e of r) {
                            const t = document.createElement("span");
                            t.textContent = e,
                            (0,
                            i.gn)(this, R, "f").appendChild(t)
                        }
                        (0,
                        i.GG)(this, L, r, "f")
                    }
                    if (null != (0,
                    i.gn)(this, P, "f")) {
                        const e = U.formatTimeString(n, !0);
                        if (e != (0,
                        i.gn)(this, N, "f")) {
                            (0,
                            i.gn)(this, P, "f").innerHTML = "";
                            for (let t = 0; t < e.length; ++t) {
                                const r = document.createElement("span");
                                0 == t && Number.isFinite(n) && (r.className = "sign"),
                                r.textContent = e[t],
                                (0,
                                i.gn)(this, P, "f").appendChild(r)
                            }
                            (0,
                            i.GG)(this, N, e, "f")
                        }
                        null == n ? "small center" != (0,
                        i.gn)(this, P, "f").className && ((0,
                        i.gn)(this, P, "f").className = "small center") : n.isNegative() ? "small green" != (0,
                        i.gn)(this, P, "f").className && ((0,
                        i.gn)(this, P, "f").className = "small green") : "small red" != (0,
                        i.gn)(this, P, "f").className && ((0,
                        i.gn)(this, P, "f").className = "small red")
                    }
                }
                set nickname(e) {
                    null != (0,
                    i.gn)(this, x, "f") ? (0,
                    i.gn)(this, x, "f").textContent = null != e ? '"' + e + '"' : (0,
                    i.gn)(this, y, "f").get("Record") : (0,
                    i.gn)(this, S, "f").textContent = null != e ? '"' + e + '"' : (0,
                    i.gn)(this, y, "f").get("Current")
                }
            }
            v = new WeakMap,
            y = new WeakMap,
            w = new WeakMap,
            b = new WeakMap,
            x = new WeakMap,
            S = new WeakMap,
            E = new WeakMap,
            T = new WeakMap,
            k = new WeakMap,
            M = new WeakMap,
            _ = new WeakMap,
            C = new WeakMap,
            R = new WeakMap,
            P = new WeakMap,
            I = new WeakMap,
            L = new WeakMap,
            N = new WeakMap;
            const D = U
        }
        ,
        5918: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/load.svg"
        }
        ,
        5945: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/music_on.svg"
        }
        ,
        5974: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_needle.svg"
        }
        ,
        6005: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".loading-spinner-ui {\n\twidth: 40px;\n\theight: 40px;\n\tborder-radius: 50%;\n\tborder: 5px solid var(--surface-tertiary-color);\n\tborder-left-color: var(--text-color);\n\n\tanimation: 1s linear infinite forwards loading-spinner-spin;\n}\n\n@keyframes loading-spinner-spin {\n\tfrom {\n\t\ttransform: rotate(0);\n\t}\n\tto {\n\t\ttransform: rotate(360deg);\n\t}\n}\n", ""]);
            const o = s
        }
        ,
        6027: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pin.svg"
        }
        ,
        6099: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/arrow_left.svg"
        }
        ,
        6104: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".hint-ui {\n\tpadding: 0 280px;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 150px;\n\twidth: 100%;\n\tbox-sizing: border-box;\n\ttext-align: center;\n\tcolor: #fff;\n\ttext-shadow: 2px 2px 0 #112052, 0 0 2px #000;\n\tpointer-events: none;\n\topacity: 0;\n}\n.hint-ui.show {\n\ttop: 150px;\n\topacity: 1;\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\n}\n.hint-ui.hide {\n\ttop: 160px;\n\topacity: 0;\n\ttransition: opacity 0.25s ease-in-out, top 0.25s ease-in-out;\n}\n\n.hint-ui > .title {\n\tfont-size: 32px;\n}\n\n.hint-ui > .subtitle {\n\tmargin: 16px 0 0 0;\n\tfont-size: 24px;\n}\n\n.hint-ui > .title > .key-binding, .hint-ui > .subtitle > .key-binding {\n\tdisplay: inline-block;\n\tpadding: 0 8px 0 8px;\n\tbackground-color: var(--surface-transparent-color);\n\tborder-radius: 4px;\n\tfont-style: normal;\n}\n", ""]);
            const o = s
        }
        ,
        6150: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/arrow_right.svg"
        }
        ,
        6168: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/export.svg"
        }
        ,
        6223: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => r
            });
            class i extends Error {
                constructor(e="Failed to load track.") {
                    super(e),
                    this.name = "TrackLoadError"
                }
            }
            const r = i
        }
        ,
        6244: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/state_verified.svg"
        }
        ,
        6249: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".session-end-ui {\n\tposition: fixed;\n\ttop: 0;\n\tleft: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 45, 0.8);\n\t-webkit-backdrop-filter: blur(4px);\n\tbackdrop-filter: blur(4px);\n\tanimation: session-end-ui-fade-in 0.25s forwards;\n}\n\n@keyframes session-end-ui-fade-in {\n\tfrom {\n\t\tbackground-color: rgba(20, 20, 45, 0);\n\t}\n\tto {\n\t\tbackground-color: rgba(20, 20, 45, 0.8);\n\t}\n}\n", ""]);
            const o = s
        }
        ,
        6252: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".leaderboard-ui {\n\tposition: relative;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 600px;\n\theight: 100%;\n\ttext-align: left;\n\tdisplay: flex;\n\tflex-shrink: 0;\n\tflex-direction: column;\n\tbackground-color: var(--surface-color);\n}\n\n.leaderboard-ui > h2 {\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.leaderboard-ui > h3 {\n\tmargin: 0 10px 10px 10px;\n\tpadding: 0;\n\tfont-weight: normal;\n\tfont-size: 18px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n\topacity: 0.5;\n}\n\n.leaderboard-ui > .total-players {\n\tmargin: 10px;\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\ttext-align: center;\n\tfont-size: 14px;\n\tcolor: var(--text-color);\n\topacity: 0;\n\ttransition: opacity 0.5s ease-out;\n}\n.leaderboard-ui > .total-players.fade-in {\n\topacity: 0.5;\n}\n\n.leaderboard-ui > .container {\n\tmargin: 0;\n\tpadding: 0;\n\tflex-grow: 1;\n\tbackground-color: var(--surface-secondary-color);\n\toverflow-x: hidden;\n\toverflow-y: scroll;\n\tpointer-events: auto;\n}\n\n.leaderboard-ui > .container > .loading-spinner-container {\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.leaderboard-ui > .container > .error-message {\n\tmargin: 0;\n\tpadding: 20px;\n\tfont-size: 20px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n}\n\n.leaderboard-ui > .container > button.main {\n\tmargin: 10px 10px 0 10px;\n\tpadding: 0;\n\tvertical-align: top;\n\twidth: calc(100% - 10px * 2);\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: left;\n\twhite-space: nowrap;\n}\n.leaderboard-ui > .container > button.main:last-of-type {\n\tmargin-bottom: 10px;\n}\n\n.leaderboard-ui > .container > button.main.self:not(:focus-visible) {\n\tbackground-color: #2e4182;\n}\n\n.leaderboard-ui > .container > button.main.selected {\n\tbackground-color: var(--button-hover-color);\n}\n.leaderboard-ui > .container > button.main.selected::after {\n\twidth: 100%;\n}\n\n.leaderboard-ui > .container > button.main > .checkmark {\n\tdisplay: none;\n}\n\n.leaderboard-ui > .container > button.main.selected > .checkmark {\n\tdisplay: block;\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tmargin: 6px;\n\twidth: 12px;\n\tanimation: leaderboard-checkmark-spawn 0.15s ease-out;\n}\n\n@keyframes leaderboard-checkmark-spawn {\n\t0% {\n\t\ttransform: scale(0);\n\t}\n\t90% {\n\t\ttransform: scale(1.2);\n\t}\n\t100% {\n\t\ttransform: scale(1);\n\t}\n}\n\n.leaderboard-ui > .container > button.main > .image-container {\n\tdisplay: inline-block;\n\tposition: relative;\n\tbackground-color: rgba(0, 0, 0, 0.1);\n\twidth: 100px;\n\theight: 100px;\n}\n\n.leaderboard-ui > .container > button.main > .image-container > img {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\tpointer-events: none;\n\topacity: 0;\n\ttransition: opacity 0.5s ease-out;\n}\n.leaderboard-ui > .container > button.main > .image-container > img.show {\n\topacity: 1;\n}\n\n.leaderboard-ui > .container > button.main > .left, .leaderboard-ui > .container > button.main > .right {\n\tdisplay: inline-block;\n\tvertical-align: top;\n}\n\n.leaderboard-ui > .container > button.main > div > p {\n\tmargin: 0;\n\tpadding: 12px;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n}\n\n.leaderboard-ui > .container > button.main > div > .position > span {\n\tfont-size: 20px;\n\topacity: 0.3;\n}\n\n.leaderboard-ui > .container > button.main > div > .name-container {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 28px;\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 360px;\n}\n\n.leaderboard-ui > .container > button.main > div > .name-container > .country-flag {\n\t/* Flag aspect ratio is 4:3. */\n\twidth: 32px;\n\theight: 24px;\n\tfilter: drop-shadow(2px 2px 1px rgba(0, 0, 0, 0.5)); /* box-shadow cannot be used because of Nepal. */\n}\n\n.leaderboard-ui > .container > button.main > div > .name-container > .name {\n\tpadding: 12px;\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n.leaderboard-ui > .container > button.main:focus-visible > div > .name-container > .name {\n\ttext-decoration: underline;\n}\n\n.leaderboard-ui > .container > button.main > div > .name-container > .self {\n\tmargin-left: -16px;\n\tpadding: 12px;\n\topacity: 0.5;\n\tfont-size: 16px;\n\tfont-style: normal;\n}\n\n.leaderboard-ui > .container > button.main > div > .verified-state {\n\topacity: 0.8;\n\tposition: absolute;\n\tright: 6px;\n\tmargin: 6px 0 0 0;\n\tfont-size: 18px;\n}\n.leaderboard-ui > .container > button.main > div > .verified-state > img {\n\tmargin: 0 0 0 2px;\n\tpadding: 0;\n\theight: 12px;\n\tvertical-align: middle;\n}\n.leaderboard-ui > .container > button.main > div > .verified-state.verified {\n\tcolor: #5f5;\n}\n.leaderboard-ui > .container > button.main > div > .verified-state.invalid {\n\tcolor: #f55;\n}\n.leaderboard-ui > .container > button.main > div > .verified-state.pending {\n\tcolor: #ff5;\n}\n\n.leaderboard-ui > .pages {\n\tmargin: 10px 10px 0 10px;\n\tdisplay: flex;\n\tflex-direction: row;\n}\n.leaderboard-ui > .pages > button.page {\n\tpadding: 0;\n\twidth: 0;\n\tflex-grow: 1;\n}\n.leaderboard-ui > .pages > button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n\n.leaderboard-ui > .button-wrapper > .back {\n\tmargin: 10px;\n}\n\n.leaderboard-ui > .button-wrapper > .button.only-verified {\n\tmargin: 10px 0;\n\tfloat: right;\n\tfont-size: 20px;\n\tline-height: 32px;\n}\n.leaderboard-ui > .button-wrapper > .button.only-verified.disabled {\n\tcolor: rgba(255, 255, 255, 0.25);\n}\n\n.leaderboard-ui > .button-wrapper > .button.only-verified > img {\n\tmargin-left: 6px;\n\tmargin-bottom: -4px;\n\twidth: 26px;\n}\n.leaderboard-ui > .button-wrapper > .button.only-verified.disabled > img {\n\topacity: 0.25;\n}\n\n.leaderboard-ui > .button-wrapper > .icon-button {\n\tmargin: 10px 0;\n\tfloat: right;\n}\n.leaderboard-ui > .button-wrapper > .icon-button.first {\n\tmargin: 10px 10px 10px 0;\n}\n\n.leaderboard-ui > .button-wrapper > .icon-button > img {\n\twidth: 28px;\n}\n.leaderboard-ui > .button-wrapper > .icon-button.disabled > img, .leaderboard-ui > .button-wrapper > .icon-button:disabled > img {\n\topacity: 0.25;\n}\n", ""]);
            const o = s
        }
        ,
        6278: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/cut.svg"
        }
        ,
        6314: e => {
            "use strict";
            e.exports = function(e) {
                var t = [];
                return t.toString = function() {
                    return this.map((function(t) {
                        var n = ""
                          , i = void 0 !== t[5];
                        return t[4] && (n += "@supports (".concat(t[4], ") {")),
                        t[2] && (n += "@media ".concat(t[2], " {")),
                        i && (n += "@layer".concat(t[5].length > 0 ? " ".concat(t[5]) : "", " {")),
                        n += e(t),
                        i && (n += "}"),
                        t[2] && (n += "}"),
                        t[4] && (n += "}"),
                        n
                    }
                    )).join("")
                }
                ,
                t.i = function(e, n, i, r, a) {
                    "string" == typeof e && (e = [[null, e, void 0]]);
                    var s = {};
                    if (i)
                        for (var o = 0; o < this.length; o++) {
                            var l = this[o][0];
                            null != l && (s[l] = !0)
                        }
                    for (var c = 0; c < e.length; c++) {
                        var h = [].concat(e[c]);
                        i && s[h[0]] || (void 0 !== a && (void 0 === h[5] || (h[1] = "@layer".concat(h[5].length > 0 ? " ".concat(h[5]) : "", " {").concat(h[1], "}")),
                        h[5] = a),
                        n && (h[2] ? (h[1] = "@media ".concat(h[2], " {").concat(h[1], "}"),
                        h[2] = n) : h[2] = n),
                        r && (h[4] ? (h[1] = "@supports (".concat(h[4], ") {").concat(h[1], "}"),
                        h[4] = r) : h[4] = "".concat(r)),
                        t.push(h))
                    }
                }
                ,
                t
            }
        }
        ,
        6366: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/apply.svg"
        }
        ,
        6471: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_zigzag.svg"
        }
        ,
        6546: (e, t, n) => {
            "use strict";
            /*! Capacitor: https://capacitorjs.com/ - MIT License */
            var i;
            n.d(t, {
                E_: () => l,
                F3: () => o
            }),
            function(e) {
                e.Unimplemented = "UNIMPLEMENTED",
                e.Unavailable = "UNAVAILABLE"
            }(i || (i = {}));
            class r extends Error {
                constructor(e, t, n) {
                    super(e),
                    this.message = e,
                    this.code = t,
                    this.data = n
                }
            }
            const a = e => {
                const t = e.CapacitorCustomPlatform || null
                  , n = e.Capacitor || {}
                  , a = n.Plugins = n.Plugins || {}
                  , s = () => null !== t ? t.name : (e => {
                    var t, n;
                    return (null == e ? void 0 : e.androidBridge) ? "android" : (null === (n = null === (t = null == e ? void 0 : e.webkit) || void 0 === t ? void 0 : t.messageHandlers) || void 0 === n ? void 0 : n.bridge) ? "ios" : "web"
                }
                )(e)
                  , o = e => {
                    var t;
                    return null === (t = n.PluginHeaders) || void 0 === t ? void 0 : t.find((t => t.name === e))
                }
                  , l = new Map;
                return n.convertFileSrc || (n.convertFileSrc = e => e),
                n.getPlatform = s,
                n.handleError = t => e.console.error(t),
                n.isNativePlatform = () => "web" !== s(),
                n.isPluginAvailable = e => {
                    const t = l.get(e);
                    return !!(null == t ? void 0 : t.platforms.has(s())) || !!o(e)
                }
                ,
                n.registerPlugin = (e, c={}) => {
                    const h = l.get(e);
                    if (h)
                        return console.warn(`Capacitor plugin "${e}" already registered. Cannot register plugins twice.`),
                        h.proxy;
                    const d = s()
                      , u = o(e);
                    let p;
                    const f = a => {
                        let s;
                        const o = (...o) => {
                            const l = (async () => (!p && d in c ? p = p = "function" == typeof c[d] ? await c[d]() : c[d] : null !== t && !p && "web"in c && (p = p = "function" == typeof c.web ? await c.web() : c.web),
                            p))().then((t => {
                                const l = ( (t, a) => {
                                    var s, o;
                                    if (!u) {
                                        if (t)
                                            return null === (o = t[a]) || void 0 === o ? void 0 : o.bind(t);
                                        throw new r(`"${e}" plugin is not implemented on ${d}`,i.Unimplemented)
                                    }
                                    {
                                        const i = null == u ? void 0 : u.methods.find((e => a === e.name));
                                        if (i)
                                            return "promise" === i.rtype ? t => n.nativePromise(e, a.toString(), t) : (t, i) => n.nativeCallback(e, a.toString(), t, i);
                                        if (t)
                                            return null === (s = t[a]) || void 0 === s ? void 0 : s.bind(t)
                                    }
                                }
                                )(t, a);
                                if (l) {
                                    const e = l(...o);
                                    return s = null == e ? void 0 : e.remove,
                                    e
                                }
                                throw new r(`"${e}.${a}()" is not implemented on ${d}`,i.Unimplemented)
                            }
                            ));
                            return "addListener" === a && (l.remove = async () => s()),
                            l
                        }
                        ;
                        return o.toString = () => `${a.toString()}() { [capacitor code] }`,
                        Object.defineProperty(o, "name", {
                            value: a,
                            writable: !1,
                            configurable: !1
                        }),
                        o
                    }
                      , g = f("addListener")
                      , m = f("removeListener")
                      , A = (e, t) => {
                        const n = g({
                            eventName: e
                        }, t)
                          , i = async () => {
                            const i = await n;
                            m({
                                eventName: e,
                                callbackId: i
                            }, t)
                        }
                          , r = new Promise((e => n.then(( () => e({
                            remove: i
                        })))));
                        return r.remove = async () => {
                            console.warn("Using addListener() without 'await' is deprecated."),
                            await i()
                        }
                        ,
                        r
                    }
                      , v = new Proxy({},{
                        get(e, t) {
                            switch (t) {
                            case "$$typeof":
                                return;
                            case "toJSON":
                                return () => ({});
                            case "addListener":
                                return u ? A : g;
                            case "removeListener":
                                return m;
                            default:
                                return f(t)
                            }
                        }
                    });
                    return a[e] = v,
                    l.set(e, {
                        name: e,
                        proxy: v,
                        platforms: new Set([...Object.keys(c), ...u ? [d] : []])
                    }),
                    v
                }
                ,
                n.Exception = r,
                n.DEBUG = !!n.DEBUG,
                n.isLoggingEnabled = !!n.isLoggingEnabled,
                n
            }
              , s = (e => e.Capacitor = a(e))("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : {})
              , o = s.registerPlugin;
            class l {
                constructor() {
                    this.listeners = {},
                    this.retainedEventArguments = {},
                    this.windowListeners = {}
                }
                addListener(e, t) {
                    let n = !1;
                    this.listeners[e] || (this.listeners[e] = [],
                    n = !0),
                    this.listeners[e].push(t);
                    const i = this.windowListeners[e];
                    i && !i.registered && this.addWindowListener(i),
                    n && this.sendRetainedArgumentsForEvent(e);
                    return Promise.resolve({
                        remove: async () => this.removeListener(e, t)
                    })
                }
                async removeAllListeners() {
                    this.listeners = {};
                    for (const e in this.windowListeners)
                        this.removeWindowListener(this.windowListeners[e]);
                    this.windowListeners = {}
                }
                notifyListeners(e, t, n) {
                    const i = this.listeners[e];
                    if (i)
                        i.forEach((e => e(t)));
                    else if (n) {
                        let n = this.retainedEventArguments[e];
                        n || (n = []),
                        n.push(t),
                        this.retainedEventArguments[e] = n
                    }
                }
                hasListeners(e) {
                    var t;
                    return !!(null === (t = this.listeners[e]) || void 0 === t ? void 0 : t.length)
                }
                registerWindowListener(e, t) {
                    this.windowListeners[t] = {
                        registered: !1,
                        windowEventName: e,
                        pluginEventName: t,
                        handler: e => {
                            this.notifyListeners(t, e)
                        }
                    }
                }
                unimplemented(e="not implemented") {
                    return new s.Exception(e,i.Unimplemented)
                }
                unavailable(e="not available") {
                    return new s.Exception(e,i.Unavailable)
                }
                async removeListener(e, t) {
                    const n = this.listeners[e];
                    if (!n)
                        return;
                    const i = n.indexOf(t);
                    this.listeners[e].splice(i, 1),
                    this.listeners[e].length || this.removeWindowListener(this.windowListeners[e])
                }
                addWindowListener(e) {
                    window.addEventListener(e.windowEventName, e.handler),
                    e.registered = !0
                }
                removeWindowListener(e) {
                    e && (window.removeEventListener(e.windowEventName, e.handler),
                    e.registered = !1)
                }
                sendRetainedArgumentsForEvent(e) {
                    const t = this.retainedEventArguments[e];
                    t && (delete this.retainedEventArguments[e],
                    t.forEach((t => {
                        this.notifyListeners(e, t)
                    }
                    )))
                }
            }
            const c = e => encodeURIComponent(e).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape)
              , h = e => e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
            class d extends l {
                async getCookies() {
                    const e = document.cookie
                      , t = {};
                    return e.split(";").forEach((e => {
                        if (e.length <= 0)
                            return;
                        let[n,i] = e.replace(/=/, "CAP_COOKIE").split("CAP_COOKIE");
                        n = h(n).trim(),
                        i = h(i).trim(),
                        t[n] = i
                    }
                    )),
                    t
                }
                async setCookie(e) {
                    try {
                        const t = c(e.key)
                          , n = c(e.value)
                          , i = `; expires=${(e.expires || "").replace("expires=", "")}`
                          , r = (e.path || "/").replace("path=", "")
                          , a = null != e.url && e.url.length > 0 ? `domain=${e.url}` : "";
                        document.cookie = `${t}=${n || ""}${i}; path=${r}; ${a};`
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
                async deleteCookie(e) {
                    try {
                        document.cookie = `${e.key}=; Max-Age=0`
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
                async clearCookies() {
                    try {
                        const e = document.cookie.split(";") || [];
                        for (const t of e)
                            document.cookie = t.replace(/^ +/, "").replace(/=.*/, `=;expires=${(new Date).toUTCString()};path=/`)
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
                async clearAllCookies() {
                    try {
                        await this.clearCookies()
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
            }
            o("CapacitorCookies", {
                web: () => new d
            });
            const u = (e, t={}) => {
                const n = Object.assign({
                    method: e.method || "GET",
                    headers: e.headers
                }, t)
                  , i = ( (e={}) => {
                    const t = Object.keys(e);
                    return Object.keys(e).map((e => e.toLocaleLowerCase())).reduce(( (n, i, r) => (n[i] = e[t[r]],
                    n)), {})
                }
                )(e.headers)["content-type"] || "";
                if ("string" == typeof e.data)
                    n.body = e.data;
                else if (i.includes("application/x-www-form-urlencoded")) {
                    const t = new URLSearchParams;
                    for (const [n,i] of Object.entries(e.data || {}))
                        t.set(n, i);
                    n.body = t.toString()
                } else if (i.includes("multipart/form-data") || e.data instanceof FormData) {
                    const t = new FormData;
                    if (e.data instanceof FormData)
                        e.data.forEach(( (e, n) => {
                            t.append(n, e)
                        }
                        ));
                    else
                        for (const n of Object.keys(e.data))
                            t.append(n, e.data[n]);
                    n.body = t;
                    const i = new Headers(n.headers);
                    i.delete("content-type"),
                    n.headers = i
                } else
                    (i.includes("application/json") || "object" == typeof e.data) && (n.body = JSON.stringify(e.data));
                return n
            }
            ;
            class p extends l {
                async request(e) {
                    const t = u(e, e.webFetchExtra)
                      , n = ( (e, t=!0) => e ? Object.entries(e).reduce(( (e, n) => {
                        const [i,r] = n;
                        let a, s;
                        return Array.isArray(r) ? (s = "",
                        r.forEach((e => {
                            a = t ? encodeURIComponent(e) : e,
                            s += `${i}=${a}&`
                        }
                        )),
                        s.slice(0, -1)) : (a = t ? encodeURIComponent(r) : r,
                        s = `${i}=${a}`),
                        `${e}&${s}`
                    }
                    ), "").substr(1) : null)(e.params, e.shouldEncodeUrlParams)
                      , i = n ? `${e.url}?${n}` : e.url
                      , r = await fetch(i, t)
                      , a = r.headers.get("content-type") || "";
                    let s, o, {responseType: l="text"} = r.ok ? e : {};
                    switch (a.includes("application/json") && (l = "json"),
                    l) {
                    case "arraybuffer":
                    case "blob":
                        o = await r.blob(),
                        s = await (async e => new Promise(( (t, n) => {
                            const i = new FileReader;
                            i.onload = () => {
                                const e = i.result;
                                t(e.indexOf(",") >= 0 ? e.split(",")[1] : e)
                            }
                            ,
                            i.onerror = e => n(e),
                            i.readAsDataURL(e)
                        }
                        )))(o);
                        break;
                    case "json":
                        s = await r.json();
                        break;
                    default:
                        s = await r.text()
                    }
                    const c = {};
                    return r.headers.forEach(( (e, t) => {
                        c[t] = e
                    }
                    )),
                    {
                        data: s,
                        headers: c,
                        status: r.status,
                        url: r.url
                    }
                }
                async get(e) {
                    return this.request(Object.assign(Object.assign({}, e), {
                        method: "GET"
                    }))
                }
                async post(e) {
                    return this.request(Object.assign(Object.assign({}, e), {
                        method: "POST"
                    }))
                }
                async put(e) {
                    return this.request(Object.assign(Object.assign({}, e), {
                        method: "PUT"
                    }))
                }
                async patch(e) {
                    return this.request(Object.assign(Object.assign({}, e), {
                        method: "PATCH"
                    }))
                }
                async delete(e) {
                    return this.request(Object.assign(Object.assign({}, e), {
                        method: "DELETE"
                    }))
                }
            }
            o("CapacitorHttp", {
                web: () => new p
            })
        }
        ,
        6557: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/blank_flag.svg"
        }
        ,
        6633: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => s
            });
            var i, r = n(1635);
            class a {
                constructor(e) {
                    if (i.set(this, 0),
                    null != e) {
                        if (!Number.isSafeInteger(e))
                            throw new Error("Frames is not a safe integer");
                        (0,
                        r.GG)(this, i, e, "f")
                    }
                }
                get numberOfFrames() {
                    return (0,
                    r.gn)(this, i, "f")
                }
                get time() {
                    return (0,
                    r.gn)(this, i, "f") / 1e3
                }
                increment() {
                    var e;
                    (0,
                    r.GG)(this, i, (e = (0,
                    r.gn)(this, i, "f"),
                    ++e), "f")
                }
                difference(e) {
                    return new a((0,
                    r.gn)(this, i, "f") - e.numberOfFrames)
                }
                lessThan(e) {
                    return (0,
                    r.gn)(this, i, "f") < e.numberOfFrames
                }
                greaterThan(e) {
                    return (0,
                    r.gn)(this, i, "f") > e.numberOfFrames
                }
                lessOrEqual(e) {
                    return (0,
                    r.gn)(this, i, "f") <= e.numberOfFrames
                }
                greaterOrEqual(e) {
                    return (0,
                    r.gn)(this, i, "f") >= e.numberOfFrames
                }
                equals(e) {
                    return (0,
                    r.gn)(this, i, "f") == e.numberOfFrames
                }
                isNegative() {
                    return (0,
                    r.gn)(this, i, "f") < 0
                }
                clone() {
                    const e = new a;
                    return (0,
                    r.GG)(e, i, (0,
                    r.gn)(this, i, "f"), "f"),
                    e
                }
            }
            i = new WeakMap;
            const s = a
        }
        ,
        6738: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".time-bar-ui {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 0;\n\tdisplay: flex;\n\tpadding: 0 var(--safe-area-horizontal);\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tbackground-color: var(--surface-color);\n\topacity: 0.9;\n}\n\n.time-bar-ui > button {\n\tmargin: 6px;\n\tpadding: 4px 12px;\n}\n.time-bar-ui > button:not(:first-of-type) {\n\tmargin-left: 0;\n}\n.time-bar-ui > button:not(:last-of-type) {\n\tmargin-right: 0;\n}\n.time-bar-ui > button > img {\n\tmargin: 0 0 2px 0;\n\tpadding: 0;\n\tvertical-align: middle;\n\twidth: 28px;\n\theight: 28px;\n\tpointer-events: none;\n}\n\n.time-bar-ui > .bar {\n\tposition: relative;\n\tmargin: 6px 6px 6px -8px;\n\tpadding: 0;\n\tflex-grow: 1;\n\theight: 40px;\n\tbackground-color: var(--surface-secondary-color);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttouch-action: none;\n\tpointer-events: auto;\n}\n.time-bar-ui > .bar > div {\n\tposition: relative;\n\twidth: calc(100% - 8px);\n\theight: 100%;\n}\n.time-bar-ui > .bar > div > .unloaded-fill {\n\tposition: absolute;\n\tright: -8px;\n\ttop: 0;\n\tmargin: 0;\n\tpadding: 0;\n\theight: 100%;\n\tbackground-color: rgba(255, 255, 255, 0.1);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\twill-change: width;\n}\n.time-bar-ui > .bar > div > .fill {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tmargin: 0;\n\tpadding: 0;\n\theight: 100%;\n\tbackground-color: #7272c2;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\twill-change: width;\n}\n.time-bar-ui > .bar > div > .dash-container {\n\tpointer-events: none;\n}\n.time-bar-ui > .bar > div > .dash-container > .dash {\n\tposition: absolute;\n\tz-index: 1;\n\tbottom: 0;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 2px;\n\theight: 25%;\n\tbackground-color: rgba(0, 0, 0, 0.25);\n}\n.time-bar-ui > .bar > div > .dash-container > .dash.long {\n\theight: 50%;\n\tbackground-color: rgba(0, 0, 0, 0.35);\n}\n.time-bar-ui > .bar > div > .dash-container > .checkpoint-dash {\n\tposition: absolute;\n\tz-index: 1;\n\tbottom: 0;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: calc(8px + 2px);\n\theight: 100%;\n\tclip-path: polygon(calc(100% - 2px) 0, 100% 0, 2px 100%, 0 100%);\n\tbackground-color: #ffff00;\n}\n", ""]);
            const o = s
        }
        ,
        6830: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".menu-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 45, 0.8);\n\t-webkit-backdrop-filter: blur(4px);\n\tbackdrop-filter: blur(4px);\n\ttext-align: center;\n\ttransition: background-color 1s ease-out;\n}\n.menu-ui.loading-screen {\n\tbackground-color: var(--surface-tertiary-color);\n}\n\n.menu-ui > .logo {\n\tdisplay: block;\n\tmargin: 80px auto 0 auto;\n\tpadding: 0;\n\twidth: 1000px;\n\theight: 200px;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\ttransition: opacity 0.25s ease-out;\n}\n.menu-ui > .logo.hidden {\n\topacity: 0;\n}\n\n@media (max-width: 1300px) {\n\t.menu-ui > .logo {\n\t\twidth: calc(100vw * (1000 / 1300));\n\t}\n}\n@media (max-width: 975px) {\n\t.menu-ui > .logo {\n\t\twidth: calc(975px * (1000 / 1300));\n\t}\n}\n\n.menu-ui > .warning-message {\n\tmargin: 16px auto 0 auto;\n\tmax-width: 900px;\n\tfont-size: 26px;\n\tcolor: #f66;\n}\n.menu-ui > .warning-message > a {\n\tmargin: 0 auto;\n\tdisplay: block;\n\twidth: max-content;\n\tcolor: var(--text-color);\n\tpointer-events: auto;\n}\n\n.menu-ui > .main-buttons-container {\n\tmargin: 0 0 140px 0;\n\tdisplay: flex;\n\tflex-grow: 1;\n\talign-items: center;\n\tjustify-content: center;\n}\n.menu-ui > .main-buttons-container.hidden {\n\tdisplay: none;\n}\n\n.menu-ui .button-image {\n\tdisplay: inline-block;\n\tmargin: 10px 0;\n\tpadding: 0;\n\twidth: 200px;\n\theight: 200px;\n\tpointer-events: auto;\n}\n.menu-ui .button-image > img {\n\tmargin: 40px 40px 0 40px;\n\tpadding: 0;\n\twidth: 96px;\n\theight: 96px;\n\ttransition: transform 0.2s ease-in-out;\n\tpointer-events: none;\n}\n.menu-ui .button-image:not(:disabled):hover > img {\n\ttransform: translateY(-10px);\n}\n@media (hover: none) {\n\t.menu-ui .button-image:not(:disabled):hover > img {\n\t\ttransform: none;\n\t}\n}\n.menu-ui .button-image > p {\n\tmargin: 0;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 24px;\n}\n\n.menu-ui .button-image.button-spawn {\n\tanimation: button-spawn 0.5s ease-out forwards;\n\topacity: 0;\n}\n\n@keyframes button-spawn {\n\t0% {\n\t\ttransform: translateY(50px) scale(0.8);\n\t\topacity: 0;\n\t}\n\t70% {\n\t\ttransform: translateY(-10px) scale(1);\n\t\topacity: 1;\n\t}\n\t100% {\n\t\ttransform: translateY(0) scale(1);\n\t\topacity: 1;\n\t}\n}\n\n.menu-ui > .button-bar {\n\tpadding: 8px calc(8px + var(--safe-area-horizontal));\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\ttext-align: left;\n\tbackground-color: var(--surface-transparent-color);\n}\n.menu-ui > .button-bar.hidden {\n\tdisplay: none;\n}\n\n.menu-ui > .button-bar > button, .menu-ui > .button-bar > a {\n\tdisplay: inline-block;\n\tpadding: 6px 12px;\n\tclip-path: polygon(4px 0, 100% 0, calc(100% - 4px) 100%, 0 100%);\n\tfont-size: 22px;\n\ttext-decoration: none;\n}\n.menu-ui > .button-bar > button.right, .menu-ui > .button-bar > a.right {\n\tfloat: right;\n}\n.menu-ui > .button-bar > button.disabled, .menu-ui > .button-bar > a.disabled {\n\tcolor: rgba(255, 255, 255, 0.25);\n}\n.menu-ui > .button-bar > button > img, .menu-ui > .button-bar > a > img {\n\tvertical-align: middle;\n\twidth: 24px;\n\theight: 24px;\n}\n.menu-ui > .button-bar > button.disabled > img, .menu-ui > .button-bar > a.disabled > img {\n\topacity: 0.25;\n}\n\n.menu-ui > .discord-link {\n\tdisplay: block;\n\tposition: absolute;\n\tright: 0;\n\tbottom: 0;\n\tmargin: 0;\n\tpadding: 0;\n\tpointer-events: auto;\n}\n.menu-ui > .discord-link > img {\n\tmargin: 16px calc(30px + var(--safe-area-right)) 64px 30px;\n\tpadding: 0;\n\theight: 40px;\n\ttransition: opacity 0.25s ease-out;\n}\n.menu-ui > .discord-link > img.hidden {\n\topacity: 0;\n}\n\n.menu-ui > .info {\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 64px;\n\twidth: 100%;\n}\n.menu-ui > .info > a {\n\tdisplay: block;\n\tmargin: 0 auto;\n\tpadding: 5px;\n\twidth: fit-content;\n\tcolor: var(--text-color);\n\ttext-decoration: none;\n\tfont-size: 20px;\n\tpointer-events: auto;\n}\n.menu-ui > .info > a[href]:hover, .menu-ui > .info > a[href]:focus-visible {\n\ttext-decoration: underline;\n\toutline: none;\n}\n", ""]);
            const o = s
        }
        ,
        6838: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/smoke.png"
        }
        ,
        6850: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".speedometer-ui {\n\tdisplay: flex;\n\tflex-direction: column;\n\tposition: absolute;\n\tbottom: 0;\n\tright: var(--safe-area-horizontal);\n}\n\n.speedometer-ui.up {\n\tbottom: auto;\n\ttop: 0;\n\tflex-direction: column-reverse;\n}\n\n.speedometer-ui > .box {\n\tmargin: 0;\n\tpadding: 8px 10px;\n\tmin-width: 140px;\n\tline-height: 0;\n\tfont-size: 40px;\n\tcolor: var(--text-color);\n\ttext-align: right;\n\topacity: 0.9;\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-color);\n}\n.speedometer-ui.up > .box {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\n}\n.speedometer-ui.hidden {\n\tdisplay: none;\n}\n\n#ui.has-safe-area-horizontal .speedometer-ui {\n\tclip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n#ui.has-safe-area-horizontal .speedometer-ui.up {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n\n.speedometer-ui > .box > .container {\n\tmargin: 0;\n\tpadding: 0 0 0 16px;\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\n\tbackground-color: var(--surface-tertiary-color);\n}\n.speedometer-ui.up > .box > .container {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\n}\n\n#ui.has-safe-area-horizontal .speedometer-ui > .box > .container {\n\tpadding-right: 4px;\n\tclip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n#ui.has-safe-area-horizontal .speedometer-ui.up > .box > .container {\n\tpadding-right: 4px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 6px 100%);\n}\n\n.speedometer-ui > .box > .container > span:last-of-type {\n\topacity: 0.5;\n\tmargin: 0 0.3em 0 0.25em;\n\tpadding: 0;\n\tfont-size: 0.5em;\n}\n.speedometer-ui > .box > .container > span > span {\n\tdisplay: inline-block;\n\twidth: 0.5em;\n\ttext-align: center;\n}\n\n.speedometer-ui > .checkpoint-speed {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\ttext-align: center;\n\tfont-size: 26px;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n\topacity: 0;\n}\n.speedometer-ui > .checkpoint-speed.green {\n\tcolor: #5f5;\n}\n.speedometer-ui > .checkpoint-speed.red {\n\tcolor: #f55;\n}\n", ""]);
            const o = s
        }
        ,
        6979: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".multiplayer-ui > .join {\n\tposition: absolute;\n\tleft: calc(50% - 700px / 2);\n\ttop: 40%;\n}\n.multiplayer-ui > .join.hidden {\n\tdisplay: none;\n}\n\n.multiplayer-ui > .join > .main-box {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 700px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.multiplayer-ui > .join > .error-box {\n\tmargin: 10px 0 0 0;\n\tpadding: 20px;\n\twidth: 700px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-secondary-color);\n\tfont-weight: normal;\n\tfont-size: 26px;\n\tcolor: #ff9696;\n\ttransform: translateY(-20px);\n\topacity: 0;\n\ttransition: transform 0.3s ease-in-out 0.3s, opacity 0.3s ease-in-out;\n}\n\n.multiplayer-ui > .join > .error-box.show {\n\ttransform: none;\n\topacity: 1;\n\ttransition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;\n}\n\n.multiplayer-ui > .join > .main-box > h2 {\n\tmargin: 0 0 10px 0;\n\tpadding: 10px 20px;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.multiplayer-ui > .join > .main-box > .invite-code-container {\n\tposition: relative;\n}\n\n.multiplayer-ui > .join > .main-box > .invite-code-container > .invite-code {\n\tmargin: 20px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 2 * 20px);\n\tfont-size: 46px;\n\ttransition: opacity 0.3s ease-in-out;\n}\n\n.multiplayer-ui > .join > .main-box > .invite-code-container > .connecting-text {\n\tdisplay: flex;\n\talign-items: center;\n\tmargin: 24px 26px;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tfont-weight: normal;\n\tfont-size: 46px;\n\ttext-align: center;\n\tcolor: var(--text-color);\n\topacity: 0;\n\ttransition: opacity 0.3s ease-in-out;\n}\n\n.multiplayer-ui > .join > .main-box > .invite-code-container > .connecting-text > .loading-spinner-ui {\n\tmargin-right: 12px;\n}\n\n.multiplayer-ui > .join > .main-box > .invite-code-container.connecting > .invite-code {\n\topacity: 0;\n}\n.multiplayer-ui > .join > .main-box > .invite-code-container.connecting > .connecting-text {\n\topacity: 1;\n}\n\n.multiplayer-ui > .join > .main-box > .buttons {\n\tpadding: 10px;\n\tbackground-color: var(--surface-color);\n}\n\n.multiplayer-ui > .join > .main-box > .buttons > .join {\n\tfloat: right;\n}\n.multiplayer-ui > .join > .main-box > .buttons > .join > .button-icon {\n\tmargin-left: 6px;\n}\n\n.multiplayer-ui > .host {\n\tposition: absolute;\n\tleft: calc(50% - 700px / 2);\n\ttop: calc(40% - 400px / 2);\n}\n.multiplayer-ui > .host.hidden {\n\tdisplay: none;\n}\n\n.multiplayer-ui > .host > .main-box {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 700px;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-secondary-color);\n}\n\n.multiplayer-ui > .host > .main-box > h2 {\n\tmargin: 0 0 10px 0;\n\tpadding: 10px 20px;\n\tfont-weight: normal;\n\tfont-size: 38px;\n\ttext-align: center;\n\tbackground-color: var(--surface-color);\n\tcolor: var(--text-color);\n}\n\n.multiplayer-ui > .host > .main-box > .game-mode-container {\n\tmargin: 10px;\n\tpadding: 20px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 10px * 2);\n\tbackground-color: var(--surface-color);\n}\n\n.multiplayer-ui > .host > .main-box > .game-mode-container > .title {\n\tmargin: 0 0 6px 0;\n\tpadding: 0;\n\tfont-size: 26px;\n\tcolor: var(--text-color);\n}\n\n.multiplayer-ui > .host > .main-box > .game-mode-container > .button:first-of-type {\n\tmargin: 0 0 0 -5px;\n}\n.multiplayer-ui > .host > .main-box > .game-mode-container > .button.selected {\n\tbackground-color: var(--button-hover-color);\n}\n\n.multiplayer-ui > .host > .main-box > .game-mode-container > .info {\n\tmargin: 10px 0 0 0;\n\tpadding: 0;\n\tfont-size: 20px;\n\tcolor: var(--text-color);\n}\n\n.multiplayer-ui > .host > .main-box > .maximum-players-container {\n\tmargin: 10px;\n\tpadding: 20px;\n\tbox-sizing: border-box;\n\twidth: calc(100% - 10px * 2);\n\tbackground-color: var(--surface-color);\n}\n\n.multiplayer-ui > .host > .main-box > .maximum-players-container > .maximum-players-info {\n\tmargin: 0;\n\tpadding: 0;\n\tfont-size: 26px;\n\tcolor: var(--text-color);\n}\n\n.multiplayer-ui > .host > .main-box > .maximum-players-container > .maximum-players {\n\tpadding: 20px 0 0 0;\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tpointer-events: auto;\n}\n\n.multiplayer-ui > .host > .main-box > .track-button {\n\tdisplay: flex;\n\tmargin: 10px;\n\tpadding: 0;\n\tvertical-align: top;\n\twidth: calc(100% - 10px * 2);\n\theight: 100px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\ttext-align: left;\n\twhite-space: nowrap;\n}\n\n.multiplayer-ui > .host > .main-box > .track-button > .thumbnail {\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\twidth: 100px;\n\theight: 100px;\n\tbackground-color: rgba(0, 0, 0, 0.1);\n\tobject-fit: contain;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\timage-rendering: pixelated;\n}\n\n.multiplayer-ui > .host > .main-box > .track-button > .name {\n\tmargin: 0;\n\tpadding: 12px;\n\tfont-size: 28px;\n\tcolor: var(--text-color);\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n.multiplayer-ui > .host > .main-box > .track-button > .name.placeholder {\n\topacity: 0.5;\n}\n\n.multiplayer-ui > .host > .main-box > .buttons {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\tpadding: 10px;\n\tbackground-color: var(--surface-color);\n}\n", ""]);
            const o = s
        }
        ,
        7024: (e, t, n) => {
            "use strict";
            n.d(t, {
                N: () => b
            });
            var i = n(4922);
            const r = {
                type: "change"
            }
              , a = {
                type: "start"
            }
              , s = {
                type: "end"
            }
              , o = new i.RlV
              , l = new i.Zcv
              , c = Math.cos(70 * i.cj9.DEG2RAD)
              , h = new i.Pq0
              , d = 2 * Math.PI
              , u = -1
              , p = 0
              , f = 1
              , g = 2
              , m = 3
              , A = 4
              , v = 5
              , y = 6
              , w = 1e-6;
            class b extends i.H2z {
                constructor(e, t=null) {
                    super(e, t),
                    this.state = u,
                    this.target = new i.Pq0,
                    this.cursor = new i.Pq0,
                    this.minDistance = 0,
                    this.maxDistance = 1 / 0,
                    this.minZoom = 0,
                    this.maxZoom = 1 / 0,
                    this.minTargetRadius = 0,
                    this.maxTargetRadius = 1 / 0,
                    this.minPolarAngle = 0,
                    this.maxPolarAngle = Math.PI,
                    this.minAzimuthAngle = -1 / 0,
                    this.maxAzimuthAngle = 1 / 0,
                    this.enableDamping = !1,
                    this.dampingFactor = .05,
                    this.enableZoom = !0,
                    this.zoomSpeed = 1,
                    this.enableRotate = !0,
                    this.rotateSpeed = 1,
                    this.keyRotateSpeed = 1,
                    this.enablePan = !0,
                    this.panSpeed = 1,
                    this.screenSpacePanning = !0,
                    this.keyPanSpeed = 7,
                    this.zoomToCursor = !1,
                    this.autoRotate = !1,
                    this.autoRotateSpeed = 2,
                    this.keys = {
                        LEFT: "ArrowLeft",
                        UP: "ArrowUp",
                        RIGHT: "ArrowRight",
                        BOTTOM: "ArrowDown"
                    },
                    this.mouseButtons = {
                        LEFT: i.kBv.ROTATE,
                        MIDDLE: i.kBv.DOLLY,
                        RIGHT: i.kBv.PAN
                    },
                    this.touches = {
                        ONE: i.wtR.ROTATE,
                        TWO: i.wtR.DOLLY_PAN
                    },
                    this.target0 = this.target.clone(),
                    this.position0 = this.object.position.clone(),
                    this.zoom0 = this.object.zoom,
                    this._domElementKeyEvents = null,
                    this._lastPosition = new i.Pq0,
                    this._lastQuaternion = new i.PTz,
                    this._lastTargetPosition = new i.Pq0,
                    this._quat = (new i.PTz).setFromUnitVectors(e.up, new i.Pq0(0,1,0)),
                    this._quatInverse = this._quat.clone().invert(),
                    this._spherical = new i.YHV,
                    this._sphericalDelta = new i.YHV,
                    this._scale = 1,
                    this._panOffset = new i.Pq0,
                    this._rotateStart = new i.I9Y,
                    this._rotateEnd = new i.I9Y,
                    this._rotateDelta = new i.I9Y,
                    this._panStart = new i.I9Y,
                    this._panEnd = new i.I9Y,
                    this._panDelta = new i.I9Y,
                    this._dollyStart = new i.I9Y,
                    this._dollyEnd = new i.I9Y,
                    this._dollyDelta = new i.I9Y,
                    this._dollyDirection = new i.Pq0,
                    this._mouse = new i.I9Y,
                    this._performCursorZoom = !1,
                    this._pointers = [],
                    this._pointerPositions = {},
                    this._controlActive = !1,
                    this._onPointerMove = S.bind(this),
                    this._onPointerDown = x.bind(this),
                    this._onPointerUp = E.bind(this),
                    this._onContextMenu = P.bind(this),
                    this._onMouseWheel = M.bind(this),
                    this._onKeyDown = _.bind(this),
                    this._onTouchStart = C.bind(this),
                    this._onTouchMove = R.bind(this),
                    this._onMouseDown = T.bind(this),
                    this._onMouseMove = k.bind(this),
                    this._interceptControlDown = I.bind(this),
                    this._interceptControlUp = L.bind(this),
                    null !== this.domElement && this.connect(this.domElement),
                    this.update()
                }
                connect(e) {
                    super.connect(e),
                    this.domElement.addEventListener("pointerdown", this._onPointerDown),
                    this.domElement.addEventListener("pointercancel", this._onPointerUp),
                    this.domElement.addEventListener("contextmenu", this._onContextMenu),
                    this.domElement.addEventListener("wheel", this._onMouseWheel, {
                        passive: !1
                    });
                    this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
                        passive: !0,
                        capture: !0
                    }),
                    this.domElement.style.touchAction = "none"
                }
                disconnect() {
                    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
                    this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove),
                    this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp),
                    this.domElement.removeEventListener("pointercancel", this._onPointerUp),
                    this.domElement.removeEventListener("wheel", this._onMouseWheel),
                    this.domElement.removeEventListener("contextmenu", this._onContextMenu),
                    this.stopListenToKeyEvents();
                    this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
                        capture: !0
                    }),
                    this.domElement.style.touchAction = "auto"
                }
                dispose() {
                    this.disconnect()
                }
                getPolarAngle() {
                    return this._spherical.phi
                }
                getAzimuthalAngle() {
                    return this._spherical.theta
                }
                getDistance() {
                    return this.object.position.distanceTo(this.target)
                }
                listenToKeyEvents(e) {
                    e.addEventListener("keydown", this._onKeyDown),
                    this._domElementKeyEvents = e
                }
                stopListenToKeyEvents() {
                    null !== this._domElementKeyEvents && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown),
                    this._domElementKeyEvents = null)
                }
                saveState() {
                    this.target0.copy(this.target),
                    this.position0.copy(this.object.position),
                    this.zoom0 = this.object.zoom
                }
                reset() {
                    this.target.copy(this.target0),
                    this.object.position.copy(this.position0),
                    this.object.zoom = this.zoom0,
                    this.object.updateProjectionMatrix(),
                    this.dispatchEvent(r),
                    this.update(),
                    this.state = u
                }
                update(e=null) {
                    const t = this.object.position;
                    h.copy(t).sub(this.target),
                    h.applyQuaternion(this._quat),
                    this._spherical.setFromVector3(h),
                    this.autoRotate && this.state === u && this._rotateLeft(this._getAutoRotationAngle(e)),
                    this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor,
                    this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta,
                    this._spherical.phi += this._sphericalDelta.phi);
                    let n = this.minAzimuthAngle
                      , a = this.maxAzimuthAngle;
                    isFinite(n) && isFinite(a) && (n < -Math.PI ? n += d : n > Math.PI && (n -= d),
                    a < -Math.PI ? a += d : a > Math.PI && (a -= d),
                    this._spherical.theta = n <= a ? Math.max(n, Math.min(a, this._spherical.theta)) : this._spherical.theta > (n + a) / 2 ? Math.max(n, this._spherical.theta) : Math.min(a, this._spherical.theta)),
                    this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)),
                    this._spherical.makeSafe(),
                    !0 === this.enableDamping ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset),
                    this.target.sub(this.cursor),
                    this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
                    this.target.add(this.cursor);
                    let s = !1;
                    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
                        this._spherical.radius = this._clampDistance(this._spherical.radius);
                    else {
                        const e = this._spherical.radius;
                        this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale),
                        s = e != this._spherical.radius
                    }
                    if (h.setFromSpherical(this._spherical),
                    h.applyQuaternion(this._quatInverse),
                    t.copy(this.target).add(h),
                    this.object.lookAt(this.target),
                    !0 === this.enableDamping ? (this._sphericalDelta.theta *= 1 - this.dampingFactor,
                    this._sphericalDelta.phi *= 1 - this.dampingFactor,
                    this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0),
                    this._panOffset.set(0, 0, 0)),
                    this.zoomToCursor && this._performCursorZoom) {
                        let e = null;
                        if (this.object.isPerspectiveCamera) {
                            const t = h.length();
                            e = this._clampDistance(t * this._scale);
                            const n = t - e;
                            this.object.position.addScaledVector(this._dollyDirection, n),
                            this.object.updateMatrixWorld(),
                            s = !!n
                        } else if (this.object.isOrthographicCamera) {
                            const t = new i.Pq0(this._mouse.x,this._mouse.y,0);
                            t.unproject(this.object);
                            const n = this.object.zoom;
                            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
                            this.object.updateProjectionMatrix(),
                            s = n !== this.object.zoom;
                            const r = new i.Pq0(this._mouse.x,this._mouse.y,0);
                            r.unproject(this.object),
                            this.object.position.sub(r).add(t),
                            this.object.updateMatrixWorld(),
                            e = h.length()
                        } else
                            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                            this.zoomToCursor = !1;
                        null !== e && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(e).add(this.object.position) : (o.origin.copy(this.object.position),
                        o.direction.set(0, 0, -1).transformDirection(this.object.matrix),
                        Math.abs(this.object.up.dot(o.direction)) < c ? this.object.lookAt(this.target) : (l.setFromNormalAndCoplanarPoint(this.object.up, this.target),
                        o.intersectPlane(l, this.target))))
                    } else if (this.object.isOrthographicCamera) {
                        const e = this.object.zoom;
                        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
                        e !== this.object.zoom && (this.object.updateProjectionMatrix(),
                        s = !0)
                    }
                    return this._scale = 1,
                    this._performCursorZoom = !1,
                    !!(s || this._lastPosition.distanceToSquared(this.object.position) > w || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > w || this._lastTargetPosition.distanceToSquared(this.target) > w) && (this.dispatchEvent(r),
                    this._lastPosition.copy(this.object.position),
                    this._lastQuaternion.copy(this.object.quaternion),
                    this._lastTargetPosition.copy(this.target),
                    !0)
                }
                _getAutoRotationAngle(e) {
                    return null !== e ? d / 60 * this.autoRotateSpeed * e : d / 60 / 60 * this.autoRotateSpeed
                }
                _getZoomScale(e) {
                    const t = Math.abs(.01 * e);
                    return Math.pow(.95, this.zoomSpeed * t)
                }
                _rotateLeft(e) {
                    this._sphericalDelta.theta -= e
                }
                _rotateUp(e) {
                    this._sphericalDelta.phi -= e
                }
                _panLeft(e, t) {
                    h.setFromMatrixColumn(t, 0),
                    h.multiplyScalar(-e),
                    this._panOffset.add(h)
                }
                _panUp(e, t) {
                    !0 === this.screenSpacePanning ? h.setFromMatrixColumn(t, 1) : (h.setFromMatrixColumn(t, 0),
                    h.crossVectors(this.object.up, h)),
                    h.multiplyScalar(e),
                    this._panOffset.add(h)
                }
                _pan(e, t) {
                    const n = this.domElement;
                    if (this.object.isPerspectiveCamera) {
                        const i = this.object.position;
                        h.copy(i).sub(this.target);
                        let r = h.length();
                        r *= Math.tan(this.object.fov / 2 * Math.PI / 180),
                        this._panLeft(2 * e * r / n.clientHeight, this.object.matrix),
                        this._panUp(2 * t * r / n.clientHeight, this.object.matrix)
                    } else
                        this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix),
                        this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                        this.enablePan = !1)
                }
                _dollyOut(e) {
                    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    this.enableZoom = !1)
                }
                _dollyIn(e) {
                    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
                    this.enableZoom = !1)
                }
                _updateZoomParameters(e, t) {
                    if (!this.zoomToCursor)
                        return;
                    this._performCursorZoom = !0;
                    const n = this.domElement.getBoundingClientRect()
                      , i = e - n.left
                      , r = t - n.top
                      , a = n.width
                      , s = n.height;
                    this._mouse.x = i / a * 2 - 1,
                    this._mouse.y = -r / s * 2 + 1,
                    this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize()
                }
                _clampDistance(e) {
                    return Math.max(this.minDistance, Math.min(this.maxDistance, e))
                }
                _handleMouseDownRotate(e) {
                    this._rotateStart.set(e.clientX, e.clientY)
                }
                _handleMouseDownDolly(e) {
                    this._updateZoomParameters(e.clientX, e.clientX),
                    this._dollyStart.set(e.clientX, e.clientY)
                }
                _handleMouseDownPan(e) {
                    this._panStart.set(e.clientX, e.clientY)
                }
                _handleMouseMoveRotate(e) {
                    this._rotateEnd.set(e.clientX, e.clientY),
                    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
                    const t = this.domElement;
                    this._rotateLeft(d * this._rotateDelta.x / t.clientHeight),
                    this._rotateUp(d * this._rotateDelta.y / t.clientHeight),
                    this._rotateStart.copy(this._rotateEnd),
                    this.update()
                }
                _handleMouseMoveDolly(e) {
                    this._dollyEnd.set(e.clientX, e.clientY),
                    this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
                    this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
                    this._dollyStart.copy(this._dollyEnd),
                    this.update()
                }
                _handleMouseMovePan(e) {
                    this._panEnd.set(e.clientX, e.clientY),
                    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
                    this._pan(this._panDelta.x, this._panDelta.y),
                    this._panStart.copy(this._panEnd),
                    this.update()
                }
                _handleMouseWheel(e) {
                    this._updateZoomParameters(e.clientX, e.clientY),
                    e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
                    this.update()
                }
                _handleKeyDown(e) {
                    let t = !1;
                    switch (e.code) {
                    case this.keys.UP:
                        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(d * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed),
                        t = !0;
                        break;
                    case this.keys.BOTTOM:
                        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-d * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed),
                        t = !0;
                        break;
                    case this.keys.LEFT:
                        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(d * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0),
                        t = !0;
                        break;
                    case this.keys.RIGHT:
                        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-d * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0),
                        t = !0
                    }
                    t && (e.preventDefault(),
                    this.update())
                }
                _handleTouchStartRotate(e) {
                    if (1 === this._pointers.length)
                        this._rotateStart.set(e.pageX, e.pageY);
                    else {
                        const t = this._getSecondPointerPosition(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        this._rotateStart.set(n, i)
                    }
                }
                _handleTouchStartPan(e) {
                    if (1 === this._pointers.length)
                        this._panStart.set(e.pageX, e.pageY);
                    else {
                        const t = this._getSecondPointerPosition(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        this._panStart.set(n, i)
                    }
                }
                _handleTouchStartDolly(e) {
                    const t = this._getSecondPointerPosition(e)
                      , n = e.pageX - t.x
                      , i = e.pageY - t.y
                      , r = Math.sqrt(n * n + i * i);
                    this._dollyStart.set(0, r)
                }
                _handleTouchStartDollyPan(e) {
                    this.enableZoom && this._handleTouchStartDolly(e),
                    this.enablePan && this._handleTouchStartPan(e)
                }
                _handleTouchStartDollyRotate(e) {
                    this.enableZoom && this._handleTouchStartDolly(e),
                    this.enableRotate && this._handleTouchStartRotate(e)
                }
                _handleTouchMoveRotate(e) {
                    if (1 == this._pointers.length)
                        this._rotateEnd.set(e.pageX, e.pageY);
                    else {
                        const t = this._getSecondPointerPosition(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        this._rotateEnd.set(n, i)
                    }
                    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
                    const t = this.domElement;
                    this._rotateLeft(d * this._rotateDelta.x / t.clientHeight),
                    this._rotateUp(d * this._rotateDelta.y / t.clientHeight),
                    this._rotateStart.copy(this._rotateEnd)
                }
                _handleTouchMovePan(e) {
                    if (1 === this._pointers.length)
                        this._panEnd.set(e.pageX, e.pageY);
                    else {
                        const t = this._getSecondPointerPosition(e)
                          , n = .5 * (e.pageX + t.x)
                          , i = .5 * (e.pageY + t.y);
                        this._panEnd.set(n, i)
                    }
                    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
                    this._pan(this._panDelta.x, this._panDelta.y),
                    this._panStart.copy(this._panEnd)
                }
                _handleTouchMoveDolly(e) {
                    const t = this._getSecondPointerPosition(e)
                      , n = e.pageX - t.x
                      , i = e.pageY - t.y
                      , r = Math.sqrt(n * n + i * i);
                    this._dollyEnd.set(0, r),
                    this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)),
                    this._dollyOut(this._dollyDelta.y),
                    this._dollyStart.copy(this._dollyEnd);
                    const a = .5 * (e.pageX + t.x)
                      , s = .5 * (e.pageY + t.y);
                    this._updateZoomParameters(a, s)
                }
                _handleTouchMoveDollyPan(e) {
                    this.enableZoom && this._handleTouchMoveDolly(e),
                    this.enablePan && this._handleTouchMovePan(e)
                }
                _handleTouchMoveDollyRotate(e) {
                    this.enableZoom && this._handleTouchMoveDolly(e),
                    this.enableRotate && this._handleTouchMoveRotate(e)
                }
                _addPointer(e) {
                    this._pointers.push(e.pointerId)
                }
                _removePointer(e) {
                    delete this._pointerPositions[e.pointerId];
                    for (let t = 0; t < this._pointers.length; t++)
                        if (this._pointers[t] == e.pointerId)
                            return void this._pointers.splice(t, 1)
                }
                _isTrackingPointer(e) {
                    for (let t = 0; t < this._pointers.length; t++)
                        if (this._pointers[t] == e.pointerId)
                            return !0;
                    return !1
                }
                _trackPointer(e) {
                    let t = this._pointerPositions[e.pointerId];
                    void 0 === t && (t = new i.I9Y,
                    this._pointerPositions[e.pointerId] = t),
                    t.set(e.pageX, e.pageY)
                }
                _getSecondPointerPosition(e) {
                    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
                    return this._pointerPositions[t]
                }
                _customWheelEvent(e) {
                    const t = e.deltaMode
                      , n = {
                        clientX: e.clientX,
                        clientY: e.clientY,
                        deltaY: e.deltaY
                    };
                    switch (t) {
                    case 1:
                        n.deltaY *= 16;
                        break;
                    case 2:
                        n.deltaY *= 100
                    }
                    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10),
                    n
                }
            }
            function x(e) {
                !1 !== this.enabled && (0 === this._pointers.length && (this.domElement.setPointerCapture(e.pointerId),
                this.domElement.ownerDocument.addEventListener("pointermove", this._onPointerMove),
                this.domElement.ownerDocument.addEventListener("pointerup", this._onPointerUp)),
                this._isTrackingPointer(e) || (this._addPointer(e),
                "touch" === e.pointerType ? this._onTouchStart(e) : this._onMouseDown(e)))
            }
            function S(e) {
                !1 !== this.enabled && ("touch" === e.pointerType ? this._onTouchMove(e) : this._onMouseMove(e))
            }
            function E(e) {
                switch (this._removePointer(e),
                this._pointers.length) {
                case 0:
                    this.domElement.releasePointerCapture(e.pointerId),
                    this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove),
                    this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp),
                    this.dispatchEvent(s),
                    this.state = u;
                    break;
                case 1:
                    const t = this._pointers[0]
                      , n = this._pointerPositions[t];
                    this._onTouchStart({
                        pointerId: t,
                        pageX: n.x,
                        pageY: n.y
                    })
                }
            }
            function T(e) {
                let t;
                switch (e.button) {
                case 0:
                    t = this.mouseButtons.LEFT;
                    break;
                case 1:
                    t = this.mouseButtons.MIDDLE;
                    break;
                case 2:
                    t = this.mouseButtons.RIGHT;
                    break;
                default:
                    t = -1
                }
                switch (t) {
                case i.kBv.DOLLY:
                    if (!1 === this.enableZoom)
                        return;
                    this._handleMouseDownDolly(e),
                    this.state = f;
                    break;
                case i.kBv.ROTATE:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === this.enablePan)
                            return;
                        this._handleMouseDownPan(e),
                        this.state = g
                    } else {
                        if (!1 === this.enableRotate)
                            return;
                        this._handleMouseDownRotate(e),
                        this.state = p
                    }
                    break;
                case i.kBv.PAN:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === this.enableRotate)
                            return;
                        this._handleMouseDownRotate(e),
                        this.state = p
                    } else {
                        if (!1 === this.enablePan)
                            return;
                        this._handleMouseDownPan(e),
                        this.state = g
                    }
                    break;
                default:
                    this.state = u
                }
                this.state !== u && this.dispatchEvent(a)
            }
            function k(e) {
                switch (this.state) {
                case p:
                    if (!1 === this.enableRotate)
                        return;
                    this._handleMouseMoveRotate(e);
                    break;
                case f:
                    if (!1 === this.enableZoom)
                        return;
                    this._handleMouseMoveDolly(e);
                    break;
                case g:
                    if (!1 === this.enablePan)
                        return;
                    this._handleMouseMovePan(e)
                }
            }
            function M(e) {
                !1 !== this.enabled && !1 !== this.enableZoom && this.state === u && (e.preventDefault(),
                this.dispatchEvent(a),
                this._handleMouseWheel(this._customWheelEvent(e)),
                this.dispatchEvent(s))
            }
            function _(e) {
                !1 !== this.enabled && this._handleKeyDown(e)
            }
            function C(e) {
                switch (this._trackPointer(e),
                this._pointers.length) {
                case 1:
                    switch (this.touches.ONE) {
                    case i.wtR.ROTATE:
                        if (!1 === this.enableRotate)
                            return;
                        this._handleTouchStartRotate(e),
                        this.state = m;
                        break;
                    case i.wtR.PAN:
                        if (!1 === this.enablePan)
                            return;
                        this._handleTouchStartPan(e),
                        this.state = A;
                        break;
                    default:
                        this.state = u
                    }
                    break;
                case 2:
                    switch (this.touches.TWO) {
                    case i.wtR.DOLLY_PAN:
                        if (!1 === this.enableZoom && !1 === this.enablePan)
                            return;
                        this._handleTouchStartDollyPan(e),
                        this.state = v;
                        break;
                    case i.wtR.DOLLY_ROTATE:
                        if (!1 === this.enableZoom && !1 === this.enableRotate)
                            return;
                        this._handleTouchStartDollyRotate(e),
                        this.state = y;
                        break;
                    default:
                        this.state = u
                    }
                    break;
                default:
                    this.state = u
                }
                this.state !== u && this.dispatchEvent(a)
            }
            function R(e) {
                switch (this._trackPointer(e),
                this.state) {
                case m:
                    if (!1 === this.enableRotate)
                        return;
                    this._handleTouchMoveRotate(e),
                    this.update();
                    break;
                case A:
                    if (!1 === this.enablePan)
                        return;
                    this._handleTouchMovePan(e),
                    this.update();
                    break;
                case v:
                    if (!1 === this.enableZoom && !1 === this.enablePan)
                        return;
                    this._handleTouchMoveDollyPan(e),
                    this.update();
                    break;
                case y:
                    if (!1 === this.enableZoom && !1 === this.enableRotate)
                        return;
                    this._handleTouchMoveDollyRotate(e),
                    this.update();
                    break;
                default:
                    this.state = u
                }
            }
            function P(e) {
                !1 !== this.enabled && e.preventDefault()
            }
            function I(e) {
                if ("Control" === e.key) {
                    this._controlActive = !0;
                    this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
                        passive: !0,
                        capture: !0
                    })
                }
            }
            function L(e) {
                if ("Control" === e.key) {
                    this._controlActive = !1;
                    this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
                        passive: !0,
                        capture: !0
                    })
                }
            }
        }
        ,
        7129: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i, r = n(1635), a = n(5735);
            class s {
                constructor(e) {
                    i.set(this, void 0);
                    const t = [];
                    for (const [n,i,r] of e)
                        t.push([n, i, r]);
                    (0,
                    r.GG)(this, i, t, "f")
                }
                rotated(e, t) {
                    return new s((0,
                    r.gn)(this, i, "f").map(( ([n,i,r]) => a.sR(n, i, r, e, t))))
                }
                forEach(e) {
                    for (let t = 0; t < (0,
                    r.gn)(this, i, "f").length; t++) {
                        const [n,a,s] = (0,
                        r.gn)(this, i, "f")[t];
                        e(n, a, s, t)
                    }
                }
                some(e) {
                    for (let t = 0; t < (0,
                    r.gn)(this, i, "f").length; t++) {
                        const [n,a,s] = (0,
                        r.gn)(this, i, "f")[t];
                        if (e(n, a, s, t))
                            return !0
                    }
                    return !1
                }
                get length() {
                    return (0,
                    r.gn)(this, i, "f").length
                }
            }
            i = new WeakMap;
            const o = s
        }
        ,
        7173: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/windowed.svg"
        }
        ,
        7213: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/music_off.svg"
        }
        ,
        7268: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/trophy.svg"
        }
        ,
        7404: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/car_thumbnail_placeholder.png"
        }
        ,
        7415: (e, t, n) => {
            "use strict";
            n.d(t, {
                D: () => o,
                l: () => s
            });
            const i = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
              , r = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]
              , a = 30;
            function s(e) {
                let t = 0
                  , n = "";
                for (; t < 8 * e.length; ) {
                    const r = l(e, t);
                    let s;
                    (r & a) == a ? (s = 31 & r,
                    t += 5) : (s = r,
                    t += 6),
                    n += i[s]
                }
                return n
            }
            function o(e) {
                let t = 0;
                const n = []
                  , i = e.length;
                for (let s = 0; s < i; s++) {
                    const o = e.charCodeAt(s);
                    if (o >= r.length)
                        return null;
                    const l = r[o];
                    if (-1 == l)
                        return null;
                    (l & a) == a ? (c(n, t, 5, l, s == i - 1),
                    t += 5) : (c(n, t, 6, l, s == i - 1),
                    t += 6)
                }
                return new Uint8Array(n)
            }
            function l(e, t) {
                if (t >= 8 * e.length)
                    throw new Error("Out of range");
                const n = Math.floor(t / 8)
                  , i = e[n]
                  , r = t - 8 * n;
                if (r <= 2 || n >= e.length - 1)
                    return (i & 63 << r) >>> r;
                return (i & 63 << r) >>> r | (e[n + 1] & 63 >>> 8 - r) << 8 - r
            }
            function c(e, t, n, i, r) {
                const a = Math.floor(t / 8);
                for (; a >= e.length; )
                    e.push(0);
                const s = t - 8 * a;
                if (e[a] |= i << s & 255,
                s > 8 - n && !r) {
                    const t = a + 1;
                    t >= e.length && e.push(0),
                    e[t] |= i >> 8 - s
                }
            }
        }
        ,
        7498: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_arrow.svg"
        }
        ,
        7581: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/fullscreen.svg"
        }
        ,
        7659: e => {
            "use strict";
            var t = {};
            e.exports = function(e, n) {
                var i = function(e) {
                    if (void 0 === t[e]) {
                        var n = document.querySelector(e);
                        if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement)
                            try {
                                n = n.contentDocument.head
                            } catch (e) {
                                n = null
                            }
                        t[e] = n
                    }
                    return t[e]
                }(e);
                if (!i)
                    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                i.appendChild(n)
            }
        }
        ,
        7680: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i, r = n(1635), a = n(4922);
            class s {
                constructor(e=28) {
                    if (i.set(this, void 0),
                    !(Number.isSafeInteger(e) && e >= 0 && e < 180))
                        throw new Error("Representation is not a safe integer or is out of range");
                    (0,
                    r.GG)(this, i, e, "f")
                }
                clone() {
                    return new s((0,
                    r.gn)(this, i, "f"))
                }
                toDegrees() {
                    return 2 * (0,
                    r.gn)(this, i, "f")
                }
                static fromDegrees(e) {
                    const t = Math.round(e / 2 % 180);
                    return new s(t)
                }
                getSunPosition() {
                    const e = 2 * (0,
                    r.gn)(this, i, "f") * (Math.PI / 180)
                      , t = Math.cos(e)
                      , n = Math.sin(e);
                    return new a.Pq0(t,.78,n).normalize()
                }
                get representation() {
                    return (0,
                    r.gn)(this, i, "f")
                }
            }
            i = new WeakMap;
            const o = s
        }
        ,
        7687: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".track-export-ui > .background {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tpointer-events: auto;\n}\n\n.track-export-ui > .box {\n\tposition: absolute;\n\tleft: calc(50% - 80% / 2);\n\ttop: 0;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\twidth: 80%;\n\theight: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.track-export-ui > .box > .bar {\n\ttext-align: left;\n\tpointer-events: auto;\n}\n.track-export-ui > .box > .bar > .button.right {\n\tfloat: right;\n}\n\n.track-export-ui > .box > textarea {\n\tmargin: 10px 0 0 0;\n\tpadding: 10px;\n\tbox-sizing: border-box;\n\tmin-width: 100%;\n\tmax-width: 100%;\n\tmin-height: calc(100% - 52px - 10px);\n\tmax-height: calc(100% - 52px - 10px);\n\tpointer-events: auto;\n\tbackground-color: var(--surface-tertiary-color);\n\tborder: none;\n\tresize: none;\n\tcolor: var(--text-color);\n\tword-break: break-all;\n\tfont-size: 20px;\n}\n.track-export-ui > .box > textarea:focus-visible {\n\toutline: none;\n}\n", ""]);
            const o = s
        }
        ,
        7727: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_outline.svg"
        }
        ,
        7780: (e, t, n) => {
            var i = {
                "./apply.svg": 6366,
                "./arrow_down.svg": 516,
                "./arrow_left.svg": 6099,
                "./arrow_right.svg": 6150,
                "./arrow_up.svg": 2207,
                "./back.svg": 8787,
                "./blank_flag.svg": 6557,
                "./cancel.svg": 1784,
                "./car_thumbnail_placeholder.png": 7404,
                "./checkmark.svg": 9809,
                "./checkpoint.svg": 5148,
                "./clouds.jpg": 8875,
                "./community_tracks.jpg": 8115,
                "./copy.svg": 1925,
                "./custom_tracks.jpg": 2709,
                "./customize.svg": 9027,
                "./cut.svg": 6278,
                "./delete.svg": 2319,
                "./desert.svg": 1705,
                "./desert_colored.svg": 1758,
                "./discord.svg": 858,
                "./editor.svg": 8889,
                "./empty.svg": 493,
                "./erase.svg": 1936,
                "./exhaust.svg": 820,
                "./export.svg": 6168,
                "./fullscreen.svg": 7581,
                "./gavel.svg": 8879,
                "./graph.svg": 8734,
                "./grid_large.svg": 3518,
                "./grid_small.svg": 4930,
                "./helmet.svg": 1333,
                "./help.svg": 5031,
                "./icon.svg": 853,
                "./import.svg": 9077,
                "./invite.svg": 5577,
                "./list.svg": 5794,
                "./load.svg": 5918,
                "./logo.svg": 8903,
                "./multiplayer.svg": 2646,
                "./music_off.svg": 7213,
                "./music_on.svg": 5945,
                "./official_tracks.jpg": 9391,
                "./overlapping_disabled.svg": 8358,
                "./overlapping_enabled.svg": 2493,
                "./paint.svg": 8658,
                "./paper.svg": 1820,
                "./paste.svg": 4055,
                "./pattern.svg": 560,
                "./pattern_arrow.svg": 7498,
                "./pattern_circle.svg": 5051,
                "./pattern_circles.svg": 8578,
                "./pattern_diamonds.svg": 228,
                "./pattern_double_stripe.svg": 3844,
                "./pattern_edge.svg": 4644,
                "./pattern_gradient.svg": 5143,
                "./pattern_half.svg": 2588,
                "./pattern_horseshoe.svg": 1411,
                "./pattern_needle.svg": 5974,
                "./pattern_outline.svg": 7727,
                "./pattern_stripe.svg": 4724,
                "./pattern_stripe2.svg": 798,
                "./pattern_stripe3.svg": 3375,
                "./pattern_triangle.svg": 7943,
                "./pattern_zigzag.svg": 6471,
                "./pause.svg": 9708,
                "./pending.svg": 3223,
                "./pin.svg": 6027,
                "./play.svg": 9236,
                "./preview.svg": 9570,
                "./quit.svg": 5739,
                "./random.svg": 2175,
                "./redo.svg": 4942,
                "./refresh.svg": 5499,
                "./reset.svg": 1719,
                "./reset_settings.svg": 4593,
                "./rims.svg": 8825,
                "./rotate.svg": 4563,
                "./rotation_axis_x_negative.svg": 5001,
                "./rotation_axis_x_positive.svg": 77,
                "./rotation_axis_y_negative.svg": 5798,
                "./rotation_axis_y_positive.svg": 9062,
                "./rotation_axis_z_negative.svg": 3895,
                "./rotation_axis_z_positive.svg": 4411,
                "./save.svg": 4309,
                "./search.svg": 8718,
                "./settings.svg": 8237,
                "./share.svg": 3755,
                "./smoke.png": 6838,
                "./state_invalid.svg": 2553,
                "./state_pending.svg": 5769,
                "./state_verified.svg": 6244,
                "./step_back.svg": 542,
                "./step_forward.svg": 1014,
                "./summer.svg": 3901,
                "./test.svg": 1734,
                "./timer.svg": 3849,
                "./trophy.svg": 7268,
                "./undo.svg": 3144,
                "./verified.svg": 3902,
                "./video.svg": 8635,
                "./windowed.svg": 7173,
                "./winter.svg": 813,
                "./winter_colored.svg": 5010
            };
            function r(e) {
                var t = a(e);
                return n(t)
            }
            function a(e) {
                if (!n.o(i, e)) {
                    var t = new Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND",
                    t
                }
                return i[e]
            }
            r.keys = function() {
                return Object.keys(i)
            }
            ,
            r.resolve = a,
            e.exports = r,
            r.id = 7780
        }
        ,
        7818: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".message-box-ui {\n\tmargin: 0;\n\tpadding: 0;\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\tmax-width: unset;\n\tmax-height: unset;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(20, 20, 30, 0.5);\n\tborder: none;\n\tpointer-events: auto;\n}\n\n.message-box-ui::backdrop {\n\tbackground-color: transparent;\n}\n\n.message-box-ui > div {\n\tposition: absolute;\n\tleft: calc(50% - 500px / 2);\n\ttop: 30%;\n\tz-index: 2;\n\tmargin: 0;\n\tpadding: 10px;\n\twidth: 500px;\n\tbox-sizing: border-box;\n\tborder: none;\n\tbackground-color: var(--surface-color);\n\toutline: none;\n\ttext-align: center;\n}\n\n.message-box-ui > div > p {\n\tmargin: 0 0 10px 0;\n\tpadding: 10px;\n\tbackground-color: var(--surface-secondary-color);\n\tmin-height: 50px;\n\tline-height: 0.9;\n\tfont-size: 32px;\n\toverflow-wrap: break-word;\n\twhite-space: pre-wrap;\n\tcolor: var(--text-color);\n}\n\n.message-box-ui > div > button {\n\tmin-width: 140px;\n}\n\n.message-box-ui.message > div > button:first-of-type {\n\tdisplay: none;\n}\n\n.message-box-ui.confirm > div > button:first-of-type {\n\tfloat: left;\n}\n.message-box-ui.confirm > div > button:last-of-type {\n\tfloat: right;\n}\n\n.message-box-ui.no-buttons > div > button {\n\tdisplay: none;\n}\n", ""]);
            const o = s
        }
        ,
        7825: e => {
            "use strict";
            e.exports = function(e) {
                if ("undefined" == typeof document)
                    return {
                        update: function() {},
                        remove: function() {}
                    };
                var t = e.insertStyleElement(e);
                return {
                    update: function(n) {
                        !function(e, t, n) {
                            var i = "";
                            n.supports && (i += "@supports (".concat(n.supports, ") {")),
                            n.media && (i += "@media ".concat(n.media, " {"));
                            var r = void 0 !== n.layer;
                            r && (i += "@layer".concat(n.layer.length > 0 ? " ".concat(n.layer) : "", " {")),
                            i += n.css,
                            r && (i += "}"),
                            n.media && (i += "}"),
                            n.supports && (i += "}");
                            var a = n.sourceMap;
                            a && "undefined" != typeof btoa && (i += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))), " */")),
                            t.styleTagTransform(i, e, t.options)
                        }(t, e, n)
                    },
                    remove: function() {
                        !function(e) {
                            if (null === e.parentNode)
                                return !1;
                            e.parentNode.removeChild(e)
                        }(t)
                    }
                }
            }
        }
        ,
        7888: (e, t, n) => {
            "use strict";
            n.d(t, {
                B: () => a
            });
            var i = n(4922)
              , r = n(1566);
            class a extends i.aHM {
                constructor(e) {
                    super(e),
                    this.dracoLoader = null,
                    this.ktx2Loader = null,
                    this.meshoptDecoder = null,
                    this.pluginCallbacks = [],
                    this.register((function(e) {
                        return new d(e)
                    }
                    )),
                    this.register((function(e) {
                        return new u(e)
                    }
                    )),
                    this.register((function(e) {
                        return new b(e)
                    }
                    )),
                    this.register((function(e) {
                        return new x(e)
                    }
                    )),
                    this.register((function(e) {
                        return new S(e)
                    }
                    )),
                    this.register((function(e) {
                        return new f(e)
                    }
                    )),
                    this.register((function(e) {
                        return new g(e)
                    }
                    )),
                    this.register((function(e) {
                        return new m(e)
                    }
                    )),
                    this.register((function(e) {
                        return new A(e)
                    }
                    )),
                    this.register((function(e) {
                        return new h(e)
                    }
                    )),
                    this.register((function(e) {
                        return new v(e)
                    }
                    )),
                    this.register((function(e) {
                        return new p(e)
                    }
                    )),
                    this.register((function(e) {
                        return new w(e)
                    }
                    )),
                    this.register((function(e) {
                        return new y(e)
                    }
                    )),
                    this.register((function(e) {
                        return new l(e)
                    }
                    )),
                    this.register((function(e) {
                        return new E(e)
                    }
                    )),
                    this.register((function(e) {
                        return new T(e)
                    }
                    ))
                }
                load(e, t, n, r) {
                    const a = this;
                    let s;
                    if ("" !== this.resourcePath)
                        s = this.resourcePath;
                    else if ("" !== this.path) {
                        const t = i.r6x.extractUrlBase(e);
                        s = i.r6x.resolveURL(t, this.path)
                    } else
                        s = i.r6x.extractUrlBase(e);
                    this.manager.itemStart(e);
                    const o = function(t) {
                        r ? r(t) : console.error(t),
                        a.manager.itemError(e),
                        a.manager.itemEnd(e)
                    }
                      , l = new i.Y9S(this.manager);
                    l.setPath(this.path),
                    l.setResponseType("arraybuffer"),
                    l.setRequestHeader(this.requestHeader),
                    l.setWithCredentials(this.withCredentials),
                    l.load(e, (function(n) {
                        try {
                            a.parse(n, s, (function(n) {
                                t(n),
                                a.manager.itemEnd(e)
                            }
                            ), o)
                        } catch (e) {
                            o(e)
                        }
                    }
                    ), n, o)
                }
                setDRACOLoader(e) {
                    return this.dracoLoader = e,
                    this
                }
                setKTX2Loader(e) {
                    return this.ktx2Loader = e,
                    this
                }
                setMeshoptDecoder(e) {
                    return this.meshoptDecoder = e,
                    this
                }
                register(e) {
                    return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                    this
                }
                unregister(e) {
                    return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                    this
                }
                parse(e, t, n, i) {
                    let r;
                    const a = {}
                      , s = {}
                      , l = new TextDecoder;
                    if ("string" == typeof e)
                        r = JSON.parse(e);
                    else if (e instanceof ArrayBuffer) {
                        if (l.decode(new Uint8Array(e,0,4)) === k) {
                            try {
                                a[o.KHR_BINARY_GLTF] = new C(e)
                            } catch (e) {
                                return void (i && i(e))
                            }
                            r = JSON.parse(a[o.KHR_BINARY_GLTF].content)
                        } else
                            r = JSON.parse(l.decode(e))
                    } else
                        r = e;
                    if (void 0 === r.asset || r.asset.version[0] < 2)
                        return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                    const h = new ee(r,{
                        path: t || this.resourcePath || "",
                        crossOrigin: this.crossOrigin,
                        requestHeader: this.requestHeader,
                        manager: this.manager,
                        ktx2Loader: this.ktx2Loader,
                        meshoptDecoder: this.meshoptDecoder
                    });
                    h.fileLoader.setRequestHeader(this.requestHeader);
                    for (let e = 0; e < this.pluginCallbacks.length; e++) {
                        const t = this.pluginCallbacks[e](h);
                        t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                        s[t.name] = t,
                        a[t.name] = !0
                    }
                    if (r.extensionsUsed)
                        for (let e = 0; e < r.extensionsUsed.length; ++e) {
                            const t = r.extensionsUsed[e]
                              , n = r.extensionsRequired || [];
                            switch (t) {
                            case o.KHR_MATERIALS_UNLIT:
                                a[t] = new c;
                                break;
                            case o.KHR_DRACO_MESH_COMPRESSION:
                                a[t] = new R(r,this.dracoLoader);
                                break;
                            case o.KHR_TEXTURE_TRANSFORM:
                                a[t] = new P;
                                break;
                            case o.KHR_MESH_QUANTIZATION:
                                a[t] = new I;
                                break;
                            default:
                                n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                            }
                        }
                    h.setExtensions(a),
                    h.setPlugins(s),
                    h.parse(n, i)
                }
                parseAsync(e, t) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.parse(e, t, i, r)
                    }
                    ))
                }
            }
            function s() {
                let e = {};
                return {
                    get: function(t) {
                        return e[t]
                    },
                    add: function(t, n) {
                        e[t] = n
                    },
                    remove: function(t) {
                        delete e[t]
                    },
                    removeAll: function() {
                        e = {}
                    }
                }
            }
            const o = {
                KHR_BINARY_GLTF: "KHR_binary_glTF",
                KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
                KHR_MATERIALS_IOR: "KHR_materials_ior",
                KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                EXT_MATERIALS_BUMP: "EXT_materials_bump",
                EXT_TEXTURE_WEBP: "EXT_texture_webp",
                EXT_TEXTURE_AVIF: "EXT_texture_avif",
                EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
            };
            class l {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_LIGHTS_PUNCTUAL,
                    this.cache = {
                        refs: {},
                        uses: {}
                    }
                }
                _markDefs() {
                    const e = this.parser
                      , t = this.parser.json.nodes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                    }
                }
                _loadLight(e) {
                    const t = this.parser
                      , n = "light:" + e;
                    let r = t.cache.get(n);
                    if (r)
                        return r;
                    const a = t.json
                      , s = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e];
                    let o;
                    const l = new i.Q1f(16777215);
                    void 0 !== s.color && l.setRGB(s.color[0], s.color[1], s.color[2], i.Zr2);
                    const c = void 0 !== s.range ? s.range : 0;
                    switch (s.type) {
                    case "directional":
                        o = new i.ZyN(l),
                        o.target.position.set(0, 0, -1),
                        o.add(o.target);
                        break;
                    case "point":
                        o = new i.HiM(l),
                        o.distance = c;
                        break;
                    case "spot":
                        o = new i.nCl(l),
                        o.distance = c,
                        s.spot = s.spot || {},
                        s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
                        s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
                        o.angle = s.spot.outerConeAngle,
                        o.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
                        o.target.position.set(0, 0, -1),
                        o.add(o.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
                    }
                    return o.position.set(0, 0, 0),
                    Q(o, s),
                    void 0 !== s.intensity && (o.intensity = s.intensity),
                    o.name = t.createUniqueName(s.name || "light_" + e),
                    r = Promise.resolve(o),
                    t.cache.add(n, r),
                    r
                }
                getDependency(e, t) {
                    if ("light" === e)
                        return this._loadLight(t)
                }
                createNodeAttachment(e) {
                    const t = this
                      , n = this.parser
                      , i = n.json.nodes[e]
                      , r = (i.extensions && i.extensions[this.name] || {}).light;
                    return void 0 === r ? null : this._loadLight(r).then((function(e) {
                        return n._getNodeRef(t.cache, r, e)
                    }
                    ))
                }
            }
            class c {
                constructor() {
                    this.name = o.KHR_MATERIALS_UNLIT
                }
                getMaterialType() {
                    return i.V9B
                }
                extendParams(e, t, n) {
                    const r = [];
                    e.color = new i.Q1f(1,1,1),
                    e.opacity = 1;
                    const a = t.pbrMetallicRoughness;
                    if (a) {
                        if (Array.isArray(a.baseColorFactor)) {
                            const t = a.baseColorFactor;
                            e.color.setRGB(t[0], t[1], t[2], i.Zr2),
                            e.opacity = t[3]
                        }
                        void 0 !== a.baseColorTexture && r.push(n.assignTexture(e, "map", a.baseColorTexture, i.er$))
                    }
                    return Promise.all(r)
                }
            }
            class h {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_EMISSIVE_STRENGTH
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name])
                        return Promise.resolve();
                    const i = n.extensions[this.name].emissiveStrength;
                    return void 0 !== i && (t.emissiveIntensity = i),
                    Promise.resolve()
                }
            }
            class d {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_CLEARCOAT
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name])
                        return Promise.resolve();
                    const a = []
                      , s = r.extensions[this.name];
                    if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
                    void 0 !== s.clearcoatTexture && a.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
                    void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
                    void 0 !== s.clearcoatRoughnessTexture && a.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
                    void 0 !== s.clearcoatNormalTexture && (a.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)),
                    void 0 !== s.clearcoatNormalTexture.scale)) {
                        const e = s.clearcoatNormalTexture.scale;
                        t.clearcoatNormalScale = new i.I9Y(e,e)
                    }
                    return Promise.all(a)
                }
            }
            class u {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_DISPERSION
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name])
                        return Promise.resolve();
                    const i = n.extensions[this.name];
                    return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0,
                    Promise.resolve()
                }
            }
            class p {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_IRIDESCENCE
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name])
                        return Promise.resolve();
                    const r = []
                      , a = i.extensions[this.name];
                    return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor),
                    void 0 !== a.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
                    void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor),
                    void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                    void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
                    void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
                    void 0 !== a.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)),
                    Promise.all(r)
                }
            }
            class f {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_SHEEN
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name])
                        return Promise.resolve();
                    const a = [];
                    t.sheenColor = new i.Q1f(0,0,0),
                    t.sheenRoughness = 0,
                    t.sheen = 1;
                    const s = r.extensions[this.name];
                    if (void 0 !== s.sheenColorFactor) {
                        const e = s.sheenColorFactor;
                        t.sheenColor.setRGB(e[0], e[1], e[2], i.Zr2)
                    }
                    return void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor),
                    void 0 !== s.sheenColorTexture && a.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, i.er$)),
                    void 0 !== s.sheenRoughnessTexture && a.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)),
                    Promise.all(a)
                }
            }
            class g {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_TRANSMISSION
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name])
                        return Promise.resolve();
                    const r = []
                      , a = i.extensions[this.name];
                    return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor),
                    void 0 !== a.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
                    Promise.all(r)
                }
            }
            class m {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_VOLUME
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name])
                        return Promise.resolve();
                    const a = []
                      , s = r.extensions[this.name];
                    t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
                    void 0 !== s.thicknessTexture && a.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
                    t.attenuationDistance = s.attenuationDistance || 1 / 0;
                    const o = s.attenuationColor || [1, 1, 1];
                    return t.attenuationColor = (new i.Q1f).setRGB(o[0], o[1], o[2], i.Zr2),
                    Promise.all(a)
                }
            }
            class A {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_IOR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser.json.materials[e];
                    if (!n.extensions || !n.extensions[this.name])
                        return Promise.resolve();
                    const i = n.extensions[this.name];
                    return t.ior = void 0 !== i.ior ? i.ior : 1.5,
                    Promise.resolve()
                }
            }
            class v {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_SPECULAR
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , r = n.json.materials[e];
                    if (!r.extensions || !r.extensions[this.name])
                        return Promise.resolve();
                    const a = []
                      , s = r.extensions[this.name];
                    t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
                    void 0 !== s.specularTexture && a.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
                    const o = s.specularColorFactor || [1, 1, 1];
                    return t.specularColor = (new i.Q1f).setRGB(o[0], o[1], o[2], i.Zr2),
                    void 0 !== s.specularColorTexture && a.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, i.er$)),
                    Promise.all(a)
                }
            }
            class y {
                constructor(e) {
                    this.parser = e,
                    this.name = o.EXT_MATERIALS_BUMP
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name])
                        return Promise.resolve();
                    const r = []
                      , a = i.extensions[this.name];
                    return t.bumpScale = void 0 !== a.bumpFactor ? a.bumpFactor : 1,
                    void 0 !== a.bumpTexture && r.push(n.assignTexture(t, "bumpMap", a.bumpTexture)),
                    Promise.all(r)
                }
            }
            class w {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_MATERIALS_ANISOTROPY
                }
                getMaterialType(e) {
                    const t = this.parser.json.materials[e];
                    return t.extensions && t.extensions[this.name] ? i.uSd : null
                }
                extendMaterialParams(e, t) {
                    const n = this.parser
                      , i = n.json.materials[e];
                    if (!i.extensions || !i.extensions[this.name])
                        return Promise.resolve();
                    const r = []
                      , a = i.extensions[this.name];
                    return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength),
                    void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation),
                    void 0 !== a.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)),
                    Promise.all(r)
                }
            }
            class b {
                constructor(e) {
                    this.parser = e,
                    this.name = o.KHR_TEXTURE_BASISU
                }
                loadTexture(e) {
                    const t = this.parser
                      , n = t.json
                      , i = n.textures[e];
                    if (!i.extensions || !i.extensions[this.name])
                        return null;
                    const r = i.extensions[this.name]
                      , a = t.options.ktx2Loader;
                    if (!a) {
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null
                    }
                    return t.loadTextureImage(e, r.source, a)
                }
            }
            class x {
                constructor(e) {
                    this.parser = e,
                    this.name = o.EXT_TEXTURE_WEBP
                }
                loadTexture(e) {
                    const t = this.name
                      , n = this.parser
                      , i = n.json
                      , r = i.textures[e];
                    if (!r.extensions || !r.extensions[t])
                        return null;
                    const a = r.extensions[t]
                      , s = i.images[a.source];
                    let o = n.textureLoader;
                    if (s.uri) {
                        const e = n.options.manager.getHandler(s.uri);
                        null !== e && (o = e)
                    }
                    return n.loadTextureImage(e, a.source, o)
                }
            }
            class S {
                constructor(e) {
                    this.parser = e,
                    this.name = o.EXT_TEXTURE_AVIF
                }
                loadTexture(e) {
                    const t = this.name
                      , n = this.parser
                      , i = n.json
                      , r = i.textures[e];
                    if (!r.extensions || !r.extensions[t])
                        return null;
                    const a = r.extensions[t]
                      , s = i.images[a.source];
                    let o = n.textureLoader;
                    if (s.uri) {
                        const e = n.options.manager.getHandler(s.uri);
                        null !== e && (o = e)
                    }
                    return n.loadTextureImage(e, a.source, o)
                }
            }
            class E {
                constructor(e) {
                    this.name = o.EXT_MESHOPT_COMPRESSION,
                    this.parser = e
                }
                loadBufferView(e) {
                    const t = this.parser.json
                      , n = t.bufferViews[e];
                    if (n.extensions && n.extensions[this.name]) {
                        const e = n.extensions[this.name]
                          , i = this.parser.getDependency("buffer", e.buffer)
                          , r = this.parser.options.meshoptDecoder;
                        if (!r || !r.supported) {
                            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                                throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null
                        }
                        return i.then((function(t) {
                            const n = e.byteOffset || 0
                              , i = e.byteLength || 0
                              , a = e.count
                              , s = e.byteStride
                              , o = new Uint8Array(t,n,i);
                            return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(a, s, o, e.mode, e.filter).then((function(e) {
                                return e.buffer
                            }
                            )) : r.ready.then((function() {
                                const t = new ArrayBuffer(a * s);
                                return r.decodeGltfBuffer(new Uint8Array(t), a, s, o, e.mode, e.filter),
                                t
                            }
                            ))
                        }
                        ))
                    }
                    return null
                }
            }
            class T {
                constructor(e) {
                    this.name = o.EXT_MESH_GPU_INSTANCING,
                    this.parser = e
                }
                createNodeMesh(e) {
                    const t = this.parser.json
                      , n = t.nodes[e];
                    if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                        return null;
                    const r = t.meshes[n.mesh];
                    for (const e of r.primitives)
                        if (e.mode !== U.TRIANGLES && e.mode !== U.TRIANGLE_STRIP && e.mode !== U.TRIANGLE_FAN && void 0 !== e.mode)
                            return null;
                    const a = n.extensions[this.name].attributes
                      , s = []
                      , o = {};
                    for (const e in a)
                        s.push(this.parser.getDependency("accessor", a[e]).then((t => (o[e] = t,
                        o[e]))));
                    return s.length < 1 ? null : (s.push(this.parser.createNodeMesh(e)),
                    Promise.all(s).then((e => {
                        const t = e.pop()
                          , n = t.isGroup ? t.children : [t]
                          , r = e[0].count
                          , a = [];
                        for (const e of n) {
                            const t = new i.kn4
                              , n = new i.Pq0
                              , s = new i.PTz
                              , l = new i.Pq0(1,1,1)
                              , c = new i.ZLX(e.geometry,e.material,r);
                            for (let e = 0; e < r; e++)
                                o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, e),
                                o.ROTATION && s.fromBufferAttribute(o.ROTATION, e),
                                o.SCALE && l.fromBufferAttribute(o.SCALE, e),
                                c.setMatrixAt(e, t.compose(n, s, l));
                            for (const t in o)
                                if ("_COLOR_0" === t) {
                                    const e = o[t];
                                    c.instanceColor = new i.uWO(e.array,e.itemSize,e.normalized)
                                } else
                                    "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, o[t]);
                            i.B69.prototype.copy.call(c, e),
                            this.parser.assignFinalMaterial(c),
                            a.push(c)
                        }
                        return t.isGroup ? (t.clear(),
                        t.add(...a),
                        t) : a[0]
                    }
                    )))
                }
            }
            const k = "glTF"
              , M = 1313821514
              , _ = 5130562;
            class C {
                constructor(e) {
                    this.name = o.KHR_BINARY_GLTF,
                    this.content = null,
                    this.body = null;
                    const t = new DataView(e,0,12)
                      , n = new TextDecoder;
                    if (this.header = {
                        magic: n.decode(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    },
                    this.header.magic !== k)
                        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2)
                        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    const i = this.header.length - 12
                      , r = new DataView(e,12);
                    let a = 0;
                    for (; a < i; ) {
                        const t = r.getUint32(a, !0);
                        a += 4;
                        const i = r.getUint32(a, !0);
                        if (a += 4,
                        i === M) {
                            const i = new Uint8Array(e,12 + a,t);
                            this.content = n.decode(i)
                        } else if (i === _) {
                            const n = 12 + a;
                            this.body = e.slice(n, n + t)
                        }
                        a += t
                    }
                    if (null === this.content)
                        throw new Error("THREE.GLTFLoader: JSON content not found.")
                }
            }
            class R {
                constructor(e, t) {
                    if (!t)
                        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    this.name = o.KHR_DRACO_MESH_COMPRESSION,
                    this.json = e,
                    this.dracoLoader = t,
                    this.dracoLoader.preload()
                }
                decodePrimitive(e, t) {
                    const n = this.json
                      , r = this.dracoLoader
                      , a = e.extensions[this.name].bufferView
                      , s = e.extensions[this.name].attributes
                      , o = {}
                      , l = {}
                      , c = {};
                    for (const e in s) {
                        const t = O[e] || e.toLowerCase();
                        o[t] = s[e]
                    }
                    for (const t in e.attributes) {
                        const i = O[t] || t.toLowerCase();
                        if (void 0 !== s[t]) {
                            const r = n.accessors[e.attributes[t]]
                              , a = D[r.componentType];
                            c[i] = a.name,
                            l[i] = !0 === r.normalized
                        }
                    }
                    return t.getDependency("bufferView", a).then((function(e) {
                        return new Promise((function(t, n) {
                            r.decodeDracoFile(e, (function(e) {
                                for (const t in e.attributes) {
                                    const n = e.attributes[t]
                                      , i = l[t];
                                    void 0 !== i && (n.normalized = i)
                                }
                                t(e)
                            }
                            ), o, c, i.Zr2, n)
                        }
                        ))
                    }
                    ))
                }
            }
            class P {
                constructor() {
                    this.name = o.KHR_TEXTURE_TRANSFORM
                }
                extendTexture(e, t) {
                    return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                    void 0 !== t.texCoord && (e.channel = t.texCoord),
                    void 0 !== t.offset && e.offset.fromArray(t.offset),
                    void 0 !== t.rotation && (e.rotation = t.rotation),
                    void 0 !== t.scale && e.repeat.fromArray(t.scale),
                    e.needsUpdate = !0,
                    e) : e
                }
            }
            class I {
                constructor() {
                    this.name = o.KHR_MESH_QUANTIZATION
                }
            }
            class L extends i.lGw {
                constructor(e, t, n, i) {
                    super(e, t, n, i)
                }
                copySampleValue_(e) {
                    const t = this.resultBuffer
                      , n = this.sampleValues
                      , i = this.valueSize
                      , r = e * i * 3 + i;
                    for (let e = 0; e !== i; e++)
                        t[e] = n[r + e];
                    return t
                }
                interpolate_(e, t, n, i) {
                    const r = this.resultBuffer
                      , a = this.sampleValues
                      , s = this.valueSize
                      , o = 2 * s
                      , l = 3 * s
                      , c = i - t
                      , h = (n - t) / c
                      , d = h * h
                      , u = d * h
                      , p = e * l
                      , f = p - l
                      , g = -2 * u + 3 * d
                      , m = u - d
                      , A = 1 - g
                      , v = m - d + h;
                    for (let e = 0; e !== s; e++) {
                        const t = a[f + e + s]
                          , n = a[f + e + o] * c
                          , i = a[p + e + s]
                          , l = a[p + e] * c;
                        r[e] = A * t + v * n + g * i + m * l
                    }
                    return r
                }
            }
            const N = new i.PTz;
            class z extends L {
                interpolate_(e, t, n, i) {
                    const r = super.interpolate_(e, t, n, i);
                    return N.fromArray(r).normalize().toArray(r),
                    r
                }
            }
            const U = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            }
              , D = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            }
              , B = {
                9728: i.hxR,
                9729: i.k6q,
                9984: i.pHI,
                9985: i.kRr,
                9986: i.Cfg,
                9987: i.$_I
            }
              , G = {
                33071: i.ghU,
                33648: i.kTW,
                10497: i.GJx
            }
              , F = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            }
              , O = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            }
              , W = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            }
              , V = {
                CUBICSPLINE: void 0,
                LINEAR: i.PJ3,
                STEP: i.ljd
            }
              , H = "OPAQUE"
              , j = "MASK"
              , K = "BLEND";
            function q(e, t, n) {
                for (const i in n.extensions)
                    void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                    t.userData.gltfExtensions[i] = n.extensions[i])
            }
            function Q(e, t) {
                void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }
            function J(e, t) {
                if (e.updateMorphTargets(),
                void 0 !== t.weights)
                    for (let n = 0, i = t.weights.length; n < i; n++)
                        e.morphTargetInfluences[n] = t.weights[n];
                if (t.extras && Array.isArray(t.extras.targetNames)) {
                    const n = t.extras.targetNames;
                    if (e.morphTargetInfluences.length === n.length) {
                        e.morphTargetDictionary = {};
                        for (let t = 0, i = n.length; t < i; t++)
                            e.morphTargetDictionary[n[t]] = t
                    } else
                        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }
            function X(e) {
                let t;
                const n = e.extensions && e.extensions[o.KHR_DRACO_MESH_COMPRESSION];
                if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + Y(n.attributes) : e.indices + ":" + Y(e.attributes) + ":" + e.mode,
                void 0 !== e.targets)
                    for (let n = 0, i = e.targets.length; n < i; n++)
                        t += ":" + Y(e.targets[n]);
                return t
            }
            function Y(e) {
                let t = "";
                const n = Object.keys(e).sort();
                for (let i = 0, r = n.length; i < r; i++)
                    t += n[i] + ":" + e[n[i]] + ";";
                return t
            }
            function Z(e) {
                switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            const $ = new i.kn4;
            class ee {
                constructor(e={}, t={}) {
                    this.json = e,
                    this.extensions = {},
                    this.plugins = {},
                    this.options = t,
                    this.cache = new s,
                    this.associations = new Map,
                    this.primitiveCache = {},
                    this.nodeCache = {},
                    this.meshCache = {
                        refs: {},
                        uses: {}
                    },
                    this.cameraCache = {
                        refs: {},
                        uses: {}
                    },
                    this.lightCache = {
                        refs: {},
                        uses: {}
                    },
                    this.sourceCache = {},
                    this.textureCache = {},
                    this.nodeNamesUsed = {};
                    let n = !1
                      , r = -1
                      , a = !1
                      , o = -1;
                    if ("undefined" != typeof navigator) {
                        const e = navigator.userAgent;
                        n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                        const t = e.match(/Version\/(\d+)/);
                        r = n && t ? parseInt(t[1], 10) : -1,
                        a = e.indexOf("Firefox") > -1,
                        o = a ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
                    }
                    "undefined" == typeof createImageBitmap || n && r < 17 || a && o < 98 ? this.textureLoader = new i.Tap(this.options.manager) : this.textureLoader = new i.Kzg(this.options.manager),
                    this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                    this.textureLoader.setRequestHeader(this.options.requestHeader),
                    this.fileLoader = new i.Y9S(this.options.manager),
                    this.fileLoader.setResponseType("arraybuffer"),
                    "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                }
                setExtensions(e) {
                    this.extensions = e
                }
                setPlugins(e) {
                    this.plugins = e
                }
                parse(e, t) {
                    const n = this
                      , i = this.json
                      , r = this.extensions;
                    this.cache.removeAll(),
                    this.nodeCache = {},
                    this._invokeAll((function(e) {
                        return e._markDefs && e._markDefs()
                    }
                    )),
                    Promise.all(this._invokeAll((function(e) {
                        return e.beforeRoot && e.beforeRoot()
                    }
                    ))).then((function() {
                        return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                    }
                    )).then((function(t) {
                        const a = {
                            scene: t[0][i.scene || 0],
                            scenes: t[0],
                            animations: t[1],
                            cameras: t[2],
                            asset: i.asset,
                            parser: n,
                            userData: {}
                        };
                        return q(r, a, i),
                        Q(a, i),
                        Promise.all(n._invokeAll((function(e) {
                            return e.afterRoot && e.afterRoot(a)
                        }
                        ))).then((function() {
                            for (const e of a.scenes)
                                e.updateMatrixWorld();
                            e(a)
                        }
                        ))
                    }
                    )).catch(t)
                }
                _markDefs() {
                    const e = this.json.nodes || []
                      , t = this.json.skins || []
                      , n = this.json.meshes || [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n].joints;
                        for (let t = 0, n = i.length; t < n; t++)
                            e[i[t]].isBone = !0
                    }
                    for (let t = 0, i = e.length; t < i; t++) {
                        const i = e[t];
                        void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                        void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                        void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                    }
                }
                _addNodeRef(e, t) {
                    void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                    e.refs[t]++)
                }
                _getNodeRef(e, t, n) {
                    if (e.refs[t] <= 1)
                        return n;
                    const i = n.clone()
                      , r = (e, t) => {
                        const n = this.associations.get(e);
                        null != n && this.associations.set(t, n);
                        for (const [n,i] of e.children.entries())
                            r(i, t.children[n])
                    }
                    ;
                    return r(n, i),
                    i.name += "_instance_" + e.uses[t]++,
                    i
                }
                _invokeOne(e) {
                    const t = Object.values(this.plugins);
                    t.push(this);
                    for (let n = 0; n < t.length; n++) {
                        const i = e(t[n]);
                        if (i)
                            return i
                    }
                    return null
                }
                _invokeAll(e) {
                    const t = Object.values(this.plugins);
                    t.unshift(this);
                    const n = [];
                    for (let i = 0; i < t.length; i++) {
                        const r = e(t[i]);
                        r && n.push(r)
                    }
                    return n
                }
                getDependency(e, t) {
                    const n = e + ":" + t;
                    let i = this.cache.get(n);
                    if (!i) {
                        switch (e) {
                        case "scene":
                            i = this.loadScene(t);
                            break;
                        case "node":
                            i = this._invokeOne((function(e) {
                                return e.loadNode && e.loadNode(t)
                            }
                            ));
                            break;
                        case "mesh":
                            i = this._invokeOne((function(e) {
                                return e.loadMesh && e.loadMesh(t)
                            }
                            ));
                            break;
                        case "accessor":
                            i = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function(e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }
                            ));
                            break;
                        case "buffer":
                            i = this.loadBuffer(t);
                            break;
                        case "material":
                            i = this._invokeOne((function(e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }
                            ));
                            break;
                        case "texture":
                            i = this._invokeOne((function(e) {
                                return e.loadTexture && e.loadTexture(t)
                            }
                            ));
                            break;
                        case "skin":
                            i = this.loadSkin(t);
                            break;
                        case "animation":
                            i = this._invokeOne((function(e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }
                            ));
                            break;
                        case "camera":
                            i = this.loadCamera(t);
                            break;
                        default:
                            if (i = this._invokeOne((function(n) {
                                return n != this && n.getDependency && n.getDependency(e, t)
                            }
                            )),
                            !i)
                                throw new Error("Unknown type: " + e)
                        }
                        this.cache.add(n, i)
                    }
                    return i
                }
                getDependencies(e) {
                    let t = this.cache.get(e);
                    if (!t) {
                        const n = this
                          , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                        t = Promise.all(i.map((function(t, i) {
                            return n.getDependency(e, i)
                        }
                        ))),
                        this.cache.add(e, t)
                    }
                    return t
                }
                loadBuffer(e) {
                    const t = this.json.buffers[e]
                      , n = this.fileLoader;
                    if (t.type && "arraybuffer" !== t.type)
                        throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                    if (void 0 === t.uri && 0 === e)
                        return Promise.resolve(this.extensions[o.KHR_BINARY_GLTF].body);
                    const r = this.options;
                    return new Promise((function(e, a) {
                        n.load(i.r6x.resolveURL(t.uri, r.path), e, void 0, (function() {
                            a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                        }
                        ))
                    }
                    ))
                }
                loadBufferView(e) {
                    const t = this.json.bufferViews[e];
                    return this.getDependency("buffer", t.buffer).then((function(e) {
                        const n = t.byteLength || 0
                          , i = t.byteOffset || 0;
                        return e.slice(i, i + n)
                    }
                    ))
                }
                loadAccessor(e) {
                    const t = this
                      , n = this.json
                      , r = this.json.accessors[e];
                    if (void 0 === r.bufferView && void 0 === r.sparse) {
                        const e = F[r.type]
                          , t = D[r.componentType]
                          , n = !0 === r.normalized
                          , a = new t(r.count * e);
                        return Promise.resolve(new i.THS(a,e,n))
                    }
                    const a = [];
                    return void 0 !== r.bufferView ? a.push(this.getDependency("bufferView", r.bufferView)) : a.push(null),
                    void 0 !== r.sparse && (a.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                    a.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
                    Promise.all(a).then((function(e) {
                        const a = e[0]
                          , s = F[r.type]
                          , o = D[r.componentType]
                          , l = o.BYTES_PER_ELEMENT
                          , c = l * s
                          , h = r.byteOffset || 0
                          , d = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0
                          , u = !0 === r.normalized;
                        let p, f;
                        if (d && d !== c) {
                            const e = Math.floor(h / d)
                              , n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                            let c = t.cache.get(n);
                            c || (p = new o(a,e * d,r.count * d / l),
                            c = new i.eB$(p,d / l),
                            t.cache.add(n, c)),
                            f = new i.eHs(c,s,h % d / l,u)
                        } else
                            p = null === a ? new o(r.count * s) : new o(a,h,r.count * s),
                            f = new i.THS(p,s,u);
                        if (void 0 !== r.sparse) {
                            const t = F.SCALAR
                              , n = D[r.sparse.indices.componentType]
                              , l = r.sparse.indices.byteOffset || 0
                              , c = r.sparse.values.byteOffset || 0
                              , h = new n(e[1],l,r.sparse.count * t)
                              , d = new o(e[2],c,r.sparse.count * s);
                            null !== a && (f = new i.THS(f.array.slice(),f.itemSize,f.normalized)),
                            f.normalized = !1;
                            for (let e = 0, t = h.length; e < t; e++) {
                                const t = h[e];
                                if (f.setX(t, d[e * s]),
                                s >= 2 && f.setY(t, d[e * s + 1]),
                                s >= 3 && f.setZ(t, d[e * s + 2]),
                                s >= 4 && f.setW(t, d[e * s + 3]),
                                s >= 5)
                                    throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                            }
                            f.normalized = u
                        }
                        return f
                    }
                    ))
                }
                loadTexture(e) {
                    const t = this.json
                      , n = this.options
                      , i = t.textures[e].source
                      , r = t.images[i];
                    let a = this.textureLoader;
                    if (r.uri) {
                        const e = n.manager.getHandler(r.uri);
                        null !== e && (a = e)
                    }
                    return this.loadTextureImage(e, i, a)
                }
                loadTextureImage(e, t, n) {
                    const r = this
                      , a = this.json
                      , s = a.textures[e]
                      , o = a.images[t]
                      , l = (o.uri || o.bufferView) + ":" + s.sampler;
                    if (this.textureCache[l])
                        return this.textureCache[l];
                    const c = this.loadImageSource(t, n).then((function(t) {
                        t.flipY = !1,
                        t.name = s.name || o.name || "",
                        "" === t.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (t.name = o.uri);
                        const n = (a.samplers || {})[s.sampler] || {};
                        return t.magFilter = B[n.magFilter] || i.k6q,
                        t.minFilter = B[n.minFilter] || i.$_I,
                        t.wrapS = G[n.wrapS] || i.GJx,
                        t.wrapT = G[n.wrapT] || i.GJx,
                        t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== i.hxR && t.minFilter !== i.k6q,
                        r.associations.set(t, {
                            textures: e
                        }),
                        t
                    }
                    )).catch((function() {
                        return null
                    }
                    ));
                    return this.textureCache[l] = c,
                    c
                }
                loadImageSource(e, t) {
                    const n = this
                      , r = this.json
                      , a = this.options;
                    if (void 0 !== this.sourceCache[e])
                        return this.sourceCache[e].then((e => e.clone()));
                    const s = r.images[e]
                      , o = self.URL || self.webkitURL;
                    let l = s.uri || ""
                      , c = !1;
                    if (void 0 !== s.bufferView)
                        l = n.getDependency("bufferView", s.bufferView).then((function(e) {
                            c = !0;
                            const t = new Blob([e],{
                                type: s.mimeType
                            });
                            return l = o.createObjectURL(t),
                            l
                        }
                        ));
                    else if (void 0 === s.uri)
                        throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                    const h = Promise.resolve(l).then((function(e) {
                        return new Promise((function(n, r) {
                            let s = n;
                            !0 === t.isImageBitmapLoader && (s = function(e) {
                                const t = new i.gPd(e);
                                t.needsUpdate = !0,
                                n(t)
                            }
                            ),
                            t.load(i.r6x.resolveURL(e, a.path), s, void 0, r)
                        }
                        ))
                    }
                    )).then((function(e) {
                        var t;
                        return !0 === c && o.revokeObjectURL(l),
                        Q(e, s),
                        e.userData.mimeType = s.mimeType || ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"),
                        e
                    }
                    )).catch((function(e) {
                        throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
                        e
                    }
                    ));
                    return this.sourceCache[e] = h,
                    h
                }
                assignTexture(e, t, n, i) {
                    const r = this;
                    return this.getDependency("texture", n.index).then((function(a) {
                        if (!a)
                            return null;
                        if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord),
                        r.extensions[o.KHR_TEXTURE_TRANSFORM]) {
                            const e = void 0 !== n.extensions ? n.extensions[o.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (e) {
                                const t = r.associations.get(a);
                                a = r.extensions[o.KHR_TEXTURE_TRANSFORM].extendTexture(a, e),
                                r.associations.set(a, t)
                            }
                        }
                        return void 0 !== i && (a.colorSpace = i),
                        e[t] = a,
                        a
                    }
                    ))
                }
                assignFinalMaterial(e) {
                    const t = e.geometry;
                    let n = e.material;
                    const r = void 0 === t.attributes.tangent
                      , a = void 0 !== t.attributes.color
                      , s = void 0 === t.attributes.normal;
                    if (e.isPoints) {
                        const e = "PointsMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new i.BH$,
                        i.imn.prototype.copy.call(t, n),
                        t.color.copy(n.color),
                        t.map = n.map,
                        t.sizeAttenuation = !1,
                        this.cache.add(e, t)),
                        n = t
                    } else if (e.isLine) {
                        const e = "LineBasicMaterial:" + n.uuid;
                        let t = this.cache.get(e);
                        t || (t = new i.mrM,
                        i.imn.prototype.copy.call(t, n),
                        t.color.copy(n.color),
                        t.map = n.map,
                        this.cache.add(e, t)),
                        n = t
                    }
                    if (r || a || s) {
                        let e = "ClonedMaterial:" + n.uuid + ":";
                        r && (e += "derivative-tangents:"),
                        a && (e += "vertex-colors:"),
                        s && (e += "flat-shading:");
                        let t = this.cache.get(e);
                        t || (t = n.clone(),
                        a && (t.vertexColors = !0),
                        s && (t.flatShading = !0),
                        r && (t.normalScale && (t.normalScale.y *= -1),
                        t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                        this.cache.add(e, t),
                        this.associations.set(t, this.associations.get(n))),
                        n = t
                    }
                    e.material = n
                }
                getMaterialType() {
                    return i._4j
                }
                loadMaterial(e) {
                    const t = this
                      , n = this.json
                      , r = this.extensions
                      , a = n.materials[e];
                    let s;
                    const l = {}
                      , c = [];
                    if ((a.extensions || {})[o.KHR_MATERIALS_UNLIT]) {
                        const e = r[o.KHR_MATERIALS_UNLIT];
                        s = e.getMaterialType(),
                        c.push(e.extendParams(l, a, t))
                    } else {
                        const n = a.pbrMetallicRoughness || {};
                        if (l.color = new i.Q1f(1,1,1),
                        l.opacity = 1,
                        Array.isArray(n.baseColorFactor)) {
                            const e = n.baseColorFactor;
                            l.color.setRGB(e[0], e[1], e[2], i.Zr2),
                            l.opacity = e[3]
                        }
                        void 0 !== n.baseColorTexture && c.push(t.assignTexture(l, "map", n.baseColorTexture, i.er$)),
                        l.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                        l.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                        void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)),
                        c.push(t.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture))),
                        s = this._invokeOne((function(t) {
                            return t.getMaterialType && t.getMaterialType(e)
                        }
                        )),
                        c.push(Promise.all(this._invokeAll((function(t) {
                            return t.extendMaterialParams && t.extendMaterialParams(e, l)
                        }
                        ))))
                    }
                    !0 === a.doubleSided && (l.side = i.$EB);
                    const h = a.alphaMode || H;
                    if (h === K ? (l.transparent = !0,
                    l.depthWrite = !1) : (l.transparent = !1,
                    h === j && (l.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)),
                    void 0 !== a.normalTexture && s !== i.V9B && (c.push(t.assignTexture(l, "normalMap", a.normalTexture)),
                    l.normalScale = new i.I9Y(1,1),
                    void 0 !== a.normalTexture.scale)) {
                        const e = a.normalTexture.scale;
                        l.normalScale.set(e, e)
                    }
                    if (void 0 !== a.occlusionTexture && s !== i.V9B && (c.push(t.assignTexture(l, "aoMap", a.occlusionTexture)),
                    void 0 !== a.occlusionTexture.strength && (l.aoMapIntensity = a.occlusionTexture.strength)),
                    void 0 !== a.emissiveFactor && s !== i.V9B) {
                        const e = a.emissiveFactor;
                        l.emissive = (new i.Q1f).setRGB(e[0], e[1], e[2], i.Zr2)
                    }
                    return void 0 !== a.emissiveTexture && s !== i.V9B && c.push(t.assignTexture(l, "emissiveMap", a.emissiveTexture, i.er$)),
                    Promise.all(c).then((function() {
                        const n = new s(l);
                        return a.name && (n.name = a.name),
                        Q(n, a),
                        t.associations.set(n, {
                            materials: e
                        }),
                        a.extensions && q(r, n, a),
                        n
                    }
                    ))
                }
                createUniqueName(e) {
                    const t = i.Nwf.sanitizeNodeName(e || "");
                    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                    t)
                }
                loadGeometries(e) {
                    const t = this
                      , n = this.extensions
                      , r = this.primitiveCache;
                    function a(e) {
                        return n[o.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                            return te(n, e, t)
                        }
                        ))
                    }
                    const s = [];
                    for (let n = 0, l = e.length; n < l; n++) {
                        const l = e[n]
                          , c = X(l)
                          , h = r[c];
                        if (h)
                            s.push(h.promise);
                        else {
                            let e;
                            e = l.extensions && l.extensions[o.KHR_DRACO_MESH_COMPRESSION] ? a(l) : te(new i.LoY, l, t),
                            r[c] = {
                                primitive: l,
                                promise: e
                            },
                            s.push(e)
                        }
                    }
                    return Promise.all(s)
                }
                loadMesh(e) {
                    const t = this
                      , n = this.json
                      , a = this.extensions
                      , s = n.meshes[e]
                      , o = s.primitives
                      , l = [];
                    for (let e = 0, t = o.length; e < t; e++) {
                        const t = void 0 === o[e].material ? (void 0 === (c = this.cache).DefaultMaterial && (c.DefaultMaterial = new i._4j({
                            color: 16777215,
                            emissive: 0,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: i.hB5
                        })),
                        c.DefaultMaterial) : this.getDependency("material", o[e].material);
                        l.push(t)
                    }
                    var c;
                    return l.push(t.loadGeometries(o)),
                    Promise.all(l).then((function(n) {
                        const l = n.slice(0, n.length - 1)
                          , c = n[n.length - 1]
                          , h = [];
                        for (let n = 0, d = c.length; n < d; n++) {
                            const d = c[n]
                              , u = o[n];
                            let p;
                            const f = l[n];
                            if (u.mode === U.TRIANGLES || u.mode === U.TRIANGLE_STRIP || u.mode === U.TRIANGLE_FAN || void 0 === u.mode)
                                p = !0 === s.isSkinnedMesh ? new i.I46(d,f) : new i.eaF(d,f),
                                !0 === p.isSkinnedMesh && p.normalizeSkinWeights(),
                                u.mode === U.TRIANGLE_STRIP ? p.geometry = (0,
                                r._c)(p.geometry, i.O49) : u.mode === U.TRIANGLE_FAN && (p.geometry = (0,
                                r._c)(p.geometry, i.rYR));
                            else if (u.mode === U.LINES)
                                p = new i.DXC(d,f);
                            else if (u.mode === U.LINE_STRIP)
                                p = new i.N1A(d,f);
                            else if (u.mode === U.LINE_LOOP)
                                p = new i.FCc(d,f);
                            else {
                                if (u.mode !== U.POINTS)
                                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode);
                                p = new i.ONl(d,f)
                            }
                            Object.keys(p.geometry.morphAttributes).length > 0 && J(p, s),
                            p.name = t.createUniqueName(s.name || "mesh_" + e),
                            Q(p, s),
                            u.extensions && q(a, p, u),
                            t.assignFinalMaterial(p),
                            h.push(p)
                        }
                        for (let n = 0, i = h.length; n < i; n++)
                            t.associations.set(h[n], {
                                meshes: e,
                                primitives: n
                            });
                        if (1 === h.length)
                            return s.extensions && q(a, h[0], s),
                            h[0];
                        const d = new i.YJl;
                        s.extensions && q(a, d, s),
                        t.associations.set(d, {
                            meshes: e
                        });
                        for (let e = 0, t = h.length; e < t; e++)
                            d.add(h[e]);
                        return d
                    }
                    ))
                }
                loadCamera(e) {
                    let t;
                    const n = this.json.cameras[e]
                      , r = n[n.type];
                    if (r)
                        return "perspective" === n.type ? t = new i.ubm(i.cj9.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : "orthographic" === n.type && (t = new i.qUd(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
                        n.name && (t.name = this.createUniqueName(n.name)),
                        Q(t, n),
                        Promise.resolve(t);
                    console.warn("THREE.GLTFLoader: Missing camera parameters.")
                }
                loadSkin(e) {
                    const t = this.json.skins[e]
                      , n = [];
                    for (let e = 0, i = t.joints.length; e < i; e++)
                        n.push(this._loadNodeShallow(t.joints[e]));
                    return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                    Promise.all(n).then((function(e) {
                        const n = e.pop()
                          , r = e
                          , a = []
                          , s = [];
                        for (let e = 0, o = r.length; e < o; e++) {
                            const o = r[e];
                            if (o) {
                                a.push(o);
                                const t = new i.kn4;
                                null !== n && t.fromArray(n.array, 16 * e),
                                s.push(t)
                            } else
                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                        }
                        return new i.EAD(a,s)
                    }
                    ))
                }
                loadAnimation(e) {
                    const t = this.json
                      , n = this
                      , r = t.animations[e]
                      , a = r.name ? r.name : "animation_" + e
                      , s = []
                      , o = []
                      , l = []
                      , c = []
                      , h = [];
                    for (let e = 0, t = r.channels.length; e < t; e++) {
                        const t = r.channels[e]
                          , n = r.samplers[t.sampler]
                          , i = t.target
                          , a = i.node
                          , d = void 0 !== r.parameters ? r.parameters[n.input] : n.input
                          , u = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
                        void 0 !== i.node && (s.push(this.getDependency("node", a)),
                        o.push(this.getDependency("accessor", d)),
                        l.push(this.getDependency("accessor", u)),
                        c.push(n),
                        h.push(i))
                    }
                    return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l), Promise.all(c), Promise.all(h)]).then((function(e) {
                        const t = e[0]
                          , s = e[1]
                          , o = e[2]
                          , l = e[3]
                          , c = e[4]
                          , h = [];
                        for (let e = 0, i = t.length; e < i; e++) {
                            const i = t[e]
                              , r = s[e]
                              , a = o[e]
                              , d = l[e]
                              , u = c[e];
                            if (void 0 === i)
                                continue;
                            i.updateMatrix && i.updateMatrix();
                            const p = n._createAnimationTracks(i, r, a, d, u);
                            if (p)
                                for (let e = 0; e < p.length; e++)
                                    h.push(p[e])
                        }
                        const d = new i.tz3(a,void 0,h);
                        return Q(d, r),
                        d
                    }
                    ))
                }
                createNodeMesh(e) {
                    const t = this.json
                      , n = this
                      , i = t.nodes[e];
                    return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                        const t = n._getNodeRef(n.meshCache, i.mesh, e);
                        return void 0 !== i.weights && t.traverse((function(e) {
                            if (e.isMesh)
                                for (let t = 0, n = i.weights.length; t < n; t++)
                                    e.morphTargetInfluences[t] = i.weights[t]
                        }
                        )),
                        t
                    }
                    ))
                }
                loadNode(e) {
                    const t = this
                      , n = this.json.nodes[e]
                      , i = t._loadNodeShallow(e)
                      , r = []
                      , a = n.children || [];
                    for (let e = 0, n = a.length; e < n; e++)
                        r.push(t.getDependency("node", a[e]));
                    const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                    return Promise.all([i, Promise.all(r), s]).then((function(e) {
                        const t = e[0]
                          , n = e[1]
                          , i = e[2];
                        null !== i && t.traverse((function(e) {
                            e.isSkinnedMesh && e.bind(i, $)
                        }
                        ));
                        for (let e = 0, i = n.length; e < i; e++)
                            t.add(n[e]);
                        return t
                    }
                    ))
                }
                _loadNodeShallow(e) {
                    const t = this.json
                      , n = this.extensions
                      , r = this;
                    if (void 0 !== this.nodeCache[e])
                        return this.nodeCache[e];
                    const a = t.nodes[e]
                      , s = a.name ? r.createUniqueName(a.name) : ""
                      , o = []
                      , l = r._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }
                    ));
                    return l && o.push(l),
                    void 0 !== a.camera && o.push(r.getDependency("camera", a.camera).then((function(e) {
                        return r._getNodeRef(r.cameraCache, a.camera, e)
                    }
                    ))),
                    r._invokeAll((function(t) {
                        return t.createNodeAttachment && t.createNodeAttachment(e)
                    }
                    )).forEach((function(e) {
                        o.push(e)
                    }
                    )),
                    this.nodeCache[e] = Promise.all(o).then((function(t) {
                        let o;
                        if (o = !0 === a.isBone ? new i.$Kf : t.length > 1 ? new i.YJl : 1 === t.length ? t[0] : new i.B69,
                        o !== t[0])
                            for (let e = 0, n = t.length; e < n; e++)
                                o.add(t[e]);
                        if (a.name && (o.userData.name = a.name,
                        o.name = s),
                        Q(o, a),
                        a.extensions && q(n, o, a),
                        void 0 !== a.matrix) {
                            const e = new i.kn4;
                            e.fromArray(a.matrix),
                            o.applyMatrix4(e)
                        } else
                            void 0 !== a.translation && o.position.fromArray(a.translation),
                            void 0 !== a.rotation && o.quaternion.fromArray(a.rotation),
                            void 0 !== a.scale && o.scale.fromArray(a.scale);
                        if (r.associations.has(o)) {
                            if (void 0 !== a.mesh && r.meshCache.refs[a.mesh] > 1) {
                                const e = r.associations.get(o);
                                r.associations.set(o, {
                                    ...e
                                })
                            }
                        } else
                            r.associations.set(o, {});
                        return r.associations.get(o).nodes = e,
                        o
                    }
                    )),
                    this.nodeCache[e]
                }
                loadScene(e) {
                    const t = this.extensions
                      , n = this.json.scenes[e]
                      , r = this
                      , a = new i.YJl;
                    n.name && (a.name = r.createUniqueName(n.name)),
                    Q(a, n),
                    n.extensions && q(t, a, n);
                    const s = n.nodes || []
                      , o = [];
                    for (let e = 0, t = s.length; e < t; e++)
                        o.push(r.getDependency("node", s[e]));
                    return Promise.all(o).then((function(e) {
                        for (let t = 0, n = e.length; t < n; t++)
                            a.add(e[t]);
                        return r.associations = (e => {
                            const t = new Map;
                            for (const [e,n] of r.associations)
                                (e instanceof i.imn || e instanceof i.gPd) && t.set(e, n);
                            return e.traverse((e => {
                                const n = r.associations.get(e);
                                null != n && t.set(e, n)
                            }
                            )),
                            t
                        }
                        )(a),
                        a
                    }
                    ))
                }
                _createAnimationTracks(e, t, n, r, a) {
                    const s = []
                      , o = e.name ? e.name : e.uuid
                      , l = [];
                    let c;
                    switch (W[a.path] === W.weights ? e.traverse((function(e) {
                        e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid)
                    }
                    )) : l.push(o),
                    W[a.path]) {
                    case W.weights:
                        c = i.Hit;
                        break;
                    case W.rotation:
                        c = i.MBL;
                        break;
                    case W.translation:
                    case W.scale:
                        c = i.RiT;
                        break;
                    default:
                        if (1 === n.itemSize)
                            c = i.Hit;
                        else
                            c = i.RiT
                    }
                    const h = void 0 !== r.interpolation ? V[r.interpolation] : i.PJ3
                      , d = this._getArrayFromAccessor(n);
                    for (let e = 0, n = l.length; e < n; e++) {
                        const n = new c(l[e] + "." + W[a.path],t.array,d,h);
                        "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n),
                        s.push(n)
                    }
                    return s
                }
                _getArrayFromAccessor(e) {
                    let t = e.array;
                    if (e.normalized) {
                        const e = Z(t.constructor)
                          , n = new Float32Array(t.length);
                        for (let i = 0, r = t.length; i < r; i++)
                            n[i] = t[i] * e;
                        t = n
                    }
                    return t
                }
                _createCubicSplineTrackInterpolant(e) {
                    e.createInterpolant = function(e) {
                        return new (this instanceof i.MBL ? z : L)(this.times,this.values,this.getValueSize() / 3,e)
                    }
                    ,
                    e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                }
            }
            function te(e, t, n) {
                const r = t.attributes
                  , a = [];
                function s(t, i) {
                    return n.getDependency("accessor", t).then((function(t) {
                        e.setAttribute(i, t)
                    }
                    ))
                }
                for (const t in r) {
                    const n = O[t] || t.toLowerCase();
                    n in e.attributes || a.push(s(r[t], n))
                }
                if (void 0 !== t.indices && !e.index) {
                    const i = n.getDependency("accessor", t.indices).then((function(t) {
                        e.setIndex(t)
                    }
                    ));
                    a.push(i)
                }
                return i.ppV.workingColorSpace !== i.Zr2 && "COLOR_0"in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${i.ppV.workingColorSpace}" not supported.`),
                Q(e, t),
                function(e, t, n) {
                    const r = t.attributes
                      , a = new i.NRn;
                    if (void 0 === r.POSITION)
                        return;
                    {
                        const e = n.json.accessors[r.POSITION]
                          , t = e.min
                          , s = e.max;
                        if (void 0 === t || void 0 === s)
                            return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (a.set(new i.Pq0(t[0],t[1],t[2]), new i.Pq0(s[0],s[1],s[2])),
                        e.normalized) {
                            const t = Z(D[e.componentType]);
                            a.min.multiplyScalar(t),
                            a.max.multiplyScalar(t)
                        }
                    }
                    const s = t.targets;
                    if (void 0 !== s) {
                        const e = new i.Pq0
                          , t = new i.Pq0;
                        for (let i = 0, r = s.length; i < r; i++) {
                            const r = s[i];
                            if (void 0 !== r.POSITION) {
                                const i = n.json.accessors[r.POSITION]
                                  , a = i.min
                                  , s = i.max;
                                if (void 0 !== a && void 0 !== s) {
                                    if (t.setX(Math.max(Math.abs(a[0]), Math.abs(s[0]))),
                                    t.setY(Math.max(Math.abs(a[1]), Math.abs(s[1]))),
                                    t.setZ(Math.max(Math.abs(a[2]), Math.abs(s[2]))),
                                    i.normalized) {
                                        const e = Z(D[i.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else
                                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        a.expandByVector(e)
                    }
                    e.boundingBox = a;
                    const o = new i.iyt;
                    a.getCenter(o.center),
                    o.radius = a.min.distanceTo(a.max) / 2,
                    e.boundingSphere = o
                }(e, t, n),
                Promise.all(a).then((function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let i = !1
                          , r = !1
                          , a = !1;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            if (void 0 !== n.POSITION && (i = !0),
                            void 0 !== n.NORMAL && (r = !0),
                            void 0 !== n.COLOR_0 && (a = !0),
                            i && r && a)
                                break
                        }
                        if (!i && !r && !a)
                            return Promise.resolve(e);
                        const s = []
                          , o = []
                          , l = [];
                        for (let c = 0, h = t.length; c < h; c++) {
                            const h = t[c];
                            if (i) {
                                const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                                s.push(t)
                            }
                            if (r) {
                                const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                                o.push(t)
                            }
                            if (a) {
                                const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(s), Promise.all(o), Promise.all(l)]).then((function(t) {
                            const n = t[0]
                              , s = t[1]
                              , o = t[2];
                            return i && (e.morphAttributes.position = n),
                            r && (e.morphAttributes.normal = s),
                            a && (e.morphAttributes.color = o),
                            e.morphTargetsRelative = !0,
                            e
                        }
                        ))
                    }(e, t.targets, n) : e
                }
                ))
            }
        }
        ,
        7943: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_triangle.svg"
        }
        ,
        7980: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => d,
                _: () => h
            });
            var i = n(7680)
              , r = n(8438)
              , a = n(5169)
              , s = n(4183)
              , o = n(2203)
              , l = n(8566)
              , c = n(405);
            function h(e) {
                if ("object" != typeof e || null == e)
                    return null;
                if (!("parts"in e) || "object" != typeof e.parts || null == e.parts)
                    return null;
                const t = e.parts
                  , n = new r.A(a.A.Summer,new i.A)
                  , h = Object.keys(t);
                for (const e of h) {
                    const i = parseInt(e, 10);
                    if (!(i in o.A))
                        return null;
                    {
                        const e = t[i];
                        if (!Array.isArray(e))
                            return null;
                        if (e.length % 4 != 0)
                            return null;
                        for (let t = 0; t < e.length; t += 4) {
                            const r = e[t + 0]
                              , a = e[t + 1]
                              , o = e[t + 2]
                              , h = e[t + 3];
                            if ("number" != typeof r || "number" != typeof a || "number" != typeof o || "number" != typeof h)
                                return null;
                            if (!(Number.isSafeInteger(r) && Number.isSafeInteger(a) && Number.isSafeInteger(o) && Number.isSafeInteger(h)))
                                return null;
                            if (!(h >= 0 && h <= 3 && Math.abs(r) <= 1e9 && a >= 0 && a <= 1e9 && Math.abs(o) <= 1e9))
                                return null;
                            {
                                if (c.bK.includes(i))
                                    return null;
                                let e = null;
                                c.l1.includes(i) && (e = 0),
                                n.addPart(4 * r, a, 4 * o, i, h, l.A.YPositive, s.A.Default, null, e)
                            }
                        }
                    }
                }
                return n
            }
            function d(e) {
                let t, n;
                try {
                    t = JSON.parse(e)
                } catch (e) {
                    return console.warn(e),
                    null
                }
                if ("object" != typeof t || null == t)
                    return null;
                if (!("name"in t) || "string" != typeof t.name)
                    return null;
                if (!("track"in t) || "string" != typeof t.track)
                    return null;
                try {
                    n = JSON.parse(t.track)
                } catch (e) {
                    return console.warn(e),
                    null
                }
                const i = h(n);
                return null == i ? null : {
                    trackMetadata: {
                        name: t.name,
                        author: null,
                        lastModified: null
                    },
                    trackData: i
                }
            }
        }
        ,
        8115: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/community_tracks.jpg"
        }
        ,
        8237: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/settings.svg"
        }
        ,
        8330: e => {
            "use strict";
            e.exports = JSON.parse('{"rE":"0.6.0","l$":{"r":1,"M":1}}')
        }
        ,
        8353: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => m
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)
              , o = n(4417)
              , l = n.n(o)
              , c = new URL(n(9391),n.b)
              , h = new URL(n(8115),n.b)
              , d = new URL(n(2709),n.b)
              , u = s()(r())
              , p = l()(c)
              , f = l()(h)
              , g = l()(d);
            u.push([e.id, `.track-selection-ui {\n\tposition: absolute;\n\tbottom: 0;\n\tdisplay: flex;\n\tflex-direction: column;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n\ttext-align: left;\n}\n.track-selection-ui.hidden {\n\tdisplay: none;\n}\n\n.track-selection-ui > .safe-area-left {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: var(--safe-area-left);\n\theight: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.track-selection-ui > .safe-area-right {\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tz-index: 1;\n\twidth: var(--safe-area-right);\n\theight: 100%;\n\tbackground-color: var(--surface-color);\n}\n\n.track-selection-ui > .bar {\n\tdisplay: flex;\n\tmargin: 0;\n\tpadding: 0 var(--safe-area-right) 0 var(--safe-area-left);\n\twidth: 100%;\n\tbox-sizing: border-box;\n\tbackground-color: var(--surface-color);\n\ttext-align: left;\n\n\tpointer-events:auto;\n}\n.track-selection-ui > .bar > .button {\n\tmargin: 8px 12px;\n}\n\n.track-selection-ui > .bar > .search-bar-container {\n\tposition: relative;\n\tdisplay: flex;\n\tflex-grow: 1;\n}\n.track-selection-ui > .bar > .search-bar-container > input {\n\tmargin: 8px -10px;\n\tpadding: 0 20px;\n\tflex-grow: 1;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tcolor: var(--text-color);\n\ttext-indent: 2px; /* Without this the italic text will be cut off on the left side. */\n}\n.track-selection-ui > .bar > .search-bar-container > img {\n\tmargin: 8px -10px 8px 0;\n\tpadding: 0 16px;\n\twidth: 24px;\n\tbackground-color: var(--button-hover-color);\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n.track-selection-ui .category-container {\n\tdisplay: flex;\n\tpadding: 0 var(--safe-area-right) 0 var(--safe-area-left);\n\tbackground-color: var(--surface-secondary-color);\n}\n.track-selection-ui .category-container > button {\n\tposition: relative;\n\tmargin: 0 -3px;\n\tpadding: 0.6em 0;\n\tflex-grow: 1;\n\tbackground-color: transparent;\n\tfont-size: 2.8vw;\n\tfont-weight: bold;\n\ttext-shadow: 2px 2px 0 #112052, 0 0 10px #000, 0 0 10px #000;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.track-selection-ui .category-container > button:first-of-type {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n.track-selection-ui .category-container > button:last-of-type {\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n}\n.track-selection-ui .category-container > button::before {\n\tcontent: "";\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tz-index: -1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-position: center;\n\tbackground-size: cover;\n\tfilter: blur(2px);\n\ttransition: filter 0.2s ease-in-out,  0.2s ease-in-out;\n}\n.track-selection-ui .category-container > button.official::before {\n\tbackground-image: url(${p});\n}\n.track-selection-ui .category-container > button.community::before {\n\tbackground-image: url(${f});\n}\n.track-selection-ui .category-container > button.custom::before {\n\tbackground-image: url(${g});\n}\n.track-selection-ui .category-container > button:hover::before {\n\tfilter: none;\n\ttransform: scale(1.1);\n}\n@media (hover: none) {\n\t.track-selection-ui .category-container > button:hover::before {\n\t\tfilter: blur(2px);\n\t\ttransform: none;\n\t}\n\n\t.track-selection-ui .category-container > button:active::before {\n\t\tfilter: none;\n\t\ttransform: scale(1.1);\n\t}\n}\n.track-selection-ui .category-container > button.selected::before {\n\tfilter: none;\n}\n.track-selection-ui .category-container > button::after {\n\tbackground-color: transparent;\n}\n.track-selection-ui .category-container > button.selected::after {\n\twidth: 100%;\n}\n\n.track-selection-ui .category-container > button > .cover {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n\tz-index: -1;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: rgba(17, 32, 82, 0.75);\n\ttransition: background-color 0.2s ease-in-out;\n}\n.track-selection-ui .category-container > button:hover > .cover {\n\tbackground-color: rgba(51, 75, 119, 0.5);\n}\n@media (hover: none) {\n\t.track-selection-ui .category-container > button:hover > .cover {\n\t\tbackground-color: rgba(17, 32, 82, 0.75);\n\t}\n}\n.track-selection-ui .category-container > button:active > .cover {\n\tbackground-color: rgba(21, 31, 65, 0.5);\n}\n.track-selection-ui .category-container > button.selected > .cover {\n\tbackground-color: transparent;\n}\n\n@media (max-width: 1150px) {\n\t.track-selection-ui .category-container > button {\n\t\tfont-size: 32.2px;\n\t}\n}\n\n.track-selection-ui .tracks-container {\n\tmargin: 0;\n\tpadding: 20px calc(60px + var(--safe-area-right)) 20px calc(60px + var(--safe-area-left));\n\tbox-sizing: border-box;\n\twidth: 100%;\n\tflex-grow: 1;\n\toverflow-y: auto;\n\tpointer-events: auto;\n\tdisplay: none;\n}\n.track-selection-ui .tracks-container.open {\n\tdisplay: block;\n}\n.track-selection-ui.with-background .tracks-container {\n\tbackground-color: rgba(20, 20, 45, 0.8);\n\t-webkit-backdrop-filter: blur(4px);\n\tbackdrop-filter: blur(4px);\n}\n\n.track-selection-ui .tracks-container.no-group-containers {\n\tpadding-top: 50px;\n}\n\n.track-selection-ui .tracks-container > .empty {\n\tmargin: 100px;\n\tcolor: var(--text-color);\n\ttext-align: center;\n}\n.track-selection-ui .tracks-container > .empty > .title {\n\tfont-size: 48px;\n}\n.track-selection-ui .tracks-container > .empty > .description {\n\tmargin: 20px 0 0 0;\n\tfont-size: 32px;\n\topacity: 0.75;\n}\n\n.track-selection-ui .group-title {\n\tmargin: 0.5em 0.4em;\n\tpadding: 0;\n\tfont-size: 50px;\n\tfont-weight: normal;\n\tborder-bottom-width: 4px;\n\tborder-bottom-style: solid;\n\tcolor: var(--text-color);\n\tborder-image: linear-gradient(to right, var(--text-color), transparent) 1;\n\t\n}\n.track-selection-ui .group-title.winter {\n\tcolor: #bed8f7;\n\tborder-image: linear-gradient(to right, #bed8f7, transparent) 1;\n}\n.track-selection-ui .group-title.desert {\n\tcolor: #ede2af;\n\tborder-image: linear-gradient(to right, #ede2af, transparent) 1;\n}\n\n.track-selection-ui .group-title > img {\n\tmargin: 6px 8px;\n\twidth: 36px;\n\theight: 36px;\n\tvertical-align: bottom;\n}\n\n.track-selection-ui .tracks-container .track {\n\tposition: relative;\n\tdisplay: inline-block;\n}\n\n.track-selection-ui .tracks-container .track button {\n\tmargin: 10px;\n\tpadding: 0;\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n}\n.track-selection-ui .tracks-container .track button:after {\n\tborder-bottom: none;\n}\n.track-selection-ui .tracks-container .track button:focus-visible {\n\ttext-decoration: none;\n}\n\n.track-selection-ui .track-title {\n\tmargin: 0;\n\tpadding: 4px;\n\tfont-size: 25px;\n\tbackground-color: var(--surface-secondary-color);\n}\n.track-selection-ui .tracks-container .track button:focus-visible .track-title {\n\ttext-decoration: underline;\n}\n.track-selection-ui .track-title > p {\n\tmargin: 0;\n\tpadding: 0 22px;\n\twidth: 208px;\n\tbox-sizing: border-box;\n\twhite-space: nowrap;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n}\n\n.track-selection-ui .track > .button > canvas, .track-selection-ui .track > .button > img:not(.environment) {\n\tmargin: 0;\n\tpadding: 20px 40px;\n\twidth: 128px;\n\theight: 128px;\n\tobject-fit: contain;\n\t-webkit-filter: drop-shadow(0 0 3px #000);\n\tfilter: drop-shadow(0 0 3px #000);\n\timage-rendering: pixelated;\n\tpointer-events: none;\n}\n\n.track-selection-ui .track .environment {\n\tposition: absolute;\n\tright: 14px;\n\tbottom: 40px;\n\twidth: 24px;\n\topacity: 0.2;\n\tpointer-events: none;\n}\n\n.track-selection-ui .record {\n\tmargin: 0;\n\tpadding: 4px;\n\tfont-size: 24px;\n\tbackground-color: var(--surface-secondary-color);\n\tcolor: var(--text-color);\n}\n\n.track-selection-ui .delete-button {\n\tposition: absolute;\n\ttop: 7px;\n\tright: 6px;\n\tmargin: 0;\n\tpadding: 0;\n\tline-height: 0;\n\tborder-radius: 2px;\n\tborder: none;\n\tbackground-color: var(--button-color);\n\n\tpointer-events: auto;\n\tcursor: pointer;\n}\n.track-selection-ui .delete-button:hover {\n\tbackground-color: var(--button-hover-color);\n}\n@media (hover: none) {\n\t.track-selection-ui .delete-button:hover {\n\t\tbackground-color: var(--button-color);\n\t}\n}\n.track-selection-ui .delete-button:active {\n\tbackground-color: var(--button-active-color);\n}\n.track-selection-ui .delete-button > img {\n\tmargin: 0;\n\tpadding: 0;\n\theight: 20px;\n\tvertical-align: top;\n\tpointer-events: none;\n}\n`, ""]);
            const m = u
        }
        ,
        8358: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/overlapping_disabled.svg"
        }
        ,
        8419: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => m
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)
              , o = n(4417)
              , l = n.n(o)
              , c = new URL(n(3682),n.b)
              , h = new URL(n(2208),n.b)
              , d = new URL(n(2832),n.b)
              , u = s()(r())
              , p = l()(c)
              , f = l()(h)
              , g = l()(d);
            u.push([e.id, `:root {\n\tinterpolate-size: allow-keywords; \n\n\t--text-color: #fff;\n\t--text-disabled-color: #5d6a7c;\n\t--surface-color: #28346a;\n\t--surface-secondary-color: #212b58;\n\t--surface-tertiary-color: #192042;\n\t--surface-transparent-color: rgba(40, 52, 106, 0.5);\n\t--button-color: #112052;\n\t--button-hover-color: #334b77;\n\t--button-active-color: #151f41;\n\t--button-disabled-color: #313d53;\n\n\t/* Set by JS */\n\t--ui-scale-factor: 1.0;\n\n\t--safe-area-left-unscaled: env(safe-area-inset-left, 0px);\n\t--safe-area-right-unscaled: env(safe-area-inset-right, 0px);\n\t--safe-area-top-unscaled: env(safe-area-inset-top, 0px);\n\t--safe-area-bottom-unscaled: env(safe-area-inset-bottom, 0px);\n\n\t--safe-area-left: calc(var(--safe-area-left-unscaled) / var(--ui-scale-factor));\n\t--safe-area-right: calc(var(--safe-area-right-unscaled) / var(--ui-scale-factor));\n\t--safe-area-horizontal: max(var(--safe-area-left), var(--safe-area-right));\n\n\t--safe-area-top: calc(var(--safe-area-top-unscaled) / var(--ui-scale-factor));\n\t--safe-area-bottom: calc(var(--safe-area-bottom-unscaled) / var(--ui-scale-factor));\n\t--safe-area-vertical: max(var(--safe-area-top), var(--safe-area-bottom));\n}\n\n@font-face {\n\tfont-family: ForcedSquare;\n\tsrc:\n\t\turl(${p}) format("woff2"),\n\t\turl(${f}) format("woff"),\n\t\turl(${g}) format("truetype");\n}\n\nhtml, body {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n\toverflow: hidden;\n\toverscroll-behavior: none;\n\n\tbackground: #000;\n}\n\nbody {\n\tscrollbar-color: #7272c2 #223;\n\ttouch-action: none;\n}\n\n* {\n\tfont-style: italic;\n\tfont-family: ForcedSquare, Arial, sans-serif;\n\tline-height: 1;\n}\n\n#screen {\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\theight: 100%;\n\t-webkit-tap-highlight-color: transparent;\n\t-webkit-touch-callout: none;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\ttouch-action: none;\n}\n\n#ui {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\ttransform-origin: 0 0;\n\tpointer-events: none;\n\t-webkit-tap-highlight-color: transparent;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n}\n\n::-webkit-scrollbar {\n\twidth: 8px;\n\tbackground-color: #223;\n}\n::-webkit-scrollbar-thumb {\n\tborder-radius: 4px;\n\tbackground-color: #7272c2;\n}\n\n::selection {\n\tbackground-color:  #5936d6;\n\tcolor:  #fff;\n}\n\n.hide-cursor {\n\tcursor: none;\n}\n\n.hidden {\n\tdisplay: none;\n}\n\ninput[type="text"] {\n\tmargin: 0;\n\tpadding: 4px 8px;\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tfont-size: 24px;\n\tfont-weight: bold;\n\ttext-indent: 6px; /* Fixes italic text being cut off. */\n\tcolor: var(--text-color);\n\tbackground-color: var(--surface-tertiary-color);\n\tborder: none;\n\tpointer-events: auto;\n}\ninput[type="text"]::placeholder {\n\tcolor: var(--text-color);\n\topacity: 0.25;\n}\ninput[type="text"]:focus-visible {\n\toutline: none;\n}\n\ninput[type="range"] {\n\tmargin: 0;\n\tpadding: 0;\n\t-webkit-appearance: none;\n\tappearance: none;\n\tbackground: transparent;\n\tcursor: pointer;\n\taccent-color: var(--text-color);\n}\ninput[type="range"]::-webkit-slider-runnable-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\ninput[type="range"]::-moz-range-track {\n\tbackground-color: var(--surface-tertiary-color);\n\theight: 10px;\n}\ninput[type="range"]::-webkit-slider-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 32px;\n\theight: 32px;\n\tmargin: -13px 0 0 0;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\ninput[type="range"]::-webkit-slider-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\tinput[type="range"]::-webkit-slider-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\ninput[type="range"]::-webkit-slider-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\ninput[type="range"]::-moz-range-thumb {\n\t-webkit-appearance: none;\n\tappearance: none;\n\tborder-radius: 0;\n\tbackground: var(--text-color);\n\twidth: 24px;\n\theight: 24px;\n\tborder: 4px solid var(--button-color);\n\toutline: 2px solid var(--text-color);\n}\ninput[type="range"]::-moz-range-thumb:hover {\n\tborder: 4px solid var(--button-hover-color);\n}\n@media (hover: none) {\n\tinput[type="range"]::-moz-range-thumb:hover {\n\t\tborder: 4px solid var(--button-color);\n\t}\n}\ninput[type="range"]::-moz-range-thumb:active {\n\tborder: 4px solid var(--button-active-color);\n}\n\n.button {\n\tposition: relative;\n\tmargin: 0;\n\tpadding: 8px 18px;\n\tbackground-color: var(--button-color);\n\tborder: none;\n\tclip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n\tcolor: var(--text-color);\n\tfont-size: 32px;\n\n\tpointer-events: auto;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\tcursor: pointer;\n}\n.button::after {\n\tcontent: "";\n\tposition: absolute;\n\tleft: 0;\n\tbottom: 0;\n\tz-index: -1;\n\twidth: 0;\n\theight: 100%;\n\tbackground-color: var(--button-hover-color);\n\tborder-bottom: 2px solid var(--text-color);\n\ttransition: width 0.1s ease-in-out;\n}\n.button:hover::after {\n\twidth: 100%;\n}\n@media (hover: none) {\n\t.button::after {\n\t\tbackground-color: var(--button-active-color);\n\t}\n\n\t.button:hover::after {\n\t\twidth: 0;\n\t}\n}\n.button:active::after {\n\tbackground-color: var(--button-active-color);\n\twidth: 100%;\n}\n.button:focus-visible {\n\tbackground-color: var(--button-hover-color);\n\ttext-decoration: underline;\n\toutline: none;\n}\n.button > img.button-icon {\n\tmargin: -6px -4px 0 -4px;\n\tpadding: 0;\n\twidth: 32px;\n\theight: 32px;\n\tvertical-align: middle;\n\tpointer-events: none;\n}\n.button:disabled {\n\tbackground-color: var(--button-disabled-color);\n\tcolor: var(--text-disabled-color);\n\tcursor: default;\n}\n.button:disabled:after {\n\tcontent: none;\n}\n.button:disabled > img.button-icon {\n\topacity: 0.3;\n}\n`, ""]);
            const m = u
        }
        ,
        8438: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => M
            });
            var i, r, a, s, o, l, c, h, d = n(1635), u = n(3075), p = n(1312), f = n(4922), g = n(7415), m = n(7980), A = n(666), v = n(5343), y = n(8928), w = n(5440), b = n(9681), x = n(2247), S = n(8971), E = n(5169), T = n(405), k = n(5735);
            r = new WeakMap,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            l = new WeakMap,
            i = new WeakSet,
            c = function() {
                let e = -1 / 0
                  , t = null;
                for (const n of (0,
                d.gn)(this, o, "f")) {
                    const i = (0,
                    d.gn)(this, l, "f").get(n);
                    if (null == i)
                        throw new Error("Part list does not exist");
                    const r = (0,
                    T.Hw)(n).startOffset;
                    if (i.length > 0 && null != r)
                        for (const n of i) {
                            if (null == n.startOrder)
                                throw new Error("Start part has no start order");
                            n.startOrder >= e && (e = n.startOrder,
                            t = {
                                part: n,
                                startOffset: r
                            })
                        }
                }
                return null != t ? {
                    x: t.part.x,
                    y: t.part.y,
                    z: t.part.z,
                    rotation: t.part.rotation,
                    rotationAxis: t.part.rotationAxis,
                    startOffset: t.startOffset.clone()
                } : null
            }
            ,
            h = function() {
                const e = [];
                e.push((0,
                d.gn)(this, a, "f")),
                e.push((0,
                d.gn)(this, s, "f").representation);
                let t = 1 / 0
                  , n = 1 / 0
                  , i = 1 / 0
                  , r = -1 / 0
                  , c = -1 / 0
                  , h = -1 / 0;
                for (const [,e] of (0,
                d.gn)(this, l, "f"))
                    for (const a of e)
                        t = Math.min(a.x, t),
                        n = Math.min(a.y, n),
                        i = Math.min(a.z, i),
                        r = Math.max(a.x, r),
                        c = Math.max(a.y, c),
                        h = Math.max(a.z, h);
                Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) && Number.isFinite(r) && Number.isFinite(c) && Number.isFinite(h) || (t = 0,
                n = 0,
                i = 0,
                r = 0,
                c = 0,
                h = 0);
                const u = r - t + 1
                  , p = c - n + 1
                  , f = h - i + 1
                  , g = Math.max(1, Math.min(4, Math.ceil(Math.log2(u + 1) / 8)))
                  , m = Math.max(1, Math.min(4, Math.ceil(Math.log2(p + 1) / 8)))
                  , A = Math.max(1, Math.min(4, Math.ceil(Math.log2(f + 1) / 8)));
                e.push(255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, 255 & n, n >>> 8 & 255, n >>> 16 & 255, n >>> 24 & 255, 255 & i, i >>> 8 & 255, i >>> 16 & 255, i >>> 24 & 255, 255 & (g | m << 2 | A << 4));
                for (const r of (0,
                d.gn)(this, o, "f")) {
                    const a = (0,
                    d.gn)(this, l, "f").get(r);
                    if (null == a)
                        throw new Error("Part list does not exist");
                    if (r < 0 || r > 255)
                        throw new Error("Part id is out of range");
                    const s = a.length;
                    e.push(255 & r, 255 & s, s >>> 8 & 255, s >>> 16 & 255, s >>> 24 & 255);
                    for (const s of a) {
                        const a = s.x - t
                          , o = s.y - n
                          , l = s.z - i;
                        if (1 == g ? e.push(255 & a) : 2 == g ? e.push(255 & a, a >>> 8 & 255) : 3 == g ? e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255) : 4 == g && e.push(255 & a, a >>> 8 & 255, a >>> 16 & 255, a >>> 24 & 255),
                        1 == m ? e.push(255 & o) : 2 == m ? e.push(255 & o, o >>> 8 & 255) : 3 == m ? e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255) : 4 == m && e.push(255 & o, o >>> 8 & 255, o >>> 16 & 255, o >>> 24 & 255),
                        1 == A ? e.push(255 & l) : 2 == A ? e.push(255 & l, l >>> 8 & 255) : 3 == A ? e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255) : 4 == A && e.push(255 & l, l >>> 8 & 255, l >>> 16 & 255, l >>> 24 & 255),
                        e.push(255 & (3 & s.rotation | (7 & s.rotationAxis) << 2), 255 & s.color),
                        T.bK.includes(r)) {
                            if (null == s.checkpointOrder)
                                throw new Error("Checkpoint has no checkpoint order");
                            e.push(255 & s.checkpointOrder, s.checkpointOrder >>> 8 & 255)
                        }
                        if (T.l1.includes(r)) {
                            if (null == s.startOrder)
                                throw new Error("Start has no start order");
                            e.push(255 & s.startOrder, s.startOrder >>> 8 & 255, s.startOrder >>> 16 & 255, s.startOrder >>> 24 & 255)
                        }
                    }
                }
                return new Uint8Array(e)
            }
            ;
            const M = class {
                constructor(e, t) {
                    i.add(this),
                    r.set(this, null),
                    a.set(this, void 0),
                    s.set(this, void 0),
                    o.set(this, []),
                    l.set(this, new Map),
                    (0,
                    d.GG)(this, a, e, "f"),
                    (0,
                    d.GG)(this, s, t.clone(), "f")
                }
                get environment() {
                    return (0,
                    d.gn)(this, a, "f")
                }
                set environment(e) {
                    (0,
                    d.GG)(this, r, null, "f"),
                    (0,
                    d.GG)(this, a, e, "f")
                }
                get sunDirection() {
                    return (0,
                    d.gn)(this, s, "f").clone()
                }
                set sunDirection(e) {
                    (0,
                    d.GG)(this, r, null, "f"),
                    (0,
                    d.GG)(this, s, e.clone(), "f")
                }
                get numberOfParts() {
                    let e = 0;
                    for (const t of (0,
                    d.gn)(this, l, "f").values())
                        e += t.length;
                    return e
                }
                addPart(e, t, n, i, a, s, c, h, u) {
                    (0,
                    d.GG)(this, r, null, "f");
                    const p = {
                        x: e,
                        y: t,
                        z: n,
                        rotation: a,
                        rotationAxis: s,
                        color: c,
                        checkpointOrder: h,
                        startOrder: u
                    }
                      , f = (0,
                    d.gn)(this, l, "f").get(i);
                    if (null != f) {
                        let e = 0
                          , t = f.length;
                        for (; e < t; ) {
                            const n = e + t >>> 1
                              , i = f[n];
                            (p.x - i.x || p.y - i.y || p.z - i.z || p.rotation - i.rotation || p.rotationAxis - i.rotationAxis || p.color - i.color || (p.checkpointOrder ?? -1) - (i.checkpointOrder ?? -1) || (p.startOrder ?? -1) - (i.startOrder ?? -1)) < 0 ? t = n : e = n + 1
                        }
                        f.splice(e, 0, p)
                    } else {
                        (0,
                        d.gn)(this, l, "f").set(i, [p]);
                        let e = 0
                          , t = (0,
                        d.gn)(this, o, "f").length;
                        for (; e < t; ) {
                            const n = e + t >>> 1;
                            (0,
                            d.gn)(this, o, "f")[n] < i ? e = n + 1 : t = n
                        }
                        (0,
                        d.gn)(this, o, "f").splice(e, 0, i)
                    }
                }
                forEachPart(e) {
                    for (const t of (0,
                    d.gn)(this, o, "f")) {
                        const n = (0,
                        d.gn)(this, l, "f").get(t);
                        if (null == n)
                            throw new Error("Part list does not exist");
                        for (const i of n)
                            e(i.x, i.y, i.z, t, i.rotation, i.rotationAxis, i.color, i.checkpointOrder, i.startOrder)
                    }
                }
                getId() {
                    return (0,
                    d.GG)(this, r, (0,
                    d.gn)(this, r, "f") ?? (0,
                    p.sha256)((0,
                    d.gn)(this, i, "m", h).call(this)), "f"),
                    (0,
                    d.gn)(this, r, "f")
                }
                getBounds() {
                    let e = 1 / 0
                      , t = 1 / 0
                      , n = -1 / 0
                      , i = -1 / 0;
                    return this.forEachPart(( (r, a, s) => {
                        e = Math.min(r, e),
                        t = Math.min(s, t),
                        n = Math.max(r, n),
                        i = Math.max(s, i)
                    }
                    )),
                    Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? {
                        min: new f.I9Y(e,t),
                        max: new f.I9Y(n,i)
                    } : {
                        min: new f.I9Y,
                        max: new f.I9Y
                    }
                }
                hasStartingPoint() {
                    return null != (0,
                    d.gn)(this, i, "m", c).call(this)
                }
                getStartTransform() {
                    const e = (0,
                    d.gn)(this, i, "m", c).call(this);
                    if (null != e) {
                        const t = k.hT(e.rotation, e.rotationAxis).multiply((new f.PTz).setFromEuler(new f.O9p(0,Math.PI,0)))
                          , n = e.startOffset;
                        return n.applyQuaternion(t),
                        {
                            position: new f.Pq0(e.x * S.A.partSize + n.x,e.y * S.A.partSize + n.y,e.z * S.A.partSize + n.z),
                            quaternion: t
                        }
                    }
                    return null
                }
                toSaveString() {
                    const e = (0,
                    d.gn)(this, i, "m", h).call(this)
                      , t = new u.Ay.Deflate({
                        level: 9,
                        windowBits: 9,
                        memLevel: 9
                    });
                    t.push(e, !0);
                    const n = g.l(t.result)
                      , r = new u.Ay.Deflate({
                        level: 9,
                        windowBits: 15,
                        memLevel: 9
                    });
                    return r.push(n, !0),
                    g.l(r.result)
                }
                toExportString(e) {
                    const t = (new TextEncoder).encode(e.name);
                    let n, r;
                    null != e.author ? (r = (new TextEncoder).encode(e.author),
                    n = r.length) : (r = null,
                    n = 0);
                    const a = [];
                    if (null == e.lastModified)
                        a.push(0);
                    else {
                        a.push(1);
                        const t = Math.floor(e.lastModified.getTime() / 1e3);
                        a.push(255 & t, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255)
                    }
                    const s = new Uint8Array(1 + t.length + 1 + n + a.length);
                    s[0] = t.length,
                    s.set(t, 1),
                    s[1 + t.length] = n,
                    null != r && s.set(r, 1 + t.length + 1),
                    s.set(a, 1 + t.length + 1 + n);
                    const o = (0,
                    d.gn)(this, i, "m", h).call(this)
                      , l = new u.Ay.Deflate({
                        level: 9,
                        windowBits: 9,
                        memLevel: 9
                    });
                    l.push(s, !1),
                    l.push(o, !0);
                    const c = g.l(l.result)
                      , p = new u.Ay.Deflate({
                        level: 9,
                        windowBits: 15,
                        memLevel: 9
                    });
                    return p.push(c, !0),
                    "PolyTrack2" + g.l(p.result)
                }
                static fromSaveString(e) {
                    const t = b._(e);
                    if (null != t)
                        return t;
                    const n = w._(e);
                    if (null != n)
                        return n;
                    const i = y._(e);
                    if (null != i)
                        return i;
                    const r = v._(e);
                    if (null != r)
                        return r;
                    const a = A._(e);
                    if (null != a)
                        return a;
                    const s = m._(e);
                    return null != s ? s : null
                }
                static fromExportString(e) {
                    const t = e.replace(/\s+/g, "")
                      , n = b.U(t);
                    if (null != n)
                        return n;
                    const i = w.U(t);
                    if (null != i)
                        return i;
                    const r = y.U(t);
                    if (null != r)
                        return r;
                    const a = v.U(t);
                    if (null != a)
                        return a;
                    const s = A.U(t);
                    if (null != s)
                        return s;
                    const o = m.U(e);
                    return null != o ? o : null
                }
                createThumbnail() {
                    let e = 1 / 0
                      , t = 1 / 0
                      , n = -1 / 0
                      , i = -1 / 0;
                    this.forEachPart(( (r, a, s, o, l, c) => {
                        (0,
                        T.Hw)(o).tiles.rotated(l, c).forEach(( (a, o, l) => {
                            e = Math.min(e, Math.floor((r + a - 2) / 4)),
                            t = Math.min(t, Math.floor((s + l - 2) / 4)),
                            n = Math.max(n, Math.floor((r + a - 2) / 4)),
                            i = Math.max(i, Math.floor((s + l - 2) / 4))
                        }
                        ))
                    }
                    )),
                    Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) || (e = 0,
                    t = 0,
                    n = 0,
                    i = 0);
                    const r = 10
                      , a = n - e + 1;
                    a <= r && (n += Math.ceil((r - a) / 2),
                    e -= Math.ceil((r - a) / 2));
                    const s = i - t + 1;
                    s <= r && (i += Math.ceil((r - s) / 2),
                    t -= Math.ceil((r - s) / 2));
                    const o = document.createElement("canvas");
                    o.width = Math.min(1024, n - e + 1),
                    o.height = Math.min(1024, i - t + 1);
                    const l = o.getContext("2d");
                    if (null == l)
                        throw new Error("Failed to get canvas context");
                    const c = l.createImageData(o.width, o.height)
                      , h = []
                      , d = []
                      , u = [];
                    let p, f, g;
                    switch (this.environment) {
                    case E.A.Summer:
                        p = 255,
                        f = 255,
                        g = 255;
                        break;
                    case E.A.Winter:
                        p = 190,
                        f = 216,
                        g = 247;
                        break;
                    case E.A.Desert:
                        p = 237,
                        f = 226,
                        g = 175
                    }
                    this.forEachPart(( (n, i, r, a, s, l) => {
                        const m = (0,
                        T.Hw)(a);
                        m.tiles.rotated(s, l).forEach(( (i, a, s) => {
                            const l = Math.floor((n + i - 2) / 4) - e
                              , A = Math.floor((r + s - 2) / 4) - t
                              , v = 4 * (l + A * o.width);
                            c.data[v + 0] = p,
                            c.data[v + 1] = f,
                            c.data[v + 2] = g,
                            c.data[v + 3] = 255,
                            null != m.startOffset ? d.push([l, A]) : null != m.detector && m.detector.type == x.A.Checkpoint ? h.push([l, A]) : null != m.detector && m.detector.type == x.A.Finish && u.push([l, A])
                        }
                        ))
                    }
                    ));
                    for (const [e,t] of h)
                        c.data[4 * (e + t * o.width) + 0] = 226,
                        c.data[4 * (e + t * o.width) + 1] = 192,
                        c.data[4 * (e + t * o.width) + 2] = 38,
                        c.data[4 * (e + t * o.width) + 3] = 255;
                    for (const [e,t] of d)
                        c.data[4 * (e + t * o.width) + 0] = 51,
                        c.data[4 * (e + t * o.width) + 1] = 140,
                        c.data[4 * (e + t * o.width) + 2] = 224,
                        c.data[4 * (e + t * o.width) + 3] = 255;
                    for (const [e,t] of u)
                        c.data[4 * (e + t * o.width) + 0] = 209,
                        c.data[4 * (e + t * o.width) + 1] = 41,
                        c.data[4 * (e + t * o.width) + 2] = 41,
                        c.data[4 * (e + t * o.width) + 3] = 255;
                    return l.putImageData(c, 0, 0),
                    o
                }
            }
        }
        ,
        8566: (e, t, n) => {
            "use strict";
            var i;
            n.d(t, {
                A: () => r
            }),
            function(e) {
                e[e.YPositive = 0] = "YPositive",
                e[e.YNegative = 1] = "YNegative",
                e[e.XPositive = 2] = "XPositive",
                e[e.XNegative = 3] = "XNegative",
                e[e.ZPositive = 4] = "ZPositive",
                e[e.ZNegative = 5] = "ZNegative"
            }(i || (i = {}));
            const r = i
        }
        ,
        8578: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pattern_circles.svg"
        }
        ,
        8635: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/video.svg"
        }
        ,
        8658: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/paint.svg"
        }
        ,
        8718: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/search.svg"
        }
        ,
        8734: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/graph.svg"
        }
        ,
        8739: (e, t, n) => {
            "use strict";
            n.d(t, {
                t: () => r
            });
            var i = n(4922);
            class r extends i.ZLX {
                constructor(e, t) {
                    const n = new i.V9B({
                        color: t,
                        depthWrite: !1
                    });
                    super(e.geometry, n, e.count);
                    for (let t = 0; t < e.count; ++t) {
                        const n = new i.kn4;
                        e.getMatrixAt(t, n),
                        this.setMatrixAt(t, n)
                    }
                    this.meshMatrix = e.matrixWorld,
                    this.frustumCulled = !1,
                    this.matrixAutoUpdate = !1,
                    this.renderOrder = -1
                }
                update(e, t) {
                    var n = new i.kn4
                      , r = e.normal.x * t.x + e.normal.y * t.y + e.normal.z * t.z + -e.constant * t.w
                      , a = n.elements;
                    a[0] = r - t.x * e.normal.x,
                    a[4] = -t.x * e.normal.y,
                    a[8] = -t.x * e.normal.z,
                    a[12] = -t.x * -e.constant,
                    a[1] = -t.y * e.normal.x,
                    a[5] = r - t.y * e.normal.y,
                    a[9] = -t.y * e.normal.z,
                    a[13] = -t.y * -e.constant,
                    a[2] = -t.z * e.normal.x,
                    a[6] = -t.z * e.normal.y,
                    a[10] = r - t.z * e.normal.z,
                    a[14] = -t.z * -e.constant,
                    a[3] = -t.w * e.normal.x,
                    a[7] = -t.w * e.normal.y,
                    a[11] = -t.w * e.normal.z,
                    a[15] = r - t.w * -e.constant,
                    this.matrix.multiplyMatrices(n, this.meshMatrix)
                }
            }
        }
        ,
        8787: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/back.svg"
        }
        ,
        8825: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rims.svg"
        }
        ,
        8875: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/clouds.jpg"
        }
        ,
        8879: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/gavel.svg"
        }
        ,
        8889: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/editor.svg"
        }
        ,
        8903: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/logo.svg"
        }
        ,
        8928: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => p,
                _: () => u
            });
            var i = n(3075)
              , r = n(7415)
              , a = n(8438)
              , s = n(2203)
              , o = n(4183)
              , l = n(5169)
              , c = n(8566)
              , h = n(7680)
              , d = n(405);
            function u(e) {
                const t = r.D(e);
                if (null == t)
                    return null;
                const n = new i.Ay.Inflate;
                if (n.push(t, !0),
                n.err)
                    return null;
                const u = n.result;
                if (!(u instanceof Uint8Array))
                    return null;
                const p = new a.A(l.A.Summer,new h.A);
                let f = 0;
                for (; f < u.length; ) {
                    if (u.length - f < 2)
                        return null;
                    let e = u[f + 0] | u[f + 1] << 8;
                    f += 2;
                    let t = o.A.Default;
                    if (e >= 134 && e <= 178)
                        switch (e) {
                        case 134:
                            e = s.A.Block,
                            t = o.A.Custom1;
                            break;
                        case 135:
                            e = s.A.HalfBlock,
                            t = o.A.Custom1;
                            break;
                        case 136:
                            e = s.A.QuarterBlock,
                            t = o.A.Custom1;
                            break;
                        case 137:
                            e = s.A.BlockSlopedDown,
                            t = o.A.Custom1;
                            break;
                        case 138:
                            e = s.A.BlockSlopedDownInnerCorner,
                            t = o.A.Custom1;
                            break;
                        case 139:
                            e = s.A.BlockSlopedDownOuterCorner,
                            t = o.A.Custom1;
                            break;
                        case 140:
                            e = s.A.BlockSlopedUp,
                            t = o.A.Custom1;
                            break;
                        case 141:
                            e = s.A.BlockSlopedUpInnerCorner,
                            t = o.A.Custom1;
                            break;
                        case 142:
                            e = s.A.BlockSlopedUpOuterCorner,
                            t = o.A.Custom1;
                            break;
                        case 143:
                            e = s.A.BlockSlopeDown,
                            t = o.A.Custom1;
                            break;
                        case 144:
                            e = s.A.BlockSlopeUp,
                            t = o.A.Custom1;
                            break;
                        case 145:
                            e = s.A.BlockBridge,
                            t = o.A.Custom1;
                            break;
                        case 146:
                            e = s.A.BlockBridgeCorner,
                            t = o.A.Custom1;
                            break;
                        case 147:
                            e = s.A.BlockBridgeIntersectionT,
                            t = o.A.Custom1;
                            break;
                        case 148:
                            e = s.A.BlockBridgeIntersectionCross,
                            t = o.A.Custom1;
                            break;
                        case 149:
                            e = s.A.Block,
                            t = o.A.Custom6;
                            break;
                        case 150:
                            e = s.A.HalfBlock,
                            t = o.A.Custom6;
                            break;
                        case 151:
                            e = s.A.QuarterBlock,
                            t = o.A.Custom6;
                            break;
                        case 152:
                            e = s.A.BlockSlopedDown,
                            t = o.A.Custom6;
                            break;
                        case 153:
                            e = s.A.BlockSlopedDownInnerCorner,
                            t = o.A.Custom6;
                            break;
                        case 154:
                            e = s.A.BlockSlopedDownOuterCorner,
                            t = o.A.Custom6;
                            break;
                        case 155:
                            e = s.A.BlockSlopedUp,
                            t = o.A.Custom6;
                            break;
                        case 156:
                            e = s.A.BlockSlopedUpInnerCorner,
                            t = o.A.Custom6;
                            break;
                        case 157:
                            e = s.A.BlockSlopedUpOuterCorner,
                            t = o.A.Custom6;
                            break;
                        case 158:
                            e = s.A.BlockSlopeDown,
                            t = o.A.Custom6;
                            break;
                        case 159:
                            e = s.A.BlockSlopeUp,
                            t = o.A.Custom6;
                            break;
                        case 160:
                            e = s.A.BlockBridge,
                            t = o.A.Custom6;
                            break;
                        case 161:
                            e = s.A.BlockBridgeCorner,
                            t = o.A.Custom6;
                            break;
                        case 162:
                            e = s.A.BlockBridgeIntersectionT,
                            t = o.A.Custom6;
                            break;
                        case 163:
                            e = s.A.BlockBridgeIntersectionCross,
                            t = o.A.Custom6;
                            break;
                        case 164:
                            e = s.A.Block,
                            t = o.A.Custom0;
                            break;
                        case 165:
                            e = s.A.HalfBlock,
                            t = o.A.Custom0;
                            break;
                        case 166:
                            e = s.A.QuarterBlock,
                            t = o.A.Custom0;
                            break;
                        case 167:
                            e = s.A.BlockSlopedDown,
                            t = o.A.Custom0;
                            break;
                        case 168:
                            e = s.A.BlockSlopedDownInnerCorner,
                            t = o.A.Custom0;
                            break;
                        case 169:
                            e = s.A.BlockSlopedDownOuterCorner,
                            t = o.A.Custom0;
                            break;
                        case 170:
                            e = s.A.BlockSlopedUp,
                            t = o.A.Custom0;
                            break;
                        case 171:
                            e = s.A.BlockSlopedUpInnerCorner,
                            t = o.A.Custom0;
                            break;
                        case 172:
                            e = s.A.BlockSlopedUpOuterCorner,
                            t = o.A.Custom0;
                            break;
                        case 173:
                            e = s.A.BlockSlopeDown,
                            t = o.A.Custom0;
                            break;
                        case 174:
                            e = s.A.BlockSlopeUp,
                            t = o.A.Custom0;
                            break;
                        case 175:
                            e = s.A.BlockBridge,
                            t = o.A.Custom0;
                            break;
                        case 176:
                            e = s.A.BlockBridgeCorner,
                            t = o.A.Custom0;
                            break;
                        case 177:
                            e = s.A.BlockBridgeIntersectionT,
                            t = o.A.Custom0;
                            break;
                        case 178:
                            e = s.A.BlockBridgeIntersectionCross,
                            t = o.A.Custom0
                        }
                    let n = null
                      , i = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                    if (79 == e)
                        n = s.A.WallTrackFloorPlaneCorner;
                    else if (81 == e)
                        n = s.A.WallTrackCeilingPlaneCorner,
                        i = {
                            x: 0,
                            y: 3,
                            z: 0
                        };
                    else if (e >= 87 && e <= 98)
                        switch (e) {
                        case 87:
                            e = s.A.Slope,
                            n = s.A.BlockSlopedUp;
                            break;
                        case 88:
                            e = s.A.SlopeUp,
                            n = s.A.BlockSlopeUp;
                            break;
                        case 89:
                            e = s.A.SlopeDown,
                            n = s.A.BlockSlopeDown;
                            break;
                        case 90:
                            e = s.A.SlopeUpLeftWide,
                            n = s.A.BlockSlopeUp;
                            break;
                        case 91:
                            e = s.A.SlopeUpRightWide,
                            n = s.A.BlockSlopeUp;
                            break;
                        case 92:
                            e = s.A.SlopeDownLeftWide,
                            n = s.A.BlockSlopeDown;
                            break;
                        case 93:
                            e = s.A.SlopeDownRightWide,
                            n = s.A.BlockSlopeDown;
                            break;
                        case 94:
                            e = s.A.SlopeLeftWide,
                            n = s.A.BlockSlopedUp;
                            break;
                        case 95:
                            e = s.A.SlopeRightWide,
                            n = s.A.BlockSlopedUp;
                            break;
                        case 96:
                            e = s.A.PlaneSlopeUp,
                            n = s.A.BlockSlopeUp;
                            break;
                        case 97:
                            e = s.A.PlaneSlopeDown,
                            n = s.A.BlockSlopeDown;
                            break;
                        case 98:
                            e = s.A.PlaneSlope,
                            n = s.A.BlockSlopedUp;
                            break;
                        default:
                            throw new Error("Invalid track part id")
                        }
                    else
                        40 == e ? (e = s.A.Slope,
                        n = s.A.PillarTopSlope) : 84 == e ? (e = s.A.Slope,
                        n = s.A.PillarShortSlope) : 99 == e ? (e = s.A.PlaneSlope,
                        n = s.A.PillarTopSlope) : 100 == e && (e = s.A.PlaneSlope,
                        n = s.A.PillarShortSlope);
                    if (!(e in s.A))
                        return null;
                    if (u.length - f < 4)
                        return null;
                    const r = u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16 | u[f + 3] << 24;
                    f += 4;
                    for (let a = 0; a < r; ++a) {
                        if (u.length - f < 3)
                            return null;
                        const r = (u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16) - 2 ** 23;
                        if (f += 3,
                        u.length - f < 3)
                            return null;
                        const a = u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16;
                        if (f += 3,
                        u.length - f < 3)
                            return null;
                        const s = (u[f + 0] | u[f + 1] << 8 | u[f + 2] << 16) - 2 ** 23;
                        if (f += 3,
                        u.length - f < 1)
                            return null;
                        const l = u[f + 0];
                        if (f += 1,
                        l < 0 || l > 3)
                            return null;
                        let h = null;
                        if (d.bK.includes(e)) {
                            if (u.length - f < 2)
                                return null;
                            h = u[f + 0] | u[f + 1] << 8,
                            f += 2
                        }
                        let g = null;
                        d.l1.includes(e) && (g = 0),
                        null != n && p.addPart(4 * r + i.x, a + i.y, 4 * s + i.z, n, l, c.A.YPositive, o.A.Default, null, null),
                        p.addPart(4 * r, a, 4 * s, e, l, c.A.YPositive, t, h, g)
                    }
                }
                return p
            }
            function p(e) {
                if (!e.startsWith("v3"))
                    return null;
                const t = e.substring(2, 4)
                  , n = r.D(t);
                if (null == n)
                    return null;
                if (1 != n.length)
                    return null;
                const i = n[0]
                  , a = e.substring(4, 4 + i)
                  , s = r.D(a);
                if (null == s)
                    return null;
                let o;
                try {
                    o = new TextDecoder("utf-8").decode(s)
                } catch {
                    return null
                }
                const l = u(e.substring(4 + i));
                return null == l ? null : {
                    trackMetadata: {
                        name: o,
                        author: null,
                        lastModified: null
                    },
                    trackData: l
                }
            }
        }
        ,
        8971: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => _
            });
            var i, r, a, s, o, l, c, h, d, u, p, f, g, m = n(1635), A = n(4922), v = n(8438), y = n(2247), w = n(4183), b = n(5169), x = n(7680), S = n(5735), E = n(3476), T = n(8739);
            class k {
                constructor(e, t, n, i, r, a, s, o, l, c) {
                    if (this.checkpointOrder = null,
                    this.startOrder = null,
                    this.x = e,
                    this.y = t,
                    this.z = n,
                    this.rotation = i,
                    this.rotationAxis = r,
                    this.color = a,
                    this.type = s,
                    this.matrix = o,
                    this.checkpointOrder = l,
                    this.startOrder = c,
                    null != s.configuration.detector && s.configuration.detector.type == y.A.Checkpoint) {
                        if (null == l)
                            throw new Error("Checkpoint has no checkpoint order")
                    } else if (null != l)
                        throw new Error("Non-checkpoint has checkpoint order");
                    if (null != s.configuration.startOffset && null == c)
                        throw new Error("Start part has no start order");
                    if (null == s.configuration.startOffset && null != c)
                        throw new Error("Non-start part has start order")
                }
            }
            class M {
                constructor(e, t, n) {
                    i.add(this),
                    r.set(this, void 0),
                    a.set(this, void 0),
                    s.set(this, void 0),
                    this.environment = b.A.Summer,
                    o.set(this, new x.A),
                    l.set(this, []),
                    c.set(this, new Map),
                    h.set(this, new Map),
                    d.set(this, {
                        min: new A.I9Y(0,0),
                        max: new A.I9Y(0,0)
                    }),
                    u.set(this, []),
                    (0,
                    m.GG)(this, r, e, "f"),
                    (0,
                    m.GG)(this, a, t, "f"),
                    (0,
                    m.GG)(this, s, n, "f")
                }
                get sunDirection() {
                    return (0,
                    m.gn)(this, o, "f")
                }
                set sunDirection(e) {
                    (0,
                    m.GG)(this, o, e.clone(), "f")
                }
                clear() {
                    (0,
                    m.gn)(this, l, "f").length = 0,
                    (0,
                    m.gn)(this, c, "f").clear(),
                    (0,
                    m.gn)(this, h, "f").clear(),
                    (0,
                    m.gn)(this, i, "m", p).call(this)
                }
                getPartsWithin(e, t, n, i, r, a) {
                    return (0,
                    m.gn)(this, l, "f").filter((s => s.type.configuration.tiles.rotated(s.rotation, s.rotationAxis).some(( (o, l, c) => {
                        const h = s.x + o
                          , d = s.y + l
                          , u = s.z + c;
                        return h >= e && h <= i && d >= t && d <= r && u >= n && u <= a
                    }
                    )))).map((e => ({
                        id: e.type.configuration.id,
                        x: e.x,
                        y: e.y,
                        z: e.z,
                        rotation: e.rotation,
                        rotationAxis: e.rotationAxis,
                        color: e.color,
                        checkpointOrder: e.checkpointOrder,
                        startOrder: e.startOrder
                    })))
                }
                getPartsAt(e, t, n) {
                    const i = (0,
                    m.gn)(this, c, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString());
                    return null == i ? [] : i.map((e => ({
                        id: e.type.configuration.id,
                        x: e.x,
                        y: e.y,
                        z: e.z,
                        rotation: e.rotation,
                        rotationAxis: e.rotationAxis,
                        color: e.color,
                        checkpointOrder: e.checkpointOrder,
                        startOrder: e.startOrder
                    })))
                }
                setPart(e, t, n, i, r, a, o, d, u) {
                    const p = (0,
                    m.gn)(this, s, "f").getPart(i);
                    if (o != w.A.Default && !p.colors.has(o))
                        throw new Error("Track part color does not exist");
                    const f = S.hT(r, a)
                      , g = new A.Pq0(e * M.partSize,t * M.partSize,n * M.partSize)
                      , v = (new A.kn4).compose(g, f, new A.Pq0(1,1,1))
                      , y = new k(e,t,n,r,a,o,p,v,d,u);
                    (0,
                    m.gn)(this, l, "f").push(y);
                    p.configuration.tiles.rotated(r, a).forEach(( (i, r, a) => {
                        const s = (e + i).toString() + "|" + (t + r).toString() + "|" + (n + a).toString();
                        if (t + r < 0)
                            throw new Error("Track part below ground");
                        {
                            const e = (0,
                            m.gn)(this, c, "f").get(s);
                            null == e ? (0,
                            m.gn)(this, c, "f").set(s, [y]) : e.push(y)
                        }
                    }
                    ));
                    const b = (0,
                    m.gn)(this, h, "f").get(i);
                    null == b ? (0,
                    m.gn)(this, h, "f").set(i, [y]) : b.push(y)
                }
                deletePartsAt(e, t, n) {
                    const r = []
                      , a = (0,
                    m.gn)(this, c, "f").get(e.toString() + "|" + t.toString() + "|" + n.toString());
                    if (null != a)
                        for (let e = 0; e < a.length; ++e) {
                            const t = a[e];
                            r.push({
                                id: t.type.configuration.id,
                                x: t.x,
                                y: t.y,
                                z: t.z,
                                rotation: t.rotation,
                                rotationAxis: t.rotationAxis,
                                color: t.color,
                                checkpointOrder: t.checkpointOrder,
                                startOrder: t.startOrder
                            }),
                            (0,
                            m.gn)(this, i, "m", f).call(this, (0,
                            m.gn)(this, l, "f").indexOf(t)),
                            --e
                        }
                    return r
                }
                deletePartsWithin(e, t, n, r, a, s) {
                    const o = [];
                    for (let c = 0; c < (0,
                    m.gn)(this, l, "f").length; ++c) {
                        const h = (0,
                        m.gn)(this, l, "f")[c];
                        h.type.configuration.tiles.rotated(h.rotation, h.rotationAxis).some(( (i, o, l) => {
                            const c = h.x + i
                              , d = h.y + o
                              , u = h.z + l;
                            return c >= e && c <= r && d >= t && d <= a && u >= n && u <= s
                        }
                        )) && (o.push({
                            id: h.type.configuration.id,
                            x: h.x,
                            y: h.y,
                            z: h.z,
                            rotation: h.rotation,
                            rotationAxis: h.rotationAxis,
                            color: h.color,
                            checkpointOrder: h.checkpointOrder,
                            startOrder: h.startOrder
                        }),
                        (0,
                        m.gn)(this, i, "m", f).call(this, c),
                        --c)
                    }
                    return o
                }
                deleteSpecificPart(e, t, n, r, a, s) {
                    for (let o = 0; o < (0,
                    m.gn)(this, l, "f").length; ++o) {
                        const c = (0,
                        m.gn)(this, l, "f")[o];
                        if (c.type.configuration.id == e && c.x == t && c.y == n && c.z == r && c.rotation == a && c.rotationAxis == s)
                            return (0,
                            m.gn)(this, i, "m", f).call(this, o),
                            {
                                id: c.type.configuration.id,
                                x: c.x,
                                y: c.y,
                                z: c.z,
                                rotation: c.rotation,
                                rotationAxis: c.rotationAxis,
                                color: c.color,
                                checkpointOrder: c.checkpointOrder,
                                startOrder: c.startOrder
                            }
                    }
                    return null
                }
                getBounds() {
                    return (0,
                    m.gn)(this, d, "f")
                }
                generateMeshes() {
                    (0,
                    m.gn)(this, i, "m", p).call(this);
                    const e = (0,
                    m.gn)(this, o, "f").getSunPosition()
                      , t = new A.IUQ(e.x,e.y,e.z,0);
                    let n, c = null;
                    if (2 == (0,
                    m.gn)(this, a, "f").getSettingInteger(E.A.ShadowQuality))
                        switch (this.environment) {
                        case b.A.Summer:
                            c = new A.Q1f(2511171);
                            break;
                        case b.A.Winter:
                            c = new A.Q1f(7904713);
                            break;
                        case b.A.Desert:
                            c = new A.Q1f(7958351)
                        }
                    switch (this.environment) {
                    case b.A.Summer:
                        n = w.A.Summer;
                        break;
                    case b.A.Winter:
                        n = w.A.Winter;
                        break;
                    case b.A.Desert:
                        n = w.A.Desert
                    }
                    const h = (0,
                    m.gn)(this, r, "f").isTrackShadowsEnabled();
                    for (const e of (0,
                    m.gn)(this, s, "f").getAllParts())
                        for (const [i,a] of e.colors) {
                            const s = [];
                            for (const t of (0,
                            m.gn)(this, l, "f")) {
                                let r = t.color;
                                r == w.A.Default && (r = n),
                                t.type == e && r == i && s.push(t)
                            }
                            if (s.length > 0) {
                                if (null == a)
                                    throw new Error("Mesh is not loaded");
                                const e = new A.ZLX(a.geometry,a.material,s.length);
                                e.matrixAutoUpdate = !1,
                                e.matrixWorldAutoUpdate = !1,
                                e.frustumCulled = !1,
                                e.castShadow = h,
                                e.receiveShadow = !0;
                                for (let t = 0; t < s.length; ++t)
                                    e.setMatrixAt(t, s[t].matrix);
                                if ((0,
                                m.gn)(this, r, "f").scene.add(e),
                                (0,
                                m.gn)(this, u, "f").push(e),
                                null != c) {
                                    const n = new T.t(e,c);
                                    n.update(new A.Zcv(new A.Pq0(0,1,0),0), t),
                                    (0,
                                    m.gn)(this, r, "f").scene.add(n),
                                    (0,
                                    m.gn)(this, u, "f").push(n)
                                }
                            }
                        }
                    (0,
                    m.gn)(this, i, "m", g).call(this)
                }
                getCheckpoints() {
                    let e = [];
                    const t = (0,
                    m.gn)(this, s, "f").getPartTypesWithDetector(y.A.Checkpoint);
                    for (const n of t) {
                        const t = (0,
                        m.gn)(this, h, "f").get(n);
                        null != t && (e = e.concat(t))
                    }
                    return e.map((e => {
                        if (null == e.checkpointOrder)
                            throw new Error("Checkpoint has no checkpoint order");
                        if (null == e.type.configuration.detector)
                            throw new Error("Checkpoint has no detector");
                        return {
                            x: e.x,
                            y: e.y,
                            z: e.z,
                            rotation: e.rotation,
                            rotationAxis: e.rotationAxis,
                            type: e.type.configuration.id,
                            checkpointOrder: e.checkpointOrder,
                            detector: e.type.configuration.detector
                        }
                    }
                    ))
                }
                getCheckpointOrders() {
                    let e = [];
                    const t = (0,
                    m.gn)(this, s, "f").getPartTypesWithDetector(y.A.Checkpoint);
                    for (const n of t) {
                        const t = (0,
                        m.gn)(this, h, "f").get(n);
                        null != t && (e = e.concat(t))
                    }
                    return e.map((e => {
                        if (null == e.checkpointOrder)
                            throw new Error("Checkpoint has no checkpoint order");
                        if (null == e.type.configuration.detector)
                            throw new Error("Checkpoint has no detector");
                        return e.checkpointOrder
                    }
                    ))
                }
                getTotalNumberOfCheckpointIndices() {
                    let e = [];
                    const t = (0,
                    m.gn)(this, s, "f").getPartTypesWithDetector(y.A.Checkpoint);
                    for (const n of t) {
                        const t = (0,
                        m.gn)(this, h, "f").get(n);
                        null != t && (e = e.concat(t))
                    }
                    return e.map((e => e.checkpointOrder)).filter(( (e, t, n) => n.indexOf(e) == t)).length
                }
                getStart() {
                    let e = -1 / 0
                      , t = null;
                    for (const [n,i] of (0,
                    m.gn)(this, h, "f")) {
                        const r = (0,
                        m.gn)(this, s, "f").getPartStartOffset(n);
                        if (i.length > 0 && null != r)
                            for (const n of i) {
                                if (null == n.startOrder)
                                    throw new Error("Start part has no start order");
                                n.startOrder >= e && (e = n.startOrder,
                                t = {
                                    part: n,
                                    startOffset: r
                                })
                            }
                    }
                    return null != t ? {
                        x: t.part.x,
                        y: t.part.y,
                        z: t.part.z,
                        rotation: t.part.rotation,
                        rotationAxis: t.part.rotationAxis,
                        startOffset: t.startOffset
                    } : null
                }
                getStartTransform() {
                    const e = this.getStart();
                    if (null != e) {
                        const t = S.hT(e.rotation, e.rotationAxis).multiply((new A.PTz).setFromEuler(new A.O9p(0,Math.PI,0)))
                          , n = e.startOffset;
                        return n.applyQuaternion(t),
                        {
                            position: new A.Pq0(e.x * M.partSize + n.x,e.y * M.partSize + n.y,e.z * M.partSize + n.z),
                            quaternion: t
                        }
                    }
                    return null
                }
                getNextStartOrder() {
                    let e = 0;
                    for (const [t,n] of (0,
                    m.gn)(this, h, "f")) {
                        const i = (0,
                        m.gn)(this, s, "f").getPartStartOffset(t);
                        if (n.length > 0 && null != i)
                            for (const t of n) {
                                if (null == t.startOrder)
                                    throw new Error("Start part has no start order");
                                e = Math.max(e, t.startOrder + 1)
                            }
                    }
                    return e
                }
                getTrackData() {
                    const e = new v.A(this.environment,(0,
                    m.gn)(this, o, "f"));
                    for (const t of (0,
                    m.gn)(this, l, "f"))
                        e.addPart(t.x, t.y, t.z, t.type.configuration.id, t.rotation, t.rotationAxis, t.color, t.checkpointOrder, t.startOrder);
                    return e
                }
                loadTrackData(e) {
                    return this.clear(),
                    this.environment = e.environment,
                    this.sunDirection = e.sunDirection.clone(),
                    e.forEachPart(( (e, t, n, i, r, a, s, o, l) => {
                        this.setPart(e, t, n, i, r, a, s, o, l)
                    }
                    )),
                    !0
                }
            }
            r = new WeakMap,
            a = new WeakMap,
            s = new WeakMap,
            o = new WeakMap,
            l = new WeakMap,
            c = new WeakMap,
            h = new WeakMap,
            d = new WeakMap,
            u = new WeakMap,
            i = new WeakSet,
            p = function() {
                for (const e of (0,
                m.gn)(this, u, "f"))
                    (0,
                    m.gn)(this, r, "f").scene.remove(e);
                (0,
                m.gn)(this, u, "f").length = 0
            }
            ,
            f = function(e) {
                if (e < 0 || e >= (0,
                m.gn)(this, l, "f").length)
                    throw new Error("Track part index out of bounds");
                const t = (0,
                m.gn)(this, l, "f")[e];
                (0,
                m.gn)(this, l, "f").splice(e, 1);
                t.type.configuration.tiles.rotated(t.rotation, t.rotationAxis).forEach(( (e, n, i) => {
                    const r = (t.x + e).toString() + "|" + (t.y + n).toString() + "|" + (t.z + i).toString()
                      , a = (0,
                    m.gn)(this, c, "f").get(r);
                    if (null == a)
                        throw new Error("Track part section missing");
                    {
                        const e = a.indexOf(t);
                        if (!(e >= 0))
                            throw new Error("Track part missing from parts by position map");
                        a.splice(e, 1),
                        0 == a.length && (0,
                        m.gn)(this, c, "f").delete(r)
                    }
                }
                ));
                const n = (0,
                m.gn)(this, h, "f").get(t.type.configuration.id);
                if (null == n)
                    throw new Error("Track part type is missing from parts by type map");
                for (let e = 0; e < n.length; ++e) {
                    if (n[e] == t) {
                        n.splice(e, 1);
                        break
                    }
                    if (e == n.length - 1)
                        throw new Error("Track part is missing from parts by type map")
                }
            }
            ,
            g = function() {
                let e = 1 / 0
                  , t = 1 / 0
                  , n = -1 / 0
                  , i = -1 / 0;
                for (const r of (0,
                m.gn)(this, l, "f"))
                    e = Math.min(r.x, e),
                    t = Math.min(r.z, t),
                    n = Math.max(r.x, n),
                    i = Math.max(r.z, i);
                Number.isFinite(e) && Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i) ? (0,
                m.GG)(this, d, {
                    min: new A.I9Y(e,t),
                    max: new A.I9Y(n,i)
                }, "f") : (0,
                m.GG)(this, d, {
                    min: new A.I9Y,
                    max: new A.I9Y
                }, "f")
            }
            ,
            M.partSize = 5;
            const _ = M
        }
        ,
        9027: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/customize.svg"
        }
        ,
        9062: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/rotation_axis_y_positive.svg"
        }
        ,
        9077: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/import.svg"
        }
        ,
        9178: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".timer-ui {\n\tposition: absolute;\n\tbottom: 0;\n\tleft: 0;\n\twidth: 100%;\n\ttext-align: center;\n\topacity: 0.9;\n}\n.timer-ui.up {\n\tbottom: auto;\n\ttop: 0;\n}\n.timer-ui.hidden {\n\tdisplay: none;\n}\n\n.timer-ui > div {\n\tmargin: 0;\n\tpadding: 0;\n\tdisplay: inline-flex;\n\tflex-direction: column;\n\twidth: 240px;\n\tvertical-align: bottom;\n}\n.timer-ui.up > div {\n\tflex-direction: column-reverse;\n\tvertical-align: top;\n}\n.timer-ui > div > .title-container {\n\tposition: relative;\n\tmargin: 0 auto;\n\twidth: 220px;\n\theight: 32px;\n}\n.timer-ui > div > .title-container > h2 {\n\tposition: absolute;\n\tmargin: 0;\n\tpadding: 0;\n\twidth: 100%;\n\toverflow: hidden;\n\ttext-overflow: ellipsis;\n\tcolor: var(--text-color);\n\tfont-size: 26px;\n\tfont-weight: normal;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n}\n.timer-ui:not(.up) > div > .title-container > .title {\n\tmargin-top: 8px;\n}\n.timer-ui > div > .title-container > .checkpoint-time {\n\topacity: 0;\n\tfont-size: 32px;\n}\n.timer-ui > div > .title-container > .checkpoint-time.green {\n\tcolor: #5f5;\n}\n.timer-ui > div > .title-container > .checkpoint-time.red {\n\tcolor: #f55;\n}\n\n.timer-ui > div > .time {\n\tmargin: 0;\n\tpadding: 0;\n\tbackground-color: var(--surface-color);\n}\n.timer-ui > .left > .time {\n\tpadding: 8px 4px 8px 10px;\n\tclip-path: polygon(8px 0, 100% 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .left > .time {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 8px 100%);\n}\n.timer-ui > .center > .time {\n\tposition: relative;\n\tz-index: 1;\n\tmargin: 0 -12px;\n\tpadding: 8px 10px;\n\tclip-path: polygon(8px 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .center > .time {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 8px 100%);\n}\n.timer-ui > .right > .time {\n\tpadding: 8px 10px 8px 4px;\n\tclip-path: polygon(0 0, calc(100% - 8px) 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .right > .time {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 8px) 100%, 0 100%);\n}\n\n.timer-ui > div > .time > p {\n\tmargin: 0;\n\tpadding: 0;\n\tbackground-color: var(--surface-tertiary-color);\n\tcolor: var(--text-color);\n\tfont-size: 34px;\n}\n.timer-ui > .left > .time > p {\n\tclip-path: polygon(6px 0, 100% 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .left > .time > p {\n\tclip-path: polygon(0 0, 100% 0, 100% 100%, 6px 100%);\n}\n.timer-ui > .center > .time > p {\n\tfont-size: 46px;\n\tclip-path: polygon(6px 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .center > .time > p {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 6px 100%);\n}\n.timer-ui > .right > .time > p {\n\tclip-path: polygon(0 0, calc(100% - 6px) 0, 100% 100%, 0 100%);\n}\n.timer-ui.up > .right > .time > p {\n\tclip-path: polygon(0 0, 100% 0, calc(100% - 6px) 100%, 0 100%);\n}\n\n.timer-ui > div > .time > p.green {\n\tcolor: #5f5;\n}\n.timer-ui > div > .time > p.red {\n\tcolor:#f55;\n}\n\n.timer-ui > div > .time > p > span {\n\tdisplay: inline-block;\n\twidth: 0.5em;\n\ttext-align: center;\n}\n.timer-ui > div > .time > p > span.sign {\n\tmargin-left: -4px;\n\twidth: 0.7em;\n}\n", ""]);
            const o = s
        }
        ,
        9207: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, "#transition-layer {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\tz-index: 100;\n\twidth: 100%;\n\theight: 100%;\n\tbackground-color: #000;\n\tpointer-events: none;\n\n\topacity: 0;\n\ttransition: 0.25s ease-in-out opacity;\n}\n", ""]);
            const o = s
        }
        ,
        9236: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/play.svg"
        }
        ,
        9391: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/official_tracks.jpg"
        }
        ,
        9437: (e, t, n) => {
            "use strict";
            n.d(t, {
                JeP: () => Yt,
                vxI: () => s
            });
            var i = n(4922);
            /**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
            function r() {
                let e = null
                  , t = !1
                  , n = null
                  , i = null;
                function r(t, a) {
                    n(t, a),
                    i = e.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
                        t = !0)
                    },
                    stop: function() {
                        e.cancelAnimationFrame(i),
                        t = !1
                    },
                    setAnimationLoop: function(e) {
                        n = e
                    },
                    setContext: function(t) {
                        e = t
                    }
                }
            }
            function a(e) {
                const t = new WeakMap;
                return {
                    get: function(e) {
                        return e.isInterleavedBufferAttribute && (e = e.data),
                        t.get(e)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        const i = t.get(n);
                        i && (e.deleteBuffer(i.buffer),
                        t.delete(n))
                    },
                    update: function(n, i) {
                        if (n.isInterleavedBufferAttribute && (n = n.data),
                        n.isGLBufferAttribute) {
                            const e = t.get(n);
                            return void ((!e || e.version < n.version) && t.set(n, {
                                buffer: n.buffer,
                                type: n.type,
                                bytesPerElement: n.elementSize,
                                version: n.version
                            }))
                        }
                        const r = t.get(n);
                        if (void 0 === r)
                            t.set(n, function(t, n) {
                                const i = t.array
                                  , r = t.usage
                                  , a = i.byteLength
                                  , s = e.createBuffer();
                                let o;
                                if (e.bindBuffer(n, s),
                                e.bufferData(n, i, r),
                                t.onUploadCallback(),
                                i instanceof Float32Array)
                                    o = e.FLOAT;
                                else if ("undefined" != typeof Float16Array && i instanceof Float16Array)
                                    o = e.HALF_FLOAT;
                                else if (i instanceof Uint16Array)
                                    o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                                else if (i instanceof Int16Array)
                                    o = e.SHORT;
                                else if (i instanceof Uint32Array)
                                    o = e.UNSIGNED_INT;
                                else if (i instanceof Int32Array)
                                    o = e.INT;
                                else if (i instanceof Int8Array)
                                    o = e.BYTE;
                                else if (i instanceof Uint8Array)
                                    o = e.UNSIGNED_BYTE;
                                else {
                                    if (!(i instanceof Uint8ClampedArray))
                                        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                    o = e.UNSIGNED_BYTE
                                }
                                return {
                                    buffer: s,
                                    type: o,
                                    bytesPerElement: i.BYTES_PER_ELEMENT,
                                    version: t.version,
                                    size: a
                                }
                            }(n, i));
                        else if (r.version < n.version) {
                            if (r.size !== n.array.byteLength)
                                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                            !function(t, n, i) {
                                const r = n.array
                                  , a = n.updateRanges;
                                if (e.bindBuffer(i, t),
                                0 === a.length)
                                    e.bufferSubData(i, 0, r);
                                else {
                                    a.sort(( (e, t) => e.start - t.start));
                                    let t = 0;
                                    for (let e = 1; e < a.length; e++) {
                                        const n = a[t]
                                          , i = a[e];
                                        i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t,
                                        a[t] = i)
                                    }
                                    a.length = t + 1;
                                    for (let t = 0, n = a.length; t < n; t++) {
                                        const n = a[t];
                                        e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                    }
                                    n.clearUpdateRanges()
                                }
                                n.onUploadCallback()
                            }(r.buffer, n, i),
                            r.version = n.version
                        }
                    }
                }
            }
            const s = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.metalness = metalnessFactor;\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;\n\tmaterial.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = vec3( 0.04 );\n\tmaterial.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tvec3 diffuseContribution;\n\tvec3 specularColor;\n\tvec3 specularColorBlended;\n\tfloat roughness;\n\tfloat metalness;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t\tvec3 iridescenceFresnelDielectric;\n\t\tvec3 iridescenceFresnelMetallic;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn v;\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColorBlended;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat rInv = 1.0 / ( roughness + 0.1 );\n\tfloat a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;\n\tfloat b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;\n\tfloat DG = exp( a * dotNV + b );\n\treturn saturate( DG );\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;\n\tvec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;\n\tvec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;\n\tvec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;\n\tfloat Ess_V = dfgV.x + dfgV.y;\n\tfloat Ess_L = dfgL.x + dfgL.y;\n\tfloat Ems_V = 1.0 - Ess_V;\n\tfloat Ems_L = 1.0 - Ess_L;\n\tvec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;\n\tvec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );\n\tfloat compensationFactor = Ems_V * Ems_L;\n\tvec3 multiScatter = Fms * compensationFactor;\n\treturn singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n \n \t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n \n \t\tfloat sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n \t\tfloat sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );\n \n \t\tfloat sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );\n \n \t\tirradiance *= sheenEnergyComp;\n \n \t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );\n\t#ifdef USE_SHEEN\n\t\tfloat sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t\tfloat sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;\n\t\tdiffuse *= sheenEnergyComp;\n\t#endif\n\treflectedLight.indirectDiffuse += diffuse;\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;\n \t#endif\n\tvec3 singleScatteringDielectric = vec3( 0.0 );\n\tvec3 multiScatteringDielectric = vec3( 0.0 );\n\tvec3 singleScatteringMetallic = vec3( 0.0 );\n\tvec3 multiScatteringMetallic = vec3( 0.0 );\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );\n\t#endif\n\tvec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );\n\tvec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );\n\tvec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;\n\tvec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tvec3 indirectSpecular = radiance * singleScattering;\n\tindirectSpecular += multiScattering * cosineWeightedIrradiance;\n\tvec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t\tfloat sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;\n\t\tindirectSpecular *= sheenEnergyComp;\n\t\tindirectDiffuse *= sheenEnergyComp;\n\t#endif\n\treflectedLight.indirectSpecular += indirectSpecular;\n\treflectedLight.indirectDiffuse += indirectDiffuse;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );\n\t\tmaterial.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tuniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\t#else\n\t\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\t#endif\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tuniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\t#else\n\t\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\t#endif\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tuniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\t#elif defined( SHADOWMAP_TYPE_BASIC )\n\t\t\tuniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\t#endif\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\tfloat interleavedGradientNoise( vec2 position ) {\n\t\t\treturn fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );\n\t\t}\n\t\tvec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {\n\t\t\tconst float goldenAngle = 2.399963229728653;\n\t\t\tfloat r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );\n\t\t\tfloat theta = float( sampleIndex ) * goldenAngle + phi;\n\t\t\treturn vec2( cos( theta ), sin( theta ) ) * r;\n\t\t}\n\t#endif\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\tfloat getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\t\tfloat shadow = 1.0;\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\t\tshadowCoord.z += shadowBias;\n\t\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\t\tif ( frustumTest ) {\n\t\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\t\tfloat radius = shadowRadius * texelSize.x;\n\t\t\t\tfloat phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +\n\t\t\t\t\ttexture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +\n\t\t\t\t\ttexture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +\n\t\t\t\t\ttexture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +\n\t\t\t\t\ttexture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )\n\t\t\t\t) * 0.2;\n\t\t\t}\n\t\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t\t}\n\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\t\tfloat shadow = 1.0;\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\t\tshadowCoord.z += shadowBias;\n\t\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\t\tif ( frustumTest ) {\n\t\t\t\tvec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;\n\t\t\t\tfloat mean = distribution.x;\n\t\t\t\tfloat variance = distribution.y * distribution.y;\n\t\t\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\t\t\tfloat hard_shadow = step( mean, shadowCoord.z );\n\t\t\t\t#else\n\t\t\t\t\tfloat hard_shadow = step( shadowCoord.z, mean );\n\t\t\t\t#endif\n\t\t\t\tif ( hard_shadow == 1.0 ) {\n\t\t\t\t\tshadow = 1.0;\n\t\t\t\t} else {\n\t\t\t\t\tvariance = max( variance, 0.0000001 );\n\t\t\t\t\tfloat d = shadowCoord.z - mean;\n\t\t\t\t\tfloat p_max = variance / ( variance + d * d );\n\t\t\t\t\tp_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );\n\t\t\t\t\tshadow = max( hard_shadow, p_max );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t\t}\n\t#else\n\t\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\t\tfloat shadow = 1.0;\n\t\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\t\tshadowCoord.z += shadowBias;\n\t\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\t\tif ( frustumTest ) {\n\t\t\t\tfloat depth = texture2D( shadowMap, shadowCoord.xy ).r;\n\t\t\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\t\t\tshadow = step( depth, shadowCoord.z );\n\t\t\t\t#else\n\t\t\t\t\tshadow = step( shadowCoord.z, depth );\n\t\t\t\t#endif\n\t\t\t}\n\t\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#if defined( SHADOWMAP_TYPE_PCF )\n\tfloat getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tvec3 absVec = abs( lightToPosition );\n\t\tfloat viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );\n\t\tif ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );\n\t\t\tdp += shadowBias;\n\t\t\tfloat texelSize = shadowRadius / shadowMapSize.x;\n\t\t\tvec3 absDir = abs( bd3D );\n\t\t\tvec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );\n\t\t\ttangent = normalize( cross( bd3D, tangent ) );\n\t\t\tvec3 bitangent = cross( bd3D, tangent );\n\t\t\tfloat phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;\n\t\t\tshadow = (\n\t\t\t\ttexture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +\n\t\t\t\ttexture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +\n\t\t\t\ttexture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +\n\t\t\t\ttexture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +\n\t\t\t\ttexture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )\n\t\t\t) * 0.2;\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\t#elif defined( SHADOWMAP_TYPE_BASIC )\n\tfloat getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tvec3 absVec = abs( lightToPosition );\n\t\tfloat viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );\n\t\tif ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );\n\t\t\tdp += shadowBias;\n\t\t\tfloat depth = textureCube( shadowMap, bd3D ).r;\n\t\t\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\t\t\tshadow = step( depth, dp );\n\t\t\t#else\n\t\t\t\tshadow = step( dp, depth );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\t#endif\n\t#endif\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t#else\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_REVERSED_DEPTH_BUFFER\n\t\tfloat fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n\t#else\n\t\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n\t#endif\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
                distance_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distance_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n \n\t\toutgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;\n \n \t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            }
              , o = {
                common: {
                    diffuse: {
                        value: new i.Q1f(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new i.dwI
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new i.dwI
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new i.dwI
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: new i.dwI
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    },
                    dfgLUT: {
                        value: null
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new i.dwI
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new i.dwI
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new i.dwI
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new i.dwI
                    },
                    normalScale: {
                        value: new i.I9Y(1,1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new i.dwI
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new i.dwI
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new i.dwI
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new i.dwI
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new i.Q1f(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowIntensity: 1,
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new i.Q1f(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new i.dwI
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new i.dwI
                    }
                },
                sprite: {
                    diffuse: {
                        value: new i.Q1f(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new i.I9Y(.5,.5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new i.dwI
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new i.dwI
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            }
              , l = {
                basic: {
                    uniforms: (0,
                    i.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.fog]),
                    vertexShader: s.meshbasic_vert,
                    fragmentShader: s.meshbasic_frag
                },
                lambert: {
                    uniforms: (0,
                    i.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.fog, o.lights, {
                        emissive: {
                            value: new i.Q1f(0)
                        }
                    }]),
                    vertexShader: s.meshlambert_vert,
                    fragmentShader: s.meshlambert_frag
                },
                phong: {
                    uniforms: (0,
                    i.Iit)([o.common, o.specularmap, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.fog, o.lights, {
                        emissive: {
                            value: new i.Q1f(0)
                        },
                        specular: {
                            value: new i.Q1f(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: s.meshphong_vert,
                    fragmentShader: s.meshphong_frag
                },
                standard: {
                    uniforms: (0,
                    i.Iit)([o.common, o.envmap, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.roughnessmap, o.metalnessmap, o.fog, o.lights, {
                        emissive: {
                            value: new i.Q1f(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: s.meshphysical_vert,
                    fragmentShader: s.meshphysical_frag
                },
                toon: {
                    uniforms: (0,
                    i.Iit)([o.common, o.aomap, o.lightmap, o.emissivemap, o.bumpmap, o.normalmap, o.displacementmap, o.gradientmap, o.fog, o.lights, {
                        emissive: {
                            value: new i.Q1f(0)
                        }
                    }]),
                    vertexShader: s.meshtoon_vert,
                    fragmentShader: s.meshtoon_frag
                },
                matcap: {
                    uniforms: (0,
                    i.Iit)([o.common, o.bumpmap, o.normalmap, o.displacementmap, o.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: s.meshmatcap_vert,
                    fragmentShader: s.meshmatcap_frag
                },
                points: {
                    uniforms: (0,
                    i.Iit)([o.points, o.fog]),
                    vertexShader: s.points_vert,
                    fragmentShader: s.points_frag
                },
                dashed: {
                    uniforms: (0,
                    i.Iit)([o.common, o.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: s.linedashed_vert,
                    fragmentShader: s.linedashed_frag
                },
                depth: {
                    uniforms: (0,
                    i.Iit)([o.common, o.displacementmap]),
                    vertexShader: s.depth_vert,
                    fragmentShader: s.depth_frag
                },
                normal: {
                    uniforms: (0,
                    i.Iit)([o.common, o.bumpmap, o.normalmap, o.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: s.meshnormal_vert,
                    fragmentShader: s.meshnormal_frag
                },
                sprite: {
                    uniforms: (0,
                    i.Iit)([o.sprite, o.fog]),
                    vertexShader: s.sprite_vert,
                    fragmentShader: s.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new i.dwI
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: s.background_vert,
                    fragmentShader: s.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        },
                        backgroundRotation: {
                            value: new i.dwI
                        }
                    },
                    vertexShader: s.backgroundCube_vert,
                    fragmentShader: s.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: s.cube_vert,
                    fragmentShader: s.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: s.equirect_vert,
                    fragmentShader: s.equirect_frag
                },
                distance: {
                    uniforms: (0,
                    i.Iit)([o.common, o.displacementmap, {
                        referencePosition: {
                            value: new i.Pq0
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: s.distance_vert,
                    fragmentShader: s.distance_frag
                },
                shadow: {
                    uniforms: (0,
                    i.Iit)([o.lights, o.fog, {
                        color: {
                            value: new i.Q1f(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: s.shadow_vert,
                    fragmentShader: s.shadow_frag
                }
            };
            l.physical = {
                uniforms: (0,
                i.Iit)([l.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatMapTransform: {
                        value: new i.dwI
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    clearcoatNormalMapTransform: {
                        value: new i.dwI
                    },
                    clearcoatNormalScale: {
                        value: new i.I9Y(1,1)
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatRoughnessMapTransform: {
                        value: new i.dwI
                    },
                    dispersion: {
                        value: 0
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceMapTransform: {
                        value: new i.dwI
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    iridescenceThicknessMapTransform: {
                        value: new i.dwI
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new i.Q1f(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenColorMapTransform: {
                        value: new i.dwI
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    sheenRoughnessMapTransform: {
                        value: new i.dwI
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionMapTransform: {
                        value: new i.dwI
                    },
                    transmissionSamplerSize: {
                        value: new i.I9Y
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    thicknessMapTransform: {
                        value: new i.dwI
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new i.Q1f(0)
                    },
                    specularColor: {
                        value: new i.Q1f(1,1,1)
                    },
                    specularColorMap: {
                        value: null
                    },
                    specularColorMapTransform: {
                        value: new i.dwI
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularIntensityMapTransform: {
                        value: new i.dwI
                    },
                    anisotropyVector: {
                        value: new i.I9Y
                    },
                    anisotropyMap: {
                        value: null
                    },
                    anisotropyMapTransform: {
                        value: new i.dwI
                    }
                }]),
                vertexShader: s.meshphysical_vert,
                fragmentShader: s.meshphysical_frag
            };
            const c = {
                r: 0,
                b: 0,
                g: 0
            }
              , h = new i.O9p
              , d = new i.kn4;
            function u(e, t, n, r, a, s, o) {
                const u = new i.Q1f(0);
                let p, f, g = !0 === s ? 0 : 1, m = null, A = 0, v = null;
                function y(e) {
                    let i = !0 === e.isScene ? e.background : null;
                    if (i && i.isTexture) {
                        i = (e.backgroundBlurriness > 0 ? n : t).get(i)
                    }
                    return i
                }
                function w(t, n) {
                    t.getRGB(c, (0,
                    i._Ut)(e)),
                    r.buffers.color.setClear(c.r, c.g, c.b, n, o)
                }
                return {
                    getClearColor: function() {
                        return u
                    },
                    setClearColor: function(e, t=1) {
                        u.set(e),
                        g = t,
                        w(u, g)
                    },
                    getClearAlpha: function() {
                        return g
                    },
                    setClearAlpha: function(e) {
                        g = e,
                        w(u, g)
                    },
                    render: function(t) {
                        let n = !1;
                        const i = y(t);
                        null === i ? w(u, g) : i && i.isColor && (w(i, 1),
                        n = !0);
                        const a = e.xr.getEnvironmentBlendMode();
                        "additive" === a ? r.buffers.color.setClear(0, 0, 0, 1, o) : "alpha-blend" === a && r.buffers.color.setClear(0, 0, 0, 0, o),
                        (e.autoClear || n) && (r.buffers.depth.setTest(!0),
                        r.buffers.depth.setMask(!0),
                        r.buffers.color.setMask(!0),
                        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                    },
                    addToRenderList: function(t, n) {
                        const r = y(n);
                        r && (r.isCubeTexture || r.mapping === i.Om) ? (void 0 === f && (f = new i.eaF(new i.iNn(1,1,1),new i.BKk({
                            name: "BackgroundCubeMaterial",
                            uniforms: (0,
                            i.lxW)(l.backgroundCube.uniforms),
                            vertexShader: l.backgroundCube.vertexShader,
                            fragmentShader: l.backgroundCube.fragmentShader,
                            side: i.hsX,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        f.geometry.deleteAttribute("normal"),
                        f.geometry.deleteAttribute("uv"),
                        f.onBeforeRender = function(e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }
                        ,
                        Object.defineProperty(f.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        a.update(f)),
                        h.copy(n.backgroundRotation),
                        h.x *= -1,
                        h.y *= -1,
                        h.z *= -1,
                        r.isCubeTexture && !1 === r.isRenderTargetTexture && (h.y *= -1,
                        h.z *= -1),
                        f.material.uniforms.envMap.value = r,
                        f.material.uniforms.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1,
                        f.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness,
                        f.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                        f.material.uniforms.backgroundRotation.value.setFromMatrix4(d.makeRotationFromEuler(h)),
                        f.material.toneMapped = i.ppV.getTransfer(r.colorSpace) !== i.KLL,
                        m === r && A === r.version && v === e.toneMapping || (f.material.needsUpdate = !0,
                        m = r,
                        A = r.version,
                        v = e.toneMapping),
                        f.layers.enableAll(),
                        t.unshift(f, f.geometry, f.material, 0, 0, null)) : r && r.isTexture && (void 0 === p && (p = new i.eaF(new i.bdM(2,2),new i.BKk({
                            name: "BackgroundMaterial",
                            uniforms: (0,
                            i.lxW)(l.background.uniforms),
                            vertexShader: l.background.vertexShader,
                            fragmentShader: l.background.fragmentShader,
                            side: i.hB5,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1,
                            allowOverride: !1
                        })),
                        p.geometry.deleteAttribute("normal"),
                        Object.defineProperty(p.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        a.update(p)),
                        p.material.uniforms.t2D.value = r,
                        p.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                        p.material.toneMapped = i.ppV.getTransfer(r.colorSpace) !== i.KLL,
                        !0 === r.matrixAutoUpdate && r.updateMatrix(),
                        p.material.uniforms.uvTransform.value.copy(r.matrix),
                        m === r && A === r.version && v === e.toneMapping || (p.material.needsUpdate = !0,
                        m = r,
                        A = r.version,
                        v = e.toneMapping),
                        p.layers.enableAll(),
                        t.unshift(p, p.geometry, p.material, 0, 0, null))
                    },
                    dispose: function() {
                        void 0 !== f && (f.geometry.dispose(),
                        f.material.dispose(),
                        f = void 0),
                        void 0 !== p && (p.geometry.dispose(),
                        p.material.dispose(),
                        p = void 0)
                    }
                }
            }
            function p(e, t) {
                const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
                  , r = {}
                  , a = h(null);
                let s = a
                  , o = !1;
                function l(t) {
                    return e.bindVertexArray(t)
                }
                function c(t) {
                    return e.deleteVertexArray(t)
                }
                function h(e) {
                    const t = []
                      , i = []
                      , r = [];
                    for (let e = 0; e < n; e++)
                        t[e] = 0,
                        i[e] = 0,
                        r[e] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: i,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }
                function d() {
                    const e = s.newAttributes;
                    for (let t = 0, n = e.length; t < n; t++)
                        e[t] = 0
                }
                function u(e) {
                    p(e, 0)
                }
                function p(t, n) {
                    const i = s.newAttributes
                      , r = s.enabledAttributes
                      , a = s.attributeDivisors;
                    i[t] = 1,
                    0 === r[t] && (e.enableVertexAttribArray(t),
                    r[t] = 1),
                    a[t] !== n && (e.vertexAttribDivisor(t, n),
                    a[t] = n)
                }
                function f() {
                    const t = s.newAttributes
                      , n = s.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++)
                        n[i] !== t[i] && (e.disableVertexAttribArray(i),
                        n[i] = 0)
                }
                function g(t, n, i, r, a, s, o) {
                    !0 === o ? e.vertexAttribIPointer(t, n, i, a, s) : e.vertexAttribPointer(t, n, i, r, a, s)
                }
                function m() {
                    A(),
                    o = !0,
                    s !== a && (s = a,
                    l(s.object))
                }
                function A() {
                    a.geometry = null,
                    a.program = null,
                    a.wireframe = !1
                }
                return {
                    setup: function(n, a, c, m, A) {
                        let v = !1;
                        const y = function(t, n, i) {
                            const a = !0 === i.wireframe;
                            let s = r[t.id];
                            void 0 === s && (s = {},
                            r[t.id] = s);
                            let o = s[n.id];
                            void 0 === o && (o = {},
                            s[n.id] = o);
                            let l = o[a];
                            void 0 === l && (l = h(e.createVertexArray()),
                            o[a] = l);
                            return l
                        }(m, c, a);
                        s !== y && (s = y,
                        l(s.object)),
                        v = function(e, t, n, i) {
                            const r = s.attributes
                              , a = t.attributes;
                            let o = 0;
                            const l = n.getAttributes();
                            for (const t in l) {
                                if (l[t].location >= 0) {
                                    const n = r[t];
                                    let i = a[t];
                                    if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                                    "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                                    void 0 === n)
                                        return !0;
                                    if (n.attribute !== i)
                                        return !0;
                                    if (i && n.data !== i.data)
                                        return !0;
                                    o++
                                }
                            }
                            return s.attributesNum !== o || s.index !== i
                        }(n, m, c, A),
                        v && function(e, t, n, i) {
                            const r = {}
                              , a = t.attributes;
                            let o = 0;
                            const l = n.getAttributes();
                            for (const t in l) {
                                if (l[t].location >= 0) {
                                    let n = a[t];
                                    void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                    "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                    const i = {};
                                    i.attribute = n,
                                    n && n.data && (i.data = n.data),
                                    r[t] = i,
                                    o++
                                }
                            }
                            s.attributes = r,
                            s.attributesNum = o,
                            s.index = i
                        }(n, m, c, A),
                        null !== A && t.update(A, e.ELEMENT_ARRAY_BUFFER),
                        (v || o) && (o = !1,
                        function(n, r, a, s) {
                            d();
                            const o = s.attributes
                              , l = a.getAttributes()
                              , c = r.defaultAttributeValues;
                            for (const r in l) {
                                const a = l[r];
                                if (a.location >= 0) {
                                    let l = o[r];
                                    if (void 0 === l && ("instanceMatrix" === r && n.instanceMatrix && (l = n.instanceMatrix),
                                    "instanceColor" === r && n.instanceColor && (l = n.instanceColor)),
                                    void 0 !== l) {
                                        const r = l.normalized
                                          , o = l.itemSize
                                          , c = t.get(l);
                                        if (void 0 === c)
                                            continue;
                                        const h = c.buffer
                                          , d = c.type
                                          , f = c.bytesPerElement
                                          , m = d === e.INT || d === e.UNSIGNED_INT || l.gpuType === i.Yuy;
                                        if (l.isInterleavedBufferAttribute) {
                                            const t = l.data
                                              , i = t.stride
                                              , c = l.offset;
                                            if (t.isInstancedInterleavedBuffer) {
                                                for (let e = 0; e < a.locationSize; e++)
                                                    p(a.location + e, t.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                            } else
                                                for (let e = 0; e < a.locationSize; e++)
                                                    u(a.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, h);
                                            for (let e = 0; e < a.locationSize; e++)
                                                g(a.location + e, o / a.locationSize, d, r, i * f, (c + o / a.locationSize * e) * f, m)
                                        } else {
                                            if (l.isInstancedBufferAttribute) {
                                                for (let e = 0; e < a.locationSize; e++)
                                                    p(a.location + e, l.meshPerAttribute);
                                                !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = l.meshPerAttribute * l.count)
                                            } else
                                                for (let e = 0; e < a.locationSize; e++)
                                                    u(a.location + e);
                                            e.bindBuffer(e.ARRAY_BUFFER, h);
                                            for (let e = 0; e < a.locationSize; e++)
                                                g(a.location + e, o / a.locationSize, d, r, o * f, o / a.locationSize * e * f, m)
                                        }
                                    } else if (void 0 !== c) {
                                        const t = c[r];
                                        if (void 0 !== t)
                                            switch (t.length) {
                                            case 2:
                                                e.vertexAttrib2fv(a.location, t);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(a.location, t);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(a.location, t);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(a.location, t)
                                            }
                                    }
                                }
                            }
                            f()
                        }(n, a, c, m),
                        null !== A && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(A).buffer))
                    },
                    reset: m,
                    resetDefaultState: A,
                    dispose: function() {
                        m();
                        for (const e in r) {
                            const t = r[e];
                            for (const e in t) {
                                const n = t[e];
                                for (const e in n)
                                    c(n[e].object),
                                    delete n[e];
                                delete t[e]
                            }
                            delete r[e]
                        }
                    },
                    releaseStatesOfGeometry: function(e) {
                        if (void 0 === r[e.id])
                            return;
                        const t = r[e.id];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                c(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete r[e.id]
                    },
                    releaseStatesOfProgram: function(e) {
                        for (const t in r) {
                            const n = r[t];
                            if (void 0 === n[e.id])
                                continue;
                            const i = n[e.id];
                            for (const e in i)
                                c(i[e].object),
                                delete i[e];
                            delete n[e.id]
                        }
                    },
                    initAttributes: d,
                    enableAttribute: u,
                    disableUnusedAttributes: f
                }
            }
            function f(e, t, n) {
                let i;
                function r(t, r, a) {
                    0 !== a && (e.drawArraysInstanced(i, t, r, a),
                    n.update(r, i, a))
                }
                this.setMode = function(e) {
                    i = e
                }
                ,
                this.render = function(t, r) {
                    e.drawArrays(i, t, r),
                    n.update(r, i, 1)
                }
                ,
                this.renderInstances = r,
                this.renderMultiDraw = function(e, r, a) {
                    if (0 === a)
                        return;
                    t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, a);
                    let s = 0;
                    for (let e = 0; e < a; e++)
                        s += r[e];
                    n.update(s, i, 1)
                }
                ,
                this.renderMultiDrawInstances = function(e, a, s, o) {
                    if (0 === s)
                        return;
                    const l = t.get("WEBGL_multi_draw");
                    if (null === l)
                        for (let t = 0; t < e.length; t++)
                            r(e[t], a[t], o[t]);
                    else {
                        l.multiDrawArraysInstancedWEBGL(i, e, 0, a, 0, o, 0, s);
                        let t = 0;
                        for (let e = 0; e < s; e++)
                            t += a[e] * o[e];
                        n.update(t, i, 1)
                    }
                }
            }
            function g(e, t, n, r) {
                let a;
                function s(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                            return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                let o = void 0 !== n.precision ? n.precision : "highp";
                const l = s(o);
                l !== o && ((0,
                i.R8M)("WebGLRenderer:", o, "not supported, using", l, "instead."),
                o = l);
                return {
                    isWebGL2: !0,
                    getMaxAnisotropy: function() {
                        if (void 0 !== a)
                            return a;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            const n = t.get("EXT_texture_filter_anisotropic");
                            a = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else
                            a = 0;
                        return a
                    },
                    getMaxPrecision: s,
                    textureFormatReadable: function(t) {
                        return t === i.GWd || r.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                    },
                    textureTypeReadable: function(n) {
                        const a = n === i.ix0 && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                        return !(n !== i.OUM && r.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== i.RQf && !a)
                    },
                    precision: o,
                    logarithmicDepthBuffer: !0 === n.logarithmicDepthBuffer,
                    reversedDepthBuffer: !0 === n.reversedDepthBuffer && t.has("EXT_clip_control"),
                    maxTextures: e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                    maxVertexTextures: e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                    maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                    maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                    maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                    maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                    maxSamples: e.getParameter(e.MAX_SAMPLES),
                    samples: e.getParameter(e.SAMPLES)
                }
            }
            function m(e) {
                const t = this;
                let n = null
                  , r = 0
                  , a = !1
                  , s = !1;
                const o = new i.Zcv
                  , l = new i.dwI
                  , c = {
                    value: null,
                    needsUpdate: !1
                };
                function h(e, n, i, r) {
                    const a = null !== e ? e.length : 0;
                    let s = null;
                    if (0 !== a) {
                        if (s = c.value,
                        !0 !== r || null === s) {
                            const t = i + 4 * a
                              , r = n.matrixWorldInverse;
                            l.getNormalMatrix(r),
                            (null === s || s.length < t) && (s = new Float32Array(t));
                            for (let t = 0, n = i; t !== a; ++t,
                            n += 4)
                                o.copy(e[t]).applyMatrix4(r, l),
                                o.normal.toArray(s, n),
                                s[n + 3] = o.constant
                        }
                        c.value = s,
                        c.needsUpdate = !0
                    }
                    return t.numPlanes = a,
                    t.numIntersection = 0,
                    s
                }
                this.uniform = c,
                this.numPlanes = 0,
                this.numIntersection = 0,
                this.init = function(e, t) {
                    const n = 0 !== e.length || t || 0 !== r || a;
                    return a = t,
                    r = e.length,
                    n
                }
                ,
                this.beginShadows = function() {
                    s = !0,
                    h(null)
                }
                ,
                this.endShadows = function() {
                    s = !1
                }
                ,
                this.setGlobalState = function(e, t) {
                    n = h(e, t, 0)
                }
                ,
                this.setState = function(i, o, l) {
                    const d = i.clippingPlanes
                      , u = i.clipIntersection
                      , p = i.clipShadows
                      , f = e.get(i);
                    if (!a || null === d || 0 === d.length || s && !p)
                        s ? h(null) : function() {
                            c.value !== n && (c.value = n,
                            c.needsUpdate = r > 0);
                            t.numPlanes = r,
                            t.numIntersection = 0
                        }();
                    else {
                        const e = s ? 0 : r
                          , t = 4 * e;
                        let i = f.clippingState || null;
                        c.value = i,
                        i = h(d, o, t, l);
                        for (let e = 0; e !== t; ++e)
                            i[e] = n[e];
                        f.clippingState = i,
                        this.numIntersection = u ? this.numPlanes : 0,
                        this.numPlanes += e
                    }
                }
            }
            function A(e) {
                let t = new WeakMap;
                function n(e, t) {
                    return t === i.wfO ? e.mapping = i.hy7 : t === i.uV5 && (e.mapping = i.xFO),
                    e
                }
                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n),
                    i.dispose())
                }
                return {
                    get: function(a) {
                        if (a && a.isTexture) {
                            const s = a.mapping;
                            if (s === i.wfO || s === i.uV5) {
                                if (t.has(a)) {
                                    return n(t.get(a).texture, a.mapping)
                                }
                                {
                                    const s = a.image;
                                    if (s && s.height > 0) {
                                        const o = new i.o6l(s.height);
                                        return o.fromEquirectangularTexture(e, a),
                                        t.set(a, o),
                                        a.addEventListener("dispose", r),
                                        n(o.texture, a.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return a
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            const v = [.125, .215, .35, .446, .526, .582]
              , y = 20
              , w = new i.qUd
              , b = new i.Q1f;
            let x = null
              , S = 0
              , E = 0
              , T = !1;
            const k = new i.Pq0;
            class M {
                constructor(e) {
                    this._renderer = e,
                    this._pingPongRenderTarget = null,
                    this._lodMax = 0,
                    this._cubeSize = 0,
                    this._sizeLods = [],
                    this._sigmas = [],
                    this._lodMeshes = [],
                    this._backgroundBox = null,
                    this._cubemapMaterial = null,
                    this._equirectMaterial = null,
                    this._blurMaterial = null,
                    this._ggxMaterial = null
                }
                fromScene(e, t=0, n=.1, i=100, r={}) {
                    const {size: a=256, position: s=k} = r;
                    x = this._renderer.getRenderTarget(),
                    S = this._renderer.getActiveCubeFace(),
                    E = this._renderer.getActiveMipmapLevel(),
                    T = this._renderer.xr.enabled,
                    this._renderer.xr.enabled = !1,
                    this._setSize(a);
                    const o = this._allocateTargets();
                    return o.depthBuffer = !0,
                    this._sceneToCubeUV(e, n, i, o, s),
                    t > 0 && this._blur(o, 0, 0, t),
                    this._applyPMREM(o),
                    this._cleanup(o),
                    o
                }
                fromEquirectangular(e, t=null) {
                    return this._fromTexture(e, t)
                }
                fromCubemap(e, t=null) {
                    return this._fromTexture(e, t)
                }
                compileCubemapShader() {
                    null === this._cubemapMaterial && (this._cubemapMaterial = P(),
                    this._compileMaterial(this._cubemapMaterial))
                }
                compileEquirectangularShader() {
                    null === this._equirectMaterial && (this._equirectMaterial = R(),
                    this._compileMaterial(this._equirectMaterial))
                }
                dispose() {
                    this._dispose(),
                    null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                    null !== this._equirectMaterial && this._equirectMaterial.dispose(),
                    null !== this._backgroundBox && (this._backgroundBox.geometry.dispose(),
                    this._backgroundBox.material.dispose())
                }
                _setSize(e) {
                    this._lodMax = Math.floor(Math.log2(e)),
                    this._cubeSize = Math.pow(2, this._lodMax)
                }
                _dispose() {
                    null !== this._blurMaterial && this._blurMaterial.dispose(),
                    null !== this._ggxMaterial && this._ggxMaterial.dispose(),
                    null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                    for (let e = 0; e < this._lodMeshes.length; e++)
                        this._lodMeshes[e].geometry.dispose()
                }
                _cleanup(e) {
                    this._renderer.setRenderTarget(x, S, E),
                    this._renderer.xr.enabled = T,
                    e.scissorTest = !1,
                    C(e, 0, 0, e.width, e.height)
                }
                _fromTexture(e, t) {
                    e.mapping === i.hy7 || e.mapping === i.xFO ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                    x = this._renderer.getRenderTarget(),
                    S = this._renderer.getActiveCubeFace(),
                    E = this._renderer.getActiveMipmapLevel(),
                    T = this._renderer.xr.enabled,
                    this._renderer.xr.enabled = !1;
                    const n = t || this._allocateTargets();
                    return this._textureToCubeUV(e, n),
                    this._applyPMREM(n),
                    this._cleanup(n),
                    n
                }
                _allocateTargets() {
                    const e = 3 * Math.max(this._cubeSize, 112)
                      , t = 4 * this._cubeSize
                      , n = {
                        magFilter: i.k6q,
                        minFilter: i.k6q,
                        generateMipmaps: !1,
                        type: i.ix0,
                        format: i.GWd,
                        colorSpace: i.Zr2,
                        depthBuffer: !1
                    }
                      , r = _(e, t, n);
                    if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                        null !== this._pingPongRenderTarget && this._dispose(),
                        this._pingPongRenderTarget = _(e, t, n);
                        const {_lodMax: r} = this;
                        ({lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas} = function(e) {
                            const t = []
                              , n = []
                              , r = [];
                            let a = e;
                            const s = e - 4 + 1 + v.length;
                            for (let o = 0; o < s; o++) {
                                const s = Math.pow(2, a);
                                t.push(s);
                                let l = 1 / s;
                                o > e - 4 ? l = v[o - e + 4 - 1] : 0 === o && (l = 0),
                                n.push(l);
                                const c = 1 / (s - 2)
                                  , h = -c
                                  , d = 1 + c
                                  , u = [h, h, d, h, d, d, h, h, d, d, h, d]
                                  , p = 6
                                  , f = 6
                                  , g = 3
                                  , m = 2
                                  , A = 1
                                  , y = new Float32Array(g * f * p)
                                  , w = new Float32Array(m * f * p)
                                  , b = new Float32Array(A * f * p);
                                for (let e = 0; e < p; e++) {
                                    const t = e % 3 * 2 / 3 - 1
                                      , n = e > 2 ? 0 : -1
                                      , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                    y.set(i, g * f * e),
                                    w.set(u, m * f * e);
                                    const r = [e, e, e, e, e, e];
                                    b.set(r, A * f * e)
                                }
                                const x = new i.LoY;
                                x.setAttribute("position", new i.THS(y,g)),
                                x.setAttribute("uv", new i.THS(w,m)),
                                x.setAttribute("faceIndex", new i.THS(b,A)),
                                r.push(new i.eaF(x,null)),
                                a > 4 && a--
                            }
                            return {
                                lodMeshes: r,
                                sizeLods: t,
                                sigmas: n
                            }
                        }(r)),
                        this._blurMaterial = function(e, t, n) {
                            const r = new Float32Array(y)
                              , a = new i.Pq0(0,1,0)
                              , s = new i.BKk({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: y,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: r
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: a
                                    }
                                },
                                vertexShader: I(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: i.XIg,
                                depthTest: !1,
                                depthWrite: !1
                            });
                            return s
                        }(r, e, t),
                        this._ggxMaterial = function(e, t, n) {
                            const r = new i.BKk({
                                name: "PMREMGGXConvolution",
                                defines: {
                                    GGX_SAMPLES: 256,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    roughness: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    }
                                },
                                vertexShader: I(),
                                fragmentShader: '\n\n\t\t\tprecision highp float;\n\t\t\tprecision highp int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform float roughness;\n\t\t\tuniform float mipInt;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\t#define PI 3.14159265359\n\n\t\t\t// Van der Corput radical inverse\n\t\t\tfloat radicalInverse_VdC(uint bits) {\n\t\t\t\tbits = (bits << 16u) | (bits >> 16u);\n\t\t\t\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\t\t\t\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\t\t\t\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\t\t\t\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\t\t\t\treturn float(bits) * 2.3283064365386963e-10; // / 0x100000000\n\t\t\t}\n\n\t\t\t// Hammersley sequence\n\t\t\tvec2 hammersley(uint i, uint N) {\n\t\t\t\treturn vec2(float(i) / float(N), radicalInverse_VdC(i));\n\t\t\t}\n\n\t\t\t// GGX VNDF importance sampling (Eric Heitz 2018)\n\t\t\t// "Sampling the GGX Distribution of Visible Normals"\n\t\t\t// https://jcgt.org/published/0007/04/01/\n\t\t\tvec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {\n\t\t\t\tfloat alpha = roughness * roughness;\n\n\t\t\t\t// Section 3.2: Transform view direction to hemisphere configuration\n\t\t\t\tvec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));\n\n\t\t\t\t// Section 4.1: Orthonormal basis\n\t\t\t\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\t\t\t\tvec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 T2 = cross(Vh, T1);\n\n\t\t\t\t// Section 4.2: Parameterization of projected area\n\t\t\t\tfloat r = sqrt(Xi.x);\n\t\t\t\tfloat phi = 2.0 * PI * Xi.y;\n\t\t\t\tfloat t1 = r * cos(phi);\n\t\t\t\tfloat t2 = r * sin(phi);\n\t\t\t\tfloat s = 0.5 * (1.0 + Vh.z);\n\t\t\t\tt2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;\n\n\t\t\t\t// Section 4.3: Reprojection onto hemisphere\n\t\t\t\tvec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;\n\n\t\t\t\t// Section 3.4: Transform back to ellipsoid configuration\n\t\t\t\treturn normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));\n\t\t\t}\n\n\t\t\tvoid main() {\n\t\t\t\tvec3 N = normalize(vOutputDirection);\n\t\t\t\tvec3 V = N; // Assume view direction equals normal for pre-filtering\n\n\t\t\t\tvec3 prefilteredColor = vec3(0.0);\n\t\t\t\tfloat totalWeight = 0.0;\n\n\t\t\t\t// For very low roughness, just sample the environment directly\n\t\t\t\tif (roughness < 0.001) {\n\t\t\t\t\tgl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Tangent space basis for VNDF sampling\n\t\t\t\tvec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 tangent = normalize(cross(up, N));\n\t\t\t\tvec3 bitangent = cross(N, tangent);\n\n\t\t\t\tfor(uint i = 0u; i < uint(GGX_SAMPLES); i++) {\n\t\t\t\t\tvec2 Xi = hammersley(i, uint(GGX_SAMPLES));\n\n\t\t\t\t\t// For PMREM, V = N, so in tangent space V is always (0, 0, 1)\n\t\t\t\t\tvec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);\n\n\t\t\t\t\t// Transform H back to world space\n\t\t\t\t\tvec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);\n\t\t\t\t\tvec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n\t\t\t\t\tfloat NdotL = max(dot(N, L), 0.0);\n\n\t\t\t\t\tif(NdotL > 0.0) {\n\t\t\t\t\t\t// Sample environment at fixed mip level\n\t\t\t\t\t\t// VNDF importance sampling handles the distribution filtering\n\t\t\t\t\t\tvec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);\n\n\t\t\t\t\t\t// Weight by NdotL for the split-sum approximation\n\t\t\t\t\t\t// VNDF PDF naturally accounts for the visible microfacet distribution\n\t\t\t\t\t\tprefilteredColor += sampleColor * NdotL;\n\t\t\t\t\t\ttotalWeight += NdotL;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (totalWeight > 0.0) {\n\t\t\t\t\tprefilteredColor = prefilteredColor / totalWeight;\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = vec4(prefilteredColor, 1.0);\n\t\t\t}\n\t\t',
                                blending: i.XIg,
                                depthTest: !1,
                                depthWrite: !1
                            });
                            return r
                        }(r, e, t)
                    }
                    return r
                }
                _compileMaterial(e) {
                    const t = new i.eaF(new i.LoY,e);
                    this._renderer.compile(t, w)
                }
                _sceneToCubeUV(e, t, n, r, a) {
                    const s = new i.ubm(90,1,t,n)
                      , o = [1, -1, 1, 1, 1, 1]
                      , l = [1, 1, 1, -1, -1, -1]
                      , c = this._renderer
                      , h = c.autoClear
                      , d = c.toneMapping;
                    c.getClearColor(b),
                    c.toneMapping = i.y_p,
                    c.autoClear = !1;
                    c.state.buffers.depth.getReversed() && (c.setRenderTarget(r),
                    c.clearDepth(),
                    c.setRenderTarget(null)),
                    null === this._backgroundBox && (this._backgroundBox = new i.eaF(new i.iNn,new i.V9B({
                        name: "PMREM.Background",
                        side: i.hsX,
                        depthWrite: !1,
                        depthTest: !1
                    })));
                    const u = this._backgroundBox
                      , p = u.material;
                    let f = !1;
                    const g = e.background;
                    g ? g.isColor && (p.color.copy(g),
                    e.background = null,
                    f = !0) : (p.color.copy(b),
                    f = !0);
                    for (let t = 0; t < 6; t++) {
                        const n = t % 3;
                        0 === n ? (s.up.set(0, o[t], 0),
                        s.position.set(a.x, a.y, a.z),
                        s.lookAt(a.x + l[t], a.y, a.z)) : 1 === n ? (s.up.set(0, 0, o[t]),
                        s.position.set(a.x, a.y, a.z),
                        s.lookAt(a.x, a.y + l[t], a.z)) : (s.up.set(0, o[t], 0),
                        s.position.set(a.x, a.y, a.z),
                        s.lookAt(a.x, a.y, a.z + l[t]));
                        const i = this._cubeSize;
                        C(r, n * i, t > 2 ? i : 0, i, i),
                        c.setRenderTarget(r),
                        f && c.render(u, s),
                        c.render(e, s)
                    }
                    c.toneMapping = d,
                    c.autoClear = h,
                    e.background = g
                }
                _textureToCubeUV(e, t) {
                    const n = this._renderer
                      , r = e.mapping === i.hy7 || e.mapping === i.xFO;
                    r ? (null === this._cubemapMaterial && (this._cubemapMaterial = P()),
                    this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = R());
                    const a = r ? this._cubemapMaterial : this._equirectMaterial
                      , s = this._lodMeshes[0];
                    s.material = a;
                    a.uniforms.envMap.value = e;
                    const o = this._cubeSize;
                    C(t, 0, 0, 3 * o, 2 * o),
                    n.setRenderTarget(t),
                    n.render(s, w)
                }
                _applyPMREM(e) {
                    const t = this._renderer
                      , n = t.autoClear;
                    t.autoClear = !1;
                    const i = this._lodMeshes.length;
                    for (let t = 1; t < i; t++)
                        this._applyGGXFilter(e, t - 1, t);
                    t.autoClear = n
                }
                _applyGGXFilter(e, t, n) {
                    const i = this._renderer
                      , r = this._pingPongRenderTarget
                      , a = this._ggxMaterial
                      , s = this._lodMeshes[n];
                    s.material = a;
                    const o = a.uniforms
                      , l = n / (this._lodMeshes.length - 1)
                      , c = t / (this._lodMeshes.length - 1)
                      , h = Math.sqrt(l * l - c * c) * (0 + 1.25 * l)
                      , {_lodMax: d} = this
                      , u = this._sizeLods[n]
                      , p = 3 * u * (n > d - 4 ? n - d + 4 : 0)
                      , f = 4 * (this._cubeSize - u);
                    o.envMap.value = e.texture,
                    o.roughness.value = h,
                    o.mipInt.value = d - t,
                    C(r, p, f, 3 * u, 2 * u),
                    i.setRenderTarget(r),
                    i.render(s, w),
                    o.envMap.value = r.texture,
                    o.roughness.value = 0,
                    o.mipInt.value = d - n,
                    C(e, p, f, 3 * u, 2 * u),
                    i.setRenderTarget(e),
                    i.render(s, w)
                }
                _blur(e, t, n, i, r) {
                    const a = this._pingPongRenderTarget;
                    this._halfBlur(e, a, t, n, i, "latitudinal", r),
                    this._halfBlur(a, e, n, n, i, "longitudinal", r)
                }
                _halfBlur(e, t, n, r, a, s, o) {
                    const l = this._renderer
                      , c = this._blurMaterial;
                    "latitudinal" !== s && "longitudinal" !== s && (0,
                    i.z3S)("blur direction must be either latitudinal or longitudinal!");
                    const h = this._lodMeshes[r];
                    h.material = c;
                    const d = c.uniforms
                      , u = this._sizeLods[n] - 1
                      , p = isFinite(a) ? Math.PI / (2 * u) : 2 * Math.PI / 39
                      , f = a / p
                      , g = isFinite(a) ? 1 + Math.floor(3 * f) : y;
                    g > y && (0,
                    i.R8M)(`sigmaRadians, ${a}, is too large and will clip, as it requested ${g} samples when the maximum is set to 20`);
                    const m = [];
                    let A = 0;
                    for (let e = 0; e < y; ++e) {
                        const t = e / f
                          , n = Math.exp(-t * t / 2);
                        m.push(n),
                        0 === e ? A += n : e < g && (A += 2 * n)
                    }
                    for (let e = 0; e < m.length; e++)
                        m[e] = m[e] / A;
                    d.envMap.value = e.texture,
                    d.samples.value = g,
                    d.weights.value = m,
                    d.latitudinal.value = "latitudinal" === s,
                    o && (d.poleAxis.value = o);
                    const {_lodMax: v} = this;
                    d.dTheta.value = p,
                    d.mipInt.value = v - n;
                    const b = this._sizeLods[r];
                    C(t, 3 * b * (r > v - 4 ? r - v + 4 : 0), 4 * (this._cubeSize - b), 3 * b, 2 * b),
                    l.setRenderTarget(t),
                    l.render(h, w)
                }
            }
            function _(e, t, n) {
                const r = new i.nWS(e,t,n);
                return r.texture.mapping = i.Om,
                r.texture.name = "PMREM.cubeUv",
                r.scissorTest = !0,
                r
            }
            function C(e, t, n, i, r) {
                e.viewport.set(t, n, i, r),
                e.scissor.set(t, n, i, r)
            }
            function R() {
                return new i.BKk({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: I(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: i.XIg,
                    depthTest: !1,
                    depthWrite: !1
                })
            }
            function P() {
                return new i.BKk({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: I(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: i.XIg,
                    depthTest: !1,
                    depthWrite: !1
                })
            }
            function I() {
                return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
            }
            function L(e) {
                let t = new WeakMap
                  , n = null;
                function r(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", r);
                    const i = t.get(n);
                    void 0 !== i && (t.delete(n),
                    i.dispose())
                }
                return {
                    get: function(a) {
                        if (a && a.isTexture) {
                            const s = a.mapping
                              , o = s === i.wfO || s === i.uV5
                              , l = s === i.hy7 || s === i.xFO;
                            if (o || l) {
                                let i = t.get(a);
                                const s = void 0 !== i ? i.texture.pmremVersion : 0;
                                if (a.isRenderTargetTexture && a.pmremVersion !== s)
                                    return null === n && (n = new M(e)),
                                    i = o ? n.fromEquirectangular(a, i) : n.fromCubemap(a, i),
                                    i.texture.pmremVersion = a.pmremVersion,
                                    t.set(a, i),
                                    i.texture;
                                if (void 0 !== i)
                                    return i.texture;
                                {
                                    const s = a.image;
                                    return o && s && s.height > 0 || l && s && function(e) {
                                        let t = 0;
                                        const n = 6;
                                        for (let i = 0; i < n; i++)
                                            void 0 !== e[i] && t++;
                                        return t === n
                                    }(s) ? (null === n && (n = new M(e)),
                                    i = o ? n.fromEquirectangular(a) : n.fromCubemap(a),
                                    i.texture.pmremVersion = a.pmremVersion,
                                    t.set(a, i),
                                    a.addEventListener("dispose", r),
                                    i.texture) : null
                                }
                            }
                        }
                        return a
                    },
                    dispose: function() {
                        t = new WeakMap,
                        null !== n && (n.dispose(),
                        n = null)
                    }
                }
            }
            function N(e) {
                const t = {};
                function n(n) {
                    if (void 0 !== t[n])
                        return t[n];
                    const i = e.getExtension(n);
                    return t[n] = i,
                    i
                }
                return {
                    has: function(e) {
                        return null !== n(e)
                    },
                    init: function() {
                        n("EXT_color_buffer_float"),
                        n("WEBGL_clip_cull_distance"),
                        n("OES_texture_float_linear"),
                        n("EXT_color_buffer_half_float"),
                        n("WEBGL_multisampled_render_to_texture"),
                        n("WEBGL_render_shared_exponent")
                    },
                    get: function(e) {
                        const t = n(e);
                        return null === t && (0,
                        i.mcG)("WebGLRenderer: " + e + " extension not supported."),
                        t
                    }
                }
            }
            function z(e, t, n, r) {
                const a = {}
                  , s = new WeakMap;
                function o(e) {
                    const i = e.target;
                    null !== i.index && t.remove(i.index);
                    for (const e in i.attributes)
                        t.remove(i.attributes[e]);
                    i.removeEventListener("dispose", o),
                    delete a[i.id];
                    const l = s.get(i);
                    l && (t.remove(l),
                    s.delete(i)),
                    r.releaseStatesOfGeometry(i),
                    !0 === i.isInstancedBufferGeometry && delete i._maxInstanceCount,
                    n.memory.geometries--
                }
                function l(e) {
                    const n = []
                      , r = e.index
                      , a = e.attributes.position;
                    let o = 0;
                    if (null !== r) {
                        const e = r.array;
                        o = r.version;
                        for (let t = 0, i = e.length; t < i; t += 3) {
                            const i = e[t + 0]
                              , r = e[t + 1]
                              , a = e[t + 2];
                            n.push(i, r, r, a, a, i)
                        }
                    } else {
                        if (void 0 === a)
                            return;
                        {
                            const e = a.array;
                            o = a.version;
                            for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                                const e = t + 0
                                  , i = t + 1
                                  , r = t + 2;
                                n.push(e, i, i, r, r, e)
                            }
                        }
                    }
                    const l = new ((0,
                    i.AQS)(n) ? i.MW4 : i.A$4)(n,1);
                    l.version = o;
                    const c = s.get(e);
                    c && t.remove(c),
                    s.set(e, l)
                }
                return {
                    get: function(e, t) {
                        return !0 === a[t.id] || (t.addEventListener("dispose", o),
                        a[t.id] = !0,
                        n.memory.geometries++),
                        t
                    },
                    update: function(n) {
                        const i = n.attributes;
                        for (const n in i)
                            t.update(i[n], e.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function(e) {
                        const t = s.get(e);
                        if (t) {
                            const n = e.index;
                            null !== n && t.version < n.version && l(e)
                        } else
                            l(e);
                        return s.get(e)
                    }
                }
            }
            function U(e, t, n) {
                let i, r, a;
                function s(t, s, o) {
                    0 !== o && (e.drawElementsInstanced(i, s, r, t * a, o),
                    n.update(s, i, o))
                }
                this.setMode = function(e) {
                    i = e
                }
                ,
                this.setIndex = function(e) {
                    r = e.type,
                    a = e.bytesPerElement
                }
                ,
                this.render = function(t, s) {
                    e.drawElements(i, s, r, t * a),
                    n.update(s, i, 1)
                }
                ,
                this.renderInstances = s,
                this.renderMultiDraw = function(e, a, s) {
                    if (0 === s)
                        return;
                    t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, a, 0, r, e, 0, s);
                    let o = 0;
                    for (let e = 0; e < s; e++)
                        o += a[e];
                    n.update(o, i, 1)
                }
                ,
                this.renderMultiDrawInstances = function(e, o, l, c) {
                    if (0 === l)
                        return;
                    const h = t.get("WEBGL_multi_draw");
                    if (null === h)
                        for (let t = 0; t < e.length; t++)
                            s(e[t] / a, o[t], c[t]);
                    else {
                        h.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
                        let t = 0;
                        for (let e = 0; e < l; e++)
                            t += o[e] * c[e];
                        n.update(t, i, 1)
                    }
                }
            }
            function D(e) {
                const t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        t.calls = 0,
                        t.triangles = 0,
                        t.points = 0,
                        t.lines = 0
                    },
                    update: function(n, r, a) {
                        switch (t.calls++,
                        r) {
                        case e.TRIANGLES:
                            t.triangles += a * (n / 3);
                            break;
                        case e.LINES:
                            t.lines += a * (n / 2);
                            break;
                        case e.LINE_STRIP:
                            t.lines += a * (n - 1);
                            break;
                        case e.LINE_LOOP:
                            t.lines += a * n;
                            break;
                        case e.POINTS:
                            t.points += a * n;
                            break;
                        default:
                            (0,
                            i.z3S)("WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }
            function B(e, t, n) {
                const r = new WeakMap
                  , a = new i.IUQ;
                return {
                    update: function(s, o, l) {
                        const c = s.morphTargetInfluences
                          , h = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color
                          , d = void 0 !== h ? h.length : 0;
                        let u = r.get(o);
                        if (void 0 === u || u.count !== d) {
                            void 0 !== u && u.texture.dispose();
                            const p = void 0 !== o.morphAttributes.position
                              , f = void 0 !== o.morphAttributes.normal
                              , g = void 0 !== o.morphAttributes.color
                              , m = o.morphAttributes.position || []
                              , A = o.morphAttributes.normal || []
                              , v = o.morphAttributes.color || [];
                            let y = 0;
                            !0 === p && (y = 1),
                            !0 === f && (y = 2),
                            !0 === g && (y = 3);
                            let w = o.attributes.position.count * y
                              , b = 1;
                            w > t.maxTextureSize && (b = Math.ceil(w / t.maxTextureSize),
                            w = t.maxTextureSize);
                            const x = new Float32Array(w * b * 4 * d)
                              , S = new i.rFo(x,w,b,d);
                            S.type = i.RQf,
                            S.needsUpdate = !0;
                            const E = 4 * y;
                            for (let k = 0; k < d; k++) {
                                const M = m[k]
                                  , _ = A[k]
                                  , C = v[k]
                                  , R = w * b * 4 * k;
                                for (let P = 0; P < M.count; P++) {
                                    const I = P * E;
                                    !0 === p && (a.fromBufferAttribute(M, P),
                                    x[R + I + 0] = a.x,
                                    x[R + I + 1] = a.y,
                                    x[R + I + 2] = a.z,
                                    x[R + I + 3] = 0),
                                    !0 === f && (a.fromBufferAttribute(_, P),
                                    x[R + I + 4] = a.x,
                                    x[R + I + 5] = a.y,
                                    x[R + I + 6] = a.z,
                                    x[R + I + 7] = 0),
                                    !0 === g && (a.fromBufferAttribute(C, P),
                                    x[R + I + 8] = a.x,
                                    x[R + I + 9] = a.y,
                                    x[R + I + 10] = a.z,
                                    x[R + I + 11] = 4 === C.itemSize ? a.w : 1)
                                }
                            }
                            function T() {
                                S.dispose(),
                                r.delete(o),
                                o.removeEventListener("dispose", T)
                            }
                            u = {
                                count: d,
                                texture: S,
                                size: new i.I9Y(w,b)
                            },
                            r.set(o, u),
                            o.addEventListener("dispose", T)
                        }
                        if (!0 === s.isInstancedMesh && null !== s.morphTexture)
                            l.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
                        else {
                            let L = 0;
                            for (let z = 0; z < c.length; z++)
                                L += c[z];
                            const N = o.morphTargetsRelative ? 1 : 1 - L;
                            l.getUniforms().setValue(e, "morphTargetBaseInfluence", N),
                            l.getUniforms().setValue(e, "morphTargetInfluences", c)
                        }
                        l.getUniforms().setValue(e, "morphTargetsTexture", u.texture, n),
                        l.getUniforms().setValue(e, "morphTargetsTextureSize", u.size)
                    }
                }
            }
            function G(e, t, n, i) {
                let r = new WeakMap;
                function a(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", a),
                    n.remove(t.instanceMatrix),
                    null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function(s) {
                        const o = i.render.frame
                          , l = s.geometry
                          , c = t.get(s, l);
                        if (r.get(c) !== o && (t.update(c),
                        r.set(c, o)),
                        s.isInstancedMesh && (!1 === s.hasEventListener("dispose", a) && s.addEventListener("dispose", a),
                        r.get(s) !== o && (n.update(s.instanceMatrix, e.ARRAY_BUFFER),
                        null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER),
                        r.set(s, o))),
                        s.isSkinnedMesh) {
                            const e = s.skeleton;
                            r.get(e) !== o && (e.update(),
                            r.set(e, o))
                        }
                        return c
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            const F = {
                [i.kyO]: "LINEAR_TONE_MAPPING",
                [i.Mjd]: "REINHARD_TONE_MAPPING",
                [i.nNL]: "CINEON_TONE_MAPPING",
                [i.FV]: "ACES_FILMIC_TONE_MAPPING",
                [i.LAk]: "AGX_TONE_MAPPING",
                [i.aJ8]: "NEUTRAL_TONE_MAPPING",
                [i.g7M]: "CUSTOM_TONE_MAPPING"
            };
            function O(e, t, n, r, a) {
                const s = new i.nWS(t,n,{
                    type: e,
                    depthBuffer: r,
                    stencilBuffer: a
                })
                  , o = new i.nWS(t,n,{
                    type: i.ix0,
                    depthBuffer: !1,
                    stencilBuffer: !1
                })
                  , l = new i.LoY;
                l.setAttribute("position", new i.qtW([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
                l.setAttribute("uv", new i.qtW([0, 2, 0, 0, 2, 0],2));
                const c = new i.D$Q({
                    uniforms: {
                        tDiffuse: {
                            value: null
                        }
                    },
                    vertexShader: "\n\t\t\tprecision highp float;\n\n\t\t\tuniform mat4 modelViewMatrix;\n\t\t\tuniform mat4 projectionMatrix;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\t\t\t\tvUv = uv;\n\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t}",
                    fragmentShader: "\n\t\t\tprecision highp float;\n\n\t\t\tuniform sampler2D tDiffuse;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\t#include <tonemapping_pars_fragment>\n\t\t\t#include <colorspace_pars_fragment>\n\n\t\t\tvoid main() {\n\t\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t\t#ifdef LINEAR_TONE_MAPPING\n\t\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( AGX_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( NEUTRAL_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );\n\t\t\t\t#elif defined( CUSTOM_TONE_MAPPING )\n\t\t\t\t\tgl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef SRGB_TRANSFER\n\t\t\t\t\tgl_FragColor = sRGBTransferOETF( gl_FragColor );\n\t\t\t\t#endif\n\t\t\t}",
                    depthTest: !1,
                    depthWrite: !1
                })
                  , h = new i.eaF(l,c)
                  , d = new i.qUd(-1,1,1,-1,0,1);
                let u, p = null, f = null, g = !1, m = null, A = [], v = !1;
                this.setSize = function(e, t) {
                    s.setSize(e, t),
                    o.setSize(e, t);
                    for (let n = 0; n < A.length; n++) {
                        const i = A[n];
                        i.setSize && i.setSize(e, t)
                    }
                }
                ,
                this.setEffects = function(e) {
                    A = e,
                    v = A.length > 0 && !0 === A[0].isRenderPass;
                    const t = s.width
                      , n = s.height;
                    for (let e = 0; e < A.length; e++) {
                        const i = A[e];
                        i.setSize && i.setSize(t, n)
                    }
                }
                ,
                this.begin = function(e, t) {
                    if (g)
                        return !1;
                    if (e.toneMapping === i.y_p && 0 === A.length)
                        return !1;
                    if (m = t,
                    null !== t) {
                        const e = t.width
                          , n = t.height;
                        s.width === e && s.height === n || this.setSize(e, n)
                    }
                    return !1 === v && e.setRenderTarget(s),
                    u = e.toneMapping,
                    e.toneMapping = i.y_p,
                    !0
                }
                ,
                this.hasRenderPass = function() {
                    return v
                }
                ,
                this.end = function(e, t) {
                    e.toneMapping = u,
                    g = !0;
                    let n = s
                      , r = o;
                    for (let i = 0; i < A.length; i++) {
                        const a = A[i];
                        if (!1 !== a.enabled && (a.render(e, r, n, t),
                        !1 !== a.needsSwap)) {
                            const e = n;
                            n = r,
                            r = e
                        }
                    }
                    if (p !== e.outputColorSpace || f !== e.toneMapping) {
                        p = e.outputColorSpace,
                        f = e.toneMapping,
                        c.defines = {},
                        i.ppV.getTransfer(p) === i.KLL && (c.defines.SRGB_TRANSFER = "");
                        const t = F[f];
                        t && (c.defines[t] = ""),
                        c.needsUpdate = !0
                    }
                    c.uniforms.tDiffuse.value = n.texture,
                    e.setRenderTarget(m),
                    e.render(h, d),
                    m = null,
                    g = !1
                }
                ,
                this.isCompositing = function() {
                    return g
                }
                ,
                this.dispose = function() {
                    s.dispose(),
                    o.dispose(),
                    l.dispose(),
                    c.dispose()
                }
            }
            const W = new i.gPd
              , V = new i.VCu(1,1)
              , H = new i.rFo
              , j = new i.dYF
              , K = new i.b4q
              , q = []
              , Q = []
              , J = new Float32Array(16)
              , X = new Float32Array(9)
              , Y = new Float32Array(4);
            function Z(e, t, n) {
                const i = e[0];
                if (i <= 0 || i > 0)
                    return e;
                const r = t * n;
                let a = q[r];
                if (void 0 === a && (a = new Float32Array(r),
                q[r] = a),
                0 !== t) {
                    i.toArray(a, 0);
                    for (let i = 1, r = 0; i !== t; ++i)
                        r += n,
                        e[i].toArray(a, r)
                }
                return a
            }
            function $(e, t) {
                if (e.length !== t.length)
                    return !1;
                for (let n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n])
                        return !1;
                return !0
            }
            function ee(e, t) {
                for (let n = 0, i = t.length; n < i; n++)
                    e[n] = t[n]
            }
            function te(e, t) {
                let n = Q[t];
                void 0 === n && (n = new Int32Array(t),
                Q[t] = n);
                for (let i = 0; i !== t; ++i)
                    n[i] = e.allocateTextureUnit();
                return n
            }
            function ne(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t),
                n[0] = t)
            }
            function ie(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if ($(n, t))
                        return;
                    e.uniform2fv(this.addr, t),
                    ee(n, t)
                }
            }
            function re(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else if (void 0 !== t.r)
                    n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                    n[0] = t.r,
                    n[1] = t.g,
                    n[2] = t.b);
                else {
                    if ($(n, t))
                        return;
                    e.uniform3fv(this.addr, t),
                    ee(n, t)
                }
            }
            function ae(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if ($(n, t))
                        return;
                    e.uniform4fv(this.addr, t),
                    ee(n, t)
                }
            }
            function se(e, t) {
                const n = this.cache
                  , i = t.elements;
                if (void 0 === i) {
                    if ($(n, t))
                        return;
                    e.uniformMatrix2fv(this.addr, !1, t),
                    ee(n, t)
                } else {
                    if ($(n, i))
                        return;
                    Y.set(i),
                    e.uniformMatrix2fv(this.addr, !1, Y),
                    ee(n, i)
                }
            }
            function oe(e, t) {
                const n = this.cache
                  , i = t.elements;
                if (void 0 === i) {
                    if ($(n, t))
                        return;
                    e.uniformMatrix3fv(this.addr, !1, t),
                    ee(n, t)
                } else {
                    if ($(n, i))
                        return;
                    X.set(i),
                    e.uniformMatrix3fv(this.addr, !1, X),
                    ee(n, i)
                }
            }
            function le(e, t) {
                const n = this.cache
                  , i = t.elements;
                if (void 0 === i) {
                    if ($(n, t))
                        return;
                    e.uniformMatrix4fv(this.addr, !1, t),
                    ee(n, t)
                } else {
                    if ($(n, i))
                        return;
                    J.set(i),
                    e.uniformMatrix4fv(this.addr, !1, J),
                    ee(n, i)
                }
            }
            function ce(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t),
                n[0] = t)
            }
            function he(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if ($(n, t))
                        return;
                    e.uniform2iv(this.addr, t),
                    ee(n, t)
                }
            }
            function de(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else {
                    if ($(n, t))
                        return;
                    e.uniform3iv(this.addr, t),
                    ee(n, t)
                }
            }
            function ue(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if ($(n, t))
                        return;
                    e.uniform4iv(this.addr, t),
                    ee(n, t)
                }
            }
            function pe(e, t) {
                const n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t),
                n[0] = t)
            }
            function fe(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                    n[0] = t.x,
                    n[1] = t.y);
                else {
                    if ($(n, t))
                        return;
                    e.uniform2uiv(this.addr, t),
                    ee(n, t)
                }
            }
            function ge(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z);
                else {
                    if ($(n, t))
                        return;
                    e.uniform3uiv(this.addr, t),
                    ee(n, t)
                }
            }
            function me(e, t) {
                const n = this.cache;
                if (void 0 !== t.x)
                    n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                    n[0] = t.x,
                    n[1] = t.y,
                    n[2] = t.z,
                    n[3] = t.w);
                else {
                    if ($(n, t))
                        return;
                    e.uniform4uiv(this.addr, t),
                    ee(n, t)
                }
            }
            function Ae(e, t, n) {
                const r = this.cache
                  , a = n.allocateTextureUnit();
                let s;
                r[0] !== a && (e.uniform1i(this.addr, a),
                r[0] = a),
                this.type === e.SAMPLER_2D_SHADOW ? (V.compareFunction = n.isReversedDepthBuffer() ? i.gWB : i.TiK,
                s = V) : s = W,
                n.setTexture2D(t || s, a)
            }
            function ve(e, t, n) {
                const i = this.cache
                  , r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r),
                i[0] = r),
                n.setTexture3D(t || j, r)
            }
            function ye(e, t, n) {
                const i = this.cache
                  , r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r),
                i[0] = r),
                n.setTextureCube(t || K, r)
            }
            function we(e, t, n) {
                const i = this.cache
                  , r = n.allocateTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r),
                i[0] = r),
                n.setTexture2DArray(t || H, r)
            }
            function be(e, t) {
                e.uniform1fv(this.addr, t)
            }
            function xe(e, t) {
                const n = Z(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }
            function Se(e, t) {
                const n = Z(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }
            function Ee(e, t) {
                const n = Z(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }
            function Te(e, t) {
                const n = Z(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }
            function ke(e, t) {
                const n = Z(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }
            function Me(e, t) {
                const n = Z(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }
            function _e(e, t) {
                e.uniform1iv(this.addr, t)
            }
            function Ce(e, t) {
                e.uniform2iv(this.addr, t)
            }
            function Re(e, t) {
                e.uniform3iv(this.addr, t)
            }
            function Pe(e, t) {
                e.uniform4iv(this.addr, t)
            }
            function Ie(e, t) {
                e.uniform1uiv(this.addr, t)
            }
            function Le(e, t) {
                e.uniform2uiv(this.addr, t)
            }
            function Ne(e, t) {
                e.uniform3uiv(this.addr, t)
            }
            function ze(e, t) {
                e.uniform4uiv(this.addr, t)
            }
            function Ue(e, t, n) {
                const i = this.cache
                  , r = t.length
                  , a = te(n, r);
                let s;
                $(i, a) || (e.uniform1iv(this.addr, a),
                ee(i, a)),
                s = this.type === e.SAMPLER_2D_SHADOW ? V : W;
                for (let e = 0; e !== r; ++e)
                    n.setTexture2D(t[e] || s, a[e])
            }
            function De(e, t, n) {
                const i = this.cache
                  , r = t.length
                  , a = te(n, r);
                $(i, a) || (e.uniform1iv(this.addr, a),
                ee(i, a));
                for (let e = 0; e !== r; ++e)
                    n.setTexture3D(t[e] || j, a[e])
            }
            function Be(e, t, n) {
                const i = this.cache
                  , r = t.length
                  , a = te(n, r);
                $(i, a) || (e.uniform1iv(this.addr, a),
                ee(i, a));
                for (let e = 0; e !== r; ++e)
                    n.setTextureCube(t[e] || K, a[e])
            }
            function Ge(e, t, n) {
                const i = this.cache
                  , r = t.length
                  , a = te(n, r);
                $(i, a) || (e.uniform1iv(this.addr, a),
                ee(i, a));
                for (let e = 0; e !== r; ++e)
                    n.setTexture2DArray(t[e] || H, a[e])
            }
            class Fe {
                constructor(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.type = t.type,
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return ne;
                        case 35664:
                            return ie;
                        case 35665:
                            return re;
                        case 35666:
                            return ae;
                        case 35674:
                            return se;
                        case 35675:
                            return oe;
                        case 35676:
                            return le;
                        case 5124:
                        case 35670:
                            return ce;
                        case 35667:
                        case 35671:
                            return he;
                        case 35668:
                        case 35672:
                            return de;
                        case 35669:
                        case 35673:
                            return ue;
                        case 5125:
                            return pe;
                        case 36294:
                            return fe;
                        case 36295:
                            return ge;
                        case 36296:
                            return me;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Ae;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ve;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ye;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return we
                        }
                    }(t.type)
                }
            }
            class Oe {
                constructor(e, t, n) {
                    this.id = e,
                    this.addr = n,
                    this.cache = [],
                    this.type = t.type,
                    this.size = t.size,
                    this.setValue = function(e) {
                        switch (e) {
                        case 5126:
                            return be;
                        case 35664:
                            return xe;
                        case 35665:
                            return Se;
                        case 35666:
                            return Ee;
                        case 35674:
                            return Te;
                        case 35675:
                            return ke;
                        case 35676:
                            return Me;
                        case 5124:
                        case 35670:
                            return _e;
                        case 35667:
                        case 35671:
                            return Ce;
                        case 35668:
                        case 35672:
                            return Re;
                        case 35669:
                        case 35673:
                            return Pe;
                        case 5125:
                            return Ie;
                        case 36294:
                            return Le;
                        case 36295:
                            return Ne;
                        case 36296:
                            return ze;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Ue;
                        case 35679:
                        case 36299:
                        case 36307:
                            return De;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Be;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Ge
                        }
                    }(t.type)
                }
            }
            class We {
                constructor(e) {
                    this.id = e,
                    this.seq = [],
                    this.map = {}
                }
                setValue(e, t, n) {
                    const i = this.seq;
                    for (let r = 0, a = i.length; r !== a; ++r) {
                        const a = i[r];
                        a.setValue(e, t[a.id], n)
                    }
                }
            }
            const Ve = /(\w+)(\])?(\[|\.)?/g;
            function He(e, t) {
                e.seq.push(t),
                e.map[t.id] = t
            }
            function je(e, t, n) {
                const i = e.name
                  , r = i.length;
                for (Ve.lastIndex = 0; ; ) {
                    const a = Ve.exec(i)
                      , s = Ve.lastIndex;
                    let o = a[1];
                    const l = "]" === a[2]
                      , c = a[3];
                    if (l && (o |= 0),
                    void 0 === c || "[" === c && s + 2 === r) {
                        He(n, void 0 === c ? new Fe(o,e,t) : new Oe(o,e,t));
                        break
                    }
                    {
                        let e = n.map[o];
                        void 0 === e && (e = new We(o),
                        He(n, e)),
                        n = e
                    }
                }
            }
            class Ke {
                constructor(e, t) {
                    this.seq = [],
                    this.map = {};
                    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                    for (let i = 0; i < n; ++i) {
                        const n = e.getActiveUniform(t, i);
                        je(n, e.getUniformLocation(t, n.name), this)
                    }
                    const i = []
                      , r = [];
                    for (const t of this.seq)
                        t.type === e.SAMPLER_2D_SHADOW || t.type === e.SAMPLER_CUBE_SHADOW || t.type === e.SAMPLER_2D_ARRAY_SHADOW ? i.push(t) : r.push(t);
                    i.length > 0 && (this.seq = i.concat(r))
                }
                setValue(e, t, n, i) {
                    const r = this.map[t];
                    void 0 !== r && r.setValue(e, n, i)
                }
                setOptional(e, t, n) {
                    const i = t[n];
                    void 0 !== i && this.setValue(e, n, i)
                }
                static upload(e, t, n, i) {
                    for (let r = 0, a = t.length; r !== a; ++r) {
                        const a = t[r]
                          , s = n[a.id];
                        !1 !== s.needsUpdate && a.setValue(e, s.value, i)
                    }
                }
                static seqWithValue(e, t) {
                    const n = [];
                    for (let i = 0, r = e.length; i !== r; ++i) {
                        const r = e[i];
                        r.id in t && n.push(r)
                    }
                    return n
                }
            }
            function qe(e, t, n) {
                const i = e.createShader(t);
                return e.shaderSource(i, n),
                e.compileShader(i),
                i
            }
            let Qe = 0;
            const Je = new i.dwI;
            function Xe(e, t, n) {
                const i = e.getShaderParameter(t, e.COMPILE_STATUS)
                  , r = (e.getShaderInfoLog(t) || "").trim();
                if (i && "" === r)
                    return "";
                const a = /ERROR: 0:(\d+)/.exec(r);
                if (a) {
                    const i = parseInt(a[1]);
                    return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                        const n = e.split("\n")
                          , i = []
                          , r = Math.max(t - 6, 0)
                          , a = Math.min(t + 6, n.length);
                        for (let e = r; e < a; e++) {
                            const r = e + 1;
                            i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
                        }
                        return i.join("\n")
                    }(e.getShaderSource(t), i)
                }
                return r
            }
            function Ye(e, t) {
                const n = function(e) {
                    i.ppV._getMatrix(Je, i.ppV.workingColorSpace, e);
                    const t = `mat3( ${Je.elements.map((e => e.toFixed(4)))} )`;
                    switch (i.ppV.getTransfer(e)) {
                    case i.VxR:
                        return [t, "LinearTransferOETF"];
                    case i.KLL:
                        return [t, "sRGBTransferOETF"];
                    default:
                        return (0,
                        i.R8M)("WebGLProgram: Unsupported color space: ", e),
                        [t, "LinearTransferOETF"]
                    }
                }(t);
                return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
            }
            const Ze = {
                [i.kyO]: "Linear",
                [i.Mjd]: "Reinhard",
                [i.nNL]: "Cineon",
                [i.FV]: "ACESFilmic",
                [i.LAk]: "AgX",
                [i.aJ8]: "Neutral",
                [i.g7M]: "Custom"
            };
            function $e(e, t) {
                const n = Ze[t];
                return void 0 === n ? ((0,
                i.R8M)("WebGLProgram: Unsupported toneMapping:", t),
                "vec3 " + e + "( vec3 color ) { return LinearToneMapping( color ); }") : "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }
            const et = new i.Pq0;
            function tt() {
                i.ppV.getLuminanceCoefficients(et);
                return ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${et.x.toFixed(4)}, ${et.y.toFixed(4)}, ${et.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")
            }
            function nt(e) {
                return "" !== e
            }
            function it(e, t) {
                const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }
            function rt(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            const at = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function st(e) {
                return e.replace(at, lt)
            }
            const ot = new Map;
            function lt(e, t) {
                let n = s[t];
                if (void 0 === n) {
                    const e = ot.get(t);
                    if (void 0 === e)
                        throw new Error("Can not resolve #include <" + t + ">");
                    n = s[e],
                    (0,
                    i.R8M)('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
                }
                return st(n)
            }
            const ct = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            function ht(e) {
                return e.replace(ct, dt)
            }
            function dt(e, t, n, i) {
                let r = "";
                for (let e = parseInt(t); e < parseInt(n); e++)
                    r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
                return r
            }
            function ut(e) {
                let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
                t
            }
            const pt = {
                [i.QP0]: "SHADOWMAP_TYPE_PCF",
                [i.RyA]: "SHADOWMAP_TYPE_VSM"
            };
            const ft = {
                [i.hy7]: "ENVMAP_TYPE_CUBE",
                [i.xFO]: "ENVMAP_TYPE_CUBE",
                [i.Om]: "ENVMAP_TYPE_CUBE_UV"
            };
            const gt = {
                [i.xFO]: "ENVMAP_MODE_REFRACTION"
            };
            const mt = {
                [i.caT]: "ENVMAP_BLENDING_MULTIPLY",
                [i.KRh]: "ENVMAP_BLENDING_MIX",
                [i.XrR]: "ENVMAP_BLENDING_ADD"
            };
            function At(e, t, n, r) {
                const a = e.getContext()
                  , o = n.defines;
                let l = n.vertexShader
                  , c = n.fragmentShader;
                const h = function(e) {
                    return pt[e.shadowMapType] || "SHADOWMAP_TYPE_BASIC"
                }(n)
                  , d = function(e) {
                    return !1 === e.envMap ? "ENVMAP_TYPE_CUBE" : ft[e.envMapMode] || "ENVMAP_TYPE_CUBE"
                }(n)
                  , u = function(e) {
                    return !1 === e.envMap ? "ENVMAP_MODE_REFLECTION" : gt[e.envMapMode] || "ENVMAP_MODE_REFLECTION"
                }(n)
                  , p = function(e) {
                    return !1 === e.envMap ? "ENVMAP_BLENDING_NONE" : mt[e.combine] || "ENVMAP_BLENDING_NONE"
                }(n)
                  , f = function(e) {
                    const t = e.envMapCubeUVHeight;
                    if (null === t)
                        return null;
                    const n = Math.log2(t) - 2
                      , i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n)
                  , g = function(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(nt).join("\n")
                }(n)
                  , m = function(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        !1 !== i && t.push("#define " + n + " " + i)
                    }
                    return t.join("\n")
                }(o)
                  , A = a.createProgram();
                let v, y, w = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(nt).join("\n"),
                v.length > 0 && (v += "\n"),
                y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(nt).join("\n"),
                y.length > 0 && (y += "\n")) : (v = [ut(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(nt).join("\n"),
                y = [ut(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + p : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "", n.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== i.y_p ? "#define TONE_MAPPING" : "", n.toneMapping !== i.y_p ? s.tonemapping_pars_fragment : "", n.toneMapping !== i.y_p ? $e("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", s.colorspace_pars_fragment, Ye("linearToOutputTexel", n.outputColorSpace), tt(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(nt).join("\n")),
                l = st(l),
                l = it(l, n),
                l = rt(l, n),
                c = st(c),
                c = it(c, n),
                c = rt(c, n),
                l = ht(l),
                c = ht(c),
                !0 !== n.isRawShaderMaterial && (w = "#version 300 es\n",
                v = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + v,
                y = ["#define varying in", n.glslVersion === i.Wdf ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === i.Wdf ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y);
                const b = w + v + l
                  , x = w + y + c
                  , S = qe(a, a.VERTEX_SHADER, b)
                  , E = qe(a, a.FRAGMENT_SHADER, x);
                function T(t) {
                    if (e.debug.checkShaderErrors) {
                        const n = a.getProgramInfoLog(A) || ""
                          , r = a.getShaderInfoLog(S) || ""
                          , s = a.getShaderInfoLog(E) || ""
                          , o = n.trim()
                          , l = r.trim()
                          , c = s.trim();
                        let h = !0
                          , d = !0;
                        if (!1 === a.getProgramParameter(A, a.LINK_STATUS))
                            if (h = !1,
                            "function" == typeof e.debug.onShaderError)
                                e.debug.onShaderError(a, A, S, E);
                            else {
                                const e = Xe(a, S, "vertex")
                                  , n = Xe(a, E, "fragment");
                                (0,
                                i.z3S)("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(A, a.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + o + "\n" + e + "\n" + n)
                            }
                        else
                            "" !== o ? (0,
                            i.R8M)("WebGLProgram: Program Info Log:", o) : "" !== l && "" !== c || (d = !1);
                        d && (t.diagnostics = {
                            runnable: h,
                            programLog: o,
                            vertexShader: {
                                log: l,
                                prefix: v
                            },
                            fragmentShader: {
                                log: c,
                                prefix: y
                            }
                        })
                    }
                    a.deleteShader(S),
                    a.deleteShader(E),
                    k = new Ke(a,A),
                    M = function(e, t) {
                        const n = {}
                          , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                        for (let r = 0; r < i; r++) {
                            const i = e.getActiveAttrib(t, r)
                              , a = i.name;
                            let s = 1;
                            i.type === e.FLOAT_MAT2 && (s = 2),
                            i.type === e.FLOAT_MAT3 && (s = 3),
                            i.type === e.FLOAT_MAT4 && (s = 4),
                            n[a] = {
                                type: i.type,
                                location: e.getAttribLocation(t, a),
                                locationSize: s
                            }
                        }
                        return n
                    }(a, A)
                }
                let k, M;
                a.attachShader(A, S),
                a.attachShader(A, E),
                void 0 !== n.index0AttributeName ? a.bindAttribLocation(A, 0, n.index0AttributeName) : !0 === n.morphTargets && a.bindAttribLocation(A, 0, "position"),
                a.linkProgram(A),
                this.getUniforms = function() {
                    return void 0 === k && T(this),
                    k
                }
                ,
                this.getAttributes = function() {
                    return void 0 === M && T(this),
                    M
                }
                ;
                let _ = !1 === n.rendererExtensionParallelShaderCompile;
                return this.isReady = function() {
                    return !1 === _ && (_ = a.getProgramParameter(A, 37297)),
                    _
                }
                ,
                this.destroy = function() {
                    r.releaseStatesOfProgram(this),
                    a.deleteProgram(A),
                    this.program = void 0
                }
                ,
                this.type = n.shaderType,
                this.name = n.shaderName,
                this.id = Qe++,
                this.cacheKey = t,
                this.usedTimes = 1,
                this.program = A,
                this.vertexShader = S,
                this.fragmentShader = E,
                this
            }
            let vt = 0;
            class yt {
                constructor() {
                    this.shaderCache = new Map,
                    this.materialCache = new Map
                }
                update(e) {
                    const t = e.vertexShader
                      , n = e.fragmentShader
                      , i = this._getShaderStage(t)
                      , r = this._getShaderStage(n)
                      , a = this._getShaderCacheForMaterial(e);
                    return !1 === a.has(i) && (a.add(i),
                    i.usedTimes++),
                    !1 === a.has(r) && (a.add(r),
                    r.usedTimes++),
                    this
                }
                remove(e) {
                    const t = this.materialCache.get(e);
                    for (const e of t)
                        e.usedTimes--,
                        0 === e.usedTimes && this.shaderCache.delete(e.code);
                    return this.materialCache.delete(e),
                    this
                }
                getVertexShaderID(e) {
                    return this._getShaderStage(e.vertexShader).id
                }
                getFragmentShaderID(e) {
                    return this._getShaderStage(e.fragmentShader).id
                }
                dispose() {
                    this.shaderCache.clear(),
                    this.materialCache.clear()
                }
                _getShaderCacheForMaterial(e) {
                    const t = this.materialCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new Set,
                    t.set(e, n)),
                    n
                }
                _getShaderStage(e) {
                    const t = this.shaderCache;
                    let n = t.get(e);
                    return void 0 === n && (n = new wt(e),
                    t.set(e, n)),
                    n
                }
            }
            class wt {
                constructor(e) {
                    this.id = vt++,
                    this.code = e,
                    this.usedTimes = 0
                }
            }
            function bt(e, t, n, r, a, s, o) {
                const c = new i.zgK
                  , h = new yt
                  , d = new Set
                  , u = []
                  , p = new Map
                  , f = a.logarithmicDepthBuffer;
                let g = a.precision;
                const m = {
                    MeshDepthMaterial: "depth",
                    MeshDistanceMaterial: "distance",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshToonMaterial: "toon",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    MeshMatcapMaterial: "matcap",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points",
                    ShadowMaterial: "shadow",
                    SpriteMaterial: "sprite"
                };
                function A(e) {
                    return d.add(e),
                    0 === e ? "uv" : `uv${e}`
                }
                return {
                    getParameters: function(s, c, u, p, v) {
                        const y = p.fog
                          , w = v.geometry
                          , b = s.isMeshStandardMaterial ? p.environment : null
                          , x = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b)
                          , S = x && x.mapping === i.Om ? x.image.height : null
                          , E = m[s.type];
                        null !== s.precision && (g = a.getMaxPrecision(s.precision),
                        g !== s.precision && (0,
                        i.R8M)("WebGLProgram.getParameters:", s.precision, "not supported, using", g, "instead."));
                        const T = w.morphAttributes.position || w.morphAttributes.normal || w.morphAttributes.color
                          , k = void 0 !== T ? T.length : 0;
                        let M, _, C, R, P = 0;
                        if (void 0 !== w.morphAttributes.position && (P = 1),
                        void 0 !== w.morphAttributes.normal && (P = 2),
                        void 0 !== w.morphAttributes.color && (P = 3),
                        E) {
                            const e = l[E];
                            M = e.vertexShader,
                            _ = e.fragmentShader
                        } else
                            M = s.vertexShader,
                            _ = s.fragmentShader,
                            h.update(s),
                            C = h.getVertexShaderID(s),
                            R = h.getFragmentShaderID(s);
                        const I = e.getRenderTarget()
                          , L = e.state.buffers.depth.getReversed()
                          , N = !0 === v.isInstancedMesh
                          , z = !0 === v.isBatchedMesh
                          , U = !!s.map
                          , D = !!s.matcap
                          , B = !!x
                          , G = !!s.aoMap
                          , F = !!s.lightMap
                          , O = !!s.bumpMap
                          , W = !!s.normalMap
                          , V = !!s.displacementMap
                          , H = !!s.emissiveMap
                          , j = !!s.metalnessMap
                          , K = !!s.roughnessMap
                          , q = s.anisotropy > 0
                          , Q = s.clearcoat > 0
                          , J = s.dispersion > 0
                          , X = s.iridescence > 0
                          , Y = s.sheen > 0
                          , Z = s.transmission > 0
                          , $ = q && !!s.anisotropyMap
                          , ee = Q && !!s.clearcoatMap
                          , te = Q && !!s.clearcoatNormalMap
                          , ne = Q && !!s.clearcoatRoughnessMap
                          , ie = X && !!s.iridescenceMap
                          , re = X && !!s.iridescenceThicknessMap
                          , ae = Y && !!s.sheenColorMap
                          , se = Y && !!s.sheenRoughnessMap
                          , oe = !!s.specularMap
                          , le = !!s.specularColorMap
                          , ce = !!s.specularIntensityMap
                          , he = Z && !!s.transmissionMap
                          , de = Z && !!s.thicknessMap
                          , ue = !!s.gradientMap
                          , pe = !!s.alphaMap
                          , fe = s.alphaTest > 0
                          , ge = !!s.alphaHash
                          , me = !!s.extensions;
                        let Ae = i.y_p;
                        s.toneMapped && (null !== I && !0 !== I.isXRRenderTarget || (Ae = e.toneMapping));
                        const ve = {
                            shaderID: E,
                            shaderType: s.type,
                            shaderName: s.name,
                            vertexShader: M,
                            fragmentShader: _,
                            defines: s.defines,
                            customVertexShaderID: C,
                            customFragmentShaderID: R,
                            isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                            glslVersion: s.glslVersion,
                            precision: g,
                            batching: z,
                            batchingColor: z && null !== v._colorsTexture,
                            instancing: N,
                            instancingColor: N && null !== v.instanceColor,
                            instancingMorph: N && null !== v.morphTexture,
                            outputColorSpace: null === I ? e.outputColorSpace : !0 === I.isXRRenderTarget ? I.texture.colorSpace : i.Zr2,
                            alphaToCoverage: !!s.alphaToCoverage,
                            map: U,
                            matcap: D,
                            envMap: B,
                            envMapMode: B && x.mapping,
                            envMapCubeUVHeight: S,
                            aoMap: G,
                            lightMap: F,
                            bumpMap: O,
                            normalMap: W,
                            displacementMap: V,
                            emissiveMap: H,
                            normalMapObjectSpace: W && s.normalMapType === i.vyJ,
                            normalMapTangentSpace: W && s.normalMapType === i.bI3,
                            metalnessMap: j,
                            roughnessMap: K,
                            anisotropy: q,
                            anisotropyMap: $,
                            clearcoat: Q,
                            clearcoatMap: ee,
                            clearcoatNormalMap: te,
                            clearcoatRoughnessMap: ne,
                            dispersion: J,
                            iridescence: X,
                            iridescenceMap: ie,
                            iridescenceThicknessMap: re,
                            sheen: Y,
                            sheenColorMap: ae,
                            sheenRoughnessMap: se,
                            specularMap: oe,
                            specularColorMap: le,
                            specularIntensityMap: ce,
                            transmission: Z,
                            transmissionMap: he,
                            thicknessMap: de,
                            gradientMap: ue,
                            opaque: !1 === s.transparent && s.blending === i.NTi && !1 === s.alphaToCoverage,
                            alphaMap: pe,
                            alphaTest: fe,
                            alphaHash: ge,
                            combine: s.combine,
                            mapUv: U && A(s.map.channel),
                            aoMapUv: G && A(s.aoMap.channel),
                            lightMapUv: F && A(s.lightMap.channel),
                            bumpMapUv: O && A(s.bumpMap.channel),
                            normalMapUv: W && A(s.normalMap.channel),
                            displacementMapUv: V && A(s.displacementMap.channel),
                            emissiveMapUv: H && A(s.emissiveMap.channel),
                            metalnessMapUv: j && A(s.metalnessMap.channel),
                            roughnessMapUv: K && A(s.roughnessMap.channel),
                            anisotropyMapUv: $ && A(s.anisotropyMap.channel),
                            clearcoatMapUv: ee && A(s.clearcoatMap.channel),
                            clearcoatNormalMapUv: te && A(s.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ne && A(s.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: ie && A(s.iridescenceMap.channel),
                            iridescenceThicknessMapUv: re && A(s.iridescenceThicknessMap.channel),
                            sheenColorMapUv: ae && A(s.sheenColorMap.channel),
                            sheenRoughnessMapUv: se && A(s.sheenRoughnessMap.channel),
                            specularMapUv: oe && A(s.specularMap.channel),
                            specularColorMapUv: le && A(s.specularColorMap.channel),
                            specularIntensityMapUv: ce && A(s.specularIntensityMap.channel),
                            transmissionMapUv: he && A(s.transmissionMap.channel),
                            thicknessMapUv: de && A(s.thicknessMap.channel),
                            alphaMapUv: pe && A(s.alphaMap.channel),
                            vertexTangents: !!w.attributes.tangent && (W || q),
                            vertexColors: s.vertexColors,
                            vertexAlphas: !0 === s.vertexColors && !!w.attributes.color && 4 === w.attributes.color.itemSize,
                            pointsUvs: !0 === v.isPoints && !!w.attributes.uv && (U || pe),
                            fog: !!y,
                            useFog: !0 === s.fog,
                            fogExp2: !!y && y.isFogExp2,
                            flatShading: !0 === s.flatShading && !1 === s.wireframe,
                            sizeAttenuation: !0 === s.sizeAttenuation,
                            logarithmicDepthBuffer: f,
                            reversedDepthBuffer: L,
                            skinning: !0 === v.isSkinnedMesh,
                            morphTargets: void 0 !== w.morphAttributes.position,
                            morphNormals: void 0 !== w.morphAttributes.normal,
                            morphColors: void 0 !== w.morphAttributes.color,
                            morphTargetsCount: k,
                            morphTextureStride: P,
                            numDirLights: c.directional.length,
                            numPointLights: c.point.length,
                            numSpotLights: c.spot.length,
                            numSpotLightMaps: c.spotLightMap.length,
                            numRectAreaLights: c.rectArea.length,
                            numHemiLights: c.hemi.length,
                            numDirLightShadows: c.directionalShadowMap.length,
                            numPointLightShadows: c.pointShadowMap.length,
                            numSpotLightShadows: c.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: c.numSpotLightShadowsWithMaps,
                            numLightProbes: c.numLightProbes,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: s.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: Ae,
                            decodeVideoTexture: U && !0 === s.map.isVideoTexture && i.ppV.getTransfer(s.map.colorSpace) === i.KLL,
                            decodeVideoTextureEmissive: H && !0 === s.emissiveMap.isVideoTexture && i.ppV.getTransfer(s.emissiveMap.colorSpace) === i.KLL,
                            premultipliedAlpha: s.premultipliedAlpha,
                            doubleSided: s.side === i.$EB,
                            flipSided: s.side === i.hsX,
                            useDepthPacking: s.depthPacking >= 0,
                            depthPacking: s.depthPacking || 0,
                            index0AttributeName: s.index0AttributeName,
                            extensionClipCullDistance: me && !0 === s.extensions.clipCullDistance && r.has("WEBGL_clip_cull_distance"),
                            extensionMultiDraw: (me && !0 === s.extensions.multiDraw || z) && r.has("WEBGL_multi_draw"),
                            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
                            customProgramCacheKey: s.customProgramCacheKey()
                        };
                        return ve.vertexUv1s = d.has(1),
                        ve.vertexUv2s = d.has(2),
                        ve.vertexUv3s = d.has(3),
                        d.clear(),
                        ve
                    },
                    getProgramCacheKey: function(t) {
                        const n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                        n.push(t.customFragmentShaderID)),
                        void 0 !== t.defines)
                            for (const e in t.defines)
                                n.push(e),
                                n.push(t.defines[e]);
                        return !1 === t.isRawShaderMaterial && (!function(e, t) {
                            e.push(t.precision),
                            e.push(t.outputColorSpace),
                            e.push(t.envMapMode),
                            e.push(t.envMapCubeUVHeight),
                            e.push(t.mapUv),
                            e.push(t.alphaMapUv),
                            e.push(t.lightMapUv),
                            e.push(t.aoMapUv),
                            e.push(t.bumpMapUv),
                            e.push(t.normalMapUv),
                            e.push(t.displacementMapUv),
                            e.push(t.emissiveMapUv),
                            e.push(t.metalnessMapUv),
                            e.push(t.roughnessMapUv),
                            e.push(t.anisotropyMapUv),
                            e.push(t.clearcoatMapUv),
                            e.push(t.clearcoatNormalMapUv),
                            e.push(t.clearcoatRoughnessMapUv),
                            e.push(t.iridescenceMapUv),
                            e.push(t.iridescenceThicknessMapUv),
                            e.push(t.sheenColorMapUv),
                            e.push(t.sheenRoughnessMapUv),
                            e.push(t.specularMapUv),
                            e.push(t.specularColorMapUv),
                            e.push(t.specularIntensityMapUv),
                            e.push(t.transmissionMapUv),
                            e.push(t.thicknessMapUv),
                            e.push(t.combine),
                            e.push(t.fogExp2),
                            e.push(t.sizeAttenuation),
                            e.push(t.morphTargetsCount),
                            e.push(t.morphAttributeCount),
                            e.push(t.numDirLights),
                            e.push(t.numPointLights),
                            e.push(t.numSpotLights),
                            e.push(t.numSpotLightMaps),
                            e.push(t.numHemiLights),
                            e.push(t.numRectAreaLights),
                            e.push(t.numDirLightShadows),
                            e.push(t.numPointLightShadows),
                            e.push(t.numSpotLightShadows),
                            e.push(t.numSpotLightShadowsWithMaps),
                            e.push(t.numLightProbes),
                            e.push(t.shadowMapType),
                            e.push(t.toneMapping),
                            e.push(t.numClippingPlanes),
                            e.push(t.numClipIntersection),
                            e.push(t.depthPacking)
                        }(n, t),
                        function(e, t) {
                            c.disableAll(),
                            t.instancing && c.enable(0);
                            t.instancingColor && c.enable(1);
                            t.instancingMorph && c.enable(2);
                            t.matcap && c.enable(3);
                            t.envMap && c.enable(4);
                            t.normalMapObjectSpace && c.enable(5);
                            t.normalMapTangentSpace && c.enable(6);
                            t.clearcoat && c.enable(7);
                            t.iridescence && c.enable(8);
                            t.alphaTest && c.enable(9);
                            t.vertexColors && c.enable(10);
                            t.vertexAlphas && c.enable(11);
                            t.vertexUv1s && c.enable(12);
                            t.vertexUv2s && c.enable(13);
                            t.vertexUv3s && c.enable(14);
                            t.vertexTangents && c.enable(15);
                            t.anisotropy && c.enable(16);
                            t.alphaHash && c.enable(17);
                            t.batching && c.enable(18);
                            t.dispersion && c.enable(19);
                            t.batchingColor && c.enable(20);
                            t.gradientMap && c.enable(21);
                            e.push(c.mask),
                            c.disableAll(),
                            t.fog && c.enable(0);
                            t.useFog && c.enable(1);
                            t.flatShading && c.enable(2);
                            t.logarithmicDepthBuffer && c.enable(3);
                            t.reversedDepthBuffer && c.enable(4);
                            t.skinning && c.enable(5);
                            t.morphTargets && c.enable(6);
                            t.morphNormals && c.enable(7);
                            t.morphColors && c.enable(8);
                            t.premultipliedAlpha && c.enable(9);
                            t.shadowMapEnabled && c.enable(10);
                            t.doubleSided && c.enable(11);
                            t.flipSided && c.enable(12);
                            t.useDepthPacking && c.enable(13);
                            t.dithering && c.enable(14);
                            t.transmission && c.enable(15);
                            t.sheen && c.enable(16);
                            t.opaque && c.enable(17);
                            t.pointsUvs && c.enable(18);
                            t.decodeVideoTexture && c.enable(19);
                            t.decodeVideoTextureEmissive && c.enable(20);
                            t.alphaToCoverage && c.enable(21);
                            e.push(c.mask)
                        }(n, t),
                        n.push(e.outputColorSpace)),
                        n.push(t.customProgramCacheKey),
                        n.join()
                    },
                    getUniforms: function(e) {
                        const t = m[e.type];
                        let n;
                        if (t) {
                            const e = l[t];
                            n = i.LlO.clone(e.uniforms)
                        } else
                            n = e.uniforms;
                        return n
                    },
                    acquireProgram: function(t, n) {
                        let i = p.get(n);
                        return void 0 !== i ? ++i.usedTimes : (i = new At(e,n,t,s),
                        u.push(i),
                        p.set(n, i)),
                        i
                    },
                    releaseProgram: function(e) {
                        if (0 == --e.usedTimes) {
                            const t = u.indexOf(e);
                            u[t] = u[u.length - 1],
                            u.pop(),
                            p.delete(e.cacheKey),
                            e.destroy()
                        }
                    },
                    releaseShaderCache: function(e) {
                        h.remove(e)
                    },
                    programs: u,
                    dispose: function() {
                        h.dispose()
                    }
                }
            }
            function xt() {
                let e = new WeakMap;
                return {
                    has: function(t) {
                        return e.has(t)
                    },
                    get: function(t) {
                        let n = e.get(t);
                        return void 0 === n && (n = {},
                        e.set(t, n)),
                        n
                    },
                    remove: function(t) {
                        e.delete(t)
                    },
                    update: function(t, n, i) {
                        e.get(t)[n] = i
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            function St(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }
            function Et(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }
            function Tt() {
                const e = [];
                let t = 0;
                const n = []
                  , i = []
                  , r = [];
                function a(n, i, r, a, s, o) {
                    let l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: i,
                        material: r,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: s,
                        group: o
                    },
                    e[t] = l) : (l.id = n.id,
                    l.object = n,
                    l.geometry = i,
                    l.material = r,
                    l.groupOrder = a,
                    l.renderOrder = n.renderOrder,
                    l.z = s,
                    l.group = o),
                    t++,
                    l
                }
                return {
                    opaque: n,
                    transmissive: i,
                    transparent: r,
                    init: function() {
                        t = 0,
                        n.length = 0,
                        i.length = 0,
                        r.length = 0
                    },
                    push: function(e, t, s, o, l, c) {
                        const h = a(e, t, s, o, l, c);
                        s.transmission > 0 ? i.push(h) : !0 === s.transparent ? r.push(h) : n.push(h)
                    },
                    unshift: function(e, t, s, o, l, c) {
                        const h = a(e, t, s, o, l, c);
                        s.transmission > 0 ? i.unshift(h) : !0 === s.transparent ? r.unshift(h) : n.unshift(h)
                    },
                    finish: function() {
                        for (let n = t, i = e.length; n < i; n++) {
                            const t = e[n];
                            if (null === t.id)
                                break;
                            t.id = null,
                            t.object = null,
                            t.geometry = null,
                            t.material = null,
                            t.group = null
                        }
                    },
                    sort: function(e, t) {
                        n.length > 1 && n.sort(e || St),
                        i.length > 1 && i.sort(t || Et),
                        r.length > 1 && r.sort(t || Et)
                    }
                }
            }
            function kt() {
                let e = new WeakMap;
                return {
                    get: function(t, n) {
                        const i = e.get(t);
                        let r;
                        return void 0 === i ? (r = new Tt,
                        e.set(t, [r])) : n >= i.length ? (r = new Tt,
                        i.push(r)) : r = i[n],
                        r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }
            function Mt() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new i.Pq0,
                                color: new i.Q1f
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new i.Pq0,
                                direction: new i.Pq0,
                                color: new i.Q1f,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new i.Pq0,
                                color: new i.Q1f,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new i.Pq0,
                                skyColor: new i.Q1f,
                                groundColor: new i.Q1f
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new i.Q1f,
                                position: new i.Pq0,
                                halfWidth: new i.Pq0,
                                halfHeight: new i.Pq0
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }
            let _t = 0;
            function Ct(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }
            function Rt(e) {
                const t = new Mt
                  , n = function() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id])
                                return e[t.id];
                            let n;
                            switch (t.type) {
                            case "DirectionalLight":
                            case "SpotLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new i.I9Y
                                };
                                break;
                            case "PointLight":
                                n = {
                                    shadowIntensity: 1,
                                    shadowBias: 0,
                                    shadowNormalBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new i.I9Y,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                }
                            }
                            return e[t.id] = n,
                            n
                        }
                    }
                }()
                  , r = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
                for (let e = 0; e < 9; e++)
                    r.probe.push(new i.Pq0);
                const a = new i.Pq0
                  , s = new i.kn4
                  , l = new i.kn4;
                return {
                    setup: function(a) {
                        let s = 0
                          , l = 0
                          , c = 0;
                        for (let e = 0; e < 9; e++)
                            r.probe[e].set(0, 0, 0);
                        let h = 0
                          , d = 0
                          , u = 0
                          , p = 0
                          , f = 0
                          , g = 0
                          , m = 0
                          , A = 0
                          , v = 0
                          , y = 0
                          , w = 0;
                        a.sort(Ct);
                        for (let e = 0, o = a.length; e < o; e++) {
                            const o = a[e]
                              , b = o.color
                              , x = o.intensity
                              , S = o.distance;
                            let E = null;
                            if (o.shadow && o.shadow.map && (E = o.shadow.map.texture.format === i.paN ? o.shadow.map.texture : o.shadow.map.depthTexture || o.shadow.map.texture),
                            o.isAmbientLight)
                                s += b.r * x,
                                l += b.g * x,
                                c += b.b * x;
                            else if (o.isLightProbe) {
                                for (let e = 0; e < 9; e++)
                                    r.probe[e].addScaledVector(o.sh.coefficients[e], x);
                                w++
                            } else if (o.isDirectionalLight) {
                                const e = t.get(o);
                                if (e.color.copy(o.color).multiplyScalar(o.intensity),
                                o.castShadow) {
                                    const e = o.shadow
                                      , t = n.get(o);
                                    t.shadowIntensity = e.intensity,
                                    t.shadowBias = e.bias,
                                    t.shadowNormalBias = e.normalBias,
                                    t.shadowRadius = e.radius,
                                    t.shadowMapSize = e.mapSize,
                                    r.directionalShadow[h] = t,
                                    r.directionalShadowMap[h] = E,
                                    r.directionalShadowMatrix[h] = o.shadow.matrix,
                                    g++
                                }
                                r.directional[h] = e,
                                h++
                            } else if (o.isSpotLight) {
                                const e = t.get(o);
                                e.position.setFromMatrixPosition(o.matrixWorld),
                                e.color.copy(b).multiplyScalar(x),
                                e.distance = S,
                                e.coneCos = Math.cos(o.angle),
                                e.penumbraCos = Math.cos(o.angle * (1 - o.penumbra)),
                                e.decay = o.decay,
                                r.spot[u] = e;
                                const i = o.shadow;
                                if (o.map && (r.spotLightMap[v] = o.map,
                                v++,
                                i.updateMatrices(o),
                                o.castShadow && y++),
                                r.spotLightMatrix[u] = i.matrix,
                                o.castShadow) {
                                    const e = n.get(o);
                                    e.shadowIntensity = i.intensity,
                                    e.shadowBias = i.bias,
                                    e.shadowNormalBias = i.normalBias,
                                    e.shadowRadius = i.radius,
                                    e.shadowMapSize = i.mapSize,
                                    r.spotShadow[u] = e,
                                    r.spotShadowMap[u] = E,
                                    A++
                                }
                                u++
                            } else if (o.isRectAreaLight) {
                                const e = t.get(o);
                                e.color.copy(b).multiplyScalar(x),
                                e.halfWidth.set(.5 * o.width, 0, 0),
                                e.halfHeight.set(0, .5 * o.height, 0),
                                r.rectArea[p] = e,
                                p++
                            } else if (o.isPointLight) {
                                const e = t.get(o);
                                if (e.color.copy(o.color).multiplyScalar(o.intensity),
                                e.distance = o.distance,
                                e.decay = o.decay,
                                o.castShadow) {
                                    const e = o.shadow
                                      , t = n.get(o);
                                    t.shadowIntensity = e.intensity,
                                    t.shadowBias = e.bias,
                                    t.shadowNormalBias = e.normalBias,
                                    t.shadowRadius = e.radius,
                                    t.shadowMapSize = e.mapSize,
                                    t.shadowCameraNear = e.camera.near,
                                    t.shadowCameraFar = e.camera.far,
                                    r.pointShadow[d] = t,
                                    r.pointShadowMap[d] = E,
                                    r.pointShadowMatrix[d] = o.shadow.matrix,
                                    m++
                                }
                                r.point[d] = e,
                                d++
                            } else if (o.isHemisphereLight) {
                                const e = t.get(o);
                                e.skyColor.copy(o.color).multiplyScalar(x),
                                e.groundColor.copy(o.groundColor).multiplyScalar(x),
                                r.hemi[f] = e,
                                f++
                            }
                        }
                        p > 0 && (!0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = o.LTC_FLOAT_1,
                        r.rectAreaLTC2 = o.LTC_FLOAT_2) : (r.rectAreaLTC1 = o.LTC_HALF_1,
                        r.rectAreaLTC2 = o.LTC_HALF_2)),
                        r.ambient[0] = s,
                        r.ambient[1] = l,
                        r.ambient[2] = c;
                        const b = r.hash;
                        b.directionalLength === h && b.pointLength === d && b.spotLength === u && b.rectAreaLength === p && b.hemiLength === f && b.numDirectionalShadows === g && b.numPointShadows === m && b.numSpotShadows === A && b.numSpotMaps === v && b.numLightProbes === w || (r.directional.length = h,
                        r.spot.length = u,
                        r.rectArea.length = p,
                        r.point.length = d,
                        r.hemi.length = f,
                        r.directionalShadow.length = g,
                        r.directionalShadowMap.length = g,
                        r.pointShadow.length = m,
                        r.pointShadowMap.length = m,
                        r.spotShadow.length = A,
                        r.spotShadowMap.length = A,
                        r.directionalShadowMatrix.length = g,
                        r.pointShadowMatrix.length = m,
                        r.spotLightMatrix.length = A + v - y,
                        r.spotLightMap.length = v,
                        r.numSpotLightShadowsWithMaps = y,
                        r.numLightProbes = w,
                        b.directionalLength = h,
                        b.pointLength = d,
                        b.spotLength = u,
                        b.rectAreaLength = p,
                        b.hemiLength = f,
                        b.numDirectionalShadows = g,
                        b.numPointShadows = m,
                        b.numSpotShadows = A,
                        b.numSpotMaps = v,
                        b.numLightProbes = w,
                        r.version = _t++)
                    },
                    setupView: function(e, t) {
                        let n = 0
                          , i = 0
                          , o = 0
                          , c = 0
                          , h = 0;
                        const d = t.matrixWorldInverse;
                        for (let t = 0, u = e.length; t < u; t++) {
                            const u = e[t];
                            if (u.isDirectionalLight) {
                                const e = r.directional[n];
                                e.direction.setFromMatrixPosition(u.matrixWorld),
                                a.setFromMatrixPosition(u.target.matrixWorld),
                                e.direction.sub(a),
                                e.direction.transformDirection(d),
                                n++
                            } else if (u.isSpotLight) {
                                const e = r.spot[o];
                                e.position.setFromMatrixPosition(u.matrixWorld),
                                e.position.applyMatrix4(d),
                                e.direction.setFromMatrixPosition(u.matrixWorld),
                                a.setFromMatrixPosition(u.target.matrixWorld),
                                e.direction.sub(a),
                                e.direction.transformDirection(d),
                                o++
                            } else if (u.isRectAreaLight) {
                                const e = r.rectArea[c];
                                e.position.setFromMatrixPosition(u.matrixWorld),
                                e.position.applyMatrix4(d),
                                l.identity(),
                                s.copy(u.matrixWorld),
                                s.premultiply(d),
                                l.extractRotation(s),
                                e.halfWidth.set(.5 * u.width, 0, 0),
                                e.halfHeight.set(0, .5 * u.height, 0),
                                e.halfWidth.applyMatrix4(l),
                                e.halfHeight.applyMatrix4(l),
                                c++
                            } else if (u.isPointLight) {
                                const e = r.point[i];
                                e.position.setFromMatrixPosition(u.matrixWorld),
                                e.position.applyMatrix4(d),
                                i++
                            } else if (u.isHemisphereLight) {
                                const e = r.hemi[h];
                                e.direction.setFromMatrixPosition(u.matrixWorld),
                                e.direction.transformDirection(d),
                                h++
                            }
                        }
                    },
                    state: r
                }
            }
            function Pt(e) {
                const t = new Rt(e)
                  , n = []
                  , i = [];
                const r = {
                    lightsArray: n,
                    shadowsArray: i,
                    camera: null,
                    lights: t,
                    transmissionRenderTarget: {}
                };
                return {
                    init: function(e) {
                        r.camera = e,
                        n.length = 0,
                        i.length = 0
                    },
                    state: r,
                    setupLights: function() {
                        t.setup(n)
                    },
                    setupLightsView: function(e) {
                        t.setupView(n, e)
                    },
                    pushLight: function(e) {
                        n.push(e)
                    },
                    pushShadow: function(e) {
                        i.push(e)
                    }
                }
            }
            function It(e) {
                let t = new WeakMap;
                return {
                    get: function(n, i=0) {
                        const r = t.get(n);
                        let a;
                        return void 0 === r ? (a = new Pt(e),
                        t.set(n, [a])) : i >= r.length ? (a = new Pt(e),
                        r.push(a)) : a = r[i],
                        a
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }
            const Lt = [new i.Pq0(1,0,0), new i.Pq0(-1,0,0), new i.Pq0(0,1,0), new i.Pq0(0,-1,0), new i.Pq0(0,0,1), new i.Pq0(0,0,-1)]
              , Nt = [new i.Pq0(0,-1,0), new i.Pq0(0,-1,0), new i.Pq0(0,0,1), new i.Pq0(0,0,-1), new i.Pq0(0,-1,0), new i.Pq0(0,-1,0)]
              , zt = new i.kn4
              , Ut = new i.Pq0
              , Dt = new i.Pq0;
            function Bt(e, t, n) {
                let r = new i.PPD;
                const a = new i.I9Y
                  , s = new i.I9Y
                  , o = new i.IUQ
                  , l = new i.CSG
                  , c = new i.aVO
                  , h = {}
                  , d = n.maxTextureSize
                  , u = {
                    [i.hB5]: i.hsX,
                    [i.hsX]: i.hB5,
                    [i.$EB]: i.$EB
                }
                  , p = new i.BKk({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new i.I9Y
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );\n\tgl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );\n}"
                })
                  , f = p.clone();
                f.defines.HORIZONTAL_PASS = 1;
                const g = new i.LoY;
                g.setAttribute("position", new i.THS(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
                const m = new i.eaF(g,p)
                  , A = this;
                this.enabled = !1,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this.type = i.QP0;
                let v = this.type;
                function y(n, r) {
                    const s = t.update(m);
                    p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples,
                    f.defines.VSM_SAMPLES = n.blurSamples,
                    p.needsUpdate = !0,
                    f.needsUpdate = !0),
                    null === n.mapPass && (n.mapPass = new i.nWS(a.x,a.y,{
                        format: i.paN,
                        type: i.ix0
                    })),
                    p.uniforms.shadow_pass.value = n.map.depthTexture,
                    p.uniforms.resolution.value = n.mapSize,
                    p.uniforms.radius.value = n.radius,
                    e.setRenderTarget(n.mapPass),
                    e.clear(),
                    e.renderBufferDirect(r, null, s, p, m, null),
                    f.uniforms.shadow_pass.value = n.mapPass.texture,
                    f.uniforms.resolution.value = n.mapSize,
                    f.uniforms.radius.value = n.radius,
                    e.setRenderTarget(n.map),
                    e.clear(),
                    e.renderBufferDirect(r, null, s, f, m, null)
                }
                function w(t, n, r, a) {
                    let s = null;
                    const o = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== o)
                        s = o;
                    else if (s = !0 === r.isPointLight ? c : l,
                    e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0 || !0 === n.alphaToCoverage) {
                        const e = s.uuid
                          , t = n.uuid;
                        let i = h[e];
                        void 0 === i && (i = {},
                        h[e] = i);
                        let r = i[t];
                        void 0 === r && (r = s.clone(),
                        i[t] = r,
                        n.addEventListener("dispose", x)),
                        s = r
                    }
                    if (s.visible = n.visible,
                    s.wireframe = n.wireframe,
                    a === i.RyA ? s.side = null !== n.shadowSide ? n.shadowSide : n.side : s.side = null !== n.shadowSide ? n.shadowSide : u[n.side],
                    s.alphaMap = n.alphaMap,
                    s.alphaTest = !0 === n.alphaToCoverage ? .5 : n.alphaTest,
                    s.map = n.map,
                    s.clipShadows = n.clipShadows,
                    s.clippingPlanes = n.clippingPlanes,
                    s.clipIntersection = n.clipIntersection,
                    s.displacementMap = n.displacementMap,
                    s.displacementScale = n.displacementScale,
                    s.displacementBias = n.displacementBias,
                    s.wireframeLinewidth = n.wireframeLinewidth,
                    s.linewidth = n.linewidth,
                    !0 === r.isPointLight && !0 === s.isMeshDistanceMaterial) {
                        e.properties.get(s).light = r
                    }
                    return s
                }
                function b(n, a, s, o, l) {
                    if (!1 === n.visible)
                        return;
                    if (n.layers.test(a.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && l === i.RyA) && (!n.frustumCulled || r.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const i = t.update(n)
                          , r = n.material;
                        if (Array.isArray(r)) {
                            const t = i.groups;
                            for (let c = 0, h = t.length; c < h; c++) {
                                const h = t[c]
                                  , d = r[h.materialIndex];
                                if (d && d.visible) {
                                    const t = w(n, d, o, l);
                                    n.onBeforeShadow(e, n, a, s, i, t, h),
                                    e.renderBufferDirect(s, null, i, t, n, h),
                                    n.onAfterShadow(e, n, a, s, i, t, h)
                                }
                            }
                        } else if (r.visible) {
                            const t = w(n, r, o, l);
                            n.onBeforeShadow(e, n, a, s, i, t, null),
                            e.renderBufferDirect(s, null, i, t, n, null),
                            n.onAfterShadow(e, n, a, s, i, t, null)
                        }
                    }
                    const c = n.children;
                    for (let e = 0, t = c.length; e < t; e++)
                        b(c[e], a, s, o, l)
                }
                function x(e) {
                    e.target.removeEventListener("dispose", x);
                    for (const t in h) {
                        const n = h[t]
                          , i = e.target.uuid;
                        if (i in n) {
                            n[i].dispose(),
                            delete n[i]
                        }
                    }
                }
                this.render = function(t, n, l) {
                    if (!1 === A.enabled)
                        return;
                    if (!1 === A.autoUpdate && !1 === A.needsUpdate)
                        return;
                    if (0 === t.length)
                        return;
                    t.type === i.Wk7 && ((0,
                    i.R8M)("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."),
                    t.type = i.QP0);
                    const c = e.getRenderTarget()
                      , h = e.getActiveCubeFace()
                      , u = e.getActiveMipmapLevel()
                      , p = e.state;
                    p.setBlending(i.XIg),
                    !0 === p.buffers.depth.getReversed() ? p.buffers.color.setClear(0, 0, 0, 0) : p.buffers.color.setClear(1, 1, 1, 1),
                    p.buffers.depth.setTest(!0),
                    p.setScissorTest(!1);
                    const f = v !== this.type;
                    f && n.traverse((function(e) {
                        e.material && (Array.isArray(e.material) ? e.material.forEach((e => e.needsUpdate = !0)) : e.material.needsUpdate = !0)
                    }
                    ));
                    for (let c = 0, h = t.length; c < h; c++) {
                        const h = t[c]
                          , u = h.shadow;
                        if (void 0 === u) {
                            (0,
                            i.R8M)("WebGLShadowMap:", h, "has no shadow.");
                            continue
                        }
                        if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                            continue;
                        a.copy(u.mapSize);
                        const g = u.getFrameExtents();
                        if (a.multiply(g),
                        s.copy(u.mapSize),
                        (a.x > d || a.y > d) && (a.x > d && (s.x = Math.floor(d / g.x),
                        a.x = s.x * g.x,
                        u.mapSize.x = s.x),
                        a.y > d && (s.y = Math.floor(d / g.y),
                        a.y = s.y * g.y,
                        u.mapSize.y = s.y)),
                        null === u.map || !0 === f) {
                            if (null !== u.map && (null !== u.map.depthTexture && (u.map.depthTexture.dispose(),
                            u.map.depthTexture = null),
                            u.map.dispose()),
                            this.type === i.RyA) {
                                if (h.isPointLight) {
                                    (0,
                                    i.R8M)("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");
                                    continue
                                }
                                u.map = new i.nWS(a.x,a.y,{
                                    format: i.paN,
                                    type: i.ix0,
                                    minFilter: i.k6q,
                                    magFilter: i.k6q,
                                    generateMipmaps: !1
                                }),
                                u.map.texture.name = h.name + ".shadowMap",
                                u.map.depthTexture = new i.VCu(a.x,a.y,i.RQf),
                                u.map.depthTexture.name = h.name + ".shadowMapDepth",
                                u.map.depthTexture.format = i.zdS,
                                u.map.depthTexture.compareFunction = null,
                                u.map.depthTexture.minFilter = i.hxR,
                                u.map.depthTexture.magFilter = i.hxR
                            } else {
                                h.isPointLight ? (u.map = new i.o6l(a.x),
                                u.map.depthTexture = new i.Gc6(a.x,i.bkx)) : (u.map = new i.nWS(a.x,a.y),
                                u.map.depthTexture = new i.VCu(a.x,a.y,i.bkx)),
                                u.map.depthTexture.name = h.name + ".shadowMap",
                                u.map.depthTexture.format = i.zdS;
                                const t = e.state.buffers.depth.getReversed();
                                this.type === i.QP0 ? (u.map.depthTexture.compareFunction = t ? i.gWB : i.TiK,
                                u.map.depthTexture.minFilter = i.k6q,
                                u.map.depthTexture.magFilter = i.k6q) : (u.map.depthTexture.compareFunction = null,
                                u.map.depthTexture.minFilter = i.hxR,
                                u.map.depthTexture.magFilter = i.hxR)
                            }
                            u.camera.updateProjectionMatrix()
                        }
                        const m = u.map.isWebGLCubeRenderTarget ? 6 : 1;
                        for (let t = 0; t < m; t++) {
                            if (u.map.isWebGLCubeRenderTarget)
                                e.setRenderTarget(u.map, t),
                                e.clear();
                            else {
                                0 === t && (e.setRenderTarget(u.map),
                                e.clear());
                                const n = u.getViewport(t);
                                o.set(s.x * n.x, s.y * n.y, s.x * n.z, s.y * n.w),
                                p.viewport(o)
                            }
                            if (h.isPointLight) {
                                const e = u.camera
                                  , n = u.matrix
                                  , i = h.distance || e.far;
                                i !== e.far && (e.far = i,
                                e.updateProjectionMatrix()),
                                Ut.setFromMatrixPosition(h.matrixWorld),
                                e.position.copy(Ut),
                                Dt.copy(e.position),
                                Dt.add(Lt[t]),
                                e.up.copy(Nt[t]),
                                e.lookAt(Dt),
                                e.updateMatrixWorld(),
                                n.makeTranslation(-Ut.x, -Ut.y, -Ut.z),
                                zt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                                u._frustum.setFromProjectionMatrix(zt, e.coordinateSystem, e.reversedDepth)
                            } else
                                u.updateMatrices(h);
                            r = u.getFrustum(),
                            b(n, l, u.camera, h, this.type)
                        }
                        !0 !== u.isPointLightShadow && this.type === i.RyA && y(u, l),
                        u.needsUpdate = !1
                    }
                    v = this.type,
                    A.needsUpdate = !1,
                    e.setRenderTarget(c, h, u)
                }
            }
            const Gt = {
                [i.eHc]: i.lGu,
                [i.brA]: i.K52,
                [i.U3G]: i.bw0,
                [i.xSv]: i.Gwm,
                [i.lGu]: i.eHc,
                [i.K52]: i.brA,
                [i.bw0]: i.U3G,
                [i.Gwm]: i.xSv
            };
            function Ft(e, t) {
                const n = new function() {
                    let t = !1;
                    const n = new i.IUQ;
                    let r = null;
                    const a = new i.IUQ(0,0,0,0);
                    return {
                        setMask: function(n) {
                            r === n || t || (e.colorMask(n, n, n, n),
                            r = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, i, r, s, o) {
                            !0 === o && (t *= s,
                            i *= s,
                            r *= s),
                            n.set(t, i, r, s),
                            !1 === a.equals(n) && (e.clearColor(t, i, r, s),
                            a.copy(n))
                        },
                        reset: function() {
                            t = !1,
                            r = null,
                            a.set(-1, 0, 0, 0)
                        }
                    }
                }
                  , r = new function() {
                    let n = !1
                      , r = !1
                      , a = null
                      , s = null
                      , o = null;
                    return {
                        setReversed: function(e) {
                            if (r !== e) {
                                const n = t.get("EXT_clip_control");
                                e ? n.clipControlEXT(n.LOWER_LEFT_EXT, n.ZERO_TO_ONE_EXT) : n.clipControlEXT(n.LOWER_LEFT_EXT, n.NEGATIVE_ONE_TO_ONE_EXT),
                                r = e;
                                const i = o;
                                o = null,
                                this.setClear(i)
                            }
                        },
                        getReversed: function() {
                            return r
                        },
                        setTest: function(t) {
                            t ? O(e.DEPTH_TEST) : W(e.DEPTH_TEST)
                        },
                        setMask: function(t) {
                            a === t || n || (e.depthMask(t),
                            a = t)
                        },
                        setFunc: function(t) {
                            if (r && (t = Gt[t]),
                            s !== t) {
                                switch (t) {
                                case i.eHc:
                                    e.depthFunc(e.NEVER);
                                    break;
                                case i.lGu:
                                    e.depthFunc(e.ALWAYS);
                                    break;
                                case i.brA:
                                    e.depthFunc(e.LESS);
                                    break;
                                case i.xSv:
                                    e.depthFunc(e.LEQUAL);
                                    break;
                                case i.U3G:
                                    e.depthFunc(e.EQUAL);
                                    break;
                                case i.Gwm:
                                    e.depthFunc(e.GEQUAL);
                                    break;
                                case i.K52:
                                    e.depthFunc(e.GREATER);
                                    break;
                                case i.bw0:
                                    e.depthFunc(e.NOTEQUAL);
                                    break;
                                default:
                                    e.depthFunc(e.LEQUAL)
                                }
                                s = t
                            }
                        },
                        setLocked: function(e) {
                            n = e
                        },
                        setClear: function(t) {
                            o !== t && (r && (t = 1 - t),
                            e.clearDepth(t),
                            o = t)
                        },
                        reset: function() {
                            n = !1,
                            a = null,
                            s = null,
                            o = null,
                            r = !1
                        }
                    }
                }
                  , a = new function() {
                    let t = !1
                      , n = null
                      , i = null
                      , r = null
                      , a = null
                      , s = null
                      , o = null
                      , l = null
                      , c = null;
                    return {
                        setTest: function(n) {
                            t || (n ? O(e.STENCIL_TEST) : W(e.STENCIL_TEST))
                        },
                        setMask: function(i) {
                            n === i || t || (e.stencilMask(i),
                            n = i)
                        },
                        setFunc: function(t, n, s) {
                            i === t && r === n && a === s || (e.stencilFunc(t, n, s),
                            i = t,
                            r = n,
                            a = s)
                        },
                        setOp: function(t, n, i) {
                            s === t && o === n && l === i || (e.stencilOp(t, n, i),
                            s = t,
                            o = n,
                            l = i)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            c !== t && (e.clearStencil(t),
                            c = t)
                        },
                        reset: function() {
                            t = !1,
                            n = null,
                            i = null,
                            r = null,
                            a = null,
                            s = null,
                            o = null,
                            l = null,
                            c = null
                        }
                    }
                }
                  , s = new WeakMap
                  , o = new WeakMap;
                let l = {}
                  , c = {}
                  , h = new WeakMap
                  , d = []
                  , u = null
                  , p = !1
                  , f = null
                  , g = null
                  , m = null
                  , A = null
                  , v = null
                  , y = null
                  , w = null
                  , b = new i.Q1f(0,0,0)
                  , x = 0
                  , S = !1
                  , E = null
                  , T = null
                  , k = null
                  , M = null
                  , _ = null;
                const C = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                let R = !1
                  , P = 0;
                const I = e.getParameter(e.VERSION);
                -1 !== I.indexOf("WebGL") ? (P = parseFloat(/^WebGL (\d)/.exec(I)[1]),
                R = P >= 1) : -1 !== I.indexOf("OpenGL ES") && (P = parseFloat(/^OpenGL ES (\d)/.exec(I)[1]),
                R = P >= 2);
                let L = null
                  , N = {};
                const z = e.getParameter(e.SCISSOR_BOX)
                  , U = e.getParameter(e.VIEWPORT)
                  , D = (new i.IUQ).fromArray(z)
                  , B = (new i.IUQ).fromArray(U);
                function G(t, n, i, r) {
                    const a = new Uint8Array(4)
                      , s = e.createTexture();
                    e.bindTexture(t, s),
                    e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                    e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                    for (let s = 0; s < i; s++)
                        t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a);
                    return s
                }
                const F = {};
                function O(t) {
                    !0 !== l[t] && (e.enable(t),
                    l[t] = !0)
                }
                function W(t) {
                    !1 !== l[t] && (e.disable(t),
                    l[t] = !1)
                }
                F[e.TEXTURE_2D] = G(e.TEXTURE_2D, e.TEXTURE_2D, 1),
                F[e.TEXTURE_CUBE_MAP] = G(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
                F[e.TEXTURE_2D_ARRAY] = G(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
                F[e.TEXTURE_3D] = G(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
                n.setClear(0, 0, 0, 1),
                r.setClear(1),
                a.setClear(0),
                O(e.DEPTH_TEST),
                r.setFunc(i.xSv),
                K(!1),
                q(i.Vb5),
                O(e.CULL_FACE),
                j(i.XIg);
                const V = {
                    [i.gO9]: e.FUNC_ADD,
                    [i.FXf]: e.FUNC_SUBTRACT,
                    [i.nST]: e.FUNC_REVERSE_SUBTRACT
                };
                V[i.znC] = e.MIN,
                V[i.$ei] = e.MAX;
                const H = {
                    [i.ojh]: e.ZERO,
                    [i.qad]: e.ONE,
                    [i.f4X]: e.SRC_COLOR,
                    [i.ie2]: e.SRC_ALPHA,
                    [i.hgQ]: e.SRC_ALPHA_SATURATE,
                    [i.wn6]: e.DST_COLOR,
                    [i.hdd]: e.DST_ALPHA,
                    [i.LiQ]: e.ONE_MINUS_SRC_COLOR,
                    [i.OuU]: e.ONE_MINUS_SRC_ALPHA,
                    [i.aEY]: e.ONE_MINUS_DST_COLOR,
                    [i.Nt7]: e.ONE_MINUS_DST_ALPHA,
                    [i.RrE]: e.CONSTANT_COLOR,
                    [i.$Yl]: e.ONE_MINUS_CONSTANT_COLOR,
                    [i.e0p]: e.CONSTANT_ALPHA,
                    [i.ov9]: e.ONE_MINUS_CONSTANT_ALPHA
                };
                function j(t, n, r, a, s, o, l, c, h, d) {
                    if (t !== i.XIg) {
                        if (!1 === p && (O(e.BLEND),
                        p = !0),
                        t === i.bCz)
                            s = s || n,
                            o = o || r,
                            l = l || a,
                            n === g && s === v || (e.blendEquationSeparate(V[n], V[s]),
                            g = n,
                            v = s),
                            r === m && a === A && o === y && l === w || (e.blendFuncSeparate(H[r], H[a], H[o], H[l]),
                            m = r,
                            A = a,
                            y = o,
                            w = l),
                            !1 !== c.equals(b) && h === x || (e.blendColor(c.r, c.g, c.b, h),
                            b.copy(c),
                            x = h),
                            f = t,
                            S = !1;
                        else if (t !== f || d !== S) {
                            if (g === i.gO9 && v === i.gO9 || (e.blendEquation(e.FUNC_ADD),
                            g = i.gO9,
                            v = i.gO9),
                            d)
                                switch (t) {
                                case i.NTi:
                                    e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case i.EZo:
                                    e.blendFunc(e.ONE, e.ONE);
                                    break;
                                case i.Kwu:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case i.EdD:
                                    e.blendFuncSeparate(e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ZERO, e.ONE);
                                    break;
                                default:
                                    (0,
                                    i.z3S)("WebGLState: Invalid blending: ", t)
                                }
                            else
                                switch (t) {
                                case i.NTi:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case i.EZo:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE, e.ONE, e.ONE);
                                    break;
                                case i.Kwu:
                                    (0,
                                    i.z3S)("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
                                    break;
                                case i.EdD:
                                    (0,
                                    i.z3S)("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
                                    break;
                                default:
                                    (0,
                                    i.z3S)("WebGLState: Invalid blending: ", t)
                                }
                            m = null,
                            A = null,
                            y = null,
                            w = null,
                            b.set(0, 0, 0),
                            x = 0,
                            f = t,
                            S = d
                        }
                    } else
                        !0 === p && (W(e.BLEND),
                        p = !1)
                }
                function K(t) {
                    E !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                    E = t)
                }
                function q(t) {
                    t !== i.WNZ ? (O(e.CULL_FACE),
                    t !== T && (t === i.Vb5 ? e.cullFace(e.BACK) : t === i.Jnc ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : W(e.CULL_FACE),
                    T = t
                }
                function Q(t, n, i) {
                    t ? (O(e.POLYGON_OFFSET_FILL),
                    M === n && _ === i || (e.polygonOffset(n, i),
                    M = n,
                    _ = i)) : W(e.POLYGON_OFFSET_FILL)
                }
                return {
                    buffers: {
                        color: n,
                        depth: r,
                        stencil: a
                    },
                    enable: O,
                    disable: W,
                    bindFramebuffer: function(t, n) {
                        return c[t] !== n && (e.bindFramebuffer(t, n),
                        c[t] = n,
                        t === e.DRAW_FRAMEBUFFER && (c[e.FRAMEBUFFER] = n),
                        t === e.FRAMEBUFFER && (c[e.DRAW_FRAMEBUFFER] = n),
                        !0)
                    },
                    drawBuffers: function(t, n) {
                        let i = d
                          , r = !1;
                        if (t) {
                            i = h.get(n),
                            void 0 === i && (i = [],
                            h.set(n, i));
                            const a = t.textures;
                            if (i.length !== a.length || i[0] !== e.COLOR_ATTACHMENT0) {
                                for (let t = 0, n = a.length; t < n; t++)
                                    i[t] = e.COLOR_ATTACHMENT0 + t;
                                i.length = a.length,
                                r = !0
                            }
                        } else
                            i[0] !== e.BACK && (i[0] = e.BACK,
                            r = !0);
                        r && e.drawBuffers(i)
                    },
                    useProgram: function(t) {
                        return u !== t && (e.useProgram(t),
                        u = t,
                        !0)
                    },
                    setBlending: j,
                    setMaterial: function(t, s) {
                        t.side === i.$EB ? W(e.CULL_FACE) : O(e.CULL_FACE);
                        let o = t.side === i.hsX;
                        s && (o = !o),
                        K(o),
                        t.blending === i.NTi && !1 === t.transparent ? j(i.XIg) : j(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                        r.setFunc(t.depthFunc),
                        r.setTest(t.depthTest),
                        r.setMask(t.depthWrite),
                        n.setMask(t.colorWrite);
                        const l = t.stencilWrite;
                        a.setTest(l),
                        l && (a.setMask(t.stencilWriteMask),
                        a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                        a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                        Q(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                        !0 === t.alphaToCoverage ? O(e.SAMPLE_ALPHA_TO_COVERAGE) : W(e.SAMPLE_ALPHA_TO_COVERAGE)
                    },
                    setFlipSided: K,
                    setCullFace: q,
                    setLineWidth: function(t) {
                        t !== k && (R && e.lineWidth(t),
                        k = t)
                    },
                    setPolygonOffset: Q,
                    setScissorTest: function(t) {
                        t ? O(e.SCISSOR_TEST) : W(e.SCISSOR_TEST)
                    },
                    activeTexture: function(t) {
                        void 0 === t && (t = e.TEXTURE0 + C - 1),
                        L !== t && (e.activeTexture(t),
                        L = t)
                    },
                    bindTexture: function(t, n, i) {
                        void 0 === i && (i = null === L ? e.TEXTURE0 + C - 1 : L);
                        let r = N[i];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        },
                        N[i] = r),
                        r.type === t && r.texture === n || (L !== i && (e.activeTexture(i),
                        L = i),
                        e.bindTexture(t, n || F[t]),
                        r.type = t,
                        r.texture = n)
                    },
                    unbindTexture: function() {
                        const t = N[L];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                        t.type = void 0,
                        t.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            e.compressedTexImage2D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    compressedTexImage3D: function() {
                        try {
                            e.compressedTexImage3D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    texImage2D: function() {
                        try {
                            e.texImage2D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    texImage3D: function() {
                        try {
                            e.texImage3D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    updateUBOMapping: function(t, n) {
                        let i = o.get(n);
                        void 0 === i && (i = new WeakMap,
                        o.set(n, i));
                        let r = i.get(t);
                        void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
                        i.set(t, r))
                    },
                    uniformBlockBinding: function(t, n) {
                        const i = o.get(n).get(t);
                        s.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
                        s.set(n, i))
                    },
                    texStorage2D: function() {
                        try {
                            e.texStorage2D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    texStorage3D: function() {
                        try {
                            e.texStorage3D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    texSubImage2D: function() {
                        try {
                            e.texSubImage2D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    texSubImage3D: function() {
                        try {
                            e.texSubImage3D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function() {
                        try {
                            e.compressedTexSubImage2D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    compressedTexSubImage3D: function() {
                        try {
                            e.compressedTexSubImage3D(...arguments)
                        } catch (e) {
                            (0,
                            i.z3S)("WebGLState:", e)
                        }
                    },
                    scissor: function(t) {
                        !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                        D.copy(t))
                    },
                    viewport: function(t) {
                        !1 === B.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                        B.copy(t))
                    },
                    reset: function() {
                        e.disable(e.BLEND),
                        e.disable(e.CULL_FACE),
                        e.disable(e.DEPTH_TEST),
                        e.disable(e.POLYGON_OFFSET_FILL),
                        e.disable(e.SCISSOR_TEST),
                        e.disable(e.STENCIL_TEST),
                        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                        e.blendEquation(e.FUNC_ADD),
                        e.blendFunc(e.ONE, e.ZERO),
                        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                        e.blendColor(0, 0, 0, 0),
                        e.colorMask(!0, !0, !0, !0),
                        e.clearColor(0, 0, 0, 0),
                        e.depthMask(!0),
                        e.depthFunc(e.LESS),
                        r.setReversed(!1),
                        e.clearDepth(1),
                        e.stencilMask(4294967295),
                        e.stencilFunc(e.ALWAYS, 0, 4294967295),
                        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                        e.clearStencil(0),
                        e.cullFace(e.BACK),
                        e.frontFace(e.CCW),
                        e.polygonOffset(0, 0),
                        e.activeTexture(e.TEXTURE0),
                        e.bindFramebuffer(e.FRAMEBUFFER, null),
                        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        e.useProgram(null),
                        e.lineWidth(1),
                        e.scissor(0, 0, e.canvas.width, e.canvas.height),
                        e.viewport(0, 0, e.canvas.width, e.canvas.height),
                        l = {},
                        L = null,
                        N = {},
                        c = {},
                        h = new WeakMap,
                        d = [],
                        u = null,
                        p = !1,
                        f = null,
                        g = null,
                        m = null,
                        A = null,
                        v = null,
                        y = null,
                        w = null,
                        b = new i.Q1f(0,0,0),
                        x = 0,
                        S = !1,
                        E = null,
                        T = null,
                        k = null,
                        M = null,
                        _ = null,
                        D.set(0, 0, e.canvas.width, e.canvas.height),
                        B.set(0, 0, e.canvas.width, e.canvas.height),
                        n.reset(),
                        r.reset(),
                        a.reset()
                    }
                }
            }
            function Ot(e, t, n, r, a, s, o) {
                const l = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
                  , c = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
                  , h = new i.I9Y
                  , d = new WeakMap;
                let u;
                const p = new WeakMap;
                let f = !1;
                try {
                    f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
                } catch (e) {}
                function g(e, t) {
                    return f ? new OffscreenCanvas(e,t) : (0,
                    i.qq$)("canvas")
                }
                function m(e, t, n) {
                    let r = 1;
                    const a = H(e);
                    if ((a.width > n || a.height > n) && (r = n / Math.max(a.width, a.height)),
                    r < 1) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                            const n = Math.floor(r * a.width)
                              , s = Math.floor(r * a.height);
                            void 0 === u && (u = g(n, s));
                            const o = t ? g(n, s) : u;
                            o.width = n,
                            o.height = s;
                            return o.getContext("2d").drawImage(e, 0, 0, n, s),
                            (0,
                            i.R8M)("WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + n + "x" + s + ")."),
                            o
                        }
                        return "data"in e && (0,
                        i.R8M)("WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height + ")."),
                        e
                    }
                    return e
                }
                function A(e) {
                    return e.generateMipmaps
                }
                function v(t) {
                    e.generateMipmap(t)
                }
                function y(t) {
                    return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
                }
                function w(n, r, a, s, o=!1) {
                    if (null !== n) {
                        if (void 0 !== e[n])
                            return e[n];
                        (0,
                        i.R8M)("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let l = r;
                    if (r === e.RED && (a === e.FLOAT && (l = e.R32F),
                    a === e.HALF_FLOAT && (l = e.R16F),
                    a === e.UNSIGNED_BYTE && (l = e.R8)),
                    r === e.RED_INTEGER && (a === e.UNSIGNED_BYTE && (l = e.R8UI),
                    a === e.UNSIGNED_SHORT && (l = e.R16UI),
                    a === e.UNSIGNED_INT && (l = e.R32UI),
                    a === e.BYTE && (l = e.R8I),
                    a === e.SHORT && (l = e.R16I),
                    a === e.INT && (l = e.R32I)),
                    r === e.RG && (a === e.FLOAT && (l = e.RG32F),
                    a === e.HALF_FLOAT && (l = e.RG16F),
                    a === e.UNSIGNED_BYTE && (l = e.RG8)),
                    r === e.RG_INTEGER && (a === e.UNSIGNED_BYTE && (l = e.RG8UI),
                    a === e.UNSIGNED_SHORT && (l = e.RG16UI),
                    a === e.UNSIGNED_INT && (l = e.RG32UI),
                    a === e.BYTE && (l = e.RG8I),
                    a === e.SHORT && (l = e.RG16I),
                    a === e.INT && (l = e.RG32I)),
                    r === e.RGB_INTEGER && (a === e.UNSIGNED_BYTE && (l = e.RGB8UI),
                    a === e.UNSIGNED_SHORT && (l = e.RGB16UI),
                    a === e.UNSIGNED_INT && (l = e.RGB32UI),
                    a === e.BYTE && (l = e.RGB8I),
                    a === e.SHORT && (l = e.RGB16I),
                    a === e.INT && (l = e.RGB32I)),
                    r === e.RGBA_INTEGER && (a === e.UNSIGNED_BYTE && (l = e.RGBA8UI),
                    a === e.UNSIGNED_SHORT && (l = e.RGBA16UI),
                    a === e.UNSIGNED_INT && (l = e.RGBA32UI),
                    a === e.BYTE && (l = e.RGBA8I),
                    a === e.SHORT && (l = e.RGBA16I),
                    a === e.INT && (l = e.RGBA32I)),
                    r === e.RGB && (a === e.UNSIGNED_INT_5_9_9_9_REV && (l = e.RGB9_E5),
                    a === e.UNSIGNED_INT_10F_11F_11F_REV && (l = e.R11F_G11F_B10F)),
                    r === e.RGBA) {
                        const t = o ? i.VxR : i.ppV.getTransfer(s);
                        a === e.FLOAT && (l = e.RGBA32F),
                        a === e.HALF_FLOAT && (l = e.RGBA16F),
                        a === e.UNSIGNED_BYTE && (l = t === i.KLL ? e.SRGB8_ALPHA8 : e.RGBA8),
                        a === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
                        a === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)
                    }
                    return l !== e.R16F && l !== e.R32F && l !== e.RG16F && l !== e.RG32F && l !== e.RGBA16F && l !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                    l
                }
                function b(t, n) {
                    let r;
                    return t ? null === n || n === i.bkx || n === i.V3x ? r = e.DEPTH24_STENCIL8 : n === i.RQf ? r = e.DEPTH32F_STENCIL8 : n === i.cHt && (r = e.DEPTH24_STENCIL8,
                    (0,
                    i.R8M)("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === i.bkx || n === i.V3x ? r = e.DEPTH_COMPONENT24 : n === i.RQf ? r = e.DEPTH_COMPONENT32F : n === i.cHt && (r = e.DEPTH_COMPONENT16),
                    r
                }
                function x(e, t) {
                    return !0 === A(e) || e.isFramebufferTexture && e.minFilter !== i.hxR && e.minFilter !== i.k6q ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }
                function S(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", S),
                    function(e) {
                        const t = r.get(e);
                        if (void 0 === t.__webglInit)
                            return;
                        const n = e.source
                          , i = p.get(n);
                        if (i) {
                            const r = i[t.__cacheKey];
                            r.usedTimes--,
                            0 === r.usedTimes && T(e),
                            0 === Object.keys(i).length && p.delete(n)
                        }
                        r.remove(e)
                    }(t),
                    t.isVideoTexture && d.delete(t)
                }
                function E(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", E),
                    function(t) {
                        const n = r.get(t);
                        t.depthTexture && (t.depthTexture.dispose(),
                        r.remove(t.depthTexture));
                        if (t.isWebGLCubeRenderTarget)
                            for (let t = 0; t < 6; t++) {
                                if (Array.isArray(n.__webglFramebuffer[t]))
                                    for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                                        e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                                else
                                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                            }
                        else {
                            if (Array.isArray(n.__webglFramebuffer))
                                for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            else
                                e.deleteFramebuffer(n.__webglFramebuffer);
                            if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                            n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                            n.__webglColorRenderbuffer)
                                for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                    n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                            n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                        }
                        const i = t.textures;
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = r.get(i[t]);
                            n.__webglTexture && (e.deleteTexture(n.__webglTexture),
                            o.memory.textures--),
                            r.remove(i[t])
                        }
                        r.remove(t)
                    }(n)
                }
                function T(t) {
                    const n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    const i = t.source;
                    delete p.get(i)[n.__cacheKey],
                    o.memory.textures--
                }
                let k = 0;
                function M(t, a) {
                    const s = r.get(t);
                    if (t.isVideoTexture && function(e) {
                        const t = o.render.frame;
                        d.get(e) !== t && (d.set(e, t),
                        e.update())
                    }(t),
                    !1 === t.isRenderTargetTexture && !0 !== t.isExternalTexture && t.version > 0 && s.__version !== t.version) {
                        const e = t.image;
                        if (null === e)
                            (0,
                            i.R8M)("WebGLRenderer: Texture marked for update but no image data found.");
                        else {
                            if (!1 !== e.complete)
                                return void N(s, t, a);
                            (0,
                            i.R8M)("WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    } else
                        t.isExternalTexture && (s.__webglTexture = t.sourceTexture ? t.sourceTexture : null);
                    n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + a)
                }
                const _ = {
                    [i.GJx]: e.REPEAT,
                    [i.ghU]: e.CLAMP_TO_EDGE,
                    [i.kTW]: e.MIRRORED_REPEAT
                }
                  , C = {
                    [i.hxR]: e.NEAREST,
                    [i.pHI]: e.NEAREST_MIPMAP_NEAREST,
                    [i.Cfg]: e.NEAREST_MIPMAP_LINEAR,
                    [i.k6q]: e.LINEAR,
                    [i.kRr]: e.LINEAR_MIPMAP_NEAREST,
                    [i.$_I]: e.LINEAR_MIPMAP_LINEAR
                }
                  , R = {
                    [i.amv]: e.NEVER,
                    [i.FFZ]: e.ALWAYS,
                    [i.vim]: e.LESS,
                    [i.TiK]: e.LEQUAL,
                    [i.kO0]: e.EQUAL,
                    [i.gWB]: e.GEQUAL,
                    [i.eoi]: e.GREATER,
                    [i.jzd]: e.NOTEQUAL
                };
                function P(n, s) {
                    if (s.type !== i.RQf || !1 !== t.has("OES_texture_float_linear") || s.magFilter !== i.k6q && s.magFilter !== i.kRr && s.magFilter !== i.Cfg && s.magFilter !== i.$_I && s.minFilter !== i.k6q && s.minFilter !== i.kRr && s.minFilter !== i.Cfg && s.minFilter !== i.$_I || (0,
                    i.R8M)("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                    e.texParameteri(n, e.TEXTURE_WRAP_S, _[s.wrapS]),
                    e.texParameteri(n, e.TEXTURE_WRAP_T, _[s.wrapT]),
                    n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, _[s.wrapR]),
                    e.texParameteri(n, e.TEXTURE_MAG_FILTER, C[s.magFilter]),
                    e.texParameteri(n, e.TEXTURE_MIN_FILTER, C[s.minFilter]),
                    s.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                    e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, R[s.compareFunction])),
                    !0 === t.has("EXT_texture_filter_anisotropic")) {
                        if (s.magFilter === i.hxR)
                            return;
                        if (s.minFilter !== i.Cfg && s.minFilter !== i.$_I)
                            return;
                        if (s.type === i.RQf && !1 === t.has("OES_texture_float_linear"))
                            return;
                        if (s.anisotropy > 1 || r.get(s).__currentAnisotropy) {
                            const i = t.get("EXT_texture_filter_anisotropic");
                            e.texParameterf(n, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, a.getMaxAnisotropy())),
                            r.get(s).__currentAnisotropy = s.anisotropy
                        }
                    }
                }
                function I(t, n) {
                    let i = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0,
                    n.addEventListener("dispose", S));
                    const r = n.source;
                    let a = p.get(r);
                    void 0 === a && (a = {},
                    p.set(r, a));
                    const s = function(e) {
                        const t = [];
                        return t.push(e.wrapS),
                        t.push(e.wrapT),
                        t.push(e.wrapR || 0),
                        t.push(e.magFilter),
                        t.push(e.minFilter),
                        t.push(e.anisotropy),
                        t.push(e.internalFormat),
                        t.push(e.format),
                        t.push(e.type),
                        t.push(e.generateMipmaps),
                        t.push(e.premultiplyAlpha),
                        t.push(e.flipY),
                        t.push(e.unpackAlignment),
                        t.push(e.colorSpace),
                        t.join()
                    }(n);
                    if (s !== t.__cacheKey) {
                        void 0 === a[s] && (a[s] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        },
                        o.memory.textures++,
                        i = !0),
                        a[s].usedTimes++;
                        const r = a[t.__cacheKey];
                        void 0 !== r && (a[t.__cacheKey].usedTimes--,
                        0 === r.usedTimes && T(n)),
                        t.__cacheKey = s,
                        t.__webglTexture = a[s].texture
                    }
                    return i
                }
                function L(e, t, n) {
                    return Math.floor(Math.floor(e / n) / t)
                }
                function N(t, o, l) {
                    let c = e.TEXTURE_2D;
                    (o.isDataArrayTexture || o.isCompressedArrayTexture) && (c = e.TEXTURE_2D_ARRAY),
                    o.isData3DTexture && (c = e.TEXTURE_3D);
                    const h = I(t, o)
                      , d = o.source;
                    n.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l);
                    const u = r.get(d);
                    if (d.version !== u.__version || !0 === h) {
                        n.activeTexture(e.TEXTURE0 + l);
                        const t = i.ppV.getPrimaries(i.ppV.workingColorSpace)
                          , r = o.colorSpace === i.jf0 ? null : i.ppV.getPrimaries(o.colorSpace)
                          , p = o.colorSpace === i.jf0 || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
                        let f = m(o.image, !1, a.maxTextureSize);
                        f = V(o, f);
                        const g = s.convert(o.format, o.colorSpace)
                          , y = s.convert(o.type);
                        let S, E = w(o.internalFormat, g, y, o.colorSpace, o.isVideoTexture);
                        P(c, o);
                        const T = o.mipmaps
                          , k = !0 !== o.isVideoTexture
                          , M = void 0 === u.__version || !0 === h
                          , _ = d.dataReady
                          , C = x(o, f);
                        if (o.isDepthTexture)
                            E = b(o.format === i.dcC, o.type),
                            M && (k ? n.texStorage2D(e.TEXTURE_2D, 1, E, f.width, f.height) : n.texImage2D(e.TEXTURE_2D, 0, E, f.width, f.height, 0, g, y, null));
                        else if (o.isDataTexture)
                            if (T.length > 0) {
                                k && M && n.texStorage2D(e.TEXTURE_2D, C, E, T[0].width, T[0].height);
                                for (let t = 0, i = T.length; t < i; t++)
                                    S = T[t],
                                    k ? _ && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, g, y, S.data) : n.texImage2D(e.TEXTURE_2D, t, E, S.width, S.height, 0, g, y, S.data);
                                o.generateMipmaps = !1
                            } else
                                k ? (M && n.texStorage2D(e.TEXTURE_2D, C, E, f.width, f.height),
                                _ && function(t, i, r, a) {
                                    const s = t.updateRanges;
                                    if (0 === s.length)
                                        n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, i.width, i.height, r, a, i.data);
                                    else {
                                        s.sort(( (e, t) => e.start - t.start));
                                        let o = 0;
                                        for (let e = 1; e < s.length; e++) {
                                            const t = s[o]
                                              , n = s[e]
                                              , r = t.start + t.count
                                              , a = L(n.start, i.width, 4)
                                              , l = L(t.start, i.width, 4);
                                            n.start <= r + 1 && a === l && L(n.start + n.count - 1, i.width, 4) === a ? t.count = Math.max(t.count, n.start + n.count - t.start) : (++o,
                                            s[o] = n)
                                        }
                                        s.length = o + 1;
                                        const l = e.getParameter(e.UNPACK_ROW_LENGTH)
                                          , c = e.getParameter(e.UNPACK_SKIP_PIXELS)
                                          , h = e.getParameter(e.UNPACK_SKIP_ROWS);
                                        e.pixelStorei(e.UNPACK_ROW_LENGTH, i.width);
                                        for (let t = 0, o = s.length; t < o; t++) {
                                            const o = s[t]
                                              , l = Math.floor(o.start / 4)
                                              , c = Math.ceil(o.count / 4)
                                              , h = l % i.width
                                              , d = Math.floor(l / i.width)
                                              , u = c
                                              , p = 1;
                                            e.pixelStorei(e.UNPACK_SKIP_PIXELS, h),
                                            e.pixelStorei(e.UNPACK_SKIP_ROWS, d),
                                            n.texSubImage2D(e.TEXTURE_2D, 0, h, d, u, p, r, a, i.data)
                                        }
                                        t.clearUpdateRanges(),
                                        e.pixelStorei(e.UNPACK_ROW_LENGTH, l),
                                        e.pixelStorei(e.UNPACK_SKIP_PIXELS, c),
                                        e.pixelStorei(e.UNPACK_SKIP_ROWS, h)
                                    }
                                }(o, f, g, y)) : n.texImage2D(e.TEXTURE_2D, 0, E, f.width, f.height, 0, g, y, f.data);
                        else if (o.isCompressedTexture)
                            if (o.isCompressedArrayTexture) {
                                k && M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, E, T[0].width, T[0].height, f.depth);
                                for (let t = 0, r = T.length; t < r; t++)
                                    if (S = T[t],
                                    o.format !== i.GWd)
                                        if (null !== g)
                                            if (k) {
                                                if (_)
                                                    if (o.layerUpdates.size > 0) {
                                                        const r = (0,
                                                        i.Nex)(S.width, S.height, o.format, o.type);
                                                        for (const i of o.layerUpdates) {
                                                            const a = S.data.subarray(i * r / S.data.BYTES_PER_ELEMENT, (i + 1) * r / S.data.BYTES_PER_ELEMENT);
                                                            n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, i, S.width, S.height, 1, g, a)
                                                        }
                                                        o.clearLayerUpdates()
                                                    } else
                                                        n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, f.depth, g, S.data)
                                            } else
                                                n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, E, S.width, S.height, f.depth, 0, S.data, 0, 0);
                                        else
                                            (0,
                                            i.R8M)("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                    else
                                        k ? _ && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, f.depth, g, y, S.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, E, S.width, S.height, f.depth, 0, g, y, S.data)
                            } else {
                                k && M && n.texStorage2D(e.TEXTURE_2D, C, E, T[0].width, T[0].height);
                                for (let t = 0, r = T.length; t < r; t++)
                                    S = T[t],
                                    o.format !== i.GWd ? null !== g ? k ? _ && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, g, S.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, E, S.width, S.height, 0, S.data) : (0,
                                    i.R8M)("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : k ? _ && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, g, y, S.data) : n.texImage2D(e.TEXTURE_2D, t, E, S.width, S.height, 0, g, y, S.data)
                            }
                        else if (o.isDataArrayTexture)
                            if (k) {
                                if (M && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, E, f.width, f.height, f.depth),
                                _)
                                    if (o.layerUpdates.size > 0) {
                                        const t = (0,
                                        i.Nex)(f.width, f.height, o.format, o.type);
                                        for (const i of o.layerUpdates) {
                                            const r = f.data.subarray(i * t / f.data.BYTES_PER_ELEMENT, (i + 1) * t / f.data.BYTES_PER_ELEMENT);
                                            n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, f.width, f.height, 1, g, y, r)
                                        }
                                        o.clearLayerUpdates()
                                    } else
                                        n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, f.width, f.height, f.depth, g, y, f.data)
                            } else
                                n.texImage3D(e.TEXTURE_2D_ARRAY, 0, E, f.width, f.height, f.depth, 0, g, y, f.data);
                        else if (o.isData3DTexture)
                            k ? (M && n.texStorage3D(e.TEXTURE_3D, C, E, f.width, f.height, f.depth),
                            _ && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, f.width, f.height, f.depth, g, y, f.data)) : n.texImage3D(e.TEXTURE_3D, 0, E, f.width, f.height, f.depth, 0, g, y, f.data);
                        else if (o.isFramebufferTexture) {
                            if (M)
                                if (k)
                                    n.texStorage2D(e.TEXTURE_2D, C, E, f.width, f.height);
                                else {
                                    let t = f.width
                                      , i = f.height;
                                    for (let r = 0; r < C; r++)
                                        n.texImage2D(e.TEXTURE_2D, r, E, t, i, 0, g, y, null),
                                        t >>= 1,
                                        i >>= 1
                                }
                        } else if (T.length > 0) {
                            if (k && M) {
                                const t = H(T[0]);
                                n.texStorage2D(e.TEXTURE_2D, C, E, t.width, t.height)
                            }
                            for (let t = 0, i = T.length; t < i; t++)
                                S = T[t],
                                k ? _ && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, g, y, S) : n.texImage2D(e.TEXTURE_2D, t, E, g, y, S);
                            o.generateMipmaps = !1
                        } else if (k) {
                            if (M) {
                                const t = H(f);
                                n.texStorage2D(e.TEXTURE_2D, C, E, t.width, t.height)
                            }
                            _ && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, g, y, f)
                        } else
                            n.texImage2D(e.TEXTURE_2D, 0, E, g, y, f);
                        A(o) && v(c),
                        u.__version = d.version,
                        o.onUpdate && o.onUpdate(o)
                    }
                    t.__version = o.version
                }
                function z(t, i, a, o, c, h) {
                    const d = s.convert(a.format, a.colorSpace)
                      , u = s.convert(a.type)
                      , p = w(a.internalFormat, d, u, a.colorSpace)
                      , f = r.get(i)
                      , g = r.get(a);
                    if (g.__renderTarget = i,
                    !f.__hasExternalTextures) {
                        const t = Math.max(1, i.width >> h)
                          , r = Math.max(1, i.height >> h);
                        c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, h, p, t, r, i.depth, 0, d, u, null) : n.texImage2D(c, h, p, t, r, 0, d, u, null)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, t),
                    W(i) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, o, c, g.__webglTexture, 0, O(i)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, o, c, g.__webglTexture, h),
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                function U(t, n, i) {
                    if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                    n.depthBuffer) {
                        const r = n.depthTexture
                          , a = r && r.isDepthTexture ? r.type : null
                          , s = b(n.stencilBuffer, a)
                          , o = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                        W(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, O(n), s, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, O(n), s, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, s, n.width, n.height),
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, o, e.RENDERBUFFER, t)
                    } else {
                        const t = n.textures;
                        for (let r = 0; r < t.length; r++) {
                            const a = t[r]
                              , o = s.convert(a.format, a.colorSpace)
                              , c = s.convert(a.type)
                              , h = w(a.internalFormat, o, c, a.colorSpace);
                            W(n) ? l.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, O(n), h, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, O(n), h, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, h, n.width, n.height)
                        }
                    }
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }
                function D(t, a, o) {
                    const c = !0 === a.isWebGLCubeRenderTarget;
                    if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                    !a.depthTexture || !a.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    const h = r.get(a.depthTexture);
                    if (h.__renderTarget = a,
                    h.__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width,
                    a.depthTexture.image.height = a.height,
                    a.depthTexture.needsUpdate = !0),
                    c) {
                        if (void 0 === h.__webglInit && (h.__webglInit = !0,
                        a.depthTexture.addEventListener("dispose", S)),
                        void 0 === h.__webglTexture) {
                            h.__webglTexture = e.createTexture(),
                            n.bindTexture(e.TEXTURE_CUBE_MAP, h.__webglTexture),
                            P(e.TEXTURE_CUBE_MAP, a.depthTexture);
                            const t = s.convert(a.depthTexture.format)
                              , r = s.convert(a.depthTexture.type);
                            let o;
                            a.depthTexture.format === i.zdS ? o = e.DEPTH_COMPONENT24 : a.depthTexture.format === i.dcC && (o = e.DEPTH24_STENCIL8);
                            for (let n = 0; n < 6; n++)
                                e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, o, a.width, a.height, 0, t, r, null)
                        }
                    } else
                        M(a.depthTexture, 0);
                    const d = h.__webglTexture
                      , u = O(a)
                      , p = c ? e.TEXTURE_CUBE_MAP_POSITIVE_X + o : e.TEXTURE_2D
                      , f = a.depthTexture.format === i.dcC ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                    if (a.depthTexture.format === i.zdS)
                        W(a) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, f, p, d, 0, u) : e.framebufferTexture2D(e.FRAMEBUFFER, f, p, d, 0);
                    else {
                        if (a.depthTexture.format !== i.dcC)
                            throw new Error("Unknown depthTexture format");
                        W(a) ? l.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, f, p, d, 0, u) : e.framebufferTexture2D(e.FRAMEBUFFER, f, p, d, 0)
                    }
                }
                function B(t) {
                    const i = r.get(t)
                      , a = !0 === t.isWebGLCubeRenderTarget;
                    if (i.__boundDepthTexture !== t.depthTexture) {
                        const e = t.depthTexture;
                        if (i.__depthDisposeCallback && i.__depthDisposeCallback(),
                        e) {
                            const t = () => {
                                delete i.__boundDepthTexture,
                                delete i.__depthDisposeCallback,
                                e.removeEventListener("dispose", t)
                            }
                            ;
                            e.addEventListener("dispose", t),
                            i.__depthDisposeCallback = t
                        }
                        i.__boundDepthTexture = e
                    }
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer)
                        if (a)
                            for (let e = 0; e < 6; e++)
                                D(i.__webglFramebuffer[e], t, e);
                        else {
                            const e = t.texture.mipmaps;
                            e && e.length > 0 ? D(i.__webglFramebuffer[0], t, 0) : D(i.__webglFramebuffer, t, 0)
                        }
                    else if (a) {
                        i.__webglDepthbuffer = [];
                        for (let r = 0; r < 6; r++)
                            if (n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[r]),
                            void 0 === i.__webglDepthbuffer[r])
                                i.__webglDepthbuffer[r] = e.createRenderbuffer(),
                                U(i.__webglDepthbuffer[r], t, !1);
                            else {
                                const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                                  , a = i.__webglDepthbuffer[r];
                                e.bindRenderbuffer(e.RENDERBUFFER, a),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, a)
                            }
                    } else {
                        const r = t.texture.mipmaps;
                        if (r && r.length > 0 ? n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[0]) : n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer),
                        void 0 === i.__webglDepthbuffer)
                            i.__webglDepthbuffer = e.createRenderbuffer(),
                            U(i.__webglDepthbuffer, t, !1);
                        else {
                            const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , r = i.__webglDepthbuffer;
                            e.bindRenderbuffer(e.RENDERBUFFER, r),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, r)
                        }
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }
                const G = []
                  , F = [];
                function O(e) {
                    return Math.min(a.maxSamples, e.samples)
                }
                function W(e) {
                    const n = r.get(e);
                    return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }
                function V(e, t) {
                    const n = e.colorSpace
                      , r = e.format
                      , a = e.type;
                    return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== i.Zr2 && n !== i.jf0 && (i.ppV.getTransfer(n) === i.KLL ? r === i.GWd && a === i.OUM || (0,
                    i.R8M)("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : (0,
                    i.z3S)("WebGLTextures: Unsupported texture color space:", n)),
                    t
                }
                function H(e) {
                    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (h.width = e.naturalWidth || e.width,
                    h.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (h.width = e.displayWidth,
                    h.height = e.displayHeight) : (h.width = e.width,
                    h.height = e.height),
                    h
                }
                this.allocateTextureUnit = function() {
                    const e = k;
                    return e >= a.maxTextures && (0,
                    i.R8M)("WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + a.maxTextures),
                    k += 1,
                    e
                }
                ,
                this.resetTextureUnits = function() {
                    k = 0
                }
                ,
                this.setTexture2D = M,
                this.setTexture2DArray = function(t, i) {
                    const a = r.get(t);
                    !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version ? N(a, t, i) : (t.isExternalTexture && (a.__webglTexture = t.sourceTexture ? t.sourceTexture : null),
                    n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + i))
                }
                ,
                this.setTexture3D = function(t, i) {
                    const a = r.get(t);
                    !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version ? N(a, t, i) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + i)
                }
                ,
                this.setTextureCube = function(t, o) {
                    const l = r.get(t);
                    !0 !== t.isCubeDepthTexture && t.version > 0 && l.__version !== t.version ? function(t, o, l) {
                        if (6 !== o.image.length)
                            return;
                        const c = I(t, o)
                          , h = o.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + l);
                        const d = r.get(h);
                        if (h.version !== d.__version || !0 === c) {
                            n.activeTexture(e.TEXTURE0 + l);
                            const t = i.ppV.getPrimaries(i.ppV.workingColorSpace)
                              , r = o.colorSpace === i.jf0 ? null : i.ppV.getPrimaries(o.colorSpace)
                              , u = o.colorSpace === i.jf0 || t === r ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, o.flipY),
                            e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, o.premultiplyAlpha),
                            e.pixelStorei(e.UNPACK_ALIGNMENT, o.unpackAlignment),
                            e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                            const p = o.isCompressedTexture || o.image[0].isCompressedTexture
                              , f = o.image[0] && o.image[0].isDataTexture
                              , g = [];
                            for (let e = 0; e < 6; e++)
                                g[e] = p || f ? f ? o.image[e].image : o.image[e] : m(o.image[e], !0, a.maxCubemapSize),
                                g[e] = V(o, g[e]);
                            const y = g[0]
                              , b = s.convert(o.format, o.colorSpace)
                              , S = s.convert(o.type)
                              , E = w(o.internalFormat, b, S, o.colorSpace)
                              , T = !0 !== o.isVideoTexture
                              , k = void 0 === d.__version || !0 === c
                              , M = h.dataReady;
                            let _, C = x(o, y);
                            if (P(e.TEXTURE_CUBE_MAP, o),
                            p) {
                                T && k && n.texStorage2D(e.TEXTURE_CUBE_MAP, C, E, y.width, y.height);
                                for (let t = 0; t < 6; t++) {
                                    _ = g[t].mipmaps;
                                    for (let r = 0; r < _.length; r++) {
                                        const a = _[r];
                                        o.format !== i.GWd ? null !== b ? T ? M && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, a.width, a.height, b, a.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, E, a.width, a.height, 0, a.data) : (0,
                                        i.R8M)("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : T ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, 0, 0, a.width, a.height, b, S, a.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, r, E, a.width, a.height, 0, b, S, a.data)
                                    }
                                }
                            } else {
                                if (_ = o.mipmaps,
                                T && k) {
                                    _.length > 0 && C++;
                                    const t = H(g[0]);
                                    n.texStorage2D(e.TEXTURE_CUBE_MAP, C, E, t.width, t.height)
                                }
                                for (let t = 0; t < 6; t++)
                                    if (f) {
                                        T ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, g[t].width, g[t].height, b, S, g[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, g[t].width, g[t].height, 0, b, S, g[t].data);
                                        for (let i = 0; i < _.length; i++) {
                                            const r = _[i].image[t].image;
                                            T ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, b, S, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, E, r.width, r.height, 0, b, S, r.data)
                                        }
                                    } else {
                                        T ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, b, S, g[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, b, S, g[t]);
                                        for (let i = 0; i < _.length; i++) {
                                            const r = _[i];
                                            T ? M && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, b, S, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, E, b, S, r.image[t])
                                        }
                                    }
                            }
                            A(o) && v(e.TEXTURE_CUBE_MAP),
                            d.__version = h.version,
                            o.onUpdate && o.onUpdate(o)
                        }
                        t.__version = o.version
                    }(l, t, o) : n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + o)
                }
                ,
                this.rebindTextures = function(t, n, i) {
                    const a = r.get(t);
                    void 0 !== n && z(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                    void 0 !== i && B(t)
                }
                ,
                this.setupRenderTarget = function(t) {
                    const i = t.texture
                      , a = r.get(t)
                      , l = r.get(i);
                    t.addEventListener("dispose", E);
                    const c = t.textures
                      , h = !0 === t.isWebGLCubeRenderTarget
                      , d = c.length > 1;
                    if (d || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()),
                    l.__version = i.version,
                    o.memory.textures++),
                    h) {
                        a.__webglFramebuffer = [];
                        for (let t = 0; t < 6; t++)
                            if (i.mipmaps && i.mipmaps.length > 0) {
                                a.__webglFramebuffer[t] = [];
                                for (let n = 0; n < i.mipmaps.length; n++)
                                    a.__webglFramebuffer[t][n] = e.createFramebuffer()
                            } else
                                a.__webglFramebuffer[t] = e.createFramebuffer()
                    } else {
                        if (i.mipmaps && i.mipmaps.length > 0) {
                            a.__webglFramebuffer = [];
                            for (let t = 0; t < i.mipmaps.length; t++)
                                a.__webglFramebuffer[t] = e.createFramebuffer()
                        } else
                            a.__webglFramebuffer = e.createFramebuffer();
                        if (d)
                            for (let t = 0, n = c.length; t < n; t++) {
                                const n = r.get(c[t]);
                                void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(),
                                o.memory.textures++)
                            }
                        if (t.samples > 0 && !1 === W(t)) {
                            a.__webglMultisampledFramebuffer = e.createFramebuffer(),
                            a.__webglColorRenderbuffer = [],
                            n.bindFramebuffer(e.FRAMEBUFFER, a.__webglMultisampledFramebuffer);
                            for (let n = 0; n < c.length; n++) {
                                const i = c[n];
                                a.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                                e.bindRenderbuffer(e.RENDERBUFFER, a.__webglColorRenderbuffer[n]);
                                const r = s.convert(i.format, i.colorSpace)
                                  , o = s.convert(i.type)
                                  , l = w(i.internalFormat, r, o, i.colorSpace, !0 === t.isXRRenderTarget)
                                  , h = O(t);
                                e.renderbufferStorageMultisample(e.RENDERBUFFER, h, l, t.width, t.height),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, a.__webglColorRenderbuffer[n])
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null),
                            t.depthBuffer && (a.__webglDepthRenderbuffer = e.createRenderbuffer(),
                            U(a.__webglDepthRenderbuffer, t, !0)),
                            n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                    }
                    if (h) {
                        n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
                        P(e.TEXTURE_CUBE_MAP, i);
                        for (let n = 0; n < 6; n++)
                            if (i.mipmaps && i.mipmaps.length > 0)
                                for (let r = 0; r < i.mipmaps.length; r++)
                                    z(a.__webglFramebuffer[n][r], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, r);
                            else
                                z(a.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                        A(i) && v(e.TEXTURE_CUBE_MAP),
                        n.unbindTexture()
                    } else if (d) {
                        for (let i = 0, s = c.length; i < s; i++) {
                            const s = c[i]
                              , o = r.get(s);
                            let l = e.TEXTURE_2D;
                            (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (l = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                            n.bindTexture(l, o.__webglTexture),
                            P(l, s),
                            z(a.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + i, l, 0),
                            A(s) && v(l)
                        }
                        n.unbindTexture()
                    } else {
                        let r = e.TEXTURE_2D;
                        if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (r = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                        n.bindTexture(r, l.__webglTexture),
                        P(r, i),
                        i.mipmaps && i.mipmaps.length > 0)
                            for (let n = 0; n < i.mipmaps.length; n++)
                                z(a.__webglFramebuffer[n], t, i, e.COLOR_ATTACHMENT0, r, n);
                        else
                            z(a.__webglFramebuffer, t, i, e.COLOR_ATTACHMENT0, r, 0);
                        A(i) && v(r),
                        n.unbindTexture()
                    }
                    t.depthBuffer && B(t)
                }
                ,
                this.updateRenderTargetMipmap = function(e) {
                    const t = e.textures;
                    for (let i = 0, a = t.length; i < a; i++) {
                        const a = t[i];
                        if (A(a)) {
                            const t = y(e)
                              , i = r.get(a).__webglTexture;
                            n.bindTexture(t, i),
                            v(t),
                            n.unbindTexture()
                        }
                    }
                }
                ,
                this.updateMultisampleRenderTarget = function(t) {
                    if (t.samples > 0)
                        if (!1 === W(t)) {
                            const i = t.textures
                              , a = t.width
                              , s = t.height;
                            let o = e.COLOR_BUFFER_BIT;
                            const l = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , h = r.get(t)
                              , d = i.length > 1;
                            if (d)
                                for (let t = 0; t < i.length; t++)
                                    n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                                    n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                            n.bindFramebuffer(e.READ_FRAMEBUFFER, h.__webglMultisampledFramebuffer);
                            const u = t.texture.mipmaps;
                            u && u.length > 0 ? n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer[0]) : n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
                            for (let n = 0; n < i.length; n++) {
                                if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                                t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                                d) {
                                    e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, h.__webglColorRenderbuffer[n]);
                                    const t = r.get(i[n]).__webglTexture;
                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                                }
                                e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, e.NEAREST),
                                !0 === c && (G.length = 0,
                                F.length = 0,
                                G.push(e.COLOR_ATTACHMENT0 + n),
                                t.depthBuffer && !1 === t.resolveDepthBuffer && (G.push(l),
                                F.push(l),
                                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, F)),
                                e.invalidateFramebuffer(e.READ_FRAMEBUFFER, G))
                            }
                            if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                            d)
                                for (let t = 0; t < i.length; t++) {
                                    n.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer),
                                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, h.__webglColorRenderbuffer[t]);
                                    const a = r.get(i[t]).__webglTexture;
                                    n.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                                    e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, a, 0)
                                }
                            n.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglMultisampledFramebuffer)
                        } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && c) {
                            const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                            e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                        }
                }
                ,
                this.setupDepthRenderbuffer = B,
                this.setupFrameBufferTexture = z,
                this.useMultisampledRTT = W,
                this.isReversedDepthBuffer = function() {
                    return n.buffers.depth.getReversed()
                }
            }
            function Wt(e, t) {
                return {
                    convert: function(n, r=i.jf0) {
                        let a;
                        const s = i.ppV.getTransfer(r);
                        if (n === i.OUM)
                            return e.UNSIGNED_BYTE;
                        if (n === i.Wew)
                            return e.UNSIGNED_SHORT_4_4_4_4;
                        if (n === i.gJ2)
                            return e.UNSIGNED_SHORT_5_5_5_1;
                        if (n === i.Dmk)
                            return e.UNSIGNED_INT_5_9_9_9_REV;
                        if (n === i.yT7)
                            return e.UNSIGNED_INT_10F_11F_11F_REV;
                        if (n === i.tJf)
                            return e.BYTE;
                        if (n === i.fBL)
                            return e.SHORT;
                        if (n === i.cHt)
                            return e.UNSIGNED_SHORT;
                        if (n === i.Yuy)
                            return e.INT;
                        if (n === i.bkx)
                            return e.UNSIGNED_INT;
                        if (n === i.RQf)
                            return e.FLOAT;
                        if (n === i.ix0)
                            return e.HALF_FLOAT;
                        if (n === i.wrO)
                            return e.ALPHA;
                        if (n === i.HIg)
                            return e.RGB;
                        if (n === i.GWd)
                            return e.RGBA;
                        if (n === i.zdS)
                            return e.DEPTH_COMPONENT;
                        if (n === i.dcC)
                            return e.DEPTH_STENCIL;
                        if (n === i.VT0)
                            return e.RED;
                        if (n === i.ZQM)
                            return e.RED_INTEGER;
                        if (n === i.paN)
                            return e.RG;
                        if (n === i.TkQ)
                            return e.RG_INTEGER;
                        if (n === i.c90)
                            return e.RGBA_INTEGER;
                        if (n === i.IE4 || n === i.Nz6 || n === i.jR7 || n === i.BXX)
                            if (s === i.KLL) {
                                if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                                null === a)
                                    return null;
                                if (n === i.IE4)
                                    return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === i.Nz6)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === i.jR7)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === i.BXX)
                                    return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (a = t.get("WEBGL_compressed_texture_s3tc"),
                                null === a)
                                    return null;
                                if (n === i.IE4)
                                    return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === i.Nz6)
                                    return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === i.jR7)
                                    return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === i.BXX)
                                    return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            }
                        if (n === i.k6Q || n === i.kTp || n === i.HXV || n === i.pBf) {
                            if (a = t.get("WEBGL_compressed_texture_pvrtc"),
                            null === a)
                                return null;
                            if (n === i.k6Q)
                                return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === i.kTp)
                                return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === i.HXV)
                                return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === i.pBf)
                                return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (n === i.CVz || n === i.Riy || n === i.KDk || n === i.BVL || n === i.gZr || n === i.OtU || n === i.jSS) {
                            if (a = t.get("WEBGL_compressed_texture_etc"),
                            null === a)
                                return null;
                            if (n === i.CVz || n === i.Riy)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
                            if (n === i.KDk)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
                            if (n === i.BVL)
                                return a.COMPRESSED_R11_EAC;
                            if (n === i.gZr)
                                return a.COMPRESSED_SIGNED_R11_EAC;
                            if (n === i.OtU)
                                return a.COMPRESSED_RG11_EAC;
                            if (n === i.jSS)
                                return a.COMPRESSED_SIGNED_RG11_EAC
                        }
                        if (n === i.qa3 || n === i.B_h || n === i.czI || n === i.rSH || n === i.Qrf || n === i.psI || n === i.a5J || n === i._QJ || n === i.uB5 || n === i.lyL || n === i.bC7 || n === i.y3Z || n === i.ojs || n === i.S$4) {
                            if (a = t.get("WEBGL_compressed_texture_astc"),
                            null === a)
                                return null;
                            if (n === i.qa3)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === i.B_h)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === i.czI)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === i.rSH)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === i.Qrf)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === i.psI)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === i.a5J)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === i._QJ)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === i.uB5)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === i.lyL)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === i.bC7)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === i.y3Z)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === i.ojs)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === i.S$4)
                                return s === i.KLL ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === i.Fn || n === i.H23 || n === i.W9U) {
                            if (a = t.get("EXT_texture_compression_bptc"),
                            null === a)
                                return null;
                            if (n === i.Fn)
                                return s === i.KLL ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            if (n === i.H23)
                                return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                            if (n === i.W9U)
                                return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                        }
                        if (n === i.Kef || n === i.XG_ || n === i.HO_ || n === i.CWW) {
                            if (a = t.get("EXT_texture_compression_rgtc"),
                            null === a)
                                return null;
                            if (n === i.Kef)
                                return a.COMPRESSED_RED_RGTC1_EXT;
                            if (n === i.XG_)
                                return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (n === i.HO_)
                                return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (n === i.CWW)
                                return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return n === i.V3x ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            class Vt {
                constructor() {
                    this.texture = null,
                    this.mesh = null,
                    this.depthNear = 0,
                    this.depthFar = 0
                }
                init(e, t) {
                    if (null === this.texture) {
                        const n = new i.rjZ(e.texture);
                        e.depthNear === t.depthNear && e.depthFar === t.depthFar || (this.depthNear = e.depthNear,
                        this.depthFar = e.depthFar),
                        this.texture = n
                    }
                }
                getMesh(e) {
                    if (null !== this.texture && null === this.mesh) {
                        const t = e.cameras[0].viewport
                          , n = new i.BKk({
                            vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                            fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                            uniforms: {
                                depthColor: {
                                    value: this.texture
                                },
                                depthWidth: {
                                    value: t.z
                                },
                                depthHeight: {
                                    value: t.w
                                }
                            }
                        });
                        this.mesh = new i.eaF(new i.bdM(20,20),n)
                    }
                    return this.mesh
                }
                reset() {
                    this.texture = null,
                    this.mesh = null
                }
                getDepthTexture() {
                    return this.texture
                }
            }
            class Ht extends i.Qev {
                constructor(e, t) {
                    super();
                    const n = this;
                    let a = null
                      , s = 1
                      , o = null
                      , l = "local-floor"
                      , c = 1
                      , h = null
                      , d = null
                      , u = null
                      , p = null
                      , f = null
                      , g = null;
                    const m = "undefined" != typeof XRWebGLBinding
                      , A = new Vt
                      , v = {}
                      , y = t.getContextAttributes();
                    let w = null
                      , b = null;
                    const x = []
                      , S = []
                      , E = new i.I9Y;
                    let T = null;
                    const k = new i.ubm;
                    k.viewport = new i.IUQ;
                    const M = new i.ubm;
                    M.viewport = new i.IUQ;
                    const _ = [k, M]
                      , C = new i.nZQ;
                    let R = null
                      , P = null;
                    function I(e) {
                        const t = S.indexOf(e.inputSource);
                        if (-1 === t)
                            return;
                        const n = x[t];
                        void 0 !== n && (n.update(e.inputSource, e.frame, h || o),
                        n.dispatchEvent({
                            type: e.type,
                            data: e.inputSource
                        }))
                    }
                    function L() {
                        a.removeEventListener("select", I),
                        a.removeEventListener("selectstart", I),
                        a.removeEventListener("selectend", I),
                        a.removeEventListener("squeeze", I),
                        a.removeEventListener("squeezestart", I),
                        a.removeEventListener("squeezeend", I),
                        a.removeEventListener("end", L),
                        a.removeEventListener("inputsourceschange", N);
                        for (let e = 0; e < x.length; e++) {
                            const t = S[e];
                            null !== t && (S[e] = null,
                            x[e].disconnect(t))
                        }
                        R = null,
                        P = null,
                        A.reset();
                        for (const e in v)
                            delete v[e];
                        e.setRenderTarget(w),
                        f = null,
                        p = null,
                        u = null,
                        a = null,
                        b = null,
                        G.stop(),
                        n.isPresenting = !1,
                        e.setPixelRatio(T),
                        e.setSize(E.width, E.height, !1),
                        n.dispatchEvent({
                            type: "sessionend"
                        })
                    }
                    function N(e) {
                        for (let t = 0; t < e.removed.length; t++) {
                            const n = e.removed[t]
                              , i = S.indexOf(n);
                            i >= 0 && (S[i] = null,
                            x[i].disconnect(n))
                        }
                        for (let t = 0; t < e.added.length; t++) {
                            const n = e.added[t];
                            let i = S.indexOf(n);
                            if (-1 === i) {
                                for (let e = 0; e < x.length; e++) {
                                    if (e >= S.length) {
                                        S.push(n),
                                        i = e;
                                        break
                                    }
                                    if (null === S[e]) {
                                        S[e] = n,
                                        i = e;
                                        break
                                    }
                                }
                                if (-1 === i)
                                    break
                            }
                            const r = x[i];
                            r && r.connect(n)
                        }
                    }
                    this.cameraAutoUpdate = !0,
                    this.enabled = !1,
                    this.isPresenting = !1,
                    this.getController = function(e) {
                        let t = x[e];
                        return void 0 === t && (t = new i.R3r,
                        x[e] = t),
                        t.getTargetRaySpace()
                    }
                    ,
                    this.getControllerGrip = function(e) {
                        let t = x[e];
                        return void 0 === t && (t = new i.R3r,
                        x[e] = t),
                        t.getGripSpace()
                    }
                    ,
                    this.getHand = function(e) {
                        let t = x[e];
                        return void 0 === t && (t = new i.R3r,
                        x[e] = t),
                        t.getHandSpace()
                    }
                    ,
                    this.setFramebufferScaleFactor = function(e) {
                        s = e,
                        !0 === n.isPresenting && (0,
                        i.R8M)("WebXRManager: Cannot change framebuffer scale while presenting.")
                    }
                    ,
                    this.setReferenceSpaceType = function(e) {
                        l = e,
                        !0 === n.isPresenting && (0,
                        i.R8M)("WebXRManager: Cannot change reference space type while presenting.")
                    }
                    ,
                    this.getReferenceSpace = function() {
                        return h || o
                    }
                    ,
                    this.setReferenceSpace = function(e) {
                        h = e
                    }
                    ,
                    this.getBaseLayer = function() {
                        return null !== p ? p : f
                    }
                    ,
                    this.getBinding = function() {
                        return null === u && m && (u = new XRWebGLBinding(a,t)),
                        u
                    }
                    ,
                    this.getFrame = function() {
                        return g
                    }
                    ,
                    this.getSession = function() {
                        return a
                    }
                    ,
                    this.setSession = async function(r) {
                        if (a = r,
                        null !== a) {
                            w = e.getRenderTarget(),
                            a.addEventListener("select", I),
                            a.addEventListener("selectstart", I),
                            a.addEventListener("selectend", I),
                            a.addEventListener("squeeze", I),
                            a.addEventListener("squeezestart", I),
                            a.addEventListener("squeezeend", I),
                            a.addEventListener("end", L),
                            a.addEventListener("inputsourceschange", N),
                            !0 !== y.xrCompatible && await t.makeXRCompatible(),
                            T = e.getPixelRatio(),
                            e.getSize(E);
                            if (m && "createProjectionLayer"in XRWebGLBinding.prototype) {
                                let n = null
                                  , r = null
                                  , o = null;
                                y.depth && (o = y.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                                n = y.stencil ? i.dcC : i.zdS,
                                r = y.stencil ? i.V3x : i.bkx);
                                const l = {
                                    colorFormat: t.RGBA8,
                                    depthFormat: o,
                                    scaleFactor: s
                                };
                                u = this.getBinding(),
                                p = u.createProjectionLayer(l),
                                a.updateRenderState({
                                    layers: [p]
                                }),
                                e.setPixelRatio(1),
                                e.setSize(p.textureWidth, p.textureHeight, !1),
                                b = new i.nWS(p.textureWidth,p.textureHeight,{
                                    format: i.GWd,
                                    type: i.OUM,
                                    depthTexture: new i.VCu(p.textureWidth,p.textureHeight,r,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                    stencilBuffer: y.stencil,
                                    colorSpace: e.outputColorSpace,
                                    samples: y.antialias ? 4 : 0,
                                    resolveDepthBuffer: !1 === p.ignoreDepthValues,
                                    resolveStencilBuffer: !1 === p.ignoreDepthValues
                                })
                            } else {
                                const n = {
                                    antialias: y.antialias,
                                    alpha: !0,
                                    depth: y.depth,
                                    stencil: y.stencil,
                                    framebufferScaleFactor: s
                                };
                                f = new XRWebGLLayer(a,t,n),
                                a.updateRenderState({
                                    baseLayer: f
                                }),
                                e.setPixelRatio(1),
                                e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                                b = new i.nWS(f.framebufferWidth,f.framebufferHeight,{
                                    format: i.GWd,
                                    type: i.OUM,
                                    colorSpace: e.outputColorSpace,
                                    stencilBuffer: y.stencil,
                                    resolveDepthBuffer: !1 === f.ignoreDepthValues,
                                    resolveStencilBuffer: !1 === f.ignoreDepthValues
                                })
                            }
                            b.isXRRenderTarget = !0,
                            this.setFoveation(c),
                            h = null,
                            o = await a.requestReferenceSpace(l),
                            G.setContext(a),
                            G.start(),
                            n.isPresenting = !0,
                            n.dispatchEvent({
                                type: "sessionstart"
                            })
                        }
                    }
                    ,
                    this.getEnvironmentBlendMode = function() {
                        if (null !== a)
                            return a.environmentBlendMode
                    }
                    ,
                    this.getDepthTexture = function() {
                        return A.getDepthTexture()
                    }
                    ;
                    const z = new i.Pq0
                      , U = new i.Pq0;
                    function D(e, t) {
                        null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert()
                    }
                    this.updateCamera = function(e) {
                        if (null === a)
                            return;
                        let t = e.near
                          , n = e.far;
                        null !== A.texture && (A.depthNear > 0 && (t = A.depthNear),
                        A.depthFar > 0 && (n = A.depthFar)),
                        C.near = M.near = k.near = t,
                        C.far = M.far = k.far = n,
                        R === C.near && P === C.far || (a.updateRenderState({
                            depthNear: C.near,
                            depthFar: C.far
                        }),
                        R = C.near,
                        P = C.far),
                        C.layers.mask = 6 | e.layers.mask,
                        k.layers.mask = 3 & C.layers.mask,
                        M.layers.mask = 5 & C.layers.mask;
                        const r = e.parent
                          , s = C.cameras;
                        D(C, r);
                        for (let e = 0; e < s.length; e++)
                            D(s[e], r);
                        2 === s.length ? function(e, t, n) {
                            z.setFromMatrixPosition(t.matrixWorld),
                            U.setFromMatrixPosition(n.matrixWorld);
                            const i = z.distanceTo(U)
                              , r = t.projectionMatrix.elements
                              , a = n.projectionMatrix.elements
                              , s = r[14] / (r[10] - 1)
                              , o = r[14] / (r[10] + 1)
                              , l = (r[9] + 1) / r[5]
                              , c = (r[9] - 1) / r[5]
                              , h = (r[8] - 1) / r[0]
                              , d = (a[8] + 1) / a[0]
                              , u = s * h
                              , p = s * d
                              , f = i / (-h + d)
                              , g = f * -h;
                            if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                            e.translateX(g),
                            e.translateZ(f),
                            e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                            e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                            -1 === r[10])
                                e.projectionMatrix.copy(t.projectionMatrix),
                                e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                            else {
                                const t = s + f
                                  , n = o + f
                                  , r = u - g
                                  , a = p + (i - g)
                                  , h = l * o / n * t
                                  , d = c * o / n * t;
                                e.projectionMatrix.makePerspective(r, a, h, d, t, n),
                                e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                            }
                        }(C, k, M) : C.projectionMatrix.copy(k.projectionMatrix),
                        function(e, t, n) {
                            null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                            e.matrix.invert(),
                            e.matrix.multiply(t.matrixWorld));
                            e.matrix.decompose(e.position, e.quaternion, e.scale),
                            e.updateMatrixWorld(!0),
                            e.projectionMatrix.copy(t.projectionMatrix),
                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                            e.isPerspectiveCamera && (e.fov = 2 * i.a55 * Math.atan(1 / e.projectionMatrix.elements[5]),
                            e.zoom = 1)
                        }(e, C, r)
                    }
                    ,
                    this.getCamera = function() {
                        return C
                    }
                    ,
                    this.getFoveation = function() {
                        if (null !== p || null !== f)
                            return c
                    }
                    ,
                    this.setFoveation = function(e) {
                        c = e,
                        null !== p && (p.fixedFoveation = e),
                        null !== f && void 0 !== f.fixedFoveation && (f.fixedFoveation = e)
                    }
                    ,
                    this.hasDepthSensing = function() {
                        return null !== A.texture
                    }
                    ,
                    this.getDepthSensingMesh = function() {
                        return A.getMesh(C)
                    }
                    ,
                    this.getCameraTexture = function(e) {
                        return v[e]
                    }
                    ;
                    let B = null;
                    const G = new r;
                    G.setAnimationLoop((function(t, r) {
                        if (d = r.getViewerPose(h || o),
                        g = r,
                        null !== d) {
                            const t = d.views;
                            null !== f && (e.setRenderTargetFramebuffer(b, f.framebuffer),
                            e.setRenderTarget(b));
                            let r = !1;
                            t.length !== C.cameras.length && (C.cameras.length = 0,
                            r = !0);
                            for (let n = 0; n < t.length; n++) {
                                const a = t[n];
                                let s = null;
                                if (null !== f)
                                    s = f.getViewport(a);
                                else {
                                    const t = u.getViewSubImage(p, a);
                                    s = t.viewport,
                                    0 === n && (e.setRenderTargetTextures(b, t.colorTexture, t.depthStencilTexture),
                                    e.setRenderTarget(b))
                                }
                                let o = _[n];
                                void 0 === o && (o = new i.ubm,
                                o.layers.enable(n),
                                o.viewport = new i.IUQ,
                                _[n] = o),
                                o.matrix.fromArray(a.transform.matrix),
                                o.matrix.decompose(o.position, o.quaternion, o.scale),
                                o.projectionMatrix.fromArray(a.projectionMatrix),
                                o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                                o.viewport.set(s.x, s.y, s.width, s.height),
                                0 === n && (C.matrix.copy(o.matrix),
                                C.matrix.decompose(C.position, C.quaternion, C.scale)),
                                !0 === r && C.cameras.push(o)
                            }
                            const s = a.enabledFeatures;
                            if (s && s.includes("depth-sensing") && "gpu-optimized" == a.depthUsage && m) {
                                u = n.getBinding();
                                const e = u.getDepthInformation(t[0]);
                                e && e.isValid && e.texture && A.init(e, a.renderState)
                            }
                            if (s && s.includes("camera-access") && m) {
                                e.state.unbindTexture(),
                                u = n.getBinding();
                                for (let e = 0; e < t.length; e++) {
                                    const n = t[e].camera;
                                    if (n) {
                                        let e = v[n];
                                        e || (e = new i.rjZ,
                                        v[n] = e);
                                        const t = u.getCameraImage(n);
                                        e.sourceTexture = t
                                    }
                                }
                            }
                        }
                        for (let e = 0; e < x.length; e++) {
                            const t = S[e]
                              , n = x[e];
                            null !== t && void 0 !== n && n.update(t, r, h || o)
                        }
                        B && B(t, r),
                        r.detectedPlanes && n.dispatchEvent({
                            type: "planesdetected",
                            data: r
                        }),
                        g = null
                    }
                    )),
                    this.setAnimationLoop = function(e) {
                        B = e
                    }
                    ,
                    this.dispose = function() {}
                }
            }
            const jt = new i.O9p
              , Kt = new i.kn4;
            function qt(e, t) {
                function n(e, t) {
                    !0 === e.matrixAutoUpdate && e.updateMatrix(),
                    t.value.copy(e.matrix)
                }
                function r(e, r) {
                    e.opacity.value = r.opacity,
                    r.color && e.diffuse.value.copy(r.color),
                    r.emissive && e.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
                    r.map && (e.map.value = r.map,
                    n(r.map, e.mapTransform)),
                    r.alphaMap && (e.alphaMap.value = r.alphaMap,
                    n(r.alphaMap, e.alphaMapTransform)),
                    r.bumpMap && (e.bumpMap.value = r.bumpMap,
                    n(r.bumpMap, e.bumpMapTransform),
                    e.bumpScale.value = r.bumpScale,
                    r.side === i.hsX && (e.bumpScale.value *= -1)),
                    r.normalMap && (e.normalMap.value = r.normalMap,
                    n(r.normalMap, e.normalMapTransform),
                    e.normalScale.value.copy(r.normalScale),
                    r.side === i.hsX && e.normalScale.value.negate()),
                    r.displacementMap && (e.displacementMap.value = r.displacementMap,
                    n(r.displacementMap, e.displacementMapTransform),
                    e.displacementScale.value = r.displacementScale,
                    e.displacementBias.value = r.displacementBias),
                    r.emissiveMap && (e.emissiveMap.value = r.emissiveMap,
                    n(r.emissiveMap, e.emissiveMapTransform)),
                    r.specularMap && (e.specularMap.value = r.specularMap,
                    n(r.specularMap, e.specularMapTransform)),
                    r.alphaTest > 0 && (e.alphaTest.value = r.alphaTest);
                    const a = t.get(r)
                      , s = a.envMap
                      , o = a.envMapRotation;
                    s && (e.envMap.value = s,
                    jt.copy(o),
                    jt.x *= -1,
                    jt.y *= -1,
                    jt.z *= -1,
                    s.isCubeTexture && !1 === s.isRenderTargetTexture && (jt.y *= -1,
                    jt.z *= -1),
                    e.envMapRotation.value.setFromMatrix4(Kt.makeRotationFromEuler(jt)),
                    e.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1,
                    e.reflectivity.value = r.reflectivity,
                    e.ior.value = r.ior,
                    e.refractionRatio.value = r.refractionRatio),
                    r.lightMap && (e.lightMap.value = r.lightMap,
                    e.lightMapIntensity.value = r.lightMapIntensity,
                    n(r.lightMap, e.lightMapTransform)),
                    r.aoMap && (e.aoMap.value = r.aoMap,
                    e.aoMapIntensity.value = r.aoMapIntensity,
                    n(r.aoMap, e.aoMapTransform))
                }
                return {
                    refreshFogUniforms: function(t, n) {
                        n.color.getRGB(t.fogColor.value, (0,
                        i._Ut)(e)),
                        n.isFog ? (t.fogNear.value = n.near,
                        t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function(e, a, s, o, l) {
                        a.isMeshBasicMaterial || a.isMeshLambertMaterial ? r(e, a) : a.isMeshToonMaterial ? (r(e, a),
                        function(e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap)
                        }(e, a)) : a.isMeshPhongMaterial ? (r(e, a),
                        function(e, t) {
                            e.specular.value.copy(t.specular),
                            e.shininess.value = Math.max(t.shininess, 1e-4)
                        }(e, a)) : a.isMeshStandardMaterial ? (r(e, a),
                        function(e, t) {
                            e.metalness.value = t.metalness,
                            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap,
                            n(t.metalnessMap, e.metalnessMapTransform));
                            e.roughness.value = t.roughness,
                            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap,
                            n(t.roughnessMap, e.roughnessMapTransform));
                            t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                        }(e, a),
                        a.isMeshPhysicalMaterial && function(e, t, r) {
                            e.ior.value = t.ior,
                            t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                            e.sheenRoughness.value = t.sheenRoughness,
                            t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                            n(t.sheenColorMap, e.sheenColorMapTransform)),
                            t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                            n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                            t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                            e.clearcoatRoughness.value = t.clearcoatRoughness,
                            t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                            n(t.clearcoatMap, e.clearcoatMapTransform)),
                            t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                            n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                            t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                            n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                            e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                            t.side === i.hsX && e.clearcoatNormalScale.value.negate()));
                            t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                            t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                            e.iridescenceIOR.value = t.iridescenceIOR,
                            e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                            e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                            t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                            n(t.iridescenceMap, e.iridescenceMapTransform)),
                            t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                            n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                            t.transmission > 0 && (e.transmission.value = t.transmission,
                            e.transmissionSamplerMap.value = r.texture,
                            e.transmissionSamplerSize.value.set(r.width, r.height),
                            t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                            n(t.transmissionMap, e.transmissionMapTransform)),
                            e.thickness.value = t.thickness,
                            t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                            n(t.thicknessMap, e.thicknessMapTransform)),
                            e.attenuationDistance.value = t.attenuationDistance,
                            e.attenuationColor.value.copy(t.attenuationColor));
                            t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                            t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                            n(t.anisotropyMap, e.anisotropyMapTransform)));
                            e.specularIntensity.value = t.specularIntensity,
                            e.specularColor.value.copy(t.specularColor),
                            t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                            n(t.specularColorMap, e.specularColorMapTransform));
                            t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                            n(t.specularIntensityMap, e.specularIntensityMapTransform))
                        }(e, a, l)) : a.isMeshMatcapMaterial ? (r(e, a),
                        function(e, t) {
                            t.matcap && (e.matcap.value = t.matcap)
                        }(e, a)) : a.isMeshDepthMaterial ? r(e, a) : a.isMeshDistanceMaterial ? (r(e, a),
                        function(e, n) {
                            const i = t.get(n).light;
                            e.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                            e.nearDistance.value = i.shadow.camera.near,
                            e.farDistance.value = i.shadow.camera.far
                        }(e, a)) : a.isMeshNormalMaterial ? r(e, a) : a.isLineBasicMaterial ? (function(e, t) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.mapTransform))
                        }(e, a),
                        a.isLineDashedMaterial && function(e, t) {
                            e.dashSize.value = t.dashSize,
                            e.totalSize.value = t.dashSize + t.gapSize,
                            e.scale.value = t.scale
                        }(e, a)) : a.isPointsMaterial ? function(e, t, i, r) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            e.size.value = t.size * i,
                            e.scale.value = .5 * r,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.uvTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap,
                            n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, a, s, o) : a.isSpriteMaterial ? function(e, t) {
                            e.diffuse.value.copy(t.color),
                            e.opacity.value = t.opacity,
                            e.rotation.value = t.rotation,
                            t.map && (e.map.value = t.map,
                            n(t.map, e.mapTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap,
                            n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, a) : a.isShadowMaterial ? (e.color.value.copy(a.color),
                        e.opacity.value = a.opacity) : a.isShaderMaterial && (a.uniformsNeedUpdate = !1)
                    }
                }
            }
            function Qt(e, t, n, r) {
                let a = {}
                  , s = {}
                  , o = [];
                const l = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
                function c(e, t, n, i) {
                    const r = e.value
                      , a = t + "_" + n;
                    if (void 0 === i[a])
                        return i[a] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
                        !0;
                    {
                        const e = i[a];
                        if ("number" == typeof r || "boolean" == typeof r) {
                            if (e !== r)
                                return i[a] = r,
                                !0
                        } else if (!1 === e.equals(r))
                            return e.copy(r),
                            !0
                    }
                    return !1
                }
                function h(e) {
                    const t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                    t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                    t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                    t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                    t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                    t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                    t.storage = 64) : e.isTexture ? (0,
                    i.R8M)("WebGLRenderer: Texture samplers can not be part of an uniforms group.") : (0,
                    i.R8M)("WebGLRenderer: Unsupported uniform value type.", e),
                    t
                }
                function d(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", d);
                    const i = o.indexOf(n.__bindingPointIndex);
                    o.splice(i, 1),
                    e.deleteBuffer(a[n.id]),
                    delete a[n.id],
                    delete s[n.id]
                }
                return {
                    bind: function(e, t) {
                        const n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function(n, u) {
                        let p = a[n.id];
                        void 0 === p && (!function(e) {
                            const t = e.uniforms;
                            let n = 0;
                            const i = 16;
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                                for (let e = 0, t = r.length; e < t; e++) {
                                    const t = r[e]
                                      , a = Array.isArray(t.value) ? t.value : [t.value];
                                    for (let e = 0, r = a.length; e < r; e++) {
                                        const r = h(a[e])
                                          , s = n % i
                                          , o = s % r.boundary
                                          , l = s + o;
                                        n += o,
                                        0 !== l && i - l < r.storage && (n += i - l),
                                        t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT),
                                        t.__offset = n,
                                        n += r.storage
                                    }
                                }
                            }
                            const r = n % i;
                            r > 0 && (n += i - r);
                            e.__size = n,
                            e.__cache = {}
                        }(n),
                        p = function(t) {
                            const n = function() {
                                for (let e = 0; e < l; e++)
                                    if (-1 === o.indexOf(e))
                                        return o.push(e),
                                        e;
                                return (0,
                                i.z3S)("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                                0
                            }();
                            t.__bindingPointIndex = n;
                            const r = e.createBuffer()
                              , a = t.__size
                              , s = t.usage;
                            return e.bindBuffer(e.UNIFORM_BUFFER, r),
                            e.bufferData(e.UNIFORM_BUFFER, a, s),
                            e.bindBuffer(e.UNIFORM_BUFFER, null),
                            e.bindBufferBase(e.UNIFORM_BUFFER, n, r),
                            r
                        }(n),
                        a[n.id] = p,
                        n.addEventListener("dispose", d));
                        const f = u.program;
                        r.updateUBOMapping(n, f);
                        const g = t.render.frame;
                        s[n.id] !== g && (!function(t) {
                            const n = a[t.id]
                              , i = t.uniforms
                              , r = t.__cache;
                            e.bindBuffer(e.UNIFORM_BUFFER, n);
                            for (let t = 0, n = i.length; t < n; t++) {
                                const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                                for (let i = 0, a = n.length; i < a; i++) {
                                    const a = n[i];
                                    if (!0 === c(a, t, i, r)) {
                                        const t = a.__offset
                                          , n = Array.isArray(a.value) ? a.value : [a.value];
                                        let i = 0;
                                        for (let r = 0; r < n.length; r++) {
                                            const s = n[r]
                                              , o = h(s);
                                            "number" == typeof s || "boolean" == typeof s ? (a.__data[0] = s,
                                            e.bufferSubData(e.UNIFORM_BUFFER, t + i, a.__data)) : s.isMatrix3 ? (a.__data[0] = s.elements[0],
                                            a.__data[1] = s.elements[1],
                                            a.__data[2] = s.elements[2],
                                            a.__data[3] = 0,
                                            a.__data[4] = s.elements[3],
                                            a.__data[5] = s.elements[4],
                                            a.__data[6] = s.elements[5],
                                            a.__data[7] = 0,
                                            a.__data[8] = s.elements[6],
                                            a.__data[9] = s.elements[7],
                                            a.__data[10] = s.elements[8],
                                            a.__data[11] = 0) : (s.toArray(a.__data, i),
                                            i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                        }
                                        e.bufferSubData(e.UNIFORM_BUFFER, t, a.__data)
                                    }
                                }
                            }
                            e.bindBuffer(e.UNIFORM_BUFFER, null)
                        }(n),
                        s[n.id] = g)
                    },
                    dispose: function() {
                        for (const t in a)
                            e.deleteBuffer(a[t]);
                        o = [],
                        a = {},
                        s = {}
                    }
                }
            }
            const Jt = new Uint16Array([12469, 15057, 12620, 14925, 13266, 14620, 13807, 14376, 14323, 13990, 14545, 13625, 14713, 13328, 14840, 12882, 14931, 12528, 14996, 12233, 15039, 11829, 15066, 11525, 15080, 11295, 15085, 10976, 15082, 10705, 15073, 10495, 13880, 14564, 13898, 14542, 13977, 14430, 14158, 14124, 14393, 13732, 14556, 13410, 14702, 12996, 14814, 12596, 14891, 12291, 14937, 11834, 14957, 11489, 14958, 11194, 14943, 10803, 14921, 10506, 14893, 10278, 14858, 9960, 14484, 14039, 14487, 14025, 14499, 13941, 14524, 13740, 14574, 13468, 14654, 13106, 14743, 12678, 14818, 12344, 14867, 11893, 14889, 11509, 14893, 11180, 14881, 10751, 14852, 10428, 14812, 10128, 14765, 9754, 14712, 9466, 14764, 13480, 14764, 13475, 14766, 13440, 14766, 13347, 14769, 13070, 14786, 12713, 14816, 12387, 14844, 11957, 14860, 11549, 14868, 11215, 14855, 10751, 14825, 10403, 14782, 10044, 14729, 9651, 14666, 9352, 14599, 9029, 14967, 12835, 14966, 12831, 14963, 12804, 14954, 12723, 14936, 12564, 14917, 12347, 14900, 11958, 14886, 11569, 14878, 11247, 14859, 10765, 14828, 10401, 14784, 10011, 14727, 9600, 14660, 9289, 14586, 8893, 14508, 8533, 15111, 12234, 15110, 12234, 15104, 12216, 15092, 12156, 15067, 12010, 15028, 11776, 14981, 11500, 14942, 11205, 14902, 10752, 14861, 10393, 14812, 9991, 14752, 9570, 14682, 9252, 14603, 8808, 14519, 8445, 14431, 8145, 15209, 11449, 15208, 11451, 15202, 11451, 15190, 11438, 15163, 11384, 15117, 11274, 15055, 10979, 14994, 10648, 14932, 10343, 14871, 9936, 14803, 9532, 14729, 9218, 14645, 8742, 14556, 8381, 14461, 8020, 14365, 7603, 15273, 10603, 15272, 10607, 15267, 10619, 15256, 10631, 15231, 10614, 15182, 10535, 15118, 10389, 15042, 10167, 14963, 9787, 14883, 9447, 14800, 9115, 14710, 8665, 14615, 8318, 14514, 7911, 14411, 7507, 14279, 7198, 15314, 9675, 15313, 9683, 15309, 9712, 15298, 9759, 15277, 9797, 15229, 9773, 15166, 9668, 15084, 9487, 14995, 9274, 14898, 8910, 14800, 8539, 14697, 8234, 14590, 7790, 14479, 7409, 14367, 7067, 14178, 6621, 15337, 8619, 15337, 8631, 15333, 8677, 15325, 8769, 15305, 8871, 15264, 8940, 15202, 8909, 15119, 8775, 15022, 8565, 14916, 8328, 14804, 8009, 14688, 7614, 14569, 7287, 14448, 6888, 14321, 6483, 14088, 6171, 15350, 7402, 15350, 7419, 15347, 7480, 15340, 7613, 15322, 7804, 15287, 7973, 15229, 8057, 15148, 8012, 15046, 7846, 14933, 7611, 14810, 7357, 14682, 7069, 14552, 6656, 14421, 6316, 14251, 5948, 14007, 5528, 15356, 5942, 15356, 5977, 15353, 6119, 15348, 6294, 15332, 6551, 15302, 6824, 15249, 7044, 15171, 7122, 15070, 7050, 14949, 6861, 14818, 6611, 14679, 6349, 14538, 6067, 14398, 5651, 14189, 5311, 13935, 4958, 15359, 4123, 15359, 4153, 15356, 4296, 15353, 4646, 15338, 5160, 15311, 5508, 15263, 5829, 15188, 6042, 15088, 6094, 14966, 6001, 14826, 5796, 14678, 5543, 14527, 5287, 14377, 4985, 14133, 4586, 13869, 4257, 15360, 1563, 15360, 1642, 15358, 2076, 15354, 2636, 15341, 3350, 15317, 4019, 15273, 4429, 15203, 4732, 15105, 4911, 14981, 4932, 14836, 4818, 14679, 4621, 14517, 4386, 14359, 4156, 14083, 3795, 13808, 3437, 15360, 122, 15360, 137, 15358, 285, 15355, 636, 15344, 1274, 15322, 2177, 15281, 2765, 15215, 3223, 15120, 3451, 14995, 3569, 14846, 3567, 14681, 3466, 14511, 3305, 14344, 3121, 14037, 2800, 13753, 2467, 15360, 0, 15360, 1, 15359, 21, 15355, 89, 15346, 253, 15325, 479, 15287, 796, 15225, 1148, 15133, 1492, 15008, 1749, 14856, 1882, 14685, 1886, 14506, 1783, 14324, 1608, 13996, 1398, 13702, 1183]);
            let Xt = null;
            class Yt {
                constructor(e={}) {
                    const {canvas: t=(0,
                    i.lPF)(), context: n=null, depth: s=!0, stencil: o=!1, alpha: l=!1, antialias: c=!1, premultipliedAlpha: h=!0, preserveDrawingBuffer: d=!1, powerPreference: v="default", failIfMajorPerformanceCaveat: y=!1, reversedDepthBuffer: w=!1, outputBufferType: b=i.OUM} = e;
                    let x;
                    if (this.isWebGLRenderer = !0,
                    null !== n) {
                        if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext)
                            throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                        x = n.getContextAttributes().alpha
                    } else
                        x = l;
                    const S = b
                      , E = new Set([i.c90, i.TkQ, i.ZQM])
                      , T = new Set([i.OUM, i.bkx, i.cHt, i.V3x, i.Wew, i.gJ2])
                      , k = new Uint32Array(4)
                      , M = new Int32Array(4);
                    let _ = null
                      , C = null;
                    const R = []
                      , P = [];
                    let I = null;
                    this.domElement = t,
                    this.debug = {
                        checkShaderErrors: !0,
                        onShaderError: null
                    },
                    this.autoClear = !0,
                    this.autoClearColor = !0,
                    this.autoClearDepth = !0,
                    this.autoClearStencil = !0,
                    this.sortObjects = !0,
                    this.clippingPlanes = [],
                    this.localClippingEnabled = !1,
                    this.toneMapping = i.y_p,
                    this.toneMappingExposure = 1,
                    this.transmissionResolutionScale = 1;
                    const F = this;
                    let W = !1;
                    this._outputColorSpace = i.er$;
                    let V = 0
                      , H = 0
                      , j = null
                      , K = -1
                      , q = null;
                    const Q = new i.IUQ
                      , J = new i.IUQ;
                    let X = null;
                    const Y = new i.Q1f(0);
                    let Z = 0
                      , $ = t.width
                      , ee = t.height
                      , te = 1
                      , ne = null
                      , ie = null;
                    const re = new i.IUQ(0,0,$,ee)
                      , ae = new i.IUQ(0,0,$,ee);
                    let se = !1;
                    const oe = new i.PPD;
                    let le = !1
                      , ce = !1;
                    const he = new i.kn4
                      , de = new i.Pq0
                      , ue = new i.IUQ
                      , pe = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };
                    let fe = !1;
                    function ge() {
                        return null === j ? te : 1
                    }
                    let me, Ae, ve, ye, we, be, xe, Se, Ee, Te, ke, Me, _e, Ce, Re, Pe, Ie, Le, Ne, ze, Ue, De, Be, Ge, Fe = n;
                    function Oe(e, n) {
                        return t.getContext(e, n)
                    }
                    try {
                        const e = {
                            alpha: !0,
                            depth: s,
                            stencil: o,
                            antialias: c,
                            premultipliedAlpha: h,
                            preserveDrawingBuffer: d,
                            powerPreference: v,
                            failIfMajorPerformanceCaveat: y
                        };
                        if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${i.sPf}`),
                        t.addEventListener("webglcontextlost", He, !1),
                        t.addEventListener("webglcontextrestored", je, !1),
                        t.addEventListener("webglcontextcreationerror", qe, !1),
                        null === Fe) {
                            const t = "webgl2";
                            if (Fe = Oe(t, e),
                            null === Fe)
                                throw Oe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                        }
                    } catch (e) {
                        throw (0,
                        i.z3S)("WebGLRenderer: " + e.message),
                        e
                    }
                    function We() {
                        me = new N(Fe),
                        me.init(),
                        De = new Wt(Fe,me),
                        Ae = new g(Fe,me,e,De),
                        ve = new Ft(Fe,me),
                        Ae.reversedDepthBuffer && w && ve.buffers.depth.setReversed(!0),
                        ye = new D(Fe),
                        we = new xt,
                        be = new Ot(Fe,me,ve,we,Ae,De,ye),
                        xe = new A(F),
                        Se = new L(F),
                        Ee = new a(Fe),
                        Be = new p(Fe,Ee),
                        Te = new z(Fe,Ee,ye,Be),
                        ke = new G(Fe,Te,Ee,ye),
                        Ne = new B(Fe,Ae,be),
                        Pe = new m(we),
                        Me = new bt(F,xe,Se,me,Ae,Be,Pe),
                        _e = new qt(F,we),
                        Ce = new kt,
                        Re = new It(me),
                        Le = new u(F,xe,Se,ve,ke,x,h),
                        Ie = new Bt(F,ke,Ae),
                        Ge = new Qt(Fe,ye,Ae,ve),
                        ze = new f(Fe,me,ye),
                        Ue = new U(Fe,me,ye),
                        ye.programs = Me.programs,
                        F.capabilities = Ae,
                        F.extensions = me,
                        F.properties = we,
                        F.renderLists = Ce,
                        F.shadowMap = Ie,
                        F.state = ve,
                        F.info = ye
                    }
                    We(),
                    S !== i.OUM && (I = new O(S,t.width,t.height,s,o));
                    const Ve = new Ht(F,Fe);
                    function He(e) {
                        e.preventDefault(),
                        (0,
                        i.Rm2)("WebGLRenderer: Context Lost."),
                        W = !0
                    }
                    function je() {
                        (0,
                        i.Rm2)("WebGLRenderer: Context Restored."),
                        W = !1;
                        const e = ye.autoReset
                          , t = Ie.enabled
                          , n = Ie.autoUpdate
                          , r = Ie.needsUpdate
                          , a = Ie.type;
                        We(),
                        ye.autoReset = e,
                        Ie.enabled = t,
                        Ie.autoUpdate = n,
                        Ie.needsUpdate = r,
                        Ie.type = a
                    }
                    function qe(e) {
                        (0,
                        i.z3S)("WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                    }
                    function Qe(e) {
                        const t = e.target;
                        t.removeEventListener("dispose", Qe),
                        function(e) {
                            (function(e) {
                                const t = we.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    Me.releaseProgram(e)
                                }
                                )),
                                e.isShaderMaterial && Me.releaseShaderCache(e))
                            }
                            )(e),
                            we.remove(e)
                        }(t)
                    }
                    function Je(e, t, n) {
                        !0 === e.transparent && e.side === i.$EB && !1 === e.forceSinglePass ? (e.side = i.hsX,
                        e.needsUpdate = !0,
                        at(e, t, n),
                        e.side = i.hB5,
                        e.needsUpdate = !0,
                        at(e, t, n),
                        e.side = i.$EB) : at(e, t, n)
                    }
                    this.xr = Ve,
                    this.getContext = function() {
                        return Fe
                    }
                    ,
                    this.getContextAttributes = function() {
                        return Fe.getContextAttributes()
                    }
                    ,
                    this.forceContextLoss = function() {
                        const e = me.get("WEBGL_lose_context");
                        e && e.loseContext()
                    }
                    ,
                    this.forceContextRestore = function() {
                        const e = me.get("WEBGL_lose_context");
                        e && e.restoreContext()
                    }
                    ,
                    this.getPixelRatio = function() {
                        return te
                    }
                    ,
                    this.setPixelRatio = function(e) {
                        void 0 !== e && (te = e,
                        this.setSize($, ee, !1))
                    }
                    ,
                    this.getSize = function(e) {
                        return e.set($, ee)
                    }
                    ,
                    this.setSize = function(e, n, r=!0) {
                        Ve.isPresenting ? (0,
                        i.R8M)("WebGLRenderer: Can't change size while VR device is presenting.") : ($ = e,
                        ee = n,
                        t.width = Math.floor(e * te),
                        t.height = Math.floor(n * te),
                        !0 === r && (t.style.width = e + "px",
                        t.style.height = n + "px"),
                        null !== I && I.setSize(t.width, t.height),
                        this.setViewport(0, 0, e, n))
                    }
                    ,
                    this.getDrawingBufferSize = function(e) {
                        return e.set($ * te, ee * te).floor()
                    }
                    ,
                    this.setDrawingBufferSize = function(e, n, i) {
                        $ = e,
                        ee = n,
                        te = i,
                        t.width = Math.floor(e * i),
                        t.height = Math.floor(n * i),
                        this.setViewport(0, 0, e, n)
                    }
                    ,
                    this.setEffects = function(e) {
                        if (S !== i.OUM) {
                            if (e)
                                for (let t = 0; t < e.length; t++)
                                    if (!0 === e[t].isOutputPass) {
                                        console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");
                                        break
                                    }
                            I.setEffects(e || [])
                        } else
                            console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.")
                    }
                    ,
                    this.getCurrentViewport = function(e) {
                        return e.copy(Q)
                    }
                    ,
                    this.getViewport = function(e) {
                        return e.copy(re)
                    }
                    ,
                    this.setViewport = function(e, t, n, i) {
                        e.isVector4 ? re.set(e.x, e.y, e.z, e.w) : re.set(e, t, n, i),
                        ve.viewport(Q.copy(re).multiplyScalar(te).round())
                    }
                    ,
                    this.getScissor = function(e) {
                        return e.copy(ae)
                    }
                    ,
                    this.setScissor = function(e, t, n, i) {
                        e.isVector4 ? ae.set(e.x, e.y, e.z, e.w) : ae.set(e, t, n, i),
                        ve.scissor(J.copy(ae).multiplyScalar(te).round())
                    }
                    ,
                    this.getScissorTest = function() {
                        return se
                    }
                    ,
                    this.setScissorTest = function(e) {
                        ve.setScissorTest(se = e)
                    }
                    ,
                    this.setOpaqueSort = function(e) {
                        ne = e
                    }
                    ,
                    this.setTransparentSort = function(e) {
                        ie = e
                    }
                    ,
                    this.getClearColor = function(e) {
                        return e.copy(Le.getClearColor())
                    }
                    ,
                    this.setClearColor = function() {
                        Le.setClearColor(...arguments)
                    }
                    ,
                    this.getClearAlpha = function() {
                        return Le.getClearAlpha()
                    }
                    ,
                    this.setClearAlpha = function() {
                        Le.setClearAlpha(...arguments)
                    }
                    ,
                    this.clear = function(e=!0, t=!0, n=!0) {
                        let i = 0;
                        if (e) {
                            let e = !1;
                            if (null !== j) {
                                const t = j.texture.format;
                                e = E.has(t)
                            }
                            if (e) {
                                const e = j.texture.type
                                  , t = T.has(e)
                                  , n = Le.getClearColor()
                                  , i = Le.getClearAlpha()
                                  , r = n.r
                                  , a = n.g
                                  , s = n.b;
                                t ? (k[0] = r,
                                k[1] = a,
                                k[2] = s,
                                k[3] = i,
                                Fe.clearBufferuiv(Fe.COLOR, 0, k)) : (M[0] = r,
                                M[1] = a,
                                M[2] = s,
                                M[3] = i,
                                Fe.clearBufferiv(Fe.COLOR, 0, M))
                            } else
                                i |= Fe.COLOR_BUFFER_BIT
                        }
                        t && (i |= Fe.DEPTH_BUFFER_BIT),
                        n && (i |= Fe.STENCIL_BUFFER_BIT,
                        this.state.buffers.stencil.setMask(4294967295)),
                        Fe.clear(i)
                    }
                    ,
                    this.clearColor = function() {
                        this.clear(!0, !1, !1)
                    }
                    ,
                    this.clearDepth = function() {
                        this.clear(!1, !0, !1)
                    }
                    ,
                    this.clearStencil = function() {
                        this.clear(!1, !1, !0)
                    }
                    ,
                    this.dispose = function() {
                        t.removeEventListener("webglcontextlost", He, !1),
                        t.removeEventListener("webglcontextrestored", je, !1),
                        t.removeEventListener("webglcontextcreationerror", qe, !1),
                        Le.dispose(),
                        Ce.dispose(),
                        Re.dispose(),
                        we.dispose(),
                        xe.dispose(),
                        Se.dispose(),
                        ke.dispose(),
                        Be.dispose(),
                        Ge.dispose(),
                        Me.dispose(),
                        Ve.dispose(),
                        Ve.removeEventListener("sessionstart", Ye),
                        Ve.removeEventListener("sessionend", Ze),
                        $e.stop()
                    }
                    ,
                    this.renderBufferDirect = function(e, t, n, r, a, s) {
                        null === t && (t = pe);
                        const o = a.isMesh && a.matrixWorld.determinant() < 0
                          , l = function(e, t, n, r, a) {
                            !0 !== t.isScene && (t = pe);
                            be.resetTextureUnits();
                            const s = t.fog
                              , o = r.isMeshStandardMaterial ? t.environment : null
                              , l = null === j ? F.outputColorSpace : !0 === j.isXRRenderTarget ? j.texture.colorSpace : i.Zr2
                              , c = (r.isMeshStandardMaterial ? Se : xe).get(r.envMap || o)
                              , h = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                              , d = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0)
                              , u = !!n.morphAttributes.position
                              , p = !!n.morphAttributes.normal
                              , f = !!n.morphAttributes.color;
                            let g = i.y_p;
                            r.toneMapped && (null !== j && !0 !== j.isXRRenderTarget || (g = F.toneMapping));
                            const m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                              , A = void 0 !== m ? m.length : 0
                              , v = we.get(r)
                              , y = C.state.lights;
                            if (!0 === le && (!0 === ce || e !== q)) {
                                const t = e === q && r.id === K;
                                Pe.setState(r, e, t)
                            }
                            let w = !1;
                            r.version === v.__version ? v.needsLights && v.lightsStateVersion !== y.state.version || v.outputColorSpace !== l || a.isBatchedMesh && !1 === v.batching ? w = !0 : a.isBatchedMesh || !0 !== v.batching ? a.isBatchedMesh && !0 === v.batchingColor && null === a.colorTexture || a.isBatchedMesh && !1 === v.batchingColor && null !== a.colorTexture || a.isInstancedMesh && !1 === v.instancing ? w = !0 : a.isInstancedMesh || !0 !== v.instancing ? a.isSkinnedMesh && !1 === v.skinning ? w = !0 : a.isSkinnedMesh || !0 !== v.skinning ? a.isInstancedMesh && !0 === v.instancingColor && null === a.instanceColor || a.isInstancedMesh && !1 === v.instancingColor && null !== a.instanceColor || a.isInstancedMesh && !0 === v.instancingMorph && null === a.morphTexture || a.isInstancedMesh && !1 === v.instancingMorph && null !== a.morphTexture || v.envMap !== c || !0 === r.fog && v.fog !== s ? w = !0 : void 0 === v.numClippingPlanes || v.numClippingPlanes === Pe.numPlanes && v.numIntersection === Pe.numIntersection ? (v.vertexAlphas !== h || v.vertexTangents !== d || v.morphTargets !== u || v.morphNormals !== p || v.morphColors !== f || v.toneMapping !== g || v.morphTargetsCount !== A) && (w = !0) : w = !0 : w = !0 : w = !0 : w = !0 : (w = !0,
                            v.__version = r.version);
                            let b = v.currentProgram;
                            !0 === w && (b = at(r, t, a));
                            let x = !1
                              , S = !1
                              , E = !1;
                            const T = b.getUniforms()
                              , k = v.uniforms;
                            ve.useProgram(b.program) && (x = !0,
                            S = !0,
                            E = !0);
                            r.id !== K && (K = r.id,
                            S = !0);
                            if (x || q !== e) {
                                ve.buffers.depth.getReversed() && !0 !== e.reversedDepth && (e._reversedDepth = !0,
                                e.updateProjectionMatrix()),
                                T.setValue(Fe, "projectionMatrix", e.projectionMatrix),
                                T.setValue(Fe, "viewMatrix", e.matrixWorldInverse);
                                const t = T.map.cameraPosition;
                                void 0 !== t && t.setValue(Fe, de.setFromMatrixPosition(e.matrixWorld)),
                                Ae.logarithmicDepthBuffer && T.setValue(Fe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                                (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && T.setValue(Fe, "isOrthographic", !0 === e.isOrthographicCamera),
                                q !== e && (q = e,
                                S = !0,
                                E = !0)
                            }
                            v.needsLights && (y.state.directionalShadowMap.length > 0 && T.setValue(Fe, "directionalShadowMap", y.state.directionalShadowMap, be),
                            y.state.spotShadowMap.length > 0 && T.setValue(Fe, "spotShadowMap", y.state.spotShadowMap, be),
                            y.state.pointShadowMap.length > 0 && T.setValue(Fe, "pointShadowMap", y.state.pointShadowMap, be));
                            if (a.isSkinnedMesh) {
                                T.setOptional(Fe, a, "bindMatrix"),
                                T.setOptional(Fe, a, "bindMatrixInverse");
                                const e = a.skeleton;
                                e && (null === e.boneTexture && e.computeBoneTexture(),
                                T.setValue(Fe, "boneTexture", e.boneTexture, be))
                            }
                            a.isBatchedMesh && (T.setOptional(Fe, a, "batchingTexture"),
                            T.setValue(Fe, "batchingTexture", a._matricesTexture, be),
                            T.setOptional(Fe, a, "batchingIdTexture"),
                            T.setValue(Fe, "batchingIdTexture", a._indirectTexture, be),
                            T.setOptional(Fe, a, "batchingColorTexture"),
                            null !== a._colorsTexture && T.setValue(Fe, "batchingColorTexture", a._colorsTexture, be));
                            const M = n.morphAttributes;
                            void 0 === M.position && void 0 === M.normal && void 0 === M.color || Ne.update(a, n, b);
                            (S || v.receiveShadow !== a.receiveShadow) && (v.receiveShadow = a.receiveShadow,
                            T.setValue(Fe, "receiveShadow", a.receiveShadow));
                            r.isMeshGouraudMaterial && null !== r.envMap && (k.envMap.value = c,
                            k.flipEnvMap.value = c.isCubeTexture && !1 === c.isRenderTargetTexture ? -1 : 1);
                            r.isMeshStandardMaterial && null === r.envMap && null !== t.environment && (k.envMapIntensity.value = t.environmentIntensity);
                            void 0 !== k.dfgLUT && (k.dfgLUT.value = (null === Xt && (Xt = new i.GYF(Jt,16,16,i.paN,i.ix0),
                            Xt.name = "DFG_LUT",
                            Xt.minFilter = i.k6q,
                            Xt.magFilter = i.k6q,
                            Xt.wrapS = i.ghU,
                            Xt.wrapT = i.ghU,
                            Xt.generateMipmaps = !1,
                            Xt.needsUpdate = !0),
                            Xt));
                            S && (T.setValue(Fe, "toneMappingExposure", F.toneMappingExposure),
                            v.needsLights && (R = E,
                            (_ = k).ambientLightColor.needsUpdate = R,
                            _.lightProbe.needsUpdate = R,
                            _.directionalLights.needsUpdate = R,
                            _.directionalLightShadows.needsUpdate = R,
                            _.pointLights.needsUpdate = R,
                            _.pointLightShadows.needsUpdate = R,
                            _.spotLights.needsUpdate = R,
                            _.spotLightShadows.needsUpdate = R,
                            _.rectAreaLights.needsUpdate = R,
                            _.hemisphereLights.needsUpdate = R),
                            s && !0 === r.fog && _e.refreshFogUniforms(k, s),
                            _e.refreshMaterialUniforms(k, r, te, ee, C.state.transmissionRenderTarget[e.id]),
                            Ke.upload(Fe, st(v), k, be));
                            var _, R;
                            r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (Ke.upload(Fe, st(v), k, be),
                            r.uniformsNeedUpdate = !1);
                            r.isSpriteMaterial && T.setValue(Fe, "center", a.center);
                            if (T.setValue(Fe, "modelViewMatrix", a.modelViewMatrix),
                            T.setValue(Fe, "normalMatrix", a.normalMatrix),
                            T.setValue(Fe, "modelMatrix", a.matrixWorld),
                            r.isShaderMaterial || r.isRawShaderMaterial) {
                                const e = r.uniformsGroups;
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    Ge.update(n, b),
                                    Ge.bind(n, b)
                                }
                            }
                            return b
                        }(e, t, n, r, a);
                        ve.setMaterial(r, o);
                        let c = n.index
                          , h = 1;
                        if (!0 === r.wireframe) {
                            if (c = Te.getWireframeAttribute(n),
                            void 0 === c)
                                return;
                            h = 2
                        }
                        const d = n.drawRange
                          , u = n.attributes.position;
                        let p = d.start * h
                          , f = (d.start + d.count) * h;
                        null !== s && (p = Math.max(p, s.start * h),
                        f = Math.min(f, (s.start + s.count) * h)),
                        null !== c ? (p = Math.max(p, 0),
                        f = Math.min(f, c.count)) : null != u && (p = Math.max(p, 0),
                        f = Math.min(f, u.count));
                        const g = f - p;
                        if (g < 0 || g === 1 / 0)
                            return;
                        let m;
                        Be.setup(a, r, l, n, c);
                        let A = ze;
                        if (null !== c && (m = Ee.get(c),
                        A = Ue,
                        A.setIndex(m)),
                        a.isMesh)
                            !0 === r.wireframe ? (ve.setLineWidth(r.wireframeLinewidth * ge()),
                            A.setMode(Fe.LINES)) : A.setMode(Fe.TRIANGLES);
                        else if (a.isLine) {
                            let e = r.linewidth;
                            void 0 === e && (e = 1),
                            ve.setLineWidth(e * ge()),
                            a.isLineSegments ? A.setMode(Fe.LINES) : a.isLineLoop ? A.setMode(Fe.LINE_LOOP) : A.setMode(Fe.LINE_STRIP)
                        } else
                            a.isPoints ? A.setMode(Fe.POINTS) : a.isSprite && A.setMode(Fe.TRIANGLES);
                        if (a.isBatchedMesh)
                            if (null !== a._multiDrawInstances)
                                (0,
                                i.mcG)("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                                A.renderMultiDrawInstances(a._multiDrawStarts, a._multiDrawCounts, a._multiDrawCount, a._multiDrawInstances);
                            else if (me.get("WEBGL_multi_draw"))
                                A.renderMultiDraw(a._multiDrawStarts, a._multiDrawCounts, a._multiDrawCount);
                            else {
                                const e = a._multiDrawStarts
                                  , t = a._multiDrawCounts
                                  , n = a._multiDrawCount
                                  , i = c ? Ee.get(c).bytesPerElement : 1
                                  , s = we.get(r).currentProgram.getUniforms();
                                for (let r = 0; r < n; r++)
                                    s.setValue(Fe, "_gl_DrawID", r),
                                    A.render(e[r] / i, t[r])
                            }
                        else if (a.isInstancedMesh)
                            A.renderInstances(p, g, a.count);
                        else if (n.isInstancedBufferGeometry) {
                            const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                              , t = Math.min(n.instanceCount, e);
                            A.renderInstances(p, g, t)
                        } else
                            A.render(p, g)
                    }
                    ,
                    this.compile = function(e, t, n=null) {
                        null === n && (n = e),
                        C = Re.get(n),
                        C.init(t),
                        P.push(C),
                        n.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (C.pushLight(e),
                            e.castShadow && C.pushShadow(e))
                        }
                        )),
                        e !== n && e.traverseVisible((function(e) {
                            e.isLight && e.layers.test(t.layers) && (C.pushLight(e),
                            e.castShadow && C.pushShadow(e))
                        }
                        )),
                        C.setupLights();
                        const i = new Set;
                        return e.traverse((function(e) {
                            if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                                return;
                            const t = e.material;
                            if (t)
                                if (Array.isArray(t))
                                    for (let r = 0; r < t.length; r++) {
                                        const a = t[r];
                                        Je(a, n, e),
                                        i.add(a)
                                    }
                                else
                                    Je(t, n, e),
                                    i.add(t)
                        }
                        )),
                        C = P.pop(),
                        i
                    }
                    ,
                    this.compileAsync = function(e, t, n=null) {
                        const i = this.compile(e, t, n);
                        return new Promise((t => {
                            function n() {
                                i.forEach((function(e) {
                                    we.get(e).currentProgram.isReady() && i.delete(e)
                                }
                                )),
                                0 !== i.size ? setTimeout(n, 10) : t(e)
                            }
                            null !== me.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                        }
                        ))
                    }
                    ;
                    let Xe = null;
                    function Ye() {
                        $e.stop()
                    }
                    function Ze() {
                        $e.start()
                    }
                    const $e = new r;
                    function et(e, t, n, i) {
                        if (!1 === e.visible)
                            return;
                        if (e.layers.test(t.layers))
                            if (e.isGroup)
                                n = e.renderOrder;
                            else if (e.isLOD)
                                !0 === e.autoUpdate && e.update(t);
                            else if (e.isLight)
                                C.pushLight(e),
                                e.castShadow && C.pushShadow(e);
                            else if (e.isSprite) {
                                if (!e.frustumCulled || oe.intersectsSprite(e)) {
                                    i && ue.setFromMatrixPosition(e.matrixWorld).applyMatrix4(he);
                                    const t = ke.update(e)
                                      , r = e.material;
                                    r.visible && _.push(e, t, r, n, ue.z, null)
                                }
                            } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || oe.intersectsObject(e))) {
                                const t = ke.update(e)
                                  , r = e.material;
                                if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                                ue.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                                ue.copy(t.boundingSphere.center)),
                                ue.applyMatrix4(e.matrixWorld).applyMatrix4(he)),
                                Array.isArray(r)) {
                                    const i = t.groups;
                                    for (let a = 0, s = i.length; a < s; a++) {
                                        const s = i[a]
                                          , o = r[s.materialIndex];
                                        o && o.visible && _.push(e, t, o, n, ue.z, s)
                                    }
                                } else
                                    r.visible && _.push(e, t, r, n, ue.z, null)
                            }
                        const r = e.children;
                        for (let e = 0, a = r.length; e < a; e++)
                            et(r[e], t, n, i)
                    }
                    function tt(e, t, n, i) {
                        const {opaque: r, transmissive: a, transparent: s} = e;
                        C.setupLightsView(n),
                        !0 === le && Pe.setGlobalState(F.clippingPlanes, n),
                        i && ve.viewport(Q.copy(i)),
                        r.length > 0 && it(r, t, n),
                        a.length > 0 && it(a, t, n),
                        s.length > 0 && it(s, t, n),
                        ve.buffers.depth.setTest(!0),
                        ve.buffers.depth.setMask(!0),
                        ve.buffers.color.setMask(!0),
                        ve.setPolygonOffset(!1)
                    }
                    function nt(e, t, n, r) {
                        if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                            return;
                        if (void 0 === C.state.transmissionRenderTarget[r.id]) {
                            const e = me.has("EXT_color_buffer_half_float") || me.has("EXT_color_buffer_float");
                            C.state.transmissionRenderTarget[r.id] = new i.nWS(1,1,{
                                generateMipmaps: !0,
                                type: e ? i.ix0 : i.OUM,
                                minFilter: i.$_I,
                                samples: Ae.samples,
                                stencilBuffer: o,
                                resolveDepthBuffer: !1,
                                resolveStencilBuffer: !1,
                                colorSpace: i.ppV.workingColorSpace
                            })
                        }
                        const a = C.state.transmissionRenderTarget[r.id]
                          , s = r.viewport || Q;
                        a.setSize(s.z * F.transmissionResolutionScale, s.w * F.transmissionResolutionScale);
                        const l = F.getRenderTarget()
                          , c = F.getActiveCubeFace()
                          , h = F.getActiveMipmapLevel();
                        F.setRenderTarget(a),
                        F.getClearColor(Y),
                        Z = F.getClearAlpha(),
                        Z < 1 && F.setClearColor(16777215, .5),
                        F.clear(),
                        fe && Le.render(n);
                        const d = F.toneMapping;
                        F.toneMapping = i.y_p;
                        const u = r.viewport;
                        if (void 0 !== r.viewport && (r.viewport = void 0),
                        C.setupLightsView(r),
                        !0 === le && Pe.setGlobalState(F.clippingPlanes, r),
                        it(e, n, r),
                        be.updateMultisampleRenderTarget(a),
                        be.updateRenderTargetMipmap(a),
                        !1 === me.has("WEBGL_multisampled_render_to_texture")) {
                            let e = !1;
                            for (let a = 0, s = t.length; a < s; a++) {
                                const s = t[a]
                                  , {object: o, geometry: l, material: c, group: h} = s;
                                if (c.side === i.$EB && o.layers.test(r.layers)) {
                                    const t = c.side;
                                    c.side = i.hsX,
                                    c.needsUpdate = !0,
                                    rt(o, n, r, l, c, h),
                                    c.side = t,
                                    c.needsUpdate = !0,
                                    e = !0
                                }
                            }
                            !0 === e && (be.updateMultisampleRenderTarget(a),
                            be.updateRenderTargetMipmap(a))
                        }
                        F.setRenderTarget(l, c, h),
                        F.setClearColor(Y, Z),
                        void 0 !== u && (r.viewport = u),
                        F.toneMapping = d
                    }
                    function it(e, t, n) {
                        const i = !0 === t.isScene ? t.overrideMaterial : null;
                        for (let r = 0, a = e.length; r < a; r++) {
                            const a = e[r]
                              , {object: s, geometry: o, group: l} = a;
                            let c = a.material;
                            !0 === c.allowOverride && null !== i && (c = i),
                            s.layers.test(n.layers) && rt(s, t, n, o, c, l)
                        }
                    }
                    function rt(e, t, n, r, a, s) {
                        e.onBeforeRender(F, t, n, r, a, s),
                        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                        a.onBeforeRender(F, t, n, r, e, s),
                        !0 === a.transparent && a.side === i.$EB && !1 === a.forceSinglePass ? (a.side = i.hsX,
                        a.needsUpdate = !0,
                        F.renderBufferDirect(n, t, r, a, e, s),
                        a.side = i.hB5,
                        a.needsUpdate = !0,
                        F.renderBufferDirect(n, t, r, a, e, s),
                        a.side = i.$EB) : F.renderBufferDirect(n, t, r, a, e, s),
                        e.onAfterRender(F, t, n, r, a, s)
                    }
                    function at(e, t, n) {
                        !0 !== t.isScene && (t = pe);
                        const i = we.get(e)
                          , r = C.state.lights
                          , a = C.state.shadowsArray
                          , s = r.state.version
                          , o = Me.getParameters(e, r.state, a, t, n)
                          , l = Me.getProgramCacheKey(o);
                        let c = i.programs;
                        i.environment = e.isMeshStandardMaterial ? t.environment : null,
                        i.fog = t.fog,
                        i.envMap = (e.isMeshStandardMaterial ? Se : xe).get(e.envMap || i.environment),
                        i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
                        void 0 === c && (e.addEventListener("dispose", Qe),
                        c = new Map,
                        i.programs = c);
                        let h = c.get(l);
                        if (void 0 !== h) {
                            if (i.currentProgram === h && i.lightsStateVersion === s)
                                return ot(e, o),
                                h
                        } else
                            o.uniforms = Me.getUniforms(e),
                            e.onBeforeCompile(o, F),
                            h = Me.acquireProgram(o, l),
                            c.set(l, h),
                            i.uniforms = o.uniforms;
                        const d = i.uniforms;
                        return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (d.clippingPlanes = Pe.uniform),
                        ot(e, o),
                        i.needsLights = function(e) {
                            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                        }(e),
                        i.lightsStateVersion = s,
                        i.needsLights && (d.ambientLightColor.value = r.state.ambient,
                        d.lightProbe.value = r.state.probe,
                        d.directionalLights.value = r.state.directional,
                        d.directionalLightShadows.value = r.state.directionalShadow,
                        d.spotLights.value = r.state.spot,
                        d.spotLightShadows.value = r.state.spotShadow,
                        d.rectAreaLights.value = r.state.rectArea,
                        d.ltc_1.value = r.state.rectAreaLTC1,
                        d.ltc_2.value = r.state.rectAreaLTC2,
                        d.pointLights.value = r.state.point,
                        d.pointLightShadows.value = r.state.pointShadow,
                        d.hemisphereLights.value = r.state.hemi,
                        d.directionalShadowMap.value = r.state.directionalShadowMap,
                        d.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                        d.spotShadowMap.value = r.state.spotShadowMap,
                        d.spotLightMatrix.value = r.state.spotLightMatrix,
                        d.spotLightMap.value = r.state.spotLightMap,
                        d.pointShadowMap.value = r.state.pointShadowMap,
                        d.pointShadowMatrix.value = r.state.pointShadowMatrix),
                        i.currentProgram = h,
                        i.uniformsList = null,
                        h
                    }
                    function st(e) {
                        if (null === e.uniformsList) {
                            const t = e.currentProgram.getUniforms();
                            e.uniformsList = Ke.seqWithValue(t.seq, e.uniforms)
                        }
                        return e.uniformsList
                    }
                    function ot(e, t) {
                        const n = we.get(e);
                        n.outputColorSpace = t.outputColorSpace,
                        n.batching = t.batching,
                        n.batchingColor = t.batchingColor,
                        n.instancing = t.instancing,
                        n.instancingColor = t.instancingColor,
                        n.instancingMorph = t.instancingMorph,
                        n.skinning = t.skinning,
                        n.morphTargets = t.morphTargets,
                        n.morphNormals = t.morphNormals,
                        n.morphColors = t.morphColors,
                        n.morphTargetsCount = t.morphTargetsCount,
                        n.numClippingPlanes = t.numClippingPlanes,
                        n.numIntersection = t.numClipIntersection,
                        n.vertexAlphas = t.vertexAlphas,
                        n.vertexTangents = t.vertexTangents,
                        n.toneMapping = t.toneMapping
                    }
                    $e.setAnimationLoop((function(e) {
                        Xe && Xe(e)
                    }
                    )),
                    "undefined" != typeof self && $e.setContext(self),
                    this.setAnimationLoop = function(e) {
                        Xe = e,
                        Ve.setAnimationLoop(e),
                        null === e ? $e.stop() : $e.start()
                    }
                    ,
                    Ve.addEventListener("sessionstart", Ye),
                    Ve.addEventListener("sessionend", Ze),
                    this.render = function(e, t) {
                        if (void 0 !== t && !0 !== t.isCamera)
                            return void (0,
                            i.z3S)("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                        if (!0 === W)
                            return;
                        const n = !0 === Ve.enabled && !0 === Ve.isPresenting
                          , r = null !== I && (null === j || n) && I.begin(F, j);
                        if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                        null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                        !0 !== Ve.enabled || !0 !== Ve.isPresenting || null !== I && !1 !== I.isCompositing() || (!0 === Ve.cameraAutoUpdate && Ve.updateCamera(t),
                        t = Ve.getCamera()),
                        !0 === e.isScene && e.onBeforeRender(F, e, t, j),
                        C = Re.get(e, P.length),
                        C.init(t),
                        P.push(C),
                        he.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                        oe.setFromProjectionMatrix(he, i.TdN, t.reversedDepth),
                        ce = this.localClippingEnabled,
                        le = Pe.init(this.clippingPlanes, ce),
                        _ = Ce.get(e, R.length),
                        _.init(),
                        R.push(_),
                        !0 === Ve.enabled && !0 === Ve.isPresenting) {
                            const e = F.xr.getDepthSensingMesh();
                            null !== e && et(e, t, -1 / 0, F.sortObjects)
                        }
                        et(e, t, 0, F.sortObjects),
                        _.finish(),
                        !0 === F.sortObjects && _.sort(ne, ie),
                        fe = !1 === Ve.enabled || !1 === Ve.isPresenting || !1 === Ve.hasDepthSensing(),
                        fe && Le.addToRenderList(_, e),
                        this.info.render.frame++,
                        !0 === le && Pe.beginShadows();
                        const a = C.state.shadowsArray;
                        Ie.render(a, e, t),
                        !0 === le && Pe.endShadows(),
                        !0 === this.info.autoReset && this.info.reset();
                        if (!1 === (r && I.hasRenderPass())) {
                            const n = _.opaque
                              , i = _.transmissive;
                            if (C.setupLights(),
                            t.isArrayCamera) {
                                const r = t.cameras;
                                if (i.length > 0)
                                    for (let t = 0, a = r.length; t < a; t++) {
                                        nt(n, i, e, r[t])
                                    }
                                fe && Le.render(e);
                                for (let t = 0, n = r.length; t < n; t++) {
                                    const n = r[t];
                                    tt(_, e, n, n.viewport)
                                }
                            } else
                                i.length > 0 && nt(n, i, e, t),
                                fe && Le.render(e),
                                tt(_, e, t)
                        }
                        null !== j && 0 === H && (be.updateMultisampleRenderTarget(j),
                        be.updateRenderTargetMipmap(j)),
                        r && I.end(F),
                        !0 === e.isScene && e.onAfterRender(F, e, t),
                        Be.resetDefaultState(),
                        K = -1,
                        q = null,
                        P.pop(),
                        P.length > 0 ? (C = P[P.length - 1],
                        !0 === le && Pe.setGlobalState(F.clippingPlanes, C.state.camera)) : C = null,
                        R.pop(),
                        _ = R.length > 0 ? R[R.length - 1] : null
                    }
                    ,
                    this.getActiveCubeFace = function() {
                        return V
                    }
                    ,
                    this.getActiveMipmapLevel = function() {
                        return H
                    }
                    ,
                    this.getRenderTarget = function() {
                        return j
                    }
                    ,
                    this.setRenderTargetTextures = function(e, t, n) {
                        const i = we.get(e);
                        i.__autoAllocateDepthBuffer = !1 === e.resolveDepthBuffer,
                        !1 === i.__autoAllocateDepthBuffer && (i.__useRenderToTexture = !1),
                        we.get(e.texture).__webglTexture = t,
                        we.get(e.depthTexture).__webglTexture = i.__autoAllocateDepthBuffer ? void 0 : n,
                        i.__hasExternalTextures = !0
                    }
                    ,
                    this.setRenderTargetFramebuffer = function(e, t) {
                        const n = we.get(e);
                        n.__webglFramebuffer = t,
                        n.__useDefaultFramebuffer = void 0 === t
                    }
                    ;
                    const lt = Fe.createFramebuffer();
                    this.setRenderTarget = function(e, t=0, n=0) {
                        j = e,
                        V = t,
                        H = n;
                        let i = null
                          , r = !1
                          , a = !1;
                        if (e) {
                            const s = we.get(e);
                            if (void 0 !== s.__useDefaultFramebuffer)
                                return ve.bindFramebuffer(Fe.FRAMEBUFFER, s.__webglFramebuffer),
                                Q.copy(e.viewport),
                                J.copy(e.scissor),
                                X = e.scissorTest,
                                ve.viewport(Q),
                                ve.scissor(J),
                                ve.setScissorTest(X),
                                void (K = -1);
                            if (void 0 === s.__webglFramebuffer)
                                be.setupRenderTarget(e);
                            else if (s.__hasExternalTextures)
                                be.rebindTextures(e, we.get(e.texture).__webglTexture, we.get(e.depthTexture).__webglTexture);
                            else if (e.depthBuffer) {
                                const t = e.depthTexture;
                                if (s.__boundDepthTexture !== t) {
                                    if (null !== t && we.has(t) && (e.width !== t.image.width || e.height !== t.image.height))
                                        throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                    be.setupDepthRenderbuffer(e)
                                }
                            }
                            const o = e.texture;
                            (o.isData3DTexture || o.isDataArrayTexture || o.isCompressedArrayTexture) && (a = !0);
                            const l = we.get(e).__webglFramebuffer;
                            e.isWebGLCubeRenderTarget ? (i = Array.isArray(l[t]) ? l[t][n] : l[t],
                            r = !0) : i = e.samples > 0 && !1 === be.useMultisampledRTT(e) ? we.get(e).__webglMultisampledFramebuffer : Array.isArray(l) ? l[n] : l,
                            Q.copy(e.viewport),
                            J.copy(e.scissor),
                            X = e.scissorTest
                        } else
                            Q.copy(re).multiplyScalar(te).floor(),
                            J.copy(ae).multiplyScalar(te).floor(),
                            X = se;
                        0 !== n && (i = lt);
                        if (ve.bindFramebuffer(Fe.FRAMEBUFFER, i) && ve.drawBuffers(e, i),
                        ve.viewport(Q),
                        ve.scissor(J),
                        ve.setScissorTest(X),
                        r) {
                            const i = we.get(e.texture);
                            Fe.framebufferTexture2D(Fe.FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, Fe.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                        } else if (a) {
                            const i = t;
                            for (let t = 0; t < e.textures.length; t++) {
                                const r = we.get(e.textures[t]);
                                Fe.framebufferTextureLayer(Fe.FRAMEBUFFER, Fe.COLOR_ATTACHMENT0 + t, r.__webglTexture, n, i)
                            }
                        } else if (null !== e && 0 !== n) {
                            const t = we.get(e.texture);
                            Fe.framebufferTexture2D(Fe.FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, Fe.TEXTURE_2D, t.__webglTexture, n)
                        }
                        K = -1
                    }
                    ,
                    this.readRenderTargetPixels = function(e, t, n, r, a, s, o, l=0) {
                        if (!e || !e.isWebGLRenderTarget)
                            return void (0,
                            i.z3S)("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let c = we.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== o && (c = c[o]),
                        c) {
                            ve.bindFramebuffer(Fe.FRAMEBUFFER, c);
                            try {
                                const o = e.textures[l]
                                  , c = o.format
                                  , h = o.type;
                                if (!Ae.textureFormatReadable(c))
                                    return void (0,
                                    i.z3S)("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!Ae.textureTypeReadable(h))
                                    return void (0,
                                    i.z3S)("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - a && (e.textures.length > 1 && Fe.readBuffer(Fe.COLOR_ATTACHMENT0 + l),
                                Fe.readPixels(t, n, r, a, De.convert(c), De.convert(h), s))
                            } finally {
                                const e = null !== j ? we.get(j).__webglFramebuffer : null;
                                ve.bindFramebuffer(Fe.FRAMEBUFFER, e)
                            }
                        }
                    }
                    ,
                    this.readRenderTargetPixelsAsync = async function(e, t, n, r, a, s, o, l=0) {
                        if (!e || !e.isWebGLRenderTarget)
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                        let c = we.get(e).__webglFramebuffer;
                        if (e.isWebGLCubeRenderTarget && void 0 !== o && (c = c[o]),
                        c) {
                            if (t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - a) {
                                ve.bindFramebuffer(Fe.FRAMEBUFFER, c);
                                const o = e.textures[l]
                                  , h = o.format
                                  , d = o.type;
                                if (!Ae.textureFormatReadable(h))
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                                if (!Ae.textureTypeReadable(d))
                                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                                const u = Fe.createBuffer();
                                Fe.bindBuffer(Fe.PIXEL_PACK_BUFFER, u),
                                Fe.bufferData(Fe.PIXEL_PACK_BUFFER, s.byteLength, Fe.STREAM_READ),
                                e.textures.length > 1 && Fe.readBuffer(Fe.COLOR_ATTACHMENT0 + l),
                                Fe.readPixels(t, n, r, a, De.convert(h), De.convert(d), 0);
                                const p = null !== j ? we.get(j).__webglFramebuffer : null;
                                ve.bindFramebuffer(Fe.FRAMEBUFFER, p);
                                const f = Fe.fenceSync(Fe.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                return Fe.flush(),
                                await (0,
                                i.jej)(Fe, f, 4),
                                Fe.bindBuffer(Fe.PIXEL_PACK_BUFFER, u),
                                Fe.getBufferSubData(Fe.PIXEL_PACK_BUFFER, 0, s),
                                Fe.deleteBuffer(u),
                                Fe.deleteSync(f),
                                s
                            }
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                        }
                    }
                    ,
                    this.copyFramebufferToTexture = function(e, t=null, n=0) {
                        const i = Math.pow(2, -n)
                          , r = Math.floor(e.image.width * i)
                          , a = Math.floor(e.image.height * i)
                          , s = null !== t ? t.x : 0
                          , o = null !== t ? t.y : 0;
                        be.setTexture2D(e, 0),
                        Fe.copyTexSubImage2D(Fe.TEXTURE_2D, n, 0, 0, s, o, r, a),
                        ve.unbindTexture()
                    }
                    ;
                    const ct = Fe.createFramebuffer()
                      , ht = Fe.createFramebuffer();
                    this.copyTextureToTexture = function(e, t, n=null, r=null, a=0, s=null) {
                        let o, l, c, h, d, u, p, f, g;
                        null === s && (0 !== a ? ((0,
                        i.mcG)("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
                        s = a,
                        a = 0) : s = 0);
                        const m = e.isCompressedTexture ? e.mipmaps[s] : e.image;
                        if (null !== n)
                            o = n.max.x - n.min.x,
                            l = n.max.y - n.min.y,
                            c = n.isBox3 ? n.max.z - n.min.z : 1,
                            h = n.min.x,
                            d = n.min.y,
                            u = n.isBox3 ? n.min.z : 0;
                        else {
                            const t = Math.pow(2, -a);
                            o = Math.floor(m.width * t),
                            l = Math.floor(m.height * t),
                            c = e.isDataArrayTexture ? m.depth : e.isData3DTexture ? Math.floor(m.depth * t) : 1,
                            h = 0,
                            d = 0,
                            u = 0
                        }
                        null !== r ? (p = r.x,
                        f = r.y,
                        g = r.z) : (p = 0,
                        f = 0,
                        g = 0);
                        const A = De.convert(t.format)
                          , v = De.convert(t.type);
                        let y;
                        t.isData3DTexture ? (be.setTexture3D(t, 0),
                        y = Fe.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (be.setTexture2DArray(t, 0),
                        y = Fe.TEXTURE_2D_ARRAY) : (be.setTexture2D(t, 0),
                        y = Fe.TEXTURE_2D),
                        Fe.pixelStorei(Fe.UNPACK_FLIP_Y_WEBGL, t.flipY),
                        Fe.pixelStorei(Fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
                        Fe.pixelStorei(Fe.UNPACK_ALIGNMENT, t.unpackAlignment);
                        const w = Fe.getParameter(Fe.UNPACK_ROW_LENGTH)
                          , b = Fe.getParameter(Fe.UNPACK_IMAGE_HEIGHT)
                          , x = Fe.getParameter(Fe.UNPACK_SKIP_PIXELS)
                          , S = Fe.getParameter(Fe.UNPACK_SKIP_ROWS)
                          , E = Fe.getParameter(Fe.UNPACK_SKIP_IMAGES);
                        Fe.pixelStorei(Fe.UNPACK_ROW_LENGTH, m.width),
                        Fe.pixelStorei(Fe.UNPACK_IMAGE_HEIGHT, m.height),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_PIXELS, h),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_ROWS, d),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_IMAGES, u);
                        const T = e.isDataArrayTexture || e.isData3DTexture
                          , k = t.isDataArrayTexture || t.isData3DTexture;
                        if (e.isDepthTexture) {
                            const n = we.get(e)
                              , i = we.get(t)
                              , r = we.get(n.__renderTarget)
                              , m = we.get(i.__renderTarget);
                            ve.bindFramebuffer(Fe.READ_FRAMEBUFFER, r.__webglFramebuffer),
                            ve.bindFramebuffer(Fe.DRAW_FRAMEBUFFER, m.__webglFramebuffer);
                            for (let n = 0; n < c; n++)
                                T && (Fe.framebufferTextureLayer(Fe.READ_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, we.get(e).__webglTexture, a, u + n),
                                Fe.framebufferTextureLayer(Fe.DRAW_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, we.get(t).__webglTexture, s, g + n)),
                                Fe.blitFramebuffer(h, d, o, l, p, f, o, l, Fe.DEPTH_BUFFER_BIT, Fe.NEAREST);
                            ve.bindFramebuffer(Fe.READ_FRAMEBUFFER, null),
                            ve.bindFramebuffer(Fe.DRAW_FRAMEBUFFER, null)
                        } else if (0 !== a || e.isRenderTargetTexture || we.has(e)) {
                            const n = we.get(e)
                              , i = we.get(t);
                            ve.bindFramebuffer(Fe.READ_FRAMEBUFFER, ct),
                            ve.bindFramebuffer(Fe.DRAW_FRAMEBUFFER, ht);
                            for (let e = 0; e < c; e++)
                                T ? Fe.framebufferTextureLayer(Fe.READ_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, n.__webglTexture, a, u + e) : Fe.framebufferTexture2D(Fe.READ_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, Fe.TEXTURE_2D, n.__webglTexture, a),
                                k ? Fe.framebufferTextureLayer(Fe.DRAW_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, i.__webglTexture, s, g + e) : Fe.framebufferTexture2D(Fe.DRAW_FRAMEBUFFER, Fe.COLOR_ATTACHMENT0, Fe.TEXTURE_2D, i.__webglTexture, s),
                                0 !== a ? Fe.blitFramebuffer(h, d, o, l, p, f, o, l, Fe.COLOR_BUFFER_BIT, Fe.NEAREST) : k ? Fe.copyTexSubImage3D(y, s, p, f, g + e, h, d, o, l) : Fe.copyTexSubImage2D(y, s, p, f, h, d, o, l);
                            ve.bindFramebuffer(Fe.READ_FRAMEBUFFER, null),
                            ve.bindFramebuffer(Fe.DRAW_FRAMEBUFFER, null)
                        } else
                            k ? e.isDataTexture || e.isData3DTexture ? Fe.texSubImage3D(y, s, p, f, g, o, l, c, A, v, m.data) : t.isCompressedArrayTexture ? Fe.compressedTexSubImage3D(y, s, p, f, g, o, l, c, A, m.data) : Fe.texSubImage3D(y, s, p, f, g, o, l, c, A, v, m) : e.isDataTexture ? Fe.texSubImage2D(Fe.TEXTURE_2D, s, p, f, o, l, A, v, m.data) : e.isCompressedTexture ? Fe.compressedTexSubImage2D(Fe.TEXTURE_2D, s, p, f, m.width, m.height, A, m.data) : Fe.texSubImage2D(Fe.TEXTURE_2D, s, p, f, o, l, A, v, m);
                        Fe.pixelStorei(Fe.UNPACK_ROW_LENGTH, w),
                        Fe.pixelStorei(Fe.UNPACK_IMAGE_HEIGHT, b),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_PIXELS, x),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_ROWS, S),
                        Fe.pixelStorei(Fe.UNPACK_SKIP_IMAGES, E),
                        0 === s && t.generateMipmaps && Fe.generateMipmap(y),
                        ve.unbindTexture()
                    }
                    ,
                    this.initRenderTarget = function(e) {
                        void 0 === we.get(e).__webglFramebuffer && be.setupRenderTarget(e)
                    }
                    ,
                    this.initTexture = function(e) {
                        e.isCubeTexture ? be.setTextureCube(e, 0) : e.isData3DTexture ? be.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? be.setTexture2DArray(e, 0) : be.setTexture2D(e, 0),
                        ve.unbindTexture()
                    }
                    ,
                    this.resetState = function() {
                        V = 0,
                        H = 0,
                        j = null,
                        ve.reset(),
                        Be.reset()
                    }
                    ,
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                        detail: this
                    }))
                }
                get coordinateSystem() {
                    return i.TdN
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e;
                    const t = this.getContext();
                    t.drawingBufferColorSpace = i.ppV._getDrawingBufferColorSpace(e),
                    t.unpackColorSpace = i.ppV._getUnpackColorSpace()
                }
            }
        }
        ,
        9507: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => E
            });
            var i, r, a, s = n(1635), o = n(4922), l = n(2825);
            class c {
                constructor(e) {
                    if (r.set(this, void 0),
                    null != e) {
                        if (!Number.isInteger(e))
                            throw new Error("Seed must be an integer");
                        (0,
                        s.GG)(this, r, e % (0,
                        s.gn)(i, i, "f", a).length, "f")
                    } else
                        (0,
                        s.GG)(this, r, 0, "f")
                }
                next() {
                    var e;
                    return (0,
                    s.GG)(this, r, (e = (0,
                    s.gn)(this, r, "f"),
                    ++e), "f"),
                    (0,
                    s.gn)(this, r, "f") >= (0,
                    s.gn)(i, i, "f", a).length && (0,
                    s.GG)(this, r, 0, "f"),
                    (0,
                    s.gn)(i, i, "f", a)[(0,
                    s.gn)(this, r, "f")]
                }
            }
            i = c,
            r = new WeakMap,
            a = {
                value: [.12047764760664692, .19645762332790628, .5525629082262744, .41272626379209965, .7795036003541387, .13367266027110114, .7999601557377349, .9519714253374205, .1735048382917752, .7513367084489158, .6531386724839523, .9026427867068505, .8543272738216994, .11176849958868162, .6705698284858437, .26628732081296946, .31140322993719605, .45170300835470933, .12615515120247944, .0610638094525735, .291990923385425, .4613983868623317, .6615759832726253, .4373182881232056, .7432890501246443, .39316710322388837, .49444122821563297, .5994296685114344, .060050119050233386, .4165885432422003, .43974364800990084, .1628314496954224, .05787972729968116, .225388541259955, .6075775236386991, .8908354370882479, .47072983115144584, .7662003453186828, .20651036895645647, .03724062137286044, .17110277274376795, .7626426077793496, .8372112804261309, .8761690804447455, .13887024930406633, .8287513367412203, .9794446290917873, .807658524448803, .8465629116398186, .5187285629536083, .33962953580139277, .9798419666114342, .6777071959103609, .5388899884934379, .7863389168762325, .4274591420924474, .25631366937500566, .5695289062505289, .026841382754547727, .18267938207996903, .9853642975717878, .24428485895234409, .5322028747608949, .9655065842019517, .043810183244384016, .541216190236913, .05897981610006209, .2849168541804703, .5349823008832073, .9655676144971486, .22831812764497283, .7698701658704175, .4103995069939841, .25782763124411856, .8490222628872495, .39280879489916987, .31999467883347554, .2860820872456349, .9684928577493004, .9973831481899462, .2930912094664657, .4847128131859766, .7218400909709828, .40407009594106236, .7059298060123587, .45362146566562744, .4640974655488792, .16076769483252273, .5989453525750241, .585759299589679, .9417035568973537, .20117930667657413, .5777873180244959, .1991854396549344, .8743781441651348, .624666386634513, .38720573630932886, .9967931526923675, .49817894572849486, .24585267823751833, .8639168275132305, .2865624029759799, .6163605496913385, .5864748073339972, .8781049154377354, .7497547608938613, .7864098057445887, .0334170452332867, .4875588105294657, .6737395339380896, .21851121231639659, .2923739650597854, .6073797612662293, .41823228947229896, .8531029420136382, .3260916332061783, .6306262204574675, .5268576689601923, .3516570914484707, .8659366375222706, .8447448461834428, .3794548980890986, .9832775904115916, .8442256760399809, .3006550591973338, .9718660619781394, .5103245035851833, .794319831388071]
            };
            const h = c;
            var d, u, p, f, g, m, A, v, y, w, b = n(8971), x = n(5169);
            class S {
                constructor(e) {
                    d.add(this),
                    p.set(this, void 0),
                    f.set(this, x.A.Summer),
                    g.set(this, void 0),
                    m.set(this, void 0),
                    A.set(this, void 0),
                    v.set(this, null),
                    (0,
                    s.GG)(this, p, e, "f"),
                    (0,
                    s.GG)(this, g, new o.G_z({
                        depthWrite: !1
                    }), "f"),
                    e.addMaterial((0,
                    s.gn)(this, g, "f")),
                    (0,
                    s.GG)(this, m, new o.G_z, "f"),
                    e.addMaterial((0,
                    s.gn)(this, m, "f"));
                    (0,
                    s.GG)(this, A, new o.eaF(new o.bdM(6 * l.A.maxViewDistance,6 * l.A.maxViewDistance,10,10),(0,
                    s.gn)(this, g, "f")), "f"),
                    (0,
                    s.gn)(this, A, "f").rotation.x = -Math.PI / 2,
                    (0,
                    s.gn)(this, A, "f").renderOrder = -2,
                    (0,
                    s.gn)(this, A, "f").receiveShadow = !0,
                    e.scene.add((0,
                    s.gn)(this, A, "f")),
                    (0,
                    s.gn)(this, d, "m", w).call(this, x.A.Summer)
                }
                clearMountains() {
                    null != (0,
                    s.gn)(this, v, "f") && ((0,
                    s.gn)(this, v, "f").material.dispose(),
                    (0,
                    s.gn)(this, v, "f").geometry.dispose(),
                    (0,
                    s.gn)(this, p, "f").scene.remove((0,
                    s.gn)(this, v, "f")),
                    (0,
                    s.GG)(this, v, null, "f"))
                }
                generateMountains(e) {
                    this.clearMountains();
                    const {vertices: t, offset: n} = u.createMountainVertices(e)
                      , i = new o.LoY;
                    i.setAttribute("position", new o.THS(new Float32Array(t),3)),
                    i.computeVertexNormals();
                    const r = new o.eaF(i,(0,
                    s.gn)(this, m, "f"));
                    r.position.copy(n),
                    r.receiveShadow = !0,
                    (0,
                    s.gn)(this, p, "f").scene.add(r),
                    (0,
                    s.GG)(this, v, r, "f")
                }
                static createMountainVertices(e) {
                    const t = new h
                      , n = Math.max(200, 160 + Math.max(Math.abs(e.max.x - e.min.x) * b.A.partSize / 2 * Math.SQRT2, Math.abs(e.max.y - e.min.y) * b.A.partSize / 2 * Math.SQRT2))
                      , i = new o.I9Y((e.min.x + (e.max.x - e.min.x) / 2) * b.A.partSize,(e.min.y + (e.max.y - e.min.y) / 2) * b.A.partSize);
                    if (n > 4500)
                        return {
                            vertices: [],
                            offset: new o.Pq0
                        };
                    const r = Math.floor(n / 10)
                      , a = [];
                    for (let e = 0; e < r; ++e) {
                        const e = [];
                        for (let n = 0; n < 8; ++n)
                            0 == n || 7 == n || 1 == n && t.next() < .5 ? e.push(0) : e.push(t.next());
                        a.push(e)
                    }
                    const s = 100
                      , l = [];
                    for (let e = 0; e < a.length; ++e) {
                        const t = e / a.length * Math.PI * 2
                          , i = (e + 1) / a.length * Math.PI * 2
                          , r = a[e];
                        let o;
                        o = e + 1 < a.length ? a[e + 1] : a[0];
                        for (let e = 0; e < r.length - 1; ++e) {
                            const a = n + 100 * e
                              , c = n + 100 * (e + 1);
                            l.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                            l.push(Math.cos(i) * a, o[e] * s, Math.sin(i) * a),
                            l.push(Math.cos(i) * c, o[e + 1] * s, Math.sin(i) * c),
                            l.push(Math.cos(t) * a, r[e] * s, Math.sin(t) * a),
                            l.push(Math.cos(i) * c, o[e + 1] * s, Math.sin(i) * c),
                            l.push(Math.cos(t) * c, r[e + 1] * s, Math.sin(t) * c)
                        }
                    }
                    return {
                        vertices: l,
                        offset: new o.Pq0(i.x,0,i.y)
                    }
                }
                getMountainVertices() {
                    if (null == (0,
                    s.gn)(this, v, "f"))
                        return [];
                    const e = (0,
                    s.gn)(this, v, "f").geometry;
                    if (!(e.attributes.position instanceof o.THS))
                        throw new Error("Vertices must use BufferAttribute");
                    return Array.from(e.attributes.position.array)
                }
                getMountainOffset() {
                    return null == (0,
                    s.gn)(this, v, "f") ? new o.Pq0 : (0,
                    s.gn)(this, v, "f").position.clone()
                }
                update(e) {
                    e.environment != (0,
                    s.gn)(this, f, "f") && (0,
                    s.gn)(this, d, "m", w).call(this, e.environment);
                    const t = new o.Pq0
                      , n = new o.PTz
                      , i = new o.Pq0;
                    (0,
                    s.gn)(this, p, "f").camera.matrix.decompose(t, n, i),
                    (0,
                    s.gn)(this, A, "f").position.set(t.x, 0, t.z)
                }
            }
            u = S,
            p = new WeakMap,
            f = new WeakMap,
            g = new WeakMap,
            m = new WeakMap,
            A = new WeakMap,
            v = new WeakMap,
            d = new WeakSet,
            y = function(e) {
                let t;
                switch (e) {
                case x.A.Summer:
                    t = new o.Q1f(3495480);
                    break;
                case x.A.Winter:
                    t = new o.Q1f(11053224);
                    break;
                case x.A.Desert:
                    t = new o.Q1f(11171394)
                }
                return t
            }
            ,
            w = function(e) {
                (0,
                s.GG)(this, f, e, "f");
                const t = (0,
                s.gn)(u, u, "m", y).call(u, e);
                (0,
                s.gn)(this, g, "f").color.copy(t),
                (0,
                s.gn)(this, m, "f").color.copy(t)
            }
            ;
            const E = S
        }
        ,
        9570: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/preview.svg"
        }
        ,
        9681: (e, t, n) => {
            "use strict";
            n.d(t, {
                U: () => f,
                _: () => p
            });
            var i = n(3075)
              , r = n(7415)
              , a = n(8438)
              , s = n(2203)
              , o = n(4183)
              , l = n(5169)
              , c = n(8566)
              , h = n(7680)
              , d = n(405);
            function u(e, t) {
                let n = e;
                if (t.length - n < 1)
                    return null;
                const i = t[n];
                if (n += 1,
                !(i in l.A))
                    return null;
                if (t.length - n < 1)
                    return null;
                const r = t[n];
                if (n += 1,
                !Number.isSafeInteger(r) || r < 0 || r >= 180)
                    return null;
                const u = new a.A(i,new h.A(r));
                if (t.length - n < 9)
                    return null;
                const p = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const f = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const g = t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                n += 4;
                const m = 3 & t[n]
                  , A = t[n] >> 2 & 3
                  , v = t[n] >> 4 & 3;
                if (n += 1,
                m < 1 || m > 4 || A < 1 || A > 4 || v < 1 || v > 4)
                    return null;
                for (; n < t.length; ) {
                    if (t.length - n < 1)
                        return null;
                    const e = t[n + 0];
                    if (n += 1,
                    !(e in s.A))
                        return null;
                    if (t.length - n < 4)
                        return null;
                    const i = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24;
                    n += 4;
                    for (let r = 0; r < i; ++r) {
                        if (t.length - n < m)
                            return null;
                        let i = 0;
                        for (let e = 0; e < m; ++e)
                            i |= t[n + e] << 8 * e;
                        if (i += p,
                        n += m,
                        t.length - n < A)
                            return null;
                        let r = 0;
                        for (let e = 0; e < A; ++e)
                            r |= t[n + e] << 8 * e;
                        if (r += f,
                        n += A,
                        t.length - n < v)
                            return null;
                        let a = 0;
                        for (let e = 0; e < v; ++e)
                            a |= t[n + e] << 8 * e;
                        if (a += g,
                        n += v,
                        t.length - n < 1)
                            return null;
                        const s = t[n];
                        n += 1;
                        const l = 3 & s;
                        if (l < 0 || l > 3)
                            return null;
                        const h = s >> 2 & 7;
                        if (!(h in c.A))
                            return null;
                        if (t.length - n < 1)
                            return null;
                        const y = t[n + 0];
                        if (n += 1,
                        !(y in o.A))
                            return null;
                        let w = null;
                        if (d.bK.includes(e)) {
                            if (t.length - n < 2)
                                return null;
                            w = t[n + 0] | t[n + 1] << 8,
                            n += 2
                        }
                        let b = null;
                        if (d.l1.includes(e)) {
                            if (t.length - n < 4)
                                return null;
                            b = t[n + 0] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24,
                            n += 4
                        }
                        u.addPart(i, r, a, e, l, h, y, w, b)
                    }
                }
                return u
            }
            function p(e) {
                const t = r.D(e);
                if (null == t)
                    return null;
                const n = new i.Ay.Inflate({
                    to: "string"
                });
                if (n.push(t, !0),
                n.err)
                    return null;
                const a = n.result;
                if ("string" != typeof a)
                    return null;
                const s = r.D(a);
                if (null == s)
                    return null;
                const o = new i.Ay.Inflate;
                if (o.push(s, !0),
                o.err)
                    return null;
                const l = o.result;
                return l instanceof Uint8Array ? u(0, l) : null
            }
            function f(e) {
                const t = "PolyTrack2";
                if (!e.startsWith(t))
                    return null;
                const n = r.D(e.substring(10));
                if (null == n)
                    return null;
                const a = new i.Ay.Inflate({
                    to: "string"
                });
                if (a.push(n, !0),
                a.err)
                    return null;
                const s = a.result;
                if ("string" != typeof s)
                    return null;
                const o = r.D(s);
                if (null == o)
                    return null;
                const l = new i.Ay.Inflate;
                if (l.push(o, !0),
                l.err)
                    return null;
                const c = l.result;
                if (!(c instanceof Uint8Array))
                    return null;
                let h = 0;
                if (c.length < h + 1)
                    return null;
                const d = c[h];
                if (h += 1,
                c.length < h + d)
                    return null;
                const p = new TextDecoder("utf-8").decode(c.subarray(h, h + d));
                if (h += d,
                c.length < h + 1)
                    return null;
                const f = c[h];
                let g;
                if (h += 1,
                f > 0) {
                    if (c.length < h + f)
                        return null;
                    g = new TextDecoder("utf-8").decode(c.subarray(h, h + f)),
                    h += f
                } else
                    g = null;
                if (c.length < h + 1)
                    return null;
                const m = c[h];
                let A;
                if (h += 1,
                0 == m)
                    A = null;
                else {
                    if (1 != m)
                        return null;
                    {
                        if (c.length < h + 4)
                            return null;
                        const e = c[h + 0] | c[h + 1] << 8 | c[h + 2] << 16 | c[h + 3] << 24;
                        h += 4,
                        A = new Date(1e3 * e)
                    }
                }
                const v = u(h, c);
                return null == v ? null : {
                    trackMetadata: {
                        name: p,
                        author: g,
                        lastModified: A
                    },
                    trackData: v
                }
            }
        }
        ,
        9708: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/pause.svg"
        }
        ,
        9782: (e, t, n) => {
            "use strict";
            n.d(t, {
                A: () => o
            });
            var i = n(1601)
              , r = n.n(i)
              , a = n(6314)
              , s = n.n(a)()(r());
            s.push([e.id, ".server-message-ui {\n\tposition: absolute;\n\tright: 0;\n\ttop: 0;\n\tmargin: 4px;\n\tcolor: var(--text-color);\n\tfont-size: 28px;\n\tfont-weight: normal;\n\ttext-shadow: 1px 1px 1px var(--surface-color), -1px 1px 1px var(--surface-color), -1px -1px 1px var(--surface-color), 1px -1px 1px var(--surface-color);\n}\n.server-message-ui.down {\n\ttop: initial;\n\tbottom: 0;\n}\n", ""]);
            const o = s
        }
        ,
        9809: (e, t, n) => {
            "use strict";
            e.exports = n.p + "images/checkmark.svg"
        }
    }, n = {};
    function i(e) {
        var r = n[e];
        if (void 0 !== r)
            return r.exports;
        var a = n[e] = {
            id: e,
            exports: {}
        };
        return t[e](a, a.exports, i),
        a.exports
    }
    i.m = t,
    i.amdO = {},
    i.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return i.d(t, {
            a: t
        }),
        t
    }
    ,
    i.d = (e, t) => {
        for (var n in t)
            i.o(t, n) && !i.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
    }
    ,
    i.f = {},
    i.e = e => Promise.all(Object.keys(i.f).reduce(( (t, n) => (i.f[n](e, t),
    t)), [])),
    i.u = e => e + ".bundle.js",
    i.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    e = {},
    i.l = (t, n, r, a) => {
        if (e[t])
            e[t].push(n);
        else {
            var s, o;
            if (void 0 !== r)
                for (var l = document.getElementsByTagName("script"), c = 0; c < l.length; c++) {
                    var h = l[c];
                    if (h.getAttribute("src") == t) {
                        s = h;
                        break
                    }
                }
            s || (o = !0,
            (s = document.createElement("script")).charset = "utf-8",
            i.nc && s.setAttribute("nonce", i.nc),
            s.src = t),
            e[t] = [n];
            var d = (n, i) => {
                s.onerror = s.onload = null,
                clearTimeout(u);
                var r = e[t];
                if (delete e[t],
                s.parentNode && s.parentNode.removeChild(s),
                r && r.forEach((e => e(i))),
                n)
                    return n(i)
            }
              , u = setTimeout(d.bind(null, void 0, {
                type: "timeout",
                target: s
            }), 12e4);
            s.onerror = d.bind(null, s.onerror),
            s.onload = d.bind(null, s.onload),
            o && document.head.appendChild(s)
        }
    }
    ,
    ( () => {
        var e;
        i.g.importScripts && (e = i.g.location + "");
        var t = i.g.document;
        if (!e && t && (t.currentScript && "SCRIPT" === t.currentScript.tagName.toUpperCase() && (e = t.currentScript.src),
        !e)) {
            var n = t.getElementsByTagName("script");
            if (n.length)
                for (var r = n.length - 1; r > -1 && (!e || !/^http(s?):/.test(e)); )
                    e = n[r--].src
        }
        if (!e)
            throw new Error("Automatic publicPath is not supported in this browser");
        e = e.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
        i.p = e
    }
    )(),
    ( () => {
        i.b = "undefined" != typeof document && document.baseURI || self.location.href;
        var e = {
            792: 0
        };
        i.f.j = (t, n) => {
            var r = i.o(e, t) ? e[t] : void 0;
            if (0 !== r)
                if (r)
                    n.push(r[2]);
                else {
                    var a = new Promise(( (n, i) => r = e[t] = [n, i]));
                    n.push(r[2] = a);
                    var s = i.p + i.u(t)
                      , o = new Error;
                    i.l(s, (n => {
                        if (i.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0),
                        r)) {
                            var a = n && ("load" === n.type ? "missing" : n.type)
                              , s = n && n.target && n.target.src;
                            o.message = "Loading chunk " + t + " failed.\n(" + a + ": " + s + ")",
                            o.name = "ChunkLoadError",
                            o.type = a,
                            o.request = s,
                            r[1](o)
                        }
                    }
                    ), "chunk-" + t, t)
                }
        }
        ;
        var t = (t, n) => {
            var r, a, [s,o,l] = n, c = 0;
            if (s.some((t => 0 !== e[t]))) {
                for (r in o)
                    i.o(o, r) && (i.m[r] = o[r]);
                if (l)
                    l(i)
            }
            for (t && t(n); c < s.length; c++)
                a = s[c],
                i.o(e, a) && e[a] && e[a][0](),
                e[a] = 0
        }
          , n = self.webpackChunk = self.webpackChunk || [];
        n.forEach(t.bind(null, 0)),
        n.push = t.bind(null, n.push.bind(n))
    }
    )(),
    i.nc = void 0,
    ( () => {
        "use strict";
        var e = i(5072)
          , t = i.n(e)
          , n = i(7825)
          , r = i.n(n)
          , a = i(7659)
          , s = i.n(a)
          , o = i(5056)
          , l = i.n(o)
          , c = i(540)
          , h = i.n(c)
          , d = i(1113)
          , u = i.n(d)
          , p = i(8419)
          , f = {};
        f.styleTagTransform = u(),
        f.setAttributes = l(),
        f.insert = s().bind(null, "head"),
        f.domAPI = r(),
        f.insertStyleElement = h();
        t()(p.A, f);
        p.A && p.A.locals && p.A.locals;
        var g = i(6546);
        const m = (0,
        g.F3)("App", {
            web: () => i.e(168).then(i.bind(i, 1168)).then((e => new e.AppWeb))
        });
        var A, v, y, w, b, x, S, E, T, k, M, _, C = i(4922), R = i(1635), P = i(3476), I = i(243);
        v = new WeakMap,
        y = new WeakMap,
        w = new WeakMap,
        b = new WeakMap,
        x = new WeakMap,
        S = new WeakMap,
        E = new WeakMap,
        A = new WeakSet,
        T = function e(t, n) {
            const i = this.context;
            if (null == i)
                n(null);
            else if (0 == t.length)
                n(null);
            else {
                const r = t[0]
                  , a = new XMLHttpRequest;
                a.open("GET", r, !0),
                a.responseType = "arraybuffer",
                a.onload = () => {
                    i.decodeAudioData(a.response).then((e => {
                        n(e)
                    }
                    )).catch(( () => {
                        (0,
                        R.gn)(this, A, "m", e).call(this, t.slice(1), n)
                    }
                    ))
                }
                ,
                a.send()
            }
        }
        ,
        k = function() {
            null != (0,
            R.gn)(this, E, "f") && (!this.isAppActive || I.ip() || I.g_() ? (0,
            R.gn)(this, E, "f").gain.setTargetAtTime(0, 0, .1) : (0,
            R.gn)(this, E, "f").gain.setTargetAtTime((0,
            R.gn)(this, y, "f").getSettingFloat(P.A.MasterVolume), 0, .1))
        }
        ,
        M = function() {
            let e = Math.min(Math.max((0,
            R.gn)(this, y, "f").getSettingFloat(P.A.SoundEffectVolume), 0), 1);
            Number.isNaN(e) && (e = 0),
            null == (0,
            R.gn)(this, S, "f") && null != this.context && null != this.destinationMaster ? ((0,
            R.GG)(this, S, this.context.createGain(), "f"),
            (0,
            R.gn)(this, S, "f").gain.value = e,
            (0,
            R.gn)(this, S, "f").connect(this.destinationMaster)) : (0,
            R.gn)(this, S, "f")?.gain.setTargetAtTime(e, 0, .1)
        }
        ,
        _ = function(e, t) {
            if (t && (0,
            R.gn)(this, v, "f").hasLoaded()) {
                if (null == (0,
                R.gn)(this, b, "f")) {
                    const e = this.getBuffer("music");
                    if (null != e && null != this.context && null != this.destinationMaster) {
                        const t = this.context.createBufferSource();
                        t.buffer = e,
                        t.loop = !0;
                        const n = this.context.createGain();
                        n.gain.value = 0,
                        t.connect(n),
                        n.connect(this.destinationMaster),
                        t.start(0),
                        (0,
                        R.GG)(this, b, {
                            source: t,
                            gain: n
                        }, "f")
                    }
                } else {
                    let e = Math.min(Math.max((0,
                    R.gn)(this, y, "f").getSettingFloat(P.A.MusicVolume), 0), 1);
                    Number.isNaN(e) && (e = 0),
                    (0,
                    R.gn)(this, b, "f").gain.gain.setTargetAtTime(.25 * e, 0, .5)
                }
                (0,
                R.GG)(this, x, 0, "f")
            } else
                null != (0,
                R.gn)(this, b, "f") && ((0,
                R.gn)(this, b, "f").gain.gain.setTargetAtTime(0, 0, .5),
                (0,
                R.gn)(this, x, "f") >= 5 ? ((0,
                R.gn)(this, b, "f").source.stop(),
                (0,
                R.GG)(this, b, null, "f")) : (0,
                R.GG)(this, x, (0,
                R.gn)(this, x, "f") + e, "f"))
        }
        ;
        const L = class {
            constructor(e, t) {
                A.add(this),
                v.set(this, void 0),
                y.set(this, void 0),
                this.context = null,
                w.set(this, new Map),
                b.set(this, null),
                x.set(this, 0),
                S.set(this, null),
                E.set(this, null),
                this.isAppActive = !0,
                (0,
                R.GG)(this, v, e, "f"),
                (0,
                R.GG)(this, y, t, "f");
                try {
                    const e = new (window.AudioContext || window.webkitAudioContext);
                    if ("running" != e.state) {
                        const t = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "pointerup", "touchend", "keydown", "keyup"]
                          , n = () => {
                            e.resume().catch((e => {
                                console.error(e)
                            }
                            ));
                            for (const e of t)
                                window.removeEventListener(e, n)
                        }
                        ;
                        for (const e of t)
                            window.addEventListener(e, n)
                    }
                    this.context = e
                } catch (e) {
                    this.context = null,
                    console.error("Failed to create audio context: ", e)
                }
                null != this.context ? ((0,
                R.GG)(this, E, this.context.createGain(), "f"),
                (0,
                R.gn)(this, E, "f").gain.value = (0,
                R.gn)(this, y, "f").getSettingFloat(P.A.MasterVolume),
                (0,
                R.gn)(this, E, "f").connect(this.context.destination)) : (0,
                R.GG)(this, E, null, "f")
            }
            get destinationSfx() {
                return (0,
                R.gn)(this, S, "f")
            }
            get destinationMaster() {
                return (0,
                R.gn)(this, E, "f")
            }
            load(e, t) {
                (0,
                R.gn)(this, v, "f").addResource(),
                (0,
                R.gn)(this, A, "m", T).call(this, t, (t => {
                    (0,
                    R.gn)(this, v, "f").loadedResource(),
                    null == t ? (console.warn('Audio "' + e + '" failed to load'),
                    (0,
                    R.gn)(this, w, "f").set(e, null)) : (0,
                    R.gn)(this, w, "f").set(e, t)
                }
                ))
            }
            getBuffer(e) {
                return null == this.context ? null : (0,
                R.gn)(this, w, "f").has(e) ? (0,
                R.gn)(this, w, "f").get(e) ?? null : null
            }
            playUIClick() {
                const e = this.getBuffer("click");
                if (null != e && null != this.context && null != this.destinationSfx) {
                    const t = this.context.createBufferSource();
                    t.buffer = e;
                    const n = this.context.createGain();
                    n.gain.value = .0075,
                    t.connect(n),
                    n.connect(this.destinationSfx),
                    t.start(0)
                }
            }
            refreshListener(e) {
                if (null != this.context) {
                    const t = new C.Pq0
                      , n = new C.PTz
                      , i = new C.Pq0;
                    e.camera.matrix.decompose(t, n, i);
                    const r = this.context.listener;
                    r.positionX && r.positionY && r.positionZ ? (r.positionX.value = t.x,
                    r.positionY.value = t.y,
                    r.positionZ.value = t.z) : r.setPosition(t.x, t.y, t.z);
                    const a = new C.Pq0(0,0,-1);
                    a.applyQuaternion(n);
                    const s = new C.Pq0(0,1,0);
                    s.applyQuaternion(n),
                    r.forwardX && r.forwardY && r.forwardZ && r.upX && r.upY && r.upZ ? (r.forwardX.value = a.x,
                    r.forwardY.value = a.y,
                    r.forwardZ.value = a.z,
                    r.upX.value = s.x,
                    r.upY.value = s.y,
                    r.upZ.value = s.z) : r.setOrientation(a.x, a.y, a.z, s.x, s.y, s.z)
                }
            }
            update(e, t, n) {
                this.refreshListener(n),
                (0,
                R.gn)(this, A, "m", k).call(this),
                (0,
                R.gn)(this, A, "m", M).call(this),
                (0,
                R.gn)(this, A, "m", _).call(this, e, t)
            }
        }
        ;
        var N = i(4078);
        const z = 2.718281828459045
          , U = 2.302585092994046
          , D = .6931471805599453
          , B = 1.4426950408889634
          , G = .4342944819032518
          , F = 3.141592653589793
          , O = .7071067811865476
          , W = 1.4142135623730951;
        function V(e) {
            throw new Error(e + ": Waiting for WASM to compile")
        }
        function H(e) {
            if (!Number.isFinite(e))
                return NaN;
            const t = (e = function(e) {
                return (e %= 2 * Math.PI) < 0 && (e += 2 * Math.PI),
                e
            }(e)) / (2 * Math.PI) * K.length
              , n = Math.floor(t)
              , i = (n + 1) % K.length
              , r = t - n;
            return K[n] * (1 - r) + K[i] * r
        }
        function j(e) {
            return Math.sin(e + Math.PI / 2)
        }
        Math = {
            E: z,
            LN10: U,
            LN2: D,
            LOG2E: B,
            LOG10E: G,
            PI: F,
            SQRT1_2: O,
            SQRT2: W,
            abs: Math.abs,
            acos: () => V("acos"),
            asin: () => V("asin"),
            atan: () => V("atan"),
            atan2: () => V("atan2"),
            ceil: Math.ceil,
            cos: j,
            exp: () => V("exp"),
            floor: Math.floor,
            log: () => V("log"),
            max: Math.max,
            min: Math.min,
            pow: () => V("pow"),
            random: Math.random,
            round: Math.round,
            sin: H,
            sqrt: () => V("sqrt"),
            tan: () => V("tan"),
            clz32: Math.clz32,
            imul: Math.imul,
            sign: Math.sign,
            log10: () => V("log10"),
            log2: () => V("log2"),
            log1p: e => Math.log(1 + e),
            expm1: e => Math.exp(e) - 1,
            cosh: e => (Math.exp(e) + Math.exp(-e)) / 2,
            sinh: e => (Math.exp(e) - Math.exp(-e)) / 2,
            tanh: e => {
                const t = Math.exp(2 * e);
                return (t - 1) / (t + 1)
            }
            ,
            acosh: e => Math.log(e + Math.sqrt(e * e - 1)),
            asinh: e => Math.log(e + Math.sqrt(e * e + 1)),
            atanh: e => Math.log((1 + e) / (1 - e)) / 2,
            hypot: (...e) => {
                let t = 0;
                for (const n of e)
                    t += n * n;
                return Math.sqrt(t)
            }
            ,
            trunc: Math.trunc,
            cbrt: e => e == 1 / 0 ? 1 / 0 : e == -1 / 0 ? -1 / 0 : e < 0 ? -Math.pow(-e, 1 / 3) : Math.pow(e, 1 / 3),
            fround: Math.fround,
            [Symbol.toStringTag]: "Math"
        };
        const K = [0, .01745240643728351, .03489949670250097, .05233595624294383, .0697564737441253, .08715574274765817, .10452846326765346, .12186934340514748, .13917310096006544, .15643446504023087, .17364817766693033, .1908089953765448, .20791169081775931, .22495105434386498, .24192189559966773, .25881904510252074, .27563735581699916, .2923717047227367, .3090169943749474, .3255681544571567, .3420201433256687, .35836794954530027, .374606593415912, .3907311284892737, .40673664307580015, .42261826174069944, .4383711467890774, .45399049973954675, .4694715627858908, .48480962024633706, .49999999999999994, .5150380749100542, .5299192642332049, .544639035015027, .5591929034707468, .573576436351046, .5877852522924731, .6018150231520483, .6156614753256583, .6293203910498375, .6427876096865393, .6560590289905073, .6691306063588582, .6819983600624985, .6946583704589973, .7071067811865475, .7193398003386511, .7313537016191705, .7431448254773942, .7547095802227719, .766044443118978, .7771459614569708, .7880107536067219, .7986355100472928, .8090169943749475, .8191520442889918, .8290375725550417, .8386705679454239, .848048096156426, .8571673007021122, .8660254037844386, .8746197071393957, .8829475928589269, .8910065241883678, .898794046299167, .9063077870366499, .9135454576426009, .9205048534524404, .9271838545667873, .9335804264972017, .9396926207859083, .9455185755993167, .9510565162951535, .9563047559630354, .9612616959383189, .9659258262890683, .9702957262759965, .9743700647852352, .9781476007338057, .981627183447664, .984807753012208, .9876883405951378, .9902680687415704, .992546151641322, .9945218953682733, .9961946980917455, .9975640502598242, .9986295347545738, .9993908270190958, .9998476951563913, 1, .9998476951563913, .9993908270190958, .9986295347545738, .9975640502598242, .9961946980917455, .9945218953682734, .9925461516413221, .9902680687415704, .9876883405951377, .984807753012208, .981627183447664, .9781476007338057, .9743700647852352, .9702957262759965, .9659258262890683, .9612616959383189, .9563047559630355, .9510565162951536, .9455185755993168, .9396926207859084, .9335804264972017, .9271838545667874, .9205048534524404, .913545457642601, .90630778703665, .8987940462991669, .8910065241883679, .8829475928589271, .8746197071393959, .8660254037844387, .8571673007021123, .8480480961564261, .8386705679454239, .8290375725550417, .819152044288992, .8090169943749475, .7986355100472927, .788010753606722, .777145961456971, .766044443118978, .7547095802227721, .7431448254773945, .7313537016191706, .7193398003386511, .7071067811865476, .6946583704589975, .6819983600624986, .669130606358858, .6560590289905073, .6427876096865395, .6293203910498374, .6156614753256584, .6018150231520486, .5877852522924732, .5735764363510459, .5591929034707469, .5446390350150273, .5299192642332049, .5150380749100544, .49999999999999994, .48480962024633717, .4694715627858907, .45399049973954686, .4383711467890777, .4226182617406995, .40673664307580004, .39073112848927377, .37460659341591224, .35836794954530066, .3420201433256689, .3255681544571566, .3090169943749475, .29237170472273705, .2756373558169992, .258819045102521, .24192189559966773, .2249510543438652, .20791169081775931, .19080899537654497, .1736481776669307, .15643446504023098, .13917310096006533, .12186934340514755, .10452846326765373, .0871557427476582, .06975647374412552, .05233595624294425, .03489949670250114, .01745240643728344, 12246467991473532e-32, -.017452406437283192, -.0348994967025009, -.052335956242943564, -.06975647374412483, -.08715574274765794, -.1045284632676535, -.12186934340514774, -.13917310096006552, -.15643446504023073, -.17364817766693047, -.19080899537654472, -.20791169081775907, -.22495105434386498, -.2419218955996675, -.25881904510252035, -.2756373558169986, -.29237170472273677, -.30901699437494773, -.32556815445715676, -.34202014332566866, -.35836794954530043, -.374606593415912, -.39073112848927355, -.4067366430757998, -.4226182617406993, -.43837114678907707, -.45399049973954625, -.4694715627858905, -.48480962024633734, -.5000000000000001, -.5150380749100542, -.5299192642332048, -.5446390350150271, -.5591929034707467, -.5735764363510458, -.587785252292473, -.601815023152048, -.6156614753256578, -.6293203910498372, -.6427876096865393, -.6560590289905074, -.6691306063588582, -.6819983600624984, -.6946583704589974, -.7071067811865475, -.7193398003386509, -.7313537016191705, -.743144825477394, -.7547095802227717, -.7660444431189779, -.7771459614569711, -.7880107536067221, -.7986355100472928, -.8090169943749473, -.8191520442889916, -.8290375725550414, -.838670567945424, -.848048096156426, -.8571673007021121, -.8660254037844384, -.8746197071393955, -.882947592858927, -.8910065241883678, -.8987940462991668, -.90630778703665, -.913545457642601, -.9205048534524403, -.9271838545667873, -.9335804264972016, -.9396926207859082, -.9455185755993168, -.9510565162951535, -.9563047559630353, -.961261695938319, -.9659258262890683, -.9702957262759965, -.9743700647852351, -.9781476007338056, -.981627183447664, -.984807753012208, -.9876883405951377, -.9902680687415703, -.992546151641322, -.9945218953682733, -.9961946980917455, -.9975640502598242, -.9986295347545739, -.9993908270190958, -.9998476951563913, -1, -.9998476951563913, -.9993908270190958, -.9986295347545739, -.9975640502598243, -.9961946980917455, -.9945218953682733, -.992546151641322, -.9902680687415704, -.9876883405951378, -.9848077530122081, -.9816271834476641, -.9781476007338056, -.9743700647852352, -.9702957262759966, -.9659258262890684, -.961261695938319, -.9563047559630354, -.9510565162951536, -.945518575599317, -.9396926207859083, -.9335804264972017, -.9271838545667874, -.9205048534524405, -.9135454576426011, -.9063077870366503, -.898794046299167, -.8910065241883679, -.8829475928589271, -.8746197071393956, -.8660254037844386, -.8571673007021123, -.8480480961564262, -.8386705679454243, -.8290375725550416, -.8191520442889918, -.8090169943749476, -.798635510047293, -.7880107536067223, -.7771459614569713, -.7660444431189781, -.7547095802227722, -.743144825477394, -.7313537016191703, -.7193398003386512, -.7071067811865477, -.6946583704589976, -.6819983600624989, -.6691306063588588, -.6560590289905074, -.6427876096865396, -.6293203910498372, -.6156614753256582, -.6018150231520483, -.5877852522924734, -.5735764363510465, -.5591929034707473, -.544639035015027, -.529919264233205, -.5150380749100545, -.5000000000000004, -.48480962024633767, -.4694715627858908, -.45399049973954697, -.4383711467890778, -.4226182617406992, -.40673664307580015, -.3907311284892739, -.37460659341591235, -.35836794954530077, -.34202014332566943, -.3255681544571567, -.3090169943749477, -.29237170472273716, -.27563735581699894, -.2588190451025207, -.24192189559966787, -.22495105434386534, -.20791169081775987, -.19080899537654467, -.1736481776669304, -.15643446504023112, -.13917310096006588, -.12186934340514811, -.1045284632676543, -.08715574274765832, -.06975647374412564, -.05233595624294348, -.034899496702500823, -.01745240643728356];
        var q = i(4344)
          , Q = {};
        Q.styleTagTransform = u(),
        Q.setAttributes = l(),
        Q.insert = s().bind(null, "head"),
        Q.domAPI = r(),
        Q.insertStyleElement = h();
        t()(q.A, Q);
        q.A && q.A.locals && q.A.locals;
        var J, X, Y, Z, $, ee, te;
        X = new WeakMap,
        Y = new WeakMap,
        Z = new WeakMap,
        $ = new WeakMap,
        ee = new WeakMap,
        J = new WeakSet,
        te = function() {
            if (null != (0,
            R.gn)(this, Y, "f")) {
                const e = "FPS: " + (0,
                R.gn)(this, ee, "f").toString();
                (0,
                R.gn)(this, Y, "f").textContent != e && ((0,
                R.gn)(this, Y, "f").textContent = e)
            }
        }
        ;
        const ne = class {
            constructor() {
                J.add(this),
                X.set(this, void 0),
                Y.set(this, null),
                Z.set(this, 0),
                $.set(this, 0),
                ee.set(this, 0);
                const e = document.getElementById("ui");
                if (null == e)
                    throw new Error("UI element not found");
                (0,
                R.GG)(this, X, e, "f")
            }
            show() {
                (0,
                R.GG)(this, Y, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Y, "f").className = "debug-ui",
                (0,
                R.gn)(this, X, "f").appendChild((0,
                R.gn)(this, Y, "f")),
                (0,
                R.gn)(this, J, "m", te).call(this)
            }
            hide() {
                null != (0,
                R.gn)(this, Y, "f") && ((0,
                R.gn)(this, X, "f").removeChild((0,
                R.gn)(this, Y, "f")),
                (0,
                R.GG)(this, Y, null, "f"))
            }
            toggle() {
                null != (0,
                R.gn)(this, Y, "f") ? this.hide() : this.show()
            }
            update(e) {
                (0,
                R.GG)(this, Z, (0,
                R.gn)(this, Z, "f") + e, "f"),
                (0,
                R.GG)(this, $, (0,
                R.gn)(this, $, "f") + 1, "f"),
                (0,
                R.gn)(this, Z, "f") >= 1 && ((0,
                R.GG)(this, ee, (0,
                R.gn)(this, $, "f"), "f"),
                (0,
                R.GG)(this, Z, (0,
                R.gn)(this, Z, "f") - Math.trunc((0,
                R.gn)(this, Z, "f")), "f"),
                (0,
                R.GG)(this, $, 0, "f"),
                (0,
                R.gn)(this, J, "m", te).call(this))
            }
        }
        ;
        var ie = i(7888)
          , re = i(927)
          , ae = i(5811)
          , se = {};
        se.styleTagTransform = u(),
        se.setAttributes = l(),
        se.insert = s().bind(null, "head"),
        se.domAPI = r(),
        se.insertStyleElement = h();
        t()(ae.A, se);
        ae.A && ae.A.locals && ae.A.locals;
        var oe, le, ce, he, de, ue;
        oe = new WeakMap,
        le = new WeakMap,
        ce = new WeakMap,
        he = new WeakMap,
        de = new WeakMap,
        ue = new WeakMap;
        const pe = class {
            constructor(e, t, n) {
                oe.set(this, void 0),
                le.set(this, void 0),
                ce.set(this, void 0),
                he.set(this, void 0),
                de.set(this, void 0),
                ue.set(this, null),
                (0,
                R.GG)(this, oe, e, "f"),
                (0,
                R.GG)(this, le, n, "f"),
                (0,
                R.GG)(this, ce, t, "f"),
                (0,
                R.GG)(this, he, document.createElement("div"), "f"),
                0 == (0,
                R.gn)(this, ce, "f") || "off" == n.getSetting(P.A.Checkpoints) ? "top" == n.getSetting(P.A.Checkpoints) ? (0,
                R.gn)(this, he, "f").className = "checkpoint-ui up" : (0,
                R.gn)(this, he, "f").className = "checkpoint-ui" : (0,
                R.gn)(this, he, "f").className = "hidden",
                (0,
                R.gn)(this, oe, "f").appendChild((0,
                R.gn)(this, he, "f"));
                const i = document.createElement("div");
                (0,
                R.gn)(this, he, "f").appendChild(i);
                const r = document.createElement("img");
                r.src = "images/checkpoint.svg",
                i.appendChild(r),
                (0,
                R.GG)(this, de, document.createElement("span"), "f"),
                i.appendChild((0,
                R.gn)(this, de, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, he, "f").parentElement == (0,
                R.gn)(this, oe, "f") && (0,
                R.gn)(this, oe, "f").removeChild((0,
                R.gn)(this, he, "f"))
            }
            setOverridePosition(e) {
                const t = (0,
                R.gn)(this, le, "f").getSetting(P.A.Checkpoints);
                0 == (0,
                R.gn)(this, ce, "f") || "off" == t ? (0,
                R.gn)(this, he, "f").className = "hidden" : (0,
                R.gn)(this, he, "f").className = e ?? "top" == t ? "checkpoint-ui up" : "checkpoint-ui"
            }
            setBottomOffset(e) {
                (0,
                R.gn)(this, he, "f").style.bottom = e.toString() + "px"
            }
            update(e) {
                const t = e.getNextCheckpointIndex().toString() + "/" + (0,
                R.gn)(this, ce, "f").toString();
                t != (0,
                R.gn)(this, ue, "f") && ((0,
                R.gn)(this, de, "f").textContent = t,
                (0,
                R.GG)(this, ue, t, "f"))
            }
        }
        ;
        var fe = i(6104)
          , ge = {};
        ge.styleTagTransform = u(),
        ge.setAttributes = l(),
        ge.insert = s().bind(null, "head"),
        ge.domAPI = r(),
        ge.insertStyleElement = h();
        t()(fe.A, ge);
        fe.A && fe.A.locals && fe.A.locals;
        var me = i(5818);
        const Ae = new Map([["ArrowUp", "Arrow Up"], ["ArrowDown", "Arrow Down"], ["ArrowLeft", "Arrow Left"], ["ArrowRight", "Arrow Right"], ["ShiftLeft", "Shift Left"], ["ShiftRight", "Shift Right"], ["ControlLeft", "Control Left"], ["ControlRight", "Control Right"], ["AltLeft", "Alt Left"], ["AltRight", "Alt Right"], ["CapsLock", "Caps Lock"], ["ScrollLock", "Scroll Lock"], ["PageUp", "Page Up"], ["PageDown", "Page Down"], ["Equal", "="], ["BracketLeft", "["], ["BracketRight", "]"], ["Semicolon", ";"], ["Quote", "'"], ["Backquote", "`"], ["Backslash", "\\"], ["Comma", ","], ["Period", "."], ["Slash", "/"], ["KeyA", "A"], ["KeyB", "B"], ["KeyC", "C"], ["KeyD", "D"], ["KeyE", "E"], ["KeyF", "F"], ["KeyG", "G"], ["KeyH", "H"], ["KeyI", "I"], ["KeyJ", "J"], ["KeyK", "K"], ["KeyL", "L"], ["KeyM", "M"], ["KeyN", "N"], ["KeyO", "O"], ["KeyP", "P"], ["KeyQ", "Q"], ["KeyR", "R"], ["KeyS", "S"], ["KeyT", "T"], ["KeyU", "U"], ["KeyV", "V"], ["KeyW", "W"], ["KeyX", "X"], ["KeyY", "Y"], ["KeyZ", "Z"], ["Digit0", "0"], ["Digit1", "1"], ["Digit2", "2"], ["Digit3", "3"], ["Digit4", "4"], ["Digit5", "5"], ["Digit6", "6"], ["Digit7", "7"], ["Digit8", "8"], ["Digit9", "9"], ["NumpadMultiply", "Numpad *"], ["NumpadAdd", "Numpad +"], ["NumpadSubtract", "Numpad -"], ["NumpadDivide", "Numpad /"], ["NumpadDecimal", "Numpad ."], ["NumpadEqual", "Numpad ="], ["Numpad0", "Numpad 0"], ["Numpad1", "Numpad 1"], ["Numpad2", "Numpad 2"], ["Numpad3", "Numpad 3"], ["Numpad4", "Numpad 4"], ["Numpad5", "Numpad 5"], ["Numpad6", "Numpad 6"], ["Numpad7", "Numpad 7"], ["Numpad8", "Numpad 8"], ["Numpad9", "Numpad 9"]]);
        function ve(e) {
            const t = Ae.get(e);
            return null != t ? t : e
        }
        var ye, we, be, xe, Se, Ee, Te, ke, Me, _e, Ce, Re;
        we = new WeakMap,
        be = new WeakMap,
        xe = new WeakMap,
        Se = new WeakMap,
        Ee = new WeakMap,
        Te = new WeakMap,
        ke = new WeakMap,
        Me = new WeakMap,
        _e = new WeakMap,
        ye = new WeakSet,
        Ce = function() {
            (0,
            R.GG)(this, Me, 2.5, "f"),
            (0,
            R.gn)(this, Ee, "f").className = "hint-ui hide"
        }
        ,
        Re = function() {
            (0,
            R.GG)(this, Me, 2.5, "f"),
            (0,
            R.gn)(this, Ee, "f").className = "hint-ui"
        }
        ;
        const Pe = class {
            constructor(e, t, n, i) {
                ye.add(this),
                we.set(this, void 0),
                be.set(this, void 0),
                xe.set(this, void 0),
                Se.set(this, void 0),
                Ee.set(this, void 0),
                Te.set(this, void 0),
                ke.set(this, void 0),
                Me.set(this, 2.5),
                _e.set(this, void 0),
                (0,
                R.GG)(this, we, e, "f"),
                (0,
                R.GG)(this, be, t, "f"),
                (0,
                R.GG)(this, xe, n, "f"),
                (0,
                R.GG)(this, Se, i, "f"),
                (0,
                R.GG)(this, Ee, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ee, "f").className = "hint-ui",
                (0,
                R.gn)(this, we, "f").appendChild((0,
                R.gn)(this, Ee, "f")),
                (0,
                R.GG)(this, Te, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Te, "f").className = "title",
                (0,
                R.gn)(this, Ee, "f").appendChild((0,
                R.gn)(this, Te, "f")),
                (0,
                R.GG)(this, ke, document.createElement("div"), "f"),
                (0,
                R.gn)(this, ke, "f").className = "subtitle",
                (0,
                R.gn)(this, Ee, "f").appendChild((0,
                R.gn)(this, ke, "f")),
                (0,
                R.GG)(this, _e, ( () => {
                    (0,
                    R.gn)(this, ye, "m", Re).call(this)
                }
                ), "f"),
                (0,
                R.gn)(this, xe, "f").addChangeListener((0,
                R.gn)(this, _e, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, we, "f").removeChild((0,
                R.gn)(this, Ee, "f")),
                (0,
                R.gn)(this, xe, "f").removeChangeListener((0,
                R.gn)(this, _e, "f"))
            }
            update(e, t, n) {
                if (e.hasStarted() && !e.getControls().reset && n && (0,
                R.gn)(this, Se, "f").getSettingBoolean(P.A.ResetHintEnabled))
                    if (e.getSpeedKmh() < 50 || e.hasFinished()) {
                        if (0 != (0,
                        R.gn)(this, Me, "f") && ((0,
                        R.GG)(this, Me, (0,
                        R.gn)(this, Me, "f") - t, "f"),
                        (0,
                        R.gn)(this, Me, "f") <= 0)) {
                            if ((0,
                            R.gn)(this, xe, "f").touchEnabled)
                                (0,
                                R.gn)(this, Te, "f").textContent = (0,
                                R.gn)(this, be, "f").get("Reset once to return to the last checkpoint"),
                                (0,
                                R.gn)(this, ke, "f").textContent = (0,
                                R.gn)(this, be, "f").get("Reset again to start over"),
                                (0,
                                R.gn)(this, Ee, "f").className = "hint-ui show";
                            else {
                                const e = (0,
                                R.gn)(this, Se, "f").getKeyBindings(me.A.VehicleCheckpointReset).filter((e => null != e))
                                  , t = (0,
                                R.gn)(this, Se, "f").getKeyBindings(me.A.VehicleStartReset).filter((e => null != e));
                                let n = null
                                  , i = null;
                                if (e.length > 0 ? (n = (0,
                                R.gn)(this, Te, "f"),
                                i = (0,
                                R.gn)(this, ke, "f")) : (n = (0,
                                R.gn)(this, ke, "f"),
                                i = (0,
                                R.gn)(this, Te, "f")),
                                e.length > 0) {
                                    const t = (0,
                                    R.gn)(this, be, "f").get("Press {0} to return to the last checkpoint").split("{0}");
                                    if (2 == t.length) {
                                        n.textContent = t[0];
                                        for (const t of e) {
                                            const i = document.createElement("div");
                                            i.className = "key-binding",
                                            i.textContent = ve(t),
                                            n.appendChild(i),
                                            t != e[e.length - 1] && n.appendChild(document.createTextNode(" / "))
                                        }
                                        n.appendChild(document.createTextNode(t[1]))
                                    }
                                }
                                if (t.length > 0) {
                                    const e = (0,
                                    R.gn)(this, be, "f").get("Press {0} to start over").split("{0}");
                                    if (2 == e.length) {
                                        i.textContent = e[0];
                                        for (const e of t) {
                                            const n = document.createElement("div");
                                            n.className = "key-binding",
                                            n.textContent = ve(e),
                                            i.appendChild(n),
                                            e != t[t.length - 1] && i.appendChild(document.createTextNode(" / "))
                                        }
                                        i.appendChild(document.createTextNode(e[1]))
                                    }
                                }
                                (0,
                                R.gn)(this, Ee, "f").className = "hint-ui show"
                            }
                            (0,
                            R.GG)(this, Me, 0, "f")
                        }
                    } else
                        (0,
                        R.gn)(this, ye, "m", Ce).call(this);
                else
                    (0,
                    R.gn)(this, ye, "m", Re).call(this)
            }
        }
        ;
        var Ie = i(6850)
          , Le = {};
        Le.styleTagTransform = u(),
        Le.setAttributes = l(),
        Le.insert = s().bind(null, "head"),
        Le.domAPI = r(),
        Le.insertStyleElement = h();
        t()(Ie.A, Le);
        Ie.A && Ie.A.locals && Ie.A.locals;
        var Ne, ze, Ue, De, Be, Ge, Fe, Oe, We;
        Ne = new WeakMap,
        ze = new WeakMap,
        Ue = new WeakMap,
        De = new WeakMap,
        Be = new WeakMap,
        Ge = new WeakMap,
        Fe = new WeakMap,
        Oe = new WeakMap,
        We = new WeakMap;
        const Ve = class {
            constructor(e, t) {
                Ne.set(this, void 0),
                ze.set(this, void 0),
                Ue.set(this, void 0),
                De.set(this, void 0),
                Be.set(this, void 0),
                Ge.set(this, null),
                Fe.set(this, void 0),
                Oe.set(this, void 0),
                We.set(this, []),
                (0,
                R.GG)(this, Ne, e, "f"),
                (0,
                R.GG)(this, ze, t, "f"),
                (0,
                R.GG)(this, Fe, t.getSettingBoolean(P.A.ImperialUnitsEnabled), "f"),
                (0,
                R.GG)(this, Ue, document.createElement("div"), "f"),
                "off" == t.getSetting(P.A.Speedometer) ? (0,
                R.gn)(this, Ue, "f").className = "speedometer-ui hidden" : "top" == t.getSetting(P.A.Speedometer) ? (0,
                R.gn)(this, Ue, "f").className = "speedometer-ui up" : (0,
                R.gn)(this, Ue, "f").className = "speedometer-ui",
                (0,
                R.gn)(this, Ne, "f").appendChild((0,
                R.gn)(this, Ue, "f")),
                (0,
                R.GG)(this, Oe, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Oe, "f").className = "checkpoint-speed",
                (0,
                R.gn)(this, Ue, "f").appendChild((0,
                R.gn)(this, Oe, "f"));
                const n = document.createElement("div");
                n.className = "box",
                (0,
                R.gn)(this, Ue, "f").appendChild(n);
                const i = document.createElement("div");
                i.className = "container",
                n.appendChild(i),
                (0,
                R.GG)(this, De, document.createElement("span"), "f"),
                (0,
                R.gn)(this, De, "f").textContent = "0",
                i.appendChild((0,
                R.gn)(this, De, "f")),
                (0,
                R.GG)(this, Be, document.createElement("span"), "f"),
                (0,
                R.gn)(this, Fe, "f") ? (0,
                R.gn)(this, Be, "f").textContent = "mph" : (0,
                R.gn)(this, Be, "f").textContent = "km/h",
                i.appendChild((0,
                R.gn)(this, Be, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Ue, "f").parentElement == (0,
                R.gn)(this, Ne, "f") && (0,
                R.gn)(this, Ne, "f").removeChild((0,
                R.gn)(this, Ue, "f"))
            }
            setOverridePosition(e) {
                const t = (0,
                R.gn)(this, ze, "f").getSetting(P.A.Speedometer);
                (0,
                R.gn)(this, Ue, "f").className = "off" == t ? "speedometer-ui hidden" : e ?? "top" == t ? "speedometer-ui up" : "speedometer-ui"
            }
            setBottomOffset(e) {
                (0,
                R.gn)(this, Ue, "f").style.bottom = e.toString() + "px"
            }
            hideCheckpointSpeed() {
                for (const e of (0,
                R.gn)(this, We, "f"))
                    e.cancel();
                (0,
                R.gn)(this, We, "f").length = 0
            }
            showCheckpointSpeed(e, t) {
                const n = e - t;
                let i, r;
                i = (0,
                R.gn)(this, Fe, "f") ? n / 1.609344 : n,
                i = Math.abs(i) >= 1 ? Math.trunc(i) : Math.abs(i) >= .1 ? Math.trunc(10 * i) / 10 : Math.abs(i) >= .01 ? Math.trunc(100 * i) / 100 : Math.trunc(1e3 * i) / 1e3,
                r = (0,
                R.gn)(this, Fe, "f") ? "mph" : "km/h",
                i < 0 ? ((0,
                R.gn)(this, Oe, "f").classList.add("red"),
                (0,
                R.gn)(this, Oe, "f").classList.remove("green"),
                (0,
                R.gn)(this, Oe, "f").textContent = i.toString() + " " + r) : ((0,
                R.gn)(this, Oe, "f").classList.remove("red"),
                (0,
                R.gn)(this, Oe, "f").classList.add("green"),
                (0,
                R.gn)(this, Oe, "f").textContent = "+" + i.toString() + " " + r),
                (0,
                R.gn)(this, We, "f").push((0,
                R.gn)(this, Oe, "f").animate([{
                    opacity: 0,
                    transform: "translateX(20px)",
                    offset: 0,
                    easing: "ease-in-out"
                }, {
                    opacity: 1,
                    transform: "translateX(0)",
                    offset: 1 / 28,
                    easing: "ease-in-out"
                }, {
                    opacity: 1,
                    transform: "translateX(0)",
                    offset: 27 / 28,
                    easing: "ease-in-out"
                }, {
                    opacity: 0,
                    transform: "translateX(-10px)",
                    offset: 1,
                    easing: "ease-in-out"
                }], {
                    duration: 3500
                }))
            }
            update(e) {
                const t = Math.abs(e.getSpeedKmh());
                let n;
                n = (0,
                R.gn)(this, Fe, "f") ? t / 1.609344 : t;
                let i = parseInt((0,
                R.gn)(this, ze, "f").getSetting(P.A.SpeedDecimalPlaces) ?? "3", 10);
                Number.isFinite(i) || (i = 3),
                i = Math.max(0, Math.min(5, i));
                const r = n.toFixed(i);
                if (r != (0,
                R.gn)(this, Ge, "f")) {
                    (0,
                    R.gn)(this, De, "f").innerHTML = "";
                    for (const e of r) {
                        const t = document.createElement("span");
                        t.textContent = e,
                        (0,
                        R.gn)(this, De, "f").appendChild(t)
                    }
                    (0,
                    R.GG)(this, Ge, r, "f")
                }
            }
        }
        ;
        var He = i(5839)
          , je = i(1196)
          , Ke = {};
        Ke.styleTagTransform = u(),
        Ke.setAttributes = l(),
        Ke.insert = s().bind(null, "head"),
        Ke.domAPI = r(),
        Ke.insertStyleElement = h();
        t()(je.A, Ke);
        je.A && je.A.locals && je.A.locals;
        function qe(e) {
            return Qe(e) + Je(e)
        }
        function Qe(e) {
            if (e <= 0 || !Number.isInteger(e))
                throw new Error("Position must be a positive integer.");
            const t = e.toString();
            let n = "";
            let i = 0;
            for (let e = t.length - 1; e >= 0; e--)
                n = t[e] + n,
                i++,
                3 == i && 0 != e && (n = "" + n,
                i = 0);
            return n
        }
        function Je(e) {
            if (e <= 0 || !Number.isInteger(e))
                throw new Error("Position must be a positive integer.");
            const t = e % 100;
            if (t >= 11 && t <= 13)
                return "th";
            switch (e % 10) {
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th"
            }
        }
        var Xe, Ye, Ze, $e, et, tt;
        Ye = new WeakMap,
        Ze = new WeakMap,
        $e = new WeakMap,
        et = new WeakMap,
        Xe = new WeakSet,
        tt = function(e) {
            (0,
            R.GG)(this, $e, setTimeout(( () => {
                const t = e.getBuffer("record");
                if (null != t && null != e.context && null != e.destinationSfx) {
                    const n = e.context.createBufferSource();
                    n.buffer = t,
                    n.playbackRate.value = 1.35;
                    const i = e.context.createGain();
                    i.gain.value = .05,
                    n.connect(i),
                    i.connect(e.destinationSfx),
                    n.start(0)
                }
            }
            ), 600), "f")
        }
        ;
        const nt = class {
            constructor(e, t, n, i, r, a, s, o, l) {
                Xe.add(this),
                Ye.set(this, void 0),
                Ze.set(this, void 0),
                $e.set(this, null),
                et.set(this, !1),
                (0,
                R.GG)(this, Ye, e, "f"),
                (0,
                R.GG)(this, Ze, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ze, "f").className = "time-announcer-ui";
                const c = document.createElement("div");
                switch (c.className = "record hidden",
                s) {
                case "personal-best":
                    c.classList.add("personal-best"),
                    c.textContent = t.get("NEW PERSONAL BEST");
                    break;
                case "session-best":
                    c.classList.add("session-best"),
                    c.textContent = t.get("NEW SESSION BEST")
                }
                (0,
                R.gn)(this, Ze, "f").appendChild(c);
                const h = document.createElement("div");
                h.className = "track-name",
                h.textContent = i,
                (0,
                R.gn)(this, Ze, "f").appendChild(h);
                const d = document.createElement("div");
                d.className = "current",
                (0,
                R.gn)(this, Ze, "f").appendChild(d);
                const u = document.createElement("div");
                u.className = "time",
                d.appendChild(u);
                const p = document.createElement("div");
                p.className = "position-dash",
                p.textContent = "-",
                d.appendChild(p);
                const f = document.createElement("div");
                f.className = "position",
                d.appendChild(f);
                const g = document.createElement("div");
                (0,
                R.gn)(this, Ze, "f").appendChild(g);
                const m = document.createElement("p");
                g.appendChild(m);
                const A = document.createElement("div");
                (0,
                R.gn)(this, Ze, "f").appendChild(A);
                const v = document.createElement("p");
                v.className = "title",
                A.appendChild(v);
                const y = document.createElement("p");
                if (A.appendChild(y),
                (0,
                R.gn)(this, Ye, "f").appendChild((0,
                R.gn)(this, Ze, "f")),
                u.textContent = He.A.formatTimeString(r),
                null == a)
                    c.classList.remove("hidden"),
                    g.className = "hidden",
                    (0,
                    R.gn)(this, Xe, "m", tt).call(this, n);
                else {
                    const e = r.difference(a);
                    m.textContent = He.A.formatTimeString(e, !0),
                    e.isNegative() ? (c.classList.remove("hidden"),
                    g.className = "difference",
                    (0,
                    R.gn)(this, Xe, "m", tt).call(this, n)) : g.className = "difference red"
                }
                if (null == o)
                    A.className = "hidden";
                else {
                    const e = r.difference(o.record);
                    v.textContent = o.nickname,
                    y.textContent = He.A.formatTimeString(e, !0),
                    e.isNegative() ? A.className = "difference" : A.className = "difference red"
                }
                const w = performance.now();
                l.then((e => {
                    if (null != e) {
                        const t = e.newPosition;
                        let i = e.previousPosition;
                        const r = Math.max(0, 1500 - (performance.now() - w));
                        setTimeout(( () => {
                            i = Math.max(i, t);
                            let e = i;
                            if (f.textContent = qe(e),
                            d.classList.add("show-position"),
                            t != i) {
                                const i = () => {
                                    let i = performance.now();
                                    let r = .1;
                                    const a = () => {
                                        if (!(0,
                                        R.gn)(this, et, "f")) {
                                            const s = performance.now()
                                              , o = (s - i) / 1e3;
                                            i = s;
                                            const l = Math.max(0, Math.min(1, 10 * o));
                                            e = e * (1 - l) + t * l;
                                            const c = Math.round(e);
                                            if (f.textContent = qe(c),
                                            r += o,
                                            r >= .1) {
                                                const e = n.getBuffer("position_tick");
                                                if (null != e && null != n.context && null != n.destinationSfx) {
                                                    const t = n.context.createBufferSource();
                                                    t.buffer = e;
                                                    const i = n.context.createGain();
                                                    i.gain.value = .01,
                                                    t.connect(i),
                                                    i.connect(n.destinationSfx),
                                                    t.start(0)
                                                }
                                                r %= .1
                                            }
                                            c != t && requestAnimationFrame(a)
                                        }
                                    }
                                    ;
                                    requestAnimationFrame(a)
                                }
                                ;
                                setTimeout(( () => {
                                    i()
                                }
                                ), 1e3)
                            }
                        }
                        ), r)
                    }
                }
                ))
            }
            dispose() {
                null != (0,
                R.gn)(this, $e, "f") && clearTimeout((0,
                R.gn)(this, $e, "f")),
                (0,
                R.gn)(this, Ye, "f").removeChild((0,
                R.gn)(this, Ze, "f")),
                (0,
                R.GG)(this, et, !0, "f")
            }
        }
        ;
        var it, rt, at, st, ot, lt, ct, ht, dt, ut, pt, ft, gt, mt, At, vt = i(2825);
        it = new WeakMap,
        rt = new WeakMap,
        at = new WeakMap,
        st = new WeakMap,
        ot = new WeakMap,
        lt = new WeakMap,
        ct = new WeakMap,
        ht = new WeakMap,
        dt = new WeakMap,
        ut = new WeakMap,
        pt = new WeakMap,
        ft = new WeakMap,
        gt = new WeakMap,
        mt = new WeakMap,
        At = new WeakMap;
        const yt = class {
            constructor(e, t) {
                it.set(this, void 0),
                rt.set(this, void 0),
                at.set(this, !1),
                st.set(this, []),
                ot.set(this, void 0),
                lt.set(this, void 0),
                ct.set(this, void 0),
                ht.set(this, void 0),
                dt.set(this, void 0),
                ut.set(this, void 0),
                pt.set(this, !1),
                ft.set(this, !1),
                gt.set(this, !1),
                mt.set(this, !1),
                At.set(this, !1),
                (0,
                R.GG)(this, it, e, "f"),
                (0,
                R.GG)(this, rt, new C.ubm(70,1,.5,vt.A.maxViewDistance), "f"),
                (0,
                R.gn)(this, rt, "f").position.set(0, 20, 0),
                window.addEventListener("keydown", (0,
                R.GG)(this, ot, (e => {
                    t.checkKeyBinding(e, me.A.SpectatorMoveForwards) ? ((0,
                    R.GG)(this, pt, !0, "f"),
                    e.preventDefault()) : t.checkKeyBinding(e, me.A.SpectatorMoveRight) ? ((0,
                    R.GG)(this, ft, !0, "f"),
                    e.preventDefault()) : t.checkKeyBinding(e, me.A.SpectatorMoveBackwards) ? ((0,
                    R.GG)(this, gt, !0, "f"),
                    e.preventDefault()) : t.checkKeyBinding(e, me.A.SpectatorMoveLeft) ? ((0,
                    R.GG)(this, mt, !0, "f"),
                    e.preventDefault()) : t.checkKeyBinding(e, me.A.SpectatorSpeedModifier) && ((0,
                    R.GG)(this, At, !0, "f"),
                    e.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", (0,
                R.GG)(this, lt, (e => {
                    t.checkKeyBinding(e, me.A.SpectatorMoveForwards) ? (0,
                    R.GG)(this, pt, !1, "f") : t.checkKeyBinding(e, me.A.SpectatorMoveRight) ? (0,
                    R.GG)(this, ft, !1, "f") : t.checkKeyBinding(e, me.A.SpectatorMoveBackwards) ? (0,
                    R.GG)(this, gt, !1, "f") : t.checkKeyBinding(e, me.A.SpectatorMoveLeft) ? (0,
                    R.GG)(this, mt, !1, "f") : t.checkKeyBinding(e, me.A.SpectatorSpeedModifier) && (0,
                    R.GG)(this, At, !1, "f")
                }
                ), "f"));
                let n = !1
                  , i = {
                    x: 0,
                    y: 0
                }
                  , r = 0
                  , a = 0;
                e.canvas.addEventListener("mousedown", (0,
                R.GG)(this, ct, (e => {
                    n = !0;
                    const t = (new C.O9p).setFromQuaternion((0,
                    R.gn)(this, rt, "f").quaternion, "YXZ");
                    r = t.y,
                    a = t.x,
                    i = {
                        x: e.clientX,
                        y: e.clientY
                    }
                }
                ), "f")),
                window.addEventListener("mouseup", (0,
                R.GG)(this, ht, ( () => {
                    n = !1
                }
                ), "f")),
                window.addEventListener("mousemove", (0,
                R.GG)(this, dt, (e => {
                    if (n) {
                        const t = Math.max(window.innerWidth, window.innerHeight)
                          , n = (e.clientX - i.x) / t
                          , s = (e.clientY - i.y) / t;
                        i = {
                            x: e.clientX,
                            y: e.clientY
                        };
                        const o = 10;
                        r -= n * o,
                        a -= s * o,
                        r %= 2 * Math.PI,
                        a = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, a)),
                        r = Math.round(1e4 * r) / 1e4,
                        a = Math.round(1e4 * a) / 1e4;
                        const l = (new C.PTz).setFromAxisAngle(new C.Pq0(1,0,0), a)
                          , c = (new C.PTz).setFromAxisAngle(new C.Pq0(0,1,0), r);
                        (0,
                        R.gn)(this, rt, "f").quaternion.copy(c).multiply(l)
                    }
                }
                ), "f")),
                window.addEventListener("contextmenu", (0,
                R.GG)(this, ut, (e => {
                    (0,
                    R.gn)(this, at, "f") && e.preventDefault()
                }
                ), "f"))
            }
            dispose() {
                window.removeEventListener("keydown", (0,
                R.gn)(this, ot, "f")),
                window.removeEventListener("keyup", (0,
                R.gn)(this, lt, "f")),
                (0,
                R.gn)(this, it, "f").canvas.removeEventListener("mousedown", (0,
                R.gn)(this, ct, "f")),
                window.removeEventListener("mouseup", (0,
                R.gn)(this, ht, "f")),
                window.removeEventListener("mousemove", (0,
                R.gn)(this, dt, "f")),
                window.removeEventListener("contextmenu", (0,
                R.gn)(this, ut, "f"))
            }
            addToggleListener(e) {
                (0,
                R.gn)(this, st, "f").push(e)
            }
            get isEnabled() {
                return (0,
                R.gn)(this, at, "f")
            }
            set isEnabled(e) {
                if ((0,
                R.gn)(this, at, "f") != e) {
                    (0,
                    R.GG)(this, at, e, "f");
                    for (const e of (0,
                    R.gn)(this, st, "f"))
                        e((0,
                        R.gn)(this, at, "f"))
                }
            }
            toggle() {
                this.isEnabled = !(0,
                R.gn)(this, at, "f")
            }
            update(e) {
                if ((0,
                R.gn)(this, at, "f")) {
                    let t;
                    if (t = (0,
                    R.gn)(this, At, "f") ? 400 * e : 50 * e,
                    (0,
                    R.gn)(this, pt, "f")) {
                        const e = new C.Pq0(0,0,-1).applyQuaternion((0,
                        R.gn)(this, rt, "f").quaternion);
                        (0,
                        R.gn)(this, rt, "f").position.add(e.multiplyScalar(t))
                    }
                    if ((0,
                    R.gn)(this, ft, "f")) {
                        const e = new C.Pq0(1,0,0).applyQuaternion((0,
                        R.gn)(this, rt, "f").quaternion);
                        (0,
                        R.gn)(this, rt, "f").position.add(e.multiplyScalar(t))
                    }
                    if ((0,
                    R.gn)(this, gt, "f")) {
                        const e = new C.Pq0(0,0,1).applyQuaternion((0,
                        R.gn)(this, rt, "f").quaternion);
                        (0,
                        R.gn)(this, rt, "f").position.add(e.multiplyScalar(t))
                    }
                    if ((0,
                    R.gn)(this, mt, "f")) {
                        const e = new C.Pq0(-1,0,0).applyQuaternion((0,
                        R.gn)(this, rt, "f").quaternion);
                        (0,
                        R.gn)(this, rt, "f").position.add(e.multiplyScalar(t))
                    }
                }
            }
            get camera() {
                return (0,
                R.gn)(this, rt, "f")
            }
        }
        ;
        var wt = i(6633)
          , bt = i(3571)
          , xt = {};
        xt.styleTagTransform = u(),
        xt.setAttributes = l(),
        xt.insert = s().bind(null, "head"),
        xt.domAPI = r(),
        xt.insertStyleElement = h();
        t()(bt.A, xt);
        bt.A && bt.A.locals && bt.A.locals;
        i(3693);
        const St = (0,
        g.F3)("Haptics", {
            web: () => i.e(789).then(i.bind(i, 3789)).then((e => new e.HapticsWeb))
        });
        var Et, Tt, kt, Mt, _t, Ct, Rt, Pt = i(4865);
        Tt = new WeakMap,
        kt = new WeakMap,
        Mt = new WeakMap,
        _t = new WeakMap,
        Ct = new WeakMap,
        Et = new WeakSet,
        Rt = function() {
            if ((0,
            R.gn)(this, Tt, "f").getSettingBoolean(P.A.VibrationEnabled))
                if ("capacitor" == Pt.aC)
                    St.vibrate({
                        duration: 11
                    }).catch((e => {
                        console.error(e)
                    }
                    ));
                else
                    try {
                        navigator.vibrate && navigator.vibrate(11)
                    } catch (e) {
                        console.error(e)
                    }
        }
        ;
        const It = class {
            constructor(e, t, n, i, r, a) {
                Et.add(this),
                Tt.set(this, void 0),
                kt.set(this, void 0),
                Mt.set(this, void 0),
                _t.set(this, void 0),
                Ct.set(this, !1),
                (0,
                R.GG)(this, Tt, n, "f");
                const s = document.getElementById("ui");
                if (null == s)
                    throw new Error("UI element not found");
                (0,
                R.GG)(this, kt, document.createElement("div"), "f"),
                (0,
                R.gn)(this, kt, "f").className = "hidden",
                s.appendChild((0,
                R.gn)(this, kt, "f"));
                const o = document.createElement("button");
                o.className = "camera",
                o.innerHTML = '<img src="images/preview.svg">',
                o.addEventListener("touchstart", ( () => {
                    (0,
                    R.gn)(this, Et, "m", Rt).call(this),
                    o.classList.add("active"),
                    i()
                }
                )),
                o.addEventListener("touchend", ( () => {
                    o.classList.remove("active"),
                    r()
                }
                )),
                (0,
                R.gn)(this, kt, "f").appendChild(o),
                (0,
                R.GG)(this, Mt, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Mt, "f").className = "reset",
                (0,
                R.gn)(this, Mt, "f").innerHTML = '<img src="images/reset.svg">',
                (0,
                R.gn)(this, Mt, "f").addEventListener("touchstart", ( () => {
                    t.playUIClick(),
                    (0,
                    R.gn)(this, Et, "m", Rt).call(this),
                    (0,
                    R.gn)(this, Mt, "f").classList.add("active"),
                    a()
                }
                )),
                (0,
                R.gn)(this, Mt, "f").addEventListener("touchend", ( () => {
                    (0,
                    R.gn)(this, Mt, "f").classList.remove("active")
                }
                )),
                (0,
                R.gn)(this, kt, "f").appendChild((0,
                R.gn)(this, Mt, "f"));
                const l = document.createElement("div");
                l.className = "left-container",
                (0,
                R.gn)(this, kt, "f").appendChild(l);
                const c = document.createElement("div");
                c.innerHTML = '<img src="images/arrow_up.svg">';
                const h = document.createElement("div");
                h.innerHTML = '<img src="images/arrow_down.svg">';
                const d = document.createElement("div");
                d.className = "right-container",
                (0,
                R.gn)(this, kt, "f").appendChild(d);
                const u = document.createElement("div");
                u.innerHTML = '<img src="images/arrow_left.svg">';
                const p = document.createElement("div");
                p.innerHTML = '<img src="images/arrow_right.svg">',
                n.getSettingBoolean(P.A.TouchSteeringSide) ? (l.appendChild(c),
                l.appendChild(h),
                d.classList.add("steering"),
                d.appendChild(u),
                d.appendChild(p)) : (l.classList.add("steering"),
                l.appendChild(u),
                l.appendChild(p),
                d.appendChild(c),
                d.appendChild(h)),
                (0,
                R.GG)(this, _t, (t => {
                    let n = !1
                      , i = !1
                      , r = !1
                      , a = !1;
                    for (let e = 0; e < t.touches.length; e++) {
                        const s = t.touches.item(e);
                        if (null != s) {
                            switch (document.elementFromPoint(s.clientX, s.clientY)) {
                            case c:
                                n = !0;
                                break;
                            case p:
                                i = !0;
                                break;
                            case h:
                                r = !0;
                                break;
                            case u:
                                a = !0
                            }
                        }
                    }
                    e.up == n && e.right == i && e.down == r && e.left == a || (0,
                    R.gn)(this, Et, "m", Rt).call(this),
                    e.up = n,
                    e.right = i,
                    e.down = r,
                    e.left = a,
                    c.className = n ? "active" : "",
                    p.className = i ? "active" : "",
                    h.className = r ? "active" : "",
                    u.className = a ? "active" : "",
                    t.target instanceof HTMLButtonElement || t.preventDefault()
                }
                ), "f"),
                window.addEventListener("touchstart", (0,
                R.gn)(this, _t, "f"), {
                    passive: !1
                }),
                window.addEventListener("touchmove", (0,
                R.gn)(this, _t, "f"), {
                    passive: !1
                }),
                window.addEventListener("touchend", (0,
                R.gn)(this, _t, "f"), {
                    passive: !1
                })
            }
            get isEnabled() {
                return (0,
                R.gn)(this, Ct, "f")
            }
            set isEnabled(e) {
                e != (0,
                R.gn)(this, Ct, "f") && ((0,
                R.gn)(this, kt, "f").className = e ? "touch-controls-ui" : "hidden",
                (0,
                R.GG)(this, Ct, e, "f"))
            }
            setResetCheckpointAvailable(e) {
                e ? (0,
                R.gn)(this, Mt, "f").classList.add("checkpoint-available") : (0,
                R.gn)(this, Mt, "f").classList.remove("checkpoint-available")
            }
            dispose() {
                (0,
                R.gn)(this, kt, "f").parentElement?.removeChild((0,
                R.gn)(this, kt, "f")),
                window.removeEventListener("touchstart", (0,
                R.gn)(this, _t, "f")),
                window.removeEventListener("touchmove", (0,
                R.gn)(this, _t, "f")),
                window.removeEventListener("touchend", (0,
                R.gn)(this, _t, "f"))
            }
        }
        ;
        var Lt, Nt, zt, Ut, Dt, Bt, Gt, Ft;
        Lt = new WeakMap,
        Nt = new WeakMap,
        zt = new WeakMap,
        Ut = new WeakMap,
        Dt = new WeakMap,
        Bt = new WeakMap,
        Gt = new WeakMap,
        Ft = new WeakMap;
        const Ot = class {
            constructor(e) {
                Lt.set(this, !1),
                Nt.set(this, !1),
                zt.set(this, !1),
                Ut.set(this, !1),
                Dt.set(this, !1),
                Bt.set(this, void 0),
                Gt.set(this, void 0),
                Ft.set(this, []),
                window.addEventListener("keydown", (0,
                R.GG)(this, Bt, (t => {
                    e.checkKeyBinding(t, me.A.VehicleAccelerate) ? (this.up = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, me.A.VehicleTurnRight) ? (this.right = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, me.A.VehicleBrake) ? (this.down = !0,
                    t.preventDefault()) : e.checkKeyBinding(t, me.A.VehicleTurnLeft) && (this.left = !0,
                    t.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", (0,
                R.GG)(this, Gt, (t => {
                    e.checkKeyBinding(t, me.A.VehicleAccelerate) ? this.up = !1 : e.checkKeyBinding(t, me.A.VehicleTurnRight) ? this.right = !1 : e.checkKeyBinding(t, me.A.VehicleBrake) ? this.down = !1 : e.checkKeyBinding(t, me.A.VehicleTurnLeft) && (this.left = !1)
                }
                ), "f"))
            }
            get up() {
                return (0,
                R.gn)(this, Lt, "f")
            }
            set up(e) {
                if ((0,
                R.gn)(this, Lt, "f") != e) {
                    (0,
                    R.GG)(this, Lt, e, "f");
                    for (const e of (0,
                    R.gn)(this, Ft, "f"))
                        e(this)
                }
            }
            get right() {
                return (0,
                R.gn)(this, Nt, "f")
            }
            set right(e) {
                if ((0,
                R.gn)(this, Nt, "f") != e) {
                    (0,
                    R.GG)(this, Nt, e, "f");
                    for (const e of (0,
                    R.gn)(this, Ft, "f"))
                        e(this)
                }
            }
            get down() {
                return (0,
                R.gn)(this, zt, "f")
            }
            set down(e) {
                if ((0,
                R.gn)(this, zt, "f") != e) {
                    (0,
                    R.GG)(this, zt, e, "f");
                    for (const e of (0,
                    R.gn)(this, Ft, "f"))
                        e(this)
                }
            }
            get left() {
                return (0,
                R.gn)(this, Ut, "f")
            }
            set left(e) {
                if ((0,
                R.gn)(this, Ut, "f") != e) {
                    (0,
                    R.GG)(this, Ut, e, "f");
                    for (const e of (0,
                    R.gn)(this, Ft, "f"))
                        e(this)
                }
            }
            get reset() {
                return (0,
                R.gn)(this, Dt, "f")
            }
            set reset(e) {
                if ((0,
                R.gn)(this, Dt, "f") != e) {
                    (0,
                    R.GG)(this, Dt, e, "f");
                    for (const e of (0,
                    R.gn)(this, Ft, "f"))
                        e(this)
                }
            }
            addChangeCallback(e) {
                (0,
                R.gn)(this, Ft, "f").push(e)
            }
            removeChangeCallback(e) {
                const t = (0,
                R.gn)(this, Ft, "f").indexOf(e);
                t >= 0 && (0,
                R.gn)(this, Ft, "f").splice(t, 1)
            }
            dispose() {
                window.removeEventListener("keydown", (0,
                R.gn)(this, Bt, "f")),
                window.removeEventListener("keyup", (0,
                R.gn)(this, Gt, "f"))
            }
            getControls() {
                return {
                    up: this.up,
                    right: this.right,
                    down: this.down,
                    left: this.left,
                    reset: this.reset
                }
            }
        }
        ;
        var Wt;
        Wt = new WeakMap;
        const Vt = class {
            constructor() {
                Wt.set(this, [])
            }
            push(e) {
                if ((0,
                R.gn)(this, Wt, "f").length > 0) {
                    if (e.frames != (0,
                    R.gn)(this, Wt, "f")[(0,
                    R.gn)(this, Wt, "f").length - 1].frames + 1)
                        throw new Error("Car states are not continuous")
                } else if (e.frames > 0)
                    throw new Error("First frame must be zero");
                (0,
                R.gn)(this, Wt, "f").push(e)
            }
            getFrame(e) {
                return e >= 0 && e < (0,
                R.gn)(this, Wt, "f").length ? (0,
                R.gn)(this, Wt, "f")[e] : null
            }
            getLastFrame() {
                return 0 == (0,
                R.gn)(this, Wt, "f").length ? new wt.A(0) : new wt.A((0,
                R.gn)(this, Wt, "f")[(0,
                R.gn)(this, Wt, "f").length - 1].frames)
            }
        }
        ;
        var Ht = i(2931)
          , jt = {};
        jt.styleTagTransform = u(),
        jt.setAttributes = l(),
        jt.insert = s().bind(null, "head"),
        jt.domAPI = r(),
        jt.insertStyleElement = h();
        t()(Ht.A, jt);
        Ht.A && Ht.A.locals && Ht.A.locals;
        var Kt, qt = i(3075), Qt = i(765), Jt = i(2108);
        !function(e) {
            e[e.CarReset = 0] = "CarReset",
            e[e.CarUpdate = 1] = "CarUpdate",
            e[e.Record = 2] = "Record",
            e[e.Pong = 3] = "Pong",
            e[e.ModCustomMessage = 255] = "ModCustomMessage"
        }(Kt || (Kt = {}));
        const Xt = Kt;
        var Yt;
        !function(e) {
            e[e.PlayerUpdate = 0] = "PlayerUpdate",
            e[e.RemovePlayer = 1] = "RemovePlayer",
            e[e.CarReset = 2] = "CarReset",
            e[e.CarUpdate = 3] = "CarUpdate",
            e[e.Kick = 4] = "Kick",
            e[e.TrackId = 5] = "TrackId",
            e[e.TrackChunk = 6] = "TrackChunk",
            e[e.EndSession = 7] = "EndSession",
            e[e.NewSession = 8] = "NewSession",
            e[e.Ping = 9] = "Ping",
            e[e.PingData = 10] = "PingData",
            e[e.ModCustomMessage = 255] = "ModCustomMessage"
        }(Yt || (Yt = {}));
        const Zt = Yt;
        var $t;
        !function(e) {
            e[e.Casual = 0] = "Casual",
            e[e.Competitive = 1] = "Competitive"
        }($t || ($t = {}));
        const en = $t;
        class tn extends Error {
            constructor(e, t) {
                super(e),
                this.name = "MultiplayerCreateInviteError",
                this.serverError = t
            }
        }
        const nn = tn;
        var rn, an, sn, on, ln, cn, hn, dn, un, pn, fn, gn, mn, An, vn, yn, wn, bn, xn, Sn, En, Tn, kn, Mn, _n, Cn, Rn, Pn, In, Ln, Nn, zn, Un, Dn, Bn, Gn, Fn, On = i(2970);
        an = new WeakMap,
        sn = new WeakMap,
        on = new WeakMap,
        ln = new WeakMap,
        cn = new WeakMap,
        hn = new WeakMap,
        dn = new WeakMap,
        un = new WeakMap,
        pn = new WeakMap,
        fn = new WeakMap,
        gn = new WeakMap,
        mn = new WeakMap,
        An = new WeakMap,
        vn = new WeakMap,
        yn = new WeakMap,
        wn = new WeakMap,
        bn = new WeakMap,
        xn = new WeakMap,
        Sn = new WeakMap,
        En = new WeakMap,
        Tn = new WeakMap,
        kn = new WeakMap,
        Mn = new WeakMap,
        rn = new WeakSet,
        _n = function(e, t, n) {
            const i = n.toExportString(t)
              , r = new Uint8Array(33);
            r[0] = Zt.TrackId;
            const a = n.getId();
            for (let e = 0; e < 32; e++) {
                const t = a.substring(2 * e, 2 * e + 2)
                  , n = parseInt(t, 16);
                if (Number.isNaN(n))
                    throw new Error("Invalid hex value in trackId");
                r[1 + e] = n
            }
            e.send(r);
            const s = (0,
            R.gn)(this, yn, "f") - 1;
            for (let t = 0; t < i.length; t += s) {
                const n = new Uint8Array(Math.min(1 + s, 1 + i.length - t));
                n[0] = Zt.TrackChunk;
                for (let e = 1; e < n.length; e++) {
                    const r = i.charCodeAt(t + e - 1);
                    if (r > 255)
                        throw new Error("Track data string contains non-ASCII characters");
                    n[e] = r
                }
                e.send(n)
            }
        }
        ,
        Cn = function(e) {
            const t = new Uint8Array(1);
            t[0] = Zt.EndSession,
            e.send(t)
        }
        ,
        Rn = function(e) {
            if ((0,
            R.gn)(this, fn, "f") > 255)
                throw new Error("Max players exceeds 255");
            const t = new Uint8Array(7);
            t[0] = Zt.NewSession,
            t[1] = 255 & (0,
            R.gn)(this, un, "f"),
            t[2] = (0,
            R.gn)(this, un, "f") >> 8 & 255,
            t[3] = (0,
            R.gn)(this, un, "f") >> 16 & 255,
            t[4] = (0,
            R.gn)(this, un, "f") >> 24 & 255,
            t[5] = (0,
            R.gn)(this, dn, "f"),
            t[6] = (0,
            R.gn)(this, fn, "f"),
            e.send(t)
        }
        ,
        Pn = function(e, t, n) {
            e.onopen = () => {
                if ("reliable" == n) {
                    (0,
                    R.GG)(this, An, (0,
                    R.gn)(this, An, "f").filter((e => e != t)), "f"),
                    (0,
                    R.gn)(this, vn, "f").push(t);
                    for (const e of (0,
                    R.gn)(this, kn, "f"))
                        e((0,
                        R.gn)(this, un, "f"));
                    for (const e of (0,
                    R.gn)(this, Mn, "f"))
                        e((0,
                        R.gn)(this, an, "f").get('"{0}" joined!', [t.nickname]));
                    null != (0,
                    R.gn)(this, hn, "f") && ((0,
                    R.gn)(this, rn, "m", _n).call(this, t.dataChannel, (0,
                    R.gn)(this, hn, "f").trackMetadata, (0,
                    R.gn)(this, hn, "f").trackData),
                    (0,
                    R.gn)(this, rn, "m", Rn).call(this, t.dataChannel),
                    null != (0,
                    R.gn)(this, pn, "f") && ((0,
                    R.gn)(this, rn, "m", Cn).call(this, t.dataChannel),
                    (0,
                    R.gn)(this, rn, "m", _n).call(this, t.dataChannel, (0,
                    R.gn)(this, pn, "f").track.trackMetadata, (0,
                    R.gn)(this, pn, "f").track.trackData))),
                    (0,
                    R.gn)(this, rn, "m", Bn).call(this, t.id, t.nickname, t.countryCode, t.carStyle, null);
                    for (const n of (0,
                    R.gn)(this, vn, "f"))
                        n != t && (0,
                        R.gn)(this, rn, "m", Gn).call(this, e, n.id, n.nickname, n.countryCode, n.carStyle, n.record);
                    if (null == (0,
                    R.gn)(this, mn, "f").nickname)
                        (0,
                        R.gn)(this, mn, "f").nickname = (0,
                        R.gn)(this, mn, "f").uncensoredNickname || "Player";
                    (0,
                    R.gn)(this, rn, "m", Gn).call(this, e, (0,
                    R.gn)(this, mn, "f").id, (0,
                    R.gn)(this, mn, "f").nickname, (0,
                    R.gn)(this, mn, "f").countryCode, (0,
                    R.gn)(this, mn, "f").carStyle, (0,
                    R.gn)(this, mn, "f").record);
                    for (const e of (0,
                    R.gn)(this, kn, "f"))
                        e((0,
                        R.gn)(this, un, "f"))
                }
            }
            ,
            e.onclose = () => {
                if (t.peerConnection.close(),
                "reliable" == n) {
                    const n = (0,
                    R.gn)(this, vn, "f").findIndex((t => t.dataChannel == e));
                    if (n >= 0) {
                        (0,
                        R.gn)(this, vn, "f").splice(n, 1),
                        (0,
                        R.gn)(this, rn, "m", Fn).call(this, t.id, t.isKicked);
                        for (const e of (0,
                        R.gn)(this, kn, "f"))
                            e((0,
                            R.gn)(this, un, "f"));
                        for (const e of (0,
                        R.gn)(this, Mn, "f"))
                            t.isKicked ? e((0,
                            R.gn)(this, an, "f").get('"{0}" was kicked!', [t.nickname])) : e((0,
                            R.gn)(this, an, "f").get('"{0}" left!', [t.nickname]))
                    } else {
                        const t = (0,
                        R.gn)(this, An, "f").findIndex((t => t.dataChannel == e));
                        if (t >= 0) {
                            (0,
                            R.gn)(this, An, "f").splice(t, 1);
                            for (const e of (0,
                            R.gn)(this, kn, "f"))
                                e((0,
                                R.gn)(this, un, "f"))
                        }
                    }
                }
            }
            ,
            e.onmessage = n => {
                let i = "Host data channel error: ";
                if (!(n.data instanceof ArrayBuffer))
                    return console.error(i + "Received non-ArrayBuffer data"),
                    void e.close();
                const r = new Uint8Array(n.data);
                let a = 0;
                if (r.length < a + 1)
                    return console.error(i + "Received empty message"),
                    void e.close();
                const s = r[0];
                switch (a++,
                s) {
                case Xt.CarReset:
                    {
                        if (i += "CarReset: ",
                        r.length < a + 4)
                            return console.error(i + "Incomplete (sessionId)"),
                            void e.close();
                        const n = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16 | r[a + 3] << 24;
                        if (a += 4,
                        r.length < a + 4)
                            return console.error(i + "Incomplete (resetCounter)"),
                            void e.close();
                        const s = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16 | r[a + 3] << 24;
                        if (a += 4,
                        n == (0,
                        R.gn)(this, un, "f") && s > t.resetCounter) {
                            t.unsentCarStates.length = 0,
                            t.resetCounter = s,
                            (0,
                            R.gn)(this, rn, "m", Ln).call(this, t.id, s);
                            for (const e of (0,
                            R.gn)(this, xn, "f"))
                                e((0,
                                R.gn)(this, un, "f"), t.id, s)
                        }
                        break
                    }
                case Xt.CarUpdate:
                    {
                        if (i += "CarUpdate: ",
                        r.length < a + 4)
                            return console.error(i + "Incomplete (sessionId)"),
                            void e.close();
                        const n = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16 | r[a + 3] << 24;
                        if (a += 4,
                        r.length < a + 4)
                            return console.error(i + "Incomplete (resetCounter)"),
                            void e.close();
                        const s = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16 | r[a + 3] << 24;
                        let o, l;
                        a += 4;
                        try {
                            ({numberOfBytes: o, carState: l} = Jt.VO(r.slice(a)))
                        } catch {
                            return console.error(i + "Failed to deserialize CarState"),
                            void e.close()
                        }
                        a += o,
                        n == (0,
                        R.gn)(this, un, "f") && (s > t.resetCounter ? (t.unsentCarStates.length = 0,
                        t.resetCounter = s) : s == t.resetCounter && t.unsentCarStates.push(l));
                        break
                    }
                case Xt.Record:
                    {
                        if (i += "Record: ",
                        r.length < a + 4)
                            return console.error(i + "Incomplete (sessionId)"),
                            void e.close();
                        const n = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16 | r[a + 3] << 24;
                        if (a += 4,
                        r.length < a + 3)
                            return console.error(i + "Incomplete (frames)"),
                            void e.close();
                        const s = r[a + 0] | r[a + 1] << 8 | r[a + 2] << 16;
                        if (a += 3,
                        s <= 0 || s > re.A.maxFrames)
                            return console.error(i + "Record has invalid number of frames"),
                            void e.close();
                        if (n == (0,
                        R.gn)(this, un, "f")) {
                            t.record = new wt.A(s),
                            (0,
                            R.gn)(this, rn, "m", Bn).call(this, t.id, t.nickname, t.countryCode, t.carStyle, t.record);
                            for (const e of (0,
                            R.gn)(this, kn, "f"))
                                e((0,
                                R.gn)(this, un, "f"))
                        }
                        break
                    }
                case Xt.Pong:
                    {
                        if (i += "Pong: ",
                        r.length < a + 1)
                            return console.error(i + "Incomplete (pingId)"),
                            void e.close();
                        const n = r[a];
                        if (a += 1,
                        t.pingPackages.length > 0) {
                            const e = t.pingPackages.findIndex((e => e.pingId == n));
                            if (e >= 0) {
                                const n = t.pingPackages[e]
                                  , i = performance.now();
                                t.ping = Math.max(0, i - n.sentTime),
                                t.pingPackages.splice(e, 1)
                            }
                        }
                        break
                    }
                case Xt.ModCustomMessage:
                    break;
                default:
                    return console.error(i + "Received unknown message type"),
                    void e.close()
                }
                return r.length != a ? (console.error(i + "Leftover data"),
                void e.close()) : void 0
            }
        }
        ,
        In = function(e, t, n) {
            const i = new Uint8Array(9);
            i[0] = Zt.CarReset,
            i[1] = 255 & t,
            i[2] = t >> 8 & 255,
            i[3] = t >> 16 & 255,
            i[4] = t >> 24 & 255,
            i[5] = 255 & n,
            i[6] = n >> 8 & 255,
            i[7] = n >> 16 & 255,
            i[8] = n >> 24 & 255,
            function() {
                try {
                    "open" === e.readyState && e.send(i)
                } catch (e) {}
            }()
        }
        ,
        Ln = function(e, t) {
            for (const n of (0,
            R.gn)(this, vn, "f"))
                n.id != e && (0,
                R.gn)(this, rn, "m", In).call(this, n.dataChannel, e, t)
        }
        ,
        Nn = function e(t, n) {
            const i = (0,
            R.gn)(this, yn, "f") - 5
              , r = n.reduce(( (e, t) => e + t.length), 0)
              , a = new Uint8Array(r);
            let s = 0;
            for (const e of n)
                a.set(e, s),
                s += e.length;
            const o = new qt.Ay.Deflate({
                level: 9,
                windowBits: 9,
                memLevel: 9
            });
            o.push(a, !0);
            const l = o.result;
            if (l.length <= i) {
                const e = new Uint8Array(5 + l.length);
                e[0] = Zt.CarUpdate,
                e[1] = 255 & (0,
                R.gn)(this, un, "f"),
                e[2] = (0,
                R.gn)(this, un, "f") >> 8 & 255,
                e[3] = (0,
                R.gn)(this, un, "f") >> 16 & 255,
                e[4] = (0,
                R.gn)(this, un, "f") >> 24 & 255,
                e.set(l, 5),
                function() {
                    try {
                        "open" === t.readyState && t.send(e)
                    } catch (e) {}
                }()
            } else {
                const i = Math.floor(n.length / 2)
                  , r = n.slice(0, i)
                  , a = n.slice(i);
                if (0 == r.length || 0 == a.length)
                    throw new Error("Cannot split car update data further");
                (0,
                R.gn)(this, rn, "m", e).call(this, t, r),
                (0,
                R.gn)(this, rn, "m", e).call(this, t, a)
            }
        }
        ,
        zn = function() {
            for (const e of (0,
            R.gn)(this, vn, "f")) {
                const t = e.pingIdCounter;
                e.pingIdCounter = (e.pingIdCounter + 1) % 256;
                const n = new Uint8Array(2);
                n[0] = Zt.Ping,
                n[1] = t,
                function() {
                    try {
                        "open" === e.unreliableDataChannel.readyState && e.unreliableDataChannel.send(n)
                    } catch (e) {}
                }(),
                e.pingPackages.push({
                    pingId: t,
                    sentTime: performance.now()
                }),
                e.pingPackages.length > 10 && e.pingPackages.shift()
            }
        }
        ,
        Un = function() {
            const e = (0,
            R.gn)(this, vn, "f").length + 1
              , t = new Uint8Array(1 + 6 * e);
            t[0] = Zt.PingData;
            let n = 1;
            t[n + 0] = 255 & (0,
            R.gn)(this, mn, "f").id,
            t[n + 1] = (0,
            R.gn)(this, mn, "f").id >> 8 & 255,
            t[n + 2] = (0,
            R.gn)(this, mn, "f").id >> 16 & 255,
            t[n + 3] = (0,
            R.gn)(this, mn, "f").id >> 24 & 255;
            t[n + 4] = 0,
            t[n + 5] = 0,
            n += 6;
            for (const e of (0,
            R.gn)(this, vn, "f")) {
                t[n + 0] = 255 & e.id,
                t[n + 1] = e.id >> 8 & 255,
                t[n + 2] = e.id >> 16 & 255,
                t[n + 3] = e.id >> 24 & 255;
                const i = e.ping ?? 65535;
                t[n + 4] = 255 & i,
                t[n + 5] = i >> 8 & 255,
                n += 6
            }
            for (const e of (0,
            R.gn)(this, vn, "f"))
                e.unreliableDataChannel.send(t)
        }
        ,
        Dn = function() {
            for (const e of (0,
            R.gn)(this, vn, "f")) {
                const t = [];
                if ((0,
                R.gn)(this, mn, "f").unsentCarStates.length > 0)
                    for (const e of (0,
                    R.gn)(this, mn, "f").unsentCarStates)
                        t.push({
                            id: (0,
                            R.gn)(this, mn, "f").id,
                            resetCounter: (0,
                            R.gn)(this, mn, "f").resetCounter,
                            carState: e
                        });
                for (const n of (0,
                R.gn)(this, vn, "f"))
                    if (n != e && n.unsentCarStates.length > 0)
                        for (const e of n.unsentCarStates)
                            t.push({
                                id: n.id,
                                resetCounter: n.resetCounter,
                                carState: e
                            });
                const n = [];
                for (const e of t) {
                    const t = Jt._c(e.carState)
                      , i = new Uint8Array(8 + t.length);
                    i[0] = 255 & e.id,
                    i[1] = e.id >> 8 & 255,
                    i[2] = e.id >> 16 & 255,
                    i[3] = e.id >> 24 & 255,
                    i[4] = 255 & e.resetCounter,
                    i[5] = e.resetCounter >> 8 & 255,
                    i[6] = e.resetCounter >> 16 & 255,
                    i[7] = e.resetCounter >> 24 & 255,
                    i.set(t, 8),
                    n.push(i)
                }
                (0,
                R.gn)(this, rn, "m", Nn).call(this, e.unreliableDataChannel, n)
            }
            for (const e of (0,
            R.gn)(this, Sn, "f"))
                for (const t of (0,
                R.gn)(this, vn, "f"))
                    if (t.unsentCarStates.length > 0)
                        for (const n of t.unsentCarStates)
                            e((0,
                            R.gn)(this, un, "f"), t.id, t.resetCounter, n);
            (0,
            R.gn)(this, mn, "f").unsentCarStates.length = 0;
            for (const e of (0,
            R.gn)(this, vn, "f"))
                e.unsentCarStates.length = 0
        }
        ,
        Bn = function(e, t, n, i, r) {
            for (const a of (0,
            R.gn)(this, vn, "f"))
                a.id != e && (0,
                R.gn)(this, rn, "m", Gn).call(this, a.dataChannel, e, t, n, i, r)
        }
        ,
        Gn = function(e, t, n, i, r, a) {
            const s = [];
            s.push(Zt.PlayerUpdate),
            s.push(255 & t),
            s.push(t >> 8 & 255),
            s.push(t >> 16 & 255),
            s.push(t >> 24 & 255);
            const o = (new TextEncoder).encode(n);
            s.push(o.length);
            for (const e of o)
                s.push(e);
            if (null == i)
                s.push(0);
            else {
                for (let e = 0; e < i.length; e++)
                    s.push(i.charCodeAt(e));
                s.push(0)
            }
            const l = r.serializeBinary();
            for (const e of l)
                s.push(e);
            const c = a?.numberOfFrames;
            null == c ? s.push(0) : (s.push(1),
            s.push(255 & c),
            s.push(c >> 8 & 255),
            s.push(c >> 16 & 255)),
            e.send(new Uint8Array(s))
        }
        ,
        Fn = function(e, t) {
            for (const n of (0,
            R.gn)(this, vn, "f")) {
                if (n.id == e)
                    continue;
                const i = [];
                let r;
                i.push(Zt.RemovePlayer),
                i.push(255 & e),
                i.push(e >> 8 & 255),
                i.push(e >> 16 & 255),
                i.push(e >> 24 & 255),
                r = t ? 1 : 0,
                i.push(r),
                n.dataChannel.send(new Uint8Array(i))
            }
        }
        ;
        const Wn = class {
            constructor(e, t, n, i) {
                var r, a;
                rn.add(this),
                an.set(this, void 0),
                sn.set(this, void 0),
                on.set(this, null),
                ln.set(this, null),
                cn.set(this, null),
                hn.set(this, null),
                dn.set(this, en.Casual),
                un.set(this, 0),
                pn.set(this, null),
                fn.set(this, void 0),
                gn.set(this, 1),
                mn.set(this, void 0),
                An.set(this, []),
                vn.set(this, []),
                yn.set(this, 16384),
                wn.set(this, void 0),
                bn.set(this, void 0),
                xn.set(this, []),
                Sn.set(this, []),
                En.set(this, []),
                Tn.set(this, []),
                kn.set(this, []),
                Mn.set(this, []),
                (0,
                R.GG)(this, an, e, "f"),
                (0,
                R.GG)(this, sn, t, "f");
                const s = i.getCurrentUserProfile();
                (0,
                R.GG)(this, mn, {
                    id: ((0,
                    R.GG)(this, gn, (a = (0,
                    R.gn)(this, gn, "f"),
                    r = a++,
                    a), "f"),
                    r),
                    nickname: null,
                    uncensoredNickname: s.nickname,
                    countryCode: s.countryCode,
                    carStyle: s.carStyle,
                    record: null,
                    resetCounter: 0,
                    unsentCarStates: []
                }, "f"),
                (0,
                R.GG)(this, fn, n, "f"),
                (0,
                R.GG)(this, wn, setInterval(( () => {
                    (0,
                    R.gn)(this, rn, "m", zn).call(this),
                    (0,
                    R.gn)(this, rn, "m", Un).call(this)
                }
                ), 1e3), "f"),
                (0,
                R.GG)(this, bn, setInterval(( () => {
                    (0,
                    R.gn)(this, rn, "m", Dn).call(this)
                }
                ), 100), "f")
            }
            dispose() {
                null != (0,
                R.gn)(this, pn, "f") && (clearTimeout((0,
                R.gn)(this, pn, "f").timeout),
                (0,
                R.GG)(this, pn, null, "f")),
                clearInterval((0,
                R.gn)(this, wn, "f")),
                clearInterval((0,
                R.gn)(this, bn, "f")),
                (0,
                R.GG)(this, Sn, [], "f"),
                (0,
                R.GG)(this, Tn, [], "f"),
                (0,
                R.GG)(this, kn, [], "f"),
                (0,
                R.GG)(this, on, null, "f"),
                null != (0,
                R.gn)(this, cn, "f") && ((0,
                R.gn)(this, cn, "f").close(),
                (0,
                R.GG)(this, cn, null, "f"));
                for (const e of (0,
                R.gn)(this, An, "f"))
                    e.dataChannel.close();
                (0,
                R.GG)(this, An, [], "f");
                for (const e of (0,
                R.gn)(this, vn, "f"))
                    e.dataChannel.close();
                (0,
                R.GG)(this, vn, [], "f")
            }
            addConnectionLostCallback() {}
            removeConnectionLostCallback() {}
            addCarResetCallback(e) {
                (0,
                R.gn)(this, xn, "f").push(e)
            }
            removeCarResetCallback(e) {
                (0,
                R.GG)(this, xn, (0,
                R.gn)(this, xn, "f").filter((t => t != e)), "f")
            }
            addCarUpdateCallback(e) {
                (0,
                R.gn)(this, Sn, "f").push(e)
            }
            removeCarUpdateCallback(e) {
                (0,
                R.GG)(this, Sn, (0,
                R.gn)(this, Sn, "f").filter((t => t != e)), "f")
            }
            addEndSessionCallback(e, t) {
                (0,
                R.gn)(this, En, "f").push(t),
                e == (0,
                R.gn)(this, un, "f") && null == (0,
                R.gn)(this, pn, "f") || t()
            }
            removeEndSessionCallback(e) {
                (0,
                R.GG)(this, En, (0,
                R.gn)(this, En, "f").filter((t => t != e)), "f")
            }
            addNewSessionCallback(e, t) {
                (0,
                R.gn)(this, Tn, "f").push(t),
                e == (0,
                R.gn)(this, un, "f") && null != (0,
                R.gn)(this, hn, "f") && t((0,
                R.gn)(this, un, "f"), (0,
                R.gn)(this, dn, "f"), (0,
                R.gn)(this, hn, "f").trackMetadata, (0,
                R.gn)(this, hn, "f").trackData)
            }
            removeNewSessionCallback(e) {
                (0,
                R.GG)(this, Tn, (0,
                R.gn)(this, Tn, "f").filter((t => t != e)), "f")
            }
            addServerMessageCallback(e) {
                (0,
                R.gn)(this, Mn, "f").push(e)
            }
            removeServerMessageCallback(e) {
                (0,
                R.GG)(this, Mn, (0,
                R.gn)(this, Mn, "f").filter((t => t != e)), "f")
            }
            sendCarReset(e, t) {
                e == (0,
                R.gn)(this, un, "f") && t > (0,
                R.gn)(this, mn, "f").resetCounter && ((0,
                R.gn)(this, mn, "f").unsentCarStates.length = 0,
                (0,
                R.gn)(this, mn, "f").resetCounter = t,
                (0,
                R.gn)(this, rn, "m", Ln).call(this, (0,
                R.gn)(this, mn, "f").id, t))
            }
            sendCarUpdate(e, t, n) {
                e == (0,
                R.gn)(this, un, "f") && (t > (0,
                R.gn)(this, mn, "f").resetCounter ? ((0,
                R.gn)(this, mn, "f").unsentCarStates.length = 0,
                (0,
                R.gn)(this, mn, "f").resetCounter = t) : t == (0,
                R.gn)(this, mn, "f").resetCounter && (0,
                R.gn)(this, mn, "f").unsentCarStates.push(n))
            }
            sendRecord(e, t) {
                if (e == (0,
                R.gn)(this, un, "f")) {
                    if ((0,
                    R.gn)(this, mn, "f").record = t.clone(),
                    (0,
                    R.gn)(this, vn, "f").length > 0) {
                        if (null == (0,
                        R.gn)(this, mn, "f").nickname)
                            (0,
                            R.gn)(this, mn, "f").nickname = (0,
                            R.gn)(this, mn, "f").uncensoredNickname || "Player";
                        (0,
                        R.gn)(this, rn, "m", Bn).call(this, (0,
                        R.gn)(this, mn, "f").id, (0,
                        R.gn)(this, mn, "f").nickname, (0,
                        R.gn)(this, mn, "f").countryCode, (0,
                        R.gn)(this, mn, "f").carStyle, (0,
                        R.gn)(this, mn, "f").record)
                    }
                    for (const t of (0,
                    R.gn)(this, kn, "f"))
                        t(e)
                }
            }
            kickPlayer(e) {
                const t = (0,
                R.gn)(this, vn, "f").find((t => t.id == e));
                if (null != t)
                    t.dataChannel.send(new Uint8Array([Zt.Kick])),
                    setTimeout(( () => {
                        t.dataChannel.close()
                    }
                    ), 1e3);
                else {
                    const t = (0,
                    R.gn)(this, An, "f").find((t => t.id == e));
                    null != t && ((0,
                    R.gn)(this, cn, "f")?.send(JSON.stringify({
                        version: Pt.rE,
                        type: "declineJoin",
                        session: t.session,
                        reason: "Kicked"
                    })),
                    t.dataChannel.close())
                }
            }
            getPing(e) {
                if (e == (0,
                R.gn)(this, mn, "f").id)
                    return 0;
                const t = (0,
                R.gn)(this, vn, "f").find((t => t.id == e));
                return null != t ? t.ping : null
            }
            getPlayers() {
                return (0,
                R.gn)(this, vn, "f").map((e => ({
                    id: e.id,
                    nickname: e.nickname,
                    countryCode: e.countryCode,
                    carStyle: e.carStyle,
                    record: e.record?.clone() ?? null,
                    isSelf: !1
                }))).concat({
                    id: (0,
                    R.gn)(this, mn, "f").id,
                    nickname: (0,
                    R.gn)(this, mn, "f").uncensoredNickname,
                    countryCode: (0,
                    R.gn)(this, mn, "f").countryCode,
                    carStyle: (0,
                    R.gn)(this, mn, "f").carStyle,
                    record: (0,
                    R.gn)(this, mn, "f").record?.clone() ?? null,
                    isSelf: !0
                })
            }
            getConnectingPlayers() {
                return (0,
                R.gn)(this, An, "f").map((e => ({
                    id: e.id,
                    nickname: e.nickname,
                    countryCode: e.countryCode,
                    carStyle: e.carStyle,
                    record: e.record?.clone() ?? null,
                    isSelf: !1
                })))
            }
            getMaxPlayers() {
                return (0,
                R.gn)(this, fn, "f")
            }
            startNewSessionImmediate(e, t, n) {
                null != (0,
                R.gn)(this, pn, "f") && (clearTimeout((0,
                R.gn)(this, pn, "f").timeout),
                (0,
                R.GG)(this, pn, null, "f")),
                (0,
                R.GG)(this, un, ((0,
                R.gn)(this, un, "f") + 1) % 2 ** 32, "f"),
                (0,
                R.GG)(this, dn, e, "f"),
                (0,
                R.GG)(this, hn, {
                    trackMetadata: t,
                    trackData: n
                }, "f"),
                (0,
                R.gn)(this, mn, "f").record = null,
                (0,
                R.gn)(this, mn, "f").resetCounter = 0;
                for (const e of (0,
                R.gn)(this, vn, "f"))
                    e.record = null,
                    e.resetCounter = 0;
                for (const e of (0,
                R.gn)(this, vn, "f"))
                    (0,
                    R.gn)(this, rn, "m", Rn).call(this, e.dataChannel);
                for (const e of (0,
                R.gn)(this, Tn, "f"))
                    e((0,
                    R.gn)(this, un, "f"), (0,
                    R.gn)(this, dn, "f"), t, n);
                return (0,
                R.gn)(this, un, "f")
            }
            startNewSession(e, t, n) {
                for (const e of (0,
                R.gn)(this, vn, "f"))
                    (0,
                    R.gn)(this, rn, "m", Cn).call(this, e.dataChannel),
                    (0,
                    R.gn)(this, rn, "m", _n).call(this, e.dataChannel, t, n);
                for (const e of (0,
                R.gn)(this, En, "f"))
                    e();
                null != (0,
                R.gn)(this, pn, "f") && clearTimeout((0,
                R.gn)(this, pn, "f").timeout),
                (0,
                R.GG)(this, pn, {
                    track: {
                        trackMetadata: t,
                        trackData: n
                    },
                    timeout: setTimeout(( () => {
                        this.startNewSessionImmediate(e, t, n)
                    }
                    ), 5e3)
                }, "f")
            }
            resetInvite() {
                null != (0,
                R.gn)(this, cn, "f") && ((0,
                R.gn)(this, cn, "f").close(),
                (0,
                R.GG)(this, cn, null, "f")),
                (0,
                R.GG)(this, on, null, "f")
            }
            createInvite(e) {
                if (null != (0,
                R.gn)(this, on, "f"))
                    return (0,
                    R.gn)(this, on, "f");
                const t = new Promise(( (n, i) => {
                    let r = !1
                      , a = null;
                    (0,
                    R.gn)(this, sn, "f").getIceServers().then((s => {
                        if ((0,
                        R.gn)(this, on, "f") != t)
                            return void i(new nn("Invite was reset"));
                        const o = (0,
                        R.gn)(this, sn, "f").createMultiplayerHostWebSocket();
                        (0,
                        R.GG)(this, cn, o, "f"),
                        o.addEventListener("open", ( () => {
                            const e = {
                                version: Pt.rE,
                                type: "createInvite"
                            };
                            null == (0,
                            R.gn)(this, mn, "f").nickname && (e.nickname = (0,
                            R.gn)(this, mn, "f").uncensoredNickname),
                            o.send(JSON.stringify(e))
                        }
                        )),
                        o.addEventListener("close", ( () => {
                            if ((0,
                            R.gn)(this, on, "f") == t && (0,
                            R.GG)(this, on, null, "f"),
                            null != (0,
                            R.gn)(this, ln, "f") && (clearTimeout((0,
                            R.gn)(this, ln, "f")),
                            (0,
                            R.GG)(this, ln, null, "f")),
                            (0,
                            R.gn)(this, cn, "f") == o && (0,
                            R.GG)(this, cn, null, "f"),
                            !r)
                                if (null != a) {
                                    let e;
                                    e = "IpLimit" == a ? "IpLimit" : void 0,
                                    i(new nn("Received error from server: " + a,e))
                                } else
                                    i(new nn("WebSocket closed unexpectedly"));
                            e()
                        }
                        )),
                        o.addEventListener("message", (e => {
                            var t, i;
                            let l, c = "Host WebSocket message error: ";
                            if ("string" != typeof e.data)
                                return console.error(c + "Received non-string data"),
                                void o.close();
                            try {
                                l = JSON.parse(e.data)
                            } catch {
                                return console.error(c + "Failed to parse JSON"),
                                void o.close()
                            }
                            if (null == l || "object" != typeof l)
                                return console.error(c + "JSON is not an object"),
                                void o.close();
                            if (!("type"in l) || "string" != typeof l.type)
                                return console.error(c + "Missing or invalid type"),
                                void o.close();
                            const h = l.type;
                            if ("error" == h)
                                return c += "error: ",
                                "error"in l && "string" == typeof l.error ? (a = l.error,
                                void o.close()) : (console.error(c + "Missing or invalid error"),
                                void o.close());
                            if ("createInvite" == h) {
                                if (c += "createInvite: ",
                                r)
                                    return console.error(c + "Received duplicate createInvite"),
                                    void o.close();
                                if (!("inviteCode"in l) || "string" != typeof l.inviteCode)
                                    return console.error(c + "Missing or invalid inviteCode"),
                                    void o.close();
                                const e = l.inviteCode;
                                if (!("timeoutMilliseconds"in l) || "number" != typeof l.timeoutMilliseconds)
                                    return console.error(c + "Missing or invalid timeoutMilliseconds"),
                                    void o.close();
                                const t = l.timeoutMilliseconds;
                                if (t <= 0 || !Number.isSafeInteger(t))
                                    return console.error(c + "Invalid timeoutMilliseconds value"),
                                    void o.close();
                                if (!("censoredNickname"in l) || "string" != typeof l.censoredNickname && null !== l.censoredNickname)
                                    return console.error(c + "Missing or invalid censoredNickname"),
                                    void o.close();
                                const i = l.censoredNickname;
                                null != i && ((0,
                                R.gn)(this, mn, "f").nickname = i),
                                (0,
                                R.GG)(this, ln, setTimeout(( () => {
                                    (0,
                                    R.GG)(this, ln, null, "f"),
                                    o.close()
                                }
                                ), t), "f"),
                                r = !0,
                                n({
                                    inviteCode: e,
                                    timeoutStart: new Date,
                                    timeoutMilliseconds: t
                                })
                            } else if ("joinInvite" == h) {
                                if (c += "joinInvite: ",
                                !("session"in l) || "string" != typeof l.session)
                                    return console.error(c + "Missing or invalid session"),
                                    void o.close();
                                const e = l.session;
                                if (!("offer"in l) || "string" != typeof l.offer)
                                    return console.error(c + "Missing or invalid offer"),
                                    void o.close();
                                const n = l.offer;
                                if (!("mods"in l) || !Array.isArray(l.mods))
                                    return console.error(c + "Missing or invalid mods"),
                                    void o.close();
                                const r = [];
                                for (const e of l.mods) {
                                    if ("string" != typeof e)
                                        return console.error(c + "Invalid mod entry"),
                                        void o.close();
                                    r.push(e)
                                }
                                if (!("isModsVanillaCompatible"in l) || "boolean" != typeof l.isModsVanillaCompatible)
                                    return console.error(c + "Missing or invalid isModsVanillaCompatible"),
                                    void o.close();
                                if (!l.isModsVanillaCompatible)
                                    return console.error(c + "Mods are not vanilla compatible"),
                                    void o.close();
                                if (!("nickname"in l) || "string" != typeof l.nickname)
                                    return console.error(c + "Missing or invalid nickname"),
                                    void o.close();
                                const a = l.nickname;
                                if (!("countryCode"in l) || "string" != typeof l.countryCode && null !== l.countryCode)
                                    return console.error(c + "Missing or invalid countryCode"),
                                    void o.close();
                                const h = l.countryCode;
                                let d;
                                if (d = null == h ? null : (0,
                                On.j)(h),
                                !("carStyle"in l) || "string" != typeof l.carStyle)
                                    return console.error(c + "Missing or invalid carStyle"),
                                    void o.close();
                                const u = Qt.A.deserializeSafe(l.carStyle);
                                if ((0,
                                R.gn)(this, vn, "f").length + (0,
                                R.gn)(this, An, "f").length + 1 >= (0,
                                R.gn)(this, fn, "f"))
                                    o.send(JSON.stringify({
                                        version: Pt.rE,
                                        type: "declineJoin",
                                        session: e,
                                        reason: "SessionFull"
                                    }));
                                else {
                                    const r = new RTCPeerConnection({
                                        iceServers: s
                                    })
                                      , l = r.createDataChannel("reliable", {
                                        negotiated: !0,
                                        id: 0
                                    });
                                    l.binaryType = "arraybuffer";
                                    const c = r.createDataChannel("unreliable", {
                                        negotiated: !0,
                                        id: 1,
                                        ordered: !1,
                                        maxRetransmits: 0
                                    });
                                    c.binaryType = "arraybuffer";
                                    const h = ((0,
                                    R.GG)(this, gn, (i = (0,
                                    R.gn)(this, gn, "f"),
                                    t = i++,
                                    i), "f"),
                                    t);
                                    (0,
                                    R.gn)(this, gn, "f") > 4294967295 && (0,
                                    R.GG)(this, gn, 1, "f");
                                    const p = {
                                        session: e,
                                        isOfferSet: !1,
                                        remoteIceCandidates: [],
                                        peerConnection: r,
                                        dataChannel: l,
                                        unreliableDataChannel: c,
                                        isInitialized: !1,
                                        isKicked: !1,
                                        id: h,
                                        nickname: a,
                                        countryCode: d,
                                        resetCounter: 0,
                                        carStyle: u,
                                        record: null,
                                        ping: null,
                                        pingIdCounter: 0,
                                        pingPackages: [],
                                        unsentCarStates: []
                                    };
                                    (0,
                                    R.gn)(this, rn, "m", Pn).call(this, l, p, "reliable"),
                                    (0,
                                    R.gn)(this, rn, "m", Pn).call(this, c, p, "unreliable"),
                                    (0,
                                    R.gn)(this, An, "f").push(p);
                                    for (const e of (0,
                                    R.gn)(this, kn, "f"))
                                        e((0,
                                        R.gn)(this, un, "f"));
                                    r.onicecandidate = t => {
                                        null != t.candidate && (r.onicecandidate = t => {
                                            o.send(JSON.stringify({
                                                version: Pt.rE,
                                                type: "iceCandidate",
                                                session: e,
                                                candidate: t.candidate
                                            }))
                                        }
                                        )
                                    }
                                    ,
                                    (async () => {
                                        await r.setRemoteDescription(new RTCSessionDescription({
                                            type: "offer",
                                            sdp: n
                                        }));
                                        const t = await r.createAnswer();
                                        await r.setLocalDescription(t),
                                        o.send(JSON.stringify({
                                            version: Pt.rE,
                                            type: "acceptJoin",
                                            session: e,
                                            answer: t.sdp,
                                            mods: [],
                                            isModsVanillaCompatible: !0,
                                            clientId: h
                                        })),
                                        p.isOfferSet = !0;
                                        for (const e of p.remoteIceCandidates)
                                            p.peerConnection.addIceCandidate(e).catch((e => {
                                                console.error("Failed to add remote ICE candidate:", e)
                                            }
                                            ));
                                        p.remoteIceCandidates.length = 0
                                    }
                                    )().catch(( () => {
                                        o.send(JSON.stringify({
                                            version: Pt.rE,
                                            type: "declineJoin",
                                            session: e,
                                            reason: "WebRTCError"
                                        })),
                                        (0,
                                        R.GG)(this, An, (0,
                                        R.gn)(this, An, "f").filter((e => e != p)), "f"),
                                        p.dataChannel.close();
                                        for (const e of (0,
                                        R.gn)(this, kn, "f"))
                                            e((0,
                                            R.gn)(this, un, "f"))
                                    }
                                    ))
                                }
                            } else {
                                if ("iceCandidate" != h)
                                    return console.error(c + "Unknown message type: " + h),
                                    void o.close();
                                {
                                    if (c += "iceCandidate: ",
                                    !("session"in l) || "string" != typeof l.session)
                                        return console.error(c + "Missing or invalid session"),
                                        void o.close();
                                    const e = l.session;
                                    if (!("candidate"in l) || "object" != typeof l.candidate)
                                        return console.error(c + "Missing or invalid candidate"),
                                        void o.close();
                                    const t = l.candidate
                                      , n = (0,
                                    R.gn)(this, An, "f").find((t => t.session == e));
                                    if (null == n)
                                        ;
                                    else if (n.isOfferSet)
                                        try {
                                            let e;
                                            e = null == t ? null : new RTCIceCandidate(t),
                                            n.peerConnection.addIceCandidate(e).catch((e => {
                                                console.error(c + "Failed to add remote ICE candidate:", e)
                                            }
                                            ))
                                        } catch (e) {
                                            console.error(c + "Failed to create RTCIceCandidate:", e)
                                        }
                                    else
                                        n.remoteIceCandidates.push(t)
                                }
                            }
                        }
                        ))
                    }
                    )).catch(( () => {
                        i(new nn("Failed to get ICE servers","IceServers"))
                    }
                    ))
                }
                ));
                return (0,
                R.GG)(this, on, t, "f"),
                (0,
                R.gn)(this, on, "f")
            }
            addPlayersChangedCallback(e) {
                (0,
                R.gn)(this, kn, "f").push(e)
            }
            removePlayersChangedCallback(e) {
                (0,
                R.GG)(this, kn, (0,
                R.gn)(this, kn, "f").filter((t => t != e)), "f")
            }
        }
        ;
        var Vn, Hn, jn, Kn, qn, Qn, Jn, Xn, Yn, Zn, $n, ei, ti, ni;
        Hn = new WeakMap,
        jn = new WeakMap,
        Kn = new WeakMap,
        qn = new WeakMap,
        Qn = new WeakMap,
        Jn = new WeakMap,
        Xn = new WeakMap,
        Yn = new WeakMap,
        Zn = new WeakMap,
        $n = new WeakMap,
        ei = new WeakMap,
        ti = new WeakMap,
        Vn = new WeakSet,
        ni = function() {
            "top" == (0,
            R.gn)(this, jn, "f").getSetting(P.A.Checkpoints) || (0,
            R.gn)(this, Kn, "f").touchEnabled ? (0,
            R.gn)(this, Qn, "f").classList.remove("up") : (0,
            R.gn)(this, Qn, "f").classList.add("up"),
            (0,
            R.gn)(this, Kn, "f").touchEnabled ? (0,
            R.gn)(this, Qn, "f").classList.add("touch") : (0,
            R.gn)(this, Qn, "f").classList.remove("touch")
        }
        ;
        const ii = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u) {
                Vn.add(this),
                Hn.set(this, void 0),
                jn.set(this, void 0),
                Kn.set(this, void 0),
                qn.set(this, void 0),
                Qn.set(this, void 0),
                Jn.set(this, void 0),
                Xn.set(this, void 0),
                Yn.set(this, void 0),
                Zn.set(this, void 0),
                $n.set(this, []),
                ei.set(this, !0),
                ti.set(this, void 0),
                (0,
                R.GG)(this, Hn, e, "f"),
                (0,
                R.GG)(this, jn, i, "f"),
                (0,
                R.GG)(this, Kn, r, "f"),
                (0,
                R.GG)(this, qn, n, "f"),
                (0,
                R.GG)(this, Qn, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Qn, "f").className = "game-toolbar-ui visible";
                const p = document.createElement("div");
                p.className = "info-container",
                (0,
                R.gn)(this, Qn, "f").appendChild(p);
                const f = document.createElement("div");
                f.className = "content",
                p.appendChild(f);
                const g = document.createElement("div");
                if (g.className = "track-name",
                f.appendChild(g),
                g.textContent = a.name,
                f.appendChild(g),
                null != s) {
                    let e;
                    switch (s.gameMode) {
                    case en.Casual:
                        e = n.get("Casual");
                        break;
                    case en.Competitive:
                        e = n.get("Competitive");
                        break;
                    default:
                        throw s.gameMode,
                        new Error("Unknown multiplayer game mode")
                    }
                    const t = document.createElement("div");
                    t.className = "game-mode",
                    t.textContent = e,
                    f.appendChild(t)
                }
                (0,
                R.GG)(this, Jn, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Jn, "f").className = "record",
                f.appendChild((0,
                R.gn)(this, Jn, "f")),
                (0,
                R.GG)(this, Xn, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Xn, "f").className = "position",
                f.appendChild((0,
                R.gn)(this, Xn, "f"));
                const m = document.createElement("div");
                m.className = "button-container",
                (0,
                R.gn)(this, Qn, "f").appendChild(m);
                const A = document.createElement("button");
                if (A.className = "button",
                A.innerHTML = '<img class="button-icon" src="images/quit.svg"> ',
                A.append(document.createTextNode(n.get("Exit"))),
                A.addEventListener("click", ( () => {
                    t.playUIClick(),
                    o()
                }
                )),
                m.appendChild(A),
                (0,
                R.gn)(this, $n, "f").push(A),
                null == s) {
                    const e = document.createElement("button");
                    if (e.className = "button",
                    e.innerHTML = '<img class="button-icon" src="images/preview.svg"> ',
                    e.append(document.createTextNode(n.get("Watch"))),
                    e.addEventListener("click", ( () => {
                        t.playUIClick(),
                        l()
                    }
                    )),
                    m.appendChild(e),
                    (0,
                    R.gn)(this, $n, "f").push(e),
                    (0,
                    R.GG)(this, Yn, e, "f"),
                    null != c) {
                        const e = document.createElement("button");
                        e.className = "button",
                        e.innerHTML = '<img class="button-icon" src="images/play.svg"> ',
                        e.append(document.createTextNode(n.get("Next Track"))),
                        e.addEventListener("click", ( () => {
                            t.playUIClick(),
                            c()
                        }
                        )),
                        m.appendChild(e),
                        (0,
                        R.gn)(this, $n, "f").push(e)
                    }
                } else
                    (0,
                    R.GG)(this, Yn, null, "f");
                if (s?.multiplayerConnection instanceof Wn) {
                    const e = document.createElement("button");
                    e.className = "button",
                    e.innerHTML = '<img class="button-icon" src="images/invite.svg"> ',
                    e.append(document.createTextNode(n.get("Invite"))),
                    e.addEventListener("click", ( () => {
                        t.playUIClick(),
                        h()
                    }
                    )),
                    m.appendChild(e),
                    (0,
                    R.gn)(this, $n, "f").push(e)
                }
                if (null != s) {
                    const e = document.createElement("button");
                    e.className = "button",
                    e.innerHTML = '<img class="button-icon" src="images/list.svg"> ',
                    e.append(document.createTextNode(n.get("Players"))),
                    e.addEventListener("click", ( () => {
                        t.playUIClick(),
                        d()
                    }
                    )),
                    m.appendChild(e),
                    (0,
                    R.gn)(this, $n, "f").push(e)
                }
                s?.multiplayerConnection instanceof Wn && ((0,
                R.GG)(this, Zn, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Zn, "f").className = "button",
                (0,
                R.gn)(this, Zn, "f").innerHTML = '<img class="button-icon" src="images/load.svg"> ',
                (0,
                R.gn)(this, Zn, "f").append(document.createTextNode(n.get("Change Track"))),
                (0,
                R.gn)(this, Zn, "f").addEventListener("click", ( () => {
                    t.playUIClick(),
                    u()
                }
                )),
                m.appendChild((0,
                R.gn)(this, Zn, "f")),
                (0,
                R.gn)(this, $n, "f").push((0,
                R.gn)(this, Zn, "f"))),
                (0,
                R.gn)(this, Hn, "f").appendChild((0,
                R.gn)(this, Qn, "f")),
                (0,
                R.gn)(this, Kn, "f").addChangeListener((0,
                R.GG)(this, ti, ( () => {
                    (0,
                    R.gn)(this, Kn, "f").touchEnabled ? p.classList.add("hidden") : p.classList.remove("hidden"),
                    (0,
                    R.gn)(this, Vn, "m", ni).call(this)
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Hn, "f").removeChild((0,
                R.gn)(this, Qn, "f")),
                (0,
                R.gn)(this, Kn, "f").removeChangeListener((0,
                R.gn)(this, ti, "f"))
            }
            setRecord(e) {
                null == e ? ((0,
                R.gn)(this, Jn, "f").textContent = (0,
                R.gn)(this, qn, "f").get("No record"),
                (0,
                R.gn)(this, Xn, "f").textContent = "") : ((0,
                R.gn)(this, Jn, "f").textContent = He.A.formatTimeString(e.time),
                (0,
                R.gn)(this, Xn, "f").textContent = "",
                e.position.then((e => {
                    null != e ? ((0,
                    R.gn)(this, Xn, "f").textContent = qe(e),
                    (0,
                    R.gn)(this, Xn, "f").classList.add("visible")) : ((0,
                    R.gn)(this, Xn, "f").textContent = "",
                    (0,
                    R.gn)(this, Xn, "f").classList.remove("visible"))
                }
                )))
            }
            setWatchButtonEnabled(e) {
                null != (0,
                R.gn)(this, Yn, "f") && ((0,
                R.gn)(this, Yn, "f").disabled = !e)
            }
            setChangeTrackEnabled(e) {
                null != (0,
                R.gn)(this, Zn, "f") && ((0,
                R.gn)(this, Zn, "f").disabled = !e)
            }
            setVisible(e) {
                (0,
                R.gn)(this, ei, "f") != e && (e ? (0,
                R.gn)(this, Qn, "f").classList.add("visible") : (0,
                R.gn)(this, Qn, "f").classList.remove("visible"),
                (0,
                R.GG)(this, ei, e, "f"))
            }
            hasFocus() {
                return document.activeElement instanceof HTMLButtonElement && (0,
                R.gn)(this, $n, "f").includes(document.activeElement)
            }
        }
        ;
        var ri = i(4538)
          , ai = {};
        ai.styleTagTransform = u(),
        ai.setAttributes = l(),
        ai.insert = s().bind(null, "head"),
        ai.domAPI = r(),
        ai.insertStyleElement = h();
        t()(ri.A, ai);
        ri.A && ri.A.locals && ri.A.locals;
        var si, oi, li;
        si = new WeakMap,
        oi = new WeakMap,
        li = new WeakMap;
        const ci = class {
            constructor(e, t) {
                si.set(this, void 0),
                oi.set(this, void 0),
                li.set(this, !1),
                (0,
                R.GG)(this, si, e, "f"),
                (0,
                R.GG)(this, oi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, oi, "f").className = "pause-screen-ui",
                (0,
                R.gn)(this, si, "f").appendChild((0,
                R.gn)(this, oi, "f"));
                const n = document.createElement("div");
                n.className = "title",
                n.textContent = t.get("Paused"),
                (0,
                R.gn)(this, oi, "f").appendChild(n)
            }
            dispose() {
                (0,
                R.gn)(this, si, "f").removeChild((0,
                R.gn)(this, oi, "f"))
            }
            startFadeOut(e) {
                (0,
                R.gn)(this, li, "f") || ((0,
                R.GG)(this, li, !0, "f"),
                (0,
                R.gn)(this, oi, "f").classList.add("fade-out"),
                setTimeout(e, 250))
            }
        }
        ;
        var hi = i(4239)
          , di = {};
        di.styleTagTransform = u(),
        di.setAttributes = l(),
        di.insert = s().bind(null, "head"),
        di.domAPI = r(),
        di.insertStyleElement = h();
        t()(hi.A, di);
        hi.A && hi.A.locals && hi.A.locals;
        var ui, pi, fi, gi;
        ui = new WeakMap,
        pi = new WeakMap,
        fi = new WeakMap,
        gi = new WeakMap;
        const mi = class {
            constructor(e, t, n) {
                ui.set(this, void 0),
                pi.set(this, void 0),
                fi.set(this, void 0),
                gi.set(this, void 0),
                (0,
                R.GG)(this, ui, e, "f"),
                (0,
                R.GG)(this, pi, n, "f"),
                (0,
                R.GG)(this, fi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, fi, "f").className = "ghost-loading-ui",
                (0,
                R.gn)(this, fi, "f").textContent = t.get("Loading replay"),
                (0,
                R.gn)(this, ui, "f").appendChild((0,
                R.gn)(this, fi, "f")),
                (0,
                R.GG)(this, gi, document.createElement("span"), "f"),
                (0,
                R.gn)(this, gi, "f").className = "percentage",
                (0,
                R.gn)(this, fi, "f").appendChild((0,
                R.gn)(this, gi, "f")),
                this.update(1)
            }
            dispose() {
                (0,
                R.gn)(this, ui, "f").removeChild((0,
                R.gn)(this, fi, "f"))
            }
            setOverridePosition(e) {
                const t = (0,
                R.gn)(this, pi, "f").getSetting(P.A.Speedometer);
                e ?? "top" == t ? (0,
                R.gn)(this, fi, "f").classList.add("down") : (0,
                R.gn)(this, fi, "f").classList.remove("down")
            }
            update(e) {
                (0,
                R.gn)(this, gi, "f").textContent = Math.floor(100 * e).toString() + "%",
                e >= 1 ? (0,
                R.gn)(this, fi, "f").classList.add("hide") : (0,
                R.gn)(this, fi, "f").classList.remove("hide")
            }
        }
        ;
        class Ai extends C.YJl {
            constructor(e) {
                super(),
                this.csm = e,
                this.displayFrustum = !0,
                this.displayPlanes = !0,
                this.displayShadowBounds = !0;
                const t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , n = new Float32Array(24)
                  , i = new C.LoY;
                i.setIndex(new C.THS(t,1)),
                i.setAttribute("position", new C.THS(n,3,!1));
                const r = new C.DXC(i,new C.mrM);
                this.add(r),
                this.frustumLines = r,
                this.cascadeLines = [],
                this.cascadePlanes = [],
                this.shadowLines = []
            }
            updateVisibility() {
                const e = this.displayFrustum
                  , t = this.displayPlanes
                  , n = this.displayShadowBounds
                  , i = this.frustumLines
                  , r = this.cascadeLines
                  , a = this.cascadePlanes
                  , s = this.shadowLines;
                for (let i = 0, o = r.length; i < o; i++) {
                    const o = r[i]
                      , l = a[i]
                      , c = s[i];
                    o.visible = e,
                    l.visible = e && t,
                    c.visible = n
                }
                i.visible = e
            }
            update() {
                const e = this.csm
                  , t = e.camera
                  , n = e.cascades
                  , i = e.mainFrustum
                  , r = e.frustums
                  , a = e.lights
                  , s = this.frustumLines.geometry.getAttribute("position")
                  , o = this.cascadeLines
                  , l = this.cascadePlanes
                  , c = this.shadowLines;
                if (null === t)
                    return;
                for (this.position.copy(t.position),
                this.quaternion.copy(t.quaternion),
                this.scale.copy(t.scale),
                this.updateMatrixWorld(!0); o.length > n; )
                    this.remove(o.pop()),
                    this.remove(l.pop()),
                    this.remove(c.pop());
                for (; o.length < n; ) {
                    const e = new C.BND(new C.NRn,16777215)
                      , t = new C.V9B({
                        transparent: !0,
                        opacity: .1,
                        depthWrite: !1,
                        side: C.$EB
                    })
                      , n = new C.eaF(new C.bdM,t)
                      , i = new C.YJl
                      , r = new C.BND(new C.NRn,16776960);
                    i.add(r),
                    this.add(e),
                    this.add(n),
                    this.add(i),
                    o.push(e),
                    l.push(n),
                    c.push(i)
                }
                for (let e = 0; e < n; e++) {
                    const t = r[e]
                      , n = a[e].shadow.camera
                      , i = t.vertices.far
                      , s = o[e]
                      , h = l[e]
                      , d = c[e]
                      , u = d.children[0];
                    s.box.min.copy(i[2]),
                    s.box.max.copy(i[0]),
                    s.box.max.z += 1e-4,
                    h.position.addVectors(i[0], i[2]),
                    h.position.multiplyScalar(.5),
                    h.scale.subVectors(i[0], i[2]),
                    h.scale.z = 1e-4,
                    this.remove(d),
                    d.position.copy(n.position),
                    d.quaternion.copy(n.quaternion),
                    d.scale.copy(n.scale),
                    d.updateMatrixWorld(!0),
                    this.attach(d),
                    u.box.min.set(n.bottom, n.left, -n.far),
                    u.box.max.set(n.top, n.right, -n.near)
                }
                const h = i.vertices.near
                  , d = i.vertices.far;
                s.setXYZ(0, d[0].x, d[0].y, d[0].z),
                s.setXYZ(1, d[3].x, d[3].y, d[3].z),
                s.setXYZ(2, d[2].x, d[2].y, d[2].z),
                s.setXYZ(3, d[1].x, d[1].y, d[1].z),
                s.setXYZ(4, h[0].x, h[0].y, h[0].z),
                s.setXYZ(5, h[3].x, h[3].y, h[3].z),
                s.setXYZ(6, h[2].x, h[2].y, h[2].z),
                s.setXYZ(7, h[1].x, h[1].y, h[1].z),
                s.needsUpdate = !0
            }
            dispose() {
                const e = this.frustumLines
                  , t = this.cascadeLines
                  , n = this.cascadePlanes
                  , i = this.shadowLines;
                e.geometry.dispose(),
                e.material.dispose();
                const r = this.csm.cascades;
                for (let e = 0; e < r; e++) {
                    const r = t[e]
                      , a = n[e]
                      , s = i[e].children[0];
                    r.dispose(),
                    a.geometry.dispose(),
                    a.material.dispose(),
                    s.dispose()
                }
            }
        }
        var vi, yi, wi, bi, xi, Si, Ei, Ti = i(8971), ki = i(405), Mi = i(5735);
        vi = new WeakMap,
        yi = new WeakMap,
        wi = new WeakMap,
        bi = new WeakMap,
        xi = new WeakMap,
        Si = new WeakMap,
        Ei = new WeakMap;
        const _i = class {
            constructor(e, t) {
                vi.set(this, void 0),
                yi.set(this, new C.YJl),
                wi.set(this, []),
                bi.set(this, null),
                xi.set(this, null),
                Si.set(this, null),
                Ei.set(this, void 0),
                (0,
                R.GG)(this, vi, e, "f"),
                (0,
                R.gn)(this, yi, "f").visible = !1,
                (0,
                R.gn)(this, vi, "f").scene.add((0,
                R.gn)(this, yi, "f")),
                t.getTrackData().forEachPart(( (e, t, n, i, r, a) => {
                    const s = (0,
                    ki.Hw)(i);
                    if (null != s.detector) {
                        const i = Mi.hT(r, a)
                          , o = new C.iNn(s.detector.size[0],s.detector.size[1],s.detector.size[2])
                          , l = new C.V9B({
                            color: 65280,
                            wireframe: !0
                        })
                          , c = new C.eaF(o,l);
                        c.position.set(e * Ti.A.partSize, t * Ti.A.partSize, n * Ti.A.partSize),
                        c.position.add(new C.Pq0(s.detector.center[0],s.detector.center[1],s.detector.center[2]).applyQuaternion(i)),
                        c.rotation.setFromQuaternion(i),
                        (0,
                        R.gn)(this, yi, "f").add(c),
                        (0,
                        R.gn)(this, wi, "f").push(c)
                    }
                }
                )),
                window.addEventListener("keydown", (0,
                R.GG)(this, Ei, (e => {
                    "BracketRight" == e.code && ((0,
                    R.gn)(this, yi, "f").visible = !(0,
                    R.gn)(this, yi, "f").visible)
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.gn)(this, vi, "f").scene.remove((0,
                R.gn)(this, yi, "f")),
                (0,
                R.gn)(this, yi, "f").clear();
                for (const e of (0,
                R.gn)(this, wi, "f"))
                    if (e.geometry.dispose(),
                    Array.isArray(e.material))
                        for (const t of e.material)
                            t.dispose();
                    else
                        e.material.dispose();
                if ((0,
                R.gn)(this, wi, "f").length = 0,
                null != (0,
                R.gn)(this, bi, "f"))
                    if ((0,
                    R.gn)(this, bi, "f").geometry.dispose(),
                    Array.isArray((0,
                    R.gn)(this, bi, "f").material))
                        for (const e of (0,
                        R.gn)(this, bi, "f").material)
                            e.dispose();
                    else
                        (0,
                        R.gn)(this, bi, "f").material.dispose();
                if (null != (0,
                R.gn)(this, xi, "f"))
                    if ((0,
                    R.gn)(this, xi, "f").geometry.dispose(),
                    Array.isArray((0,
                    R.gn)(this, xi, "f").material))
                        for (const e of (0,
                        R.gn)(this, xi, "f").material)
                            e.dispose();
                    else
                        (0,
                        R.gn)(this, xi, "f").material.dispose();
                null != (0,
                R.gn)(this, Si, "f") && (0,
                R.gn)(this, Si, "f").dispose(),
                window.removeEventListener("keydown", (0,
                R.gn)(this, Ei, "f"))
            }
            updateCar(e) {
                const t = e.getPosition()
                  , n = e.getQuaternion();
                if (null == (0,
                R.gn)(this, bi, "f")) {
                    const e = new C.iNn(2 * N.A.detectorBoxSize.x,2 * N.A.detectorBoxSize.y,2 * N.A.detectorBoxSize.z)
                      , t = new C.V9B({
                        color: 16711680,
                        wireframe: !0
                    });
                    (0,
                    R.GG)(this, bi, new C.eaF(e,t), "f"),
                    (0,
                    R.gn)(this, yi, "f").add((0,
                    R.gn)(this, bi, "f"))
                }
                if ((0,
                R.gn)(this, bi, "f").position.copy(N.A.detectorBoxCenter).applyQuaternion(n).add(t),
                (0,
                R.gn)(this, bi, "f").rotation.setFromQuaternion(n),
                null == (0,
                R.gn)(this, xi, "f")) {
                    if (null == N.A.models)
                        throw new Error("Car model has not been loaded yet");
                    const e = new C.LoY;
                    e.setAttribute("position", new C.THS(new Float32Array(N.A.models.collisionShapeVertices),3));
                    const t = new C.V9B({
                        color: 255,
                        wireframe: !0
                    });
                    (0,
                    R.GG)(this, xi, new C.eaF(e,t), "f"),
                    (0,
                    R.gn)(this, yi, "f").add((0,
                    R.gn)(this, xi, "f"))
                }
                const i = new C.Pq0(0,N.A.massOffset,0).applyQuaternion(n);
                (0,
                R.gn)(this, xi, "f").position.copy(t.clone().add(i)),
                (0,
                R.gn)(this, xi, "f").rotation.setFromQuaternion(n),
                (0,
                R.gn)(this, yi, "f").visible ? null != (0,
                R.gn)(this, vi, "f").csm && (null == (0,
                R.gn)(this, Si, "f") && ((0,
                R.GG)(this, Si, new Ai((0,
                R.gn)(this, vi, "f").csm), "f"),
                (0,
                R.gn)(this, yi, "f").add((0,
                R.gn)(this, Si, "f"))),
                (0,
                R.gn)(this, Si, "f").update()) : null != (0,
                R.gn)(this, Si, "f") && ((0,
                R.gn)(this, yi, "f").remove((0,
                R.gn)(this, Si, "f")),
                (0,
                R.gn)(this, Si, "f").dispose(),
                (0,
                R.GG)(this, Si, null, "f"))
            }
        }
        ;
        var Ci = i(732)
          , Ri = {};
        Ri.styleTagTransform = u(),
        Ri.setAttributes = l(),
        Ri.insert = s().bind(null, "head"),
        Ri.domAPI = r(),
        Ri.insertStyleElement = h();
        t()(Ci.A, Ri);
        Ci.A && Ci.A.locals && Ci.A.locals;
        var Pi, Ii, Li, Ni, zi, Ui, Di, Bi, Gi, Fi, Oi, Wi, Vi, Hi, ji, Ki, qi = i(202);
        Ii = new WeakMap,
        Li = new WeakMap,
        Ni = new WeakMap,
        zi = new WeakMap,
        Ui = new WeakMap,
        Di = new WeakMap,
        Bi = new WeakMap,
        Gi = new WeakMap,
        Fi = new WeakMap,
        Oi = new WeakMap,
        Wi = new WeakMap,
        Vi = new WeakMap,
        Hi = new WeakMap,
        Pi = new WeakSet,
        ji = function(e) {
            (0,
            R.gn)(this, Hi, "f") || ((0,
            R.GG)(this, Hi, !0, "f"),
            (0,
            R.gn)(this, zi, "f").prepend((0,
            R.gn)(this, Ui, "f")),
            null != (0,
            R.gn)(this, Bi, "f") && ((0,
            R.gn)(this, zi, "f").removeChild((0,
            R.gn)(this, Bi, "f")),
            (0,
            R.GG)(this, Bi, null, "f")),
            (0,
            R.GG)(this, Gi, null, "f"),
            null != (0,
            R.gn)(this, Fi, "f") && ((0,
            R.gn)(this, zi, "f").removeChild((0,
            R.gn)(this, Fi, "f")),
            (0,
            R.GG)(this, Fi, null, "f")),
            null != (0,
            R.gn)(this, Vi, "f") && (clearInterval((0,
            R.gn)(this, Vi, "f")),
            (0,
            R.GG)(this, Vi, null, "f")),
            (0,
            R.gn)(this, Oi, "f").disabled = !0,
            e.createInvite(( () => {
                (0,
                R.gn)(this, Pi, "m", Ki).call(this, null),
                null != (0,
                R.gn)(this, Vi, "f") && (clearInterval((0,
                R.gn)(this, Vi, "f")),
                (0,
                R.GG)(this, Vi, null, "f"))
            }
            )).then(( ({inviteCode: e, timeoutStart: t, timeoutMilliseconds: n}) => {
                (0,
                R.gn)(this, zi, "f").removeChild((0,
                R.gn)(this, Ui, "f")),
                (0,
                R.GG)(this, Bi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Bi, "f").className = "invite-code-container",
                (0,
                R.gn)(this, zi, "f").prepend((0,
                R.gn)(this, Bi, "f"));
                const i = document.createElement("div");
                i.className = "title",
                i.textContent = (0,
                R.gn)(this, Li, "f").get("Share the invite code below to invite people to your game"),
                (0,
                R.gn)(this, Bi, "f").appendChild(i),
                (0,
                R.GG)(this, Gi, document.createElement("input"), "f"),
                (0,
                R.gn)(this, Gi, "f").type = "text",
                (0,
                R.gn)(this, Gi, "f").value = e,
                (0,
                R.gn)(this, Gi, "f").readOnly = !0,
                (0,
                R.gn)(this, Bi, "f").appendChild((0,
                R.gn)(this, Gi, "f")),
                (0,
                R.GG)(this, Wi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Wi, "f").className = "timeout-timer",
                (0,
                R.gn)(this, Bi, "f").appendChild((0,
                R.gn)(this, Wi, "f")),
                (0,
                R.gn)(this, Pi, "m", Ki).call(this, {
                    timeoutStart: t,
                    timeoutMilliseconds: n
                }),
                (0,
                R.GG)(this, Vi, setInterval(( () => {
                    (0,
                    R.gn)(this, Pi, "m", Ki).call(this, {
                        timeoutStart: t,
                        timeoutMilliseconds: n
                    })
                }
                ), 1e3), "f"),
                (0,
                R.gn)(this, Di, "f").disabled = !1
            }
            )).catch((e => {
                if ((0,
                R.gn)(this, zi, "f").removeChild((0,
                R.gn)(this, Ui, "f")),
                (0,
                R.GG)(this, Fi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Fi, "f").className = "error-container",
                (0,
                R.gn)(this, Fi, "f").textContent = (0,
                R.gn)(this, Li, "f").get("Failed to create invite"),
                (0,
                R.gn)(this, zi, "f").prepend((0,
                R.gn)(this, Fi, "f")),
                e instanceof nn) {
                    let t;
                    switch (e.serverError) {
                    case void 0:
                        t = null;
                        break;
                    case "IpLimit":
                        t = (0,
                        R.gn)(this, Li, "f").get("Too many hosts on this IP address");
                        break;
                    case "IceServers":
                        t = (0,
                        R.gn)(this, Li, "f").get("Failed to connect to server");
                        break;
                    default:
                        e.serverError,
                        t = null
                    }
                    if (null != t) {
                        const e = document.createElement("div");
                        e.className = "error-reason",
                        e.textContent = t,
                        (0,
                        R.gn)(this, Fi, "f").appendChild(e)
                    }
                }
                (0,
                R.gn)(this, Oi, "f").disabled = !1
            }
            )).finally(( () => {
                (0,
                R.GG)(this, Hi, !1, "f")
            }
            )))
        }
        ,
        Ki = function(e) {
            if (null == (0,
            R.gn)(this, Wi, "f"))
                return;
            const t = new Date;
            let n;
            if (n = null == e ? 0 : e.timeoutStart.getTime() + e.timeoutMilliseconds - t.getTime(),
            n <= 0)
                (0,
                R.gn)(this, Wi, "f").textContent = (0,
                R.gn)(this, Li, "f").get("Invite Expired"),
                (0,
                R.gn)(this, Wi, "f").classList.add("expired"),
                (0,
                R.gn)(this, Oi, "f").disabled = !1;
            else {
                const i = Math.floor(n / 6e4)
                  , r = Math.floor(n / 1e3) - 60 * i;
                (0,
                R.gn)(this, Wi, "f").textContent = (0,
                R.gn)(this, Li, "f").get("Expires in {0}", [i.toString() + ":" + r.toString().padStart(2, "0")]),
                (0,
                R.gn)(this, Wi, "f").classList.remove("expired");
                const a = 6e4;
                (0,
                R.gn)(this, Oi, "f").disabled = null != e && t.getTime() - e.timeoutStart.getTime() < a
            }
        }
        ;
        const Qi = class {
            constructor(e, t, n, i, r) {
                Pi.add(this),
                Ii.set(this, void 0),
                Li.set(this, void 0),
                Ni.set(this, void 0),
                zi.set(this, void 0),
                Ui.set(this, void 0),
                Di.set(this, void 0),
                Bi.set(this, null),
                Gi.set(this, null),
                Fi.set(this, null),
                Oi.set(this, void 0),
                Wi.set(this, null),
                Vi.set(this, null),
                Hi.set(this, !1),
                (0,
                R.GG)(this, Ii, e, "f"),
                (0,
                R.GG)(this, Li, n, "f"),
                (0,
                R.GG)(this, Ni, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ni, "f").className = "invite-ui",
                (0,
                R.gn)(this, Ii, "f").appendChild((0,
                R.gn)(this, Ni, "f"));
                const a = document.createElement("h2");
                a.textContent = n.get("Invite"),
                (0,
                R.gn)(this, Ni, "f").appendChild(a),
                (0,
                R.GG)(this, zi, document.createElement("div"), "f"),
                (0,
                R.gn)(this, zi, "f").className = "content",
                (0,
                R.gn)(this, Ni, "f").appendChild((0,
                R.gn)(this, zi, "f")),
                (0,
                R.GG)(this, Ui, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ui, "f").className = "loading-container";
                const s = document.createElement("div");
                s.className = "loading-text",
                s.textContent = n.get("Creating invite..."),
                (0,
                R.gn)(this, Ui, "f").appendChild(s);
                const o = document.createElement("div");
                o.className = "loading-spinner-ui",
                (0,
                R.gn)(this, Ui, "f").appendChild(o);
                const l = document.createElement("div");
                l.className = "new-code-container",
                (0,
                R.gn)(this, zi, "f").appendChild(l),
                (0,
                R.GG)(this, Oi, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Oi, "f").className = "button new-code-button",
                (0,
                R.gn)(this, Oi, "f").innerHTML = '<img class="button-icon" src="images/refresh.svg"> ',
                (0,
                R.gn)(this, Oi, "f").disabled = !0,
                (0,
                R.gn)(this, Oi, "f").prepend(document.createTextNode(n.get("New Code") + " ")),
                (0,
                R.gn)(this, Oi, "f").addEventListener("click", ( () => {
                    t.playUIClick(),
                    i.resetInvite(),
                    (0,
                    R.gn)(this, Pi, "m", ji).call(this, i)
                }
                )),
                l.appendChild((0,
                R.gn)(this, Oi, "f"));
                const c = document.createElement("div");
                c.className = "buttons-container",
                (0,
                R.gn)(this, Ni, "f").appendChild(c);
                const h = document.createElement("button");
                h.className = "button",
                h.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                h.addEventListener("click", ( () => {
                    t.playUIClick(),
                    r()
                }
                )),
                h.appendChild(document.createTextNode(n.get("Close"))),
                c.appendChild(h),
                (0,
                R.GG)(this, Di, new qi.A(t,n,( () => (0,
                R.gn)(this, Gi, "f")?.value ?? "")), "f"),
                (0,
                R.gn)(this, Di, "f").disabled = !0,
                c.appendChild((0,
                R.gn)(this, Di, "f")),
                (0,
                R.gn)(this, Pi, "m", ji).call(this, i)
            }
            dispose() {
                (0,
                R.gn)(this, Ii, "f").removeChild((0,
                R.gn)(this, Ni, "f")),
                null != (0,
                R.gn)(this, Vi, "f") && (clearInterval((0,
                R.gn)(this, Vi, "f")),
                (0,
                R.GG)(this, Vi, null, "f"))
            }
        }
        ;
        var Ji = i(1901)
          , Xi = {};
        Xi.styleTagTransform = u(),
        Xi.setAttributes = l(),
        Xi.insert = s().bind(null, "head"),
        Xi.domAPI = r(),
        Xi.insertStyleElement = h();
        t()(Ji.A, Xi);
        Ji.A && Ji.A.locals && Ji.A.locals;
        var Yi, Zi, $i, er, tr, nr, ir, rr, ar, sr, or, lr, cr, hr, dr, ur, pr, fr, gr = i(832), mr = i(1055);
        Zi = new WeakMap,
        $i = new WeakMap,
        er = new WeakMap,
        tr = new WeakMap,
        nr = new WeakMap,
        ir = new WeakMap,
        rr = new WeakMap,
        ar = new WeakMap,
        sr = new WeakMap,
        or = new WeakMap,
        lr = new WeakMap,
        cr = new WeakMap,
        hr = new WeakMap,
        dr = new WeakMap,
        ur = new WeakMap,
        Yi = new WeakSet,
        pr = function() {
            (0,
            R.gn)(this, ar, "f").innerHTML = "",
            (0,
            R.gn)(this, sr, "f").length = 0;
            let e = (0,
            R.gn)(this, nr, "f").getPlayers();
            (0,
            R.gn)(this, nr, "f")instanceof Wn && (e = e.concat((0,
            R.gn)(this, nr, "f").getConnectingPlayers())),
            (0,
            R.gn)(this, hr, "f") || ((0,
            R.gn)(this, rr, "f").textContent = (0,
            R.gn)(this, er, "f").get("Players") + " (" + e.length.toString() + "/" + (0,
            R.gn)(this, nr, "f").getMaxPlayers().toString() + ")"),
            e.sort(( (e, t) => {
                let n;
                return n = null != e.record && null != t.record ? e.record.numberOfFrames - t.record.numberOfFrames : null != e.record && null == t.record ? -1 : null == e.record && null != t.record ? 1 : 0,
                0 == n ? e.id - t.id : n
            }
            ));
            for (let t = 0; t < e.length; t++) {
                const n = 1 + t
                  , i = e[t]
                  , r = document.createElement("div");
                i.isSelf && r.classList.add("self"),
                (0,
                R.gn)(this, ar, "f").appendChild(r);
                const a = document.createElement("div");
                a.className = "position",
                a.textContent = Qe(n),
                r.appendChild(a);
                const s = document.createElement("span");
                s.textContent = Je(n),
                a.appendChild(s);
                const o = document.createElement("div");
                o.className = "time",
                o.textContent = He.A.formatTimeString(i.record),
                r.appendChild(o);
                const l = document.createElement("img");
                l.className = "car-thumbnail";
                const c = (0,
                R.gn)(this, cr, "f").get(i.carStyle.serialize());
                if (null != c)
                    l.src = c;
                else {
                    l.src = "images/car_thumbnail_placeholder.png";
                    const e = i.carStyle.serialize();
                    gr.F(i.carStyle, (0,
                    R.gn)(this, lr, "f")).then((t => {
                        l.src = t,
                        (0,
                        R.gn)(this, cr, "f").set(e, t)
                    }
                    ))
                }
                r.appendChild(l);
                const h = document.createElement("div");
                h.className = "nickname",
                r.appendChild(h);
                const d = (0,
                On.O)()
                  , u = null == i.countryCode ? null : d.find((e => e.code == i.countryCode));
                if (null != u) {
                    const e = document.createElement("img");
                    e.className = "country-flag",
                    e.src = "images/countries/" + u.code + ".svg?v=0.6.0-beta1-mp21",
                    e.draggable = !1,
                    e.title = u.name,
                    h.appendChild(e)
                }
                const p = document.createElement("span");
                if (p.textContent = i.nickname,
                h.appendChild(p),
                i.isSelf) {
                    const e = document.createElement("span");
                    e.className = "self",
                    e.textContent = "(" + (0,
                    R.gn)(this, er, "f").get("You") + ")",
                    h.appendChild(e)
                }
                const f = document.createElement("div");
                f.className = "ping",
                r.appendChild(f);
                const g = document.createTextNode("-");
                f.appendChild(g);
                const m = document.createElement("span");
                if (m.textContent = "ms",
                f.appendChild(m),
                (0,
                R.gn)(this, sr, "f").push({
                    playerId: i.id,
                    textNode: g,
                    unitElement: m
                }),
                (0,
                R.gn)(this, nr, "f")instanceof Wn)
                    if (i.isSelf) {
                        const e = document.createElement("div");
                        e.className = "kick-button-placeholder",
                        r.appendChild(e)
                    } else {
                        const e = (0,
                        R.gn)(this, nr, "f")
                          , t = i.id
                          , n = document.createElement("button");
                        n.className = "button kick-button",
                        n.innerHTML = '<img class="button-icon" src="images/cancel.svg">',
                        n.addEventListener("click", ( () => {
                            (0,
                            R.gn)(this, $i, "f").playUIClick(),
                            (0,
                            R.gn)(this, tr, "f").showConfirm((0,
                            R.gn)(this, er, "f").get('Are you sure you want to kick the player "{0}"?', [i.nickname]), (0,
                            R.gn)(this, er, "f").get("Cancel"), (0,
                            R.gn)(this, er, "f").get("Kick"), null, ( () => {
                                e.kickPlayer(t)
                            }
                            ))
                        }
                        )),
                        r.appendChild(n)
                    }
            }
            (0,
            R.gn)(this, Yi, "m", fr).call(this)
        }
        ,
        fr = function() {
            for (const {playerId: e, textNode: t, unitElement: n} of (0,
            R.gn)(this, sr, "f")) {
                const i = (0,
                R.gn)(this, nr, "f").getPing(e);
                null != i ? (t.textContent = Math.max(0, Math.min(999, i)).toString(),
                n.style.display = "") : (t.textContent = "-",
                n.style.display = "none")
            }
        }
        ;
        const Ar = class {
            constructor(e, t, n, i, r, a, s) {
                Yi.add(this),
                Zi.set(this, void 0),
                $i.set(this, void 0),
                er.set(this, void 0),
                tr.set(this, void 0),
                nr.set(this, void 0),
                ir.set(this, void 0),
                rr.set(this, void 0),
                ar.set(this, void 0),
                sr.set(this, []),
                or.set(this, void 0),
                lr.set(this, new mr.A),
                cr.set(this, new Map),
                hr.set(this, !1),
                dr.set(this, void 0),
                ur.set(this, void 0),
                (0,
                R.GG)(this, Zi, e, "f"),
                (0,
                R.GG)(this, $i, t, "f"),
                (0,
                R.GG)(this, er, n, "f"),
                (0,
                R.GG)(this, tr, i, "f"),
                (0,
                R.GG)(this, nr, a, "f"),
                (0,
                R.GG)(this, ir, document.createElement("div"), "f"),
                (0,
                R.gn)(this, ir, "f").className = "player-list-ui",
                (0,
                R.gn)(this, Zi, "f").appendChild((0,
                R.gn)(this, ir, "f")),
                (0,
                R.GG)(this, rr, document.createElement("h2"), "f"),
                (0,
                R.gn)(this, ir, "f").appendChild((0,
                R.gn)(this, rr, "f")),
                (0,
                R.GG)(this, ar, document.createElement("div"), "f"),
                (0,
                R.gn)(this, ar, "f").className = "content",
                (0,
                R.gn)(this, ir, "f").appendChild((0,
                R.gn)(this, ar, "f"));
                const o = document.createElement("div");
                o.className = "bottom-container",
                (0,
                R.gn)(this, ir, "f").appendChild(o);
                const l = document.createElement("button");
                l.className = "button",
                l.innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
                l.addEventListener("click", ( () => {
                    t.playUIClick(),
                    s()
                }
                )),
                l.appendChild(document.createTextNode(n.get("Close"))),
                o.appendChild(l),
                (0,
                R.gn)(this, Yi, "m", pr).call(this),
                (0,
                R.gn)(this, nr, "f").addPlayersChangedCallback((0,
                R.GG)(this, ur, ( () => {
                    (0,
                    R.gn)(this, Yi, "m", pr).call(this)
                }
                ), "f")),
                (0,
                R.gn)(this, nr, "f").addEndSessionCallback(r, (0,
                R.GG)(this, dr, ( () => {
                    if ((0,
                    R.GG)(this, hr, !0, "f"),
                    (0,
                    R.gn)(this, rr, "f").textContent = (0,
                    R.gn)(this, er, "f").get("Session Results"),
                    l.parentElement == o) {
                        o.removeChild(l);
                        const e = document.createElement("div");
                        e.className = "session-ended-text",
                        e.textContent = (0,
                        R.gn)(this, er, "f").get("A new session will start shortly"),
                        o.appendChild(e)
                    }
                }
                ), "f")),
                (0,
                R.GG)(this, or, setInterval(( () => {
                    (0,
                    R.gn)(this, Yi, "m", fr).call(this)
                }
                ), 500), "f")
            }
            dispose() {
                (0,
                R.gn)(this, nr, "f").removePlayersChangedCallback((0,
                R.gn)(this, ur, "f")),
                (0,
                R.gn)(this, nr, "f").removeEndSessionCallback((0,
                R.gn)(this, dr, "f")),
                clearInterval((0,
                R.gn)(this, or, "f")),
                (0,
                R.gn)(this, Zi, "f").removeChild((0,
                R.gn)(this, ir, "f")),
                (0,
                R.gn)(this, lr, "f").cancel()
            }
        }
        ;
        var vr = i(4839)
          , yr = i(9782)
          , wr = {};
        wr.styleTagTransform = u(),
        wr.setAttributes = l(),
        wr.insert = s().bind(null, "head"),
        wr.domAPI = r(),
        wr.insertStyleElement = h();
        t()(yr.A, wr);
        yr.A && yr.A.locals && yr.A.locals;
        var br, xr, Sr;
        br = new WeakMap,
        xr = new WeakMap,
        Sr = new WeakMap;
        const Er = class {
            constructor(e, t) {
                br.set(this, void 0),
                xr.set(this, void 0),
                Sr.set(this, void 0),
                (0,
                R.GG)(this, br, e, "f"),
                (0,
                R.GG)(this, xr, t, "f"),
                (0,
                R.GG)(this, Sr, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Sr, "f").className = "server-message-ui",
                (0,
                R.gn)(this, br, "f").appendChild((0,
                R.gn)(this, Sr, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, br, "f").removeChild((0,
                R.gn)(this, Sr, "f"))
            }
            show(e) {
                const t = .03125;
                (0,
                R.gn)(this, Sr, "f").animate([{
                    offset: 0,
                    opacity: "0",
                    transform: "translateX(20px)"
                }, {
                    offset: t,
                    opacity: "1",
                    transform: "none"
                }, {
                    offset: .96875,
                    opacity: "1",
                    transform: "none"
                }, {
                    offset: 1,
                    opacity: "0",
                    transform: "translateX(20px)"
                }], {
                    duration: 3200,
                    iterations: 1,
                    fill: "forwards",
                    easing: "ease-in-out"
                }),
                (0,
                R.gn)(this, Sr, "f").textContent = e
            }
            setOverridePosition(e) {
                const t = (0,
                R.gn)(this, xr, "f").getSetting(P.A.Speedometer);
                e ?? "top" == t ? (0,
                R.gn)(this, Sr, "f").classList.add("down") : (0,
                R.gn)(this, Sr, "f").classList.remove("down")
            }
        }
        ;
        var Tr = i(6223)
          , kr = i(5302)
          , Mr = i(1083)
          , _r = {};
        _r.styleTagTransform = u(),
        _r.setAttributes = l(),
        _r.insert = s().bind(null, "head"),
        _r.domAPI = r(),
        _r.insertStyleElement = h();
        t()(Mr.A, _r);
        Mr.A && Mr.A.locals && Mr.A.locals;
        var Cr, Rr, Pr;
        Cr = new WeakMap,
        Rr = new WeakMap,
        Pr = new WeakMap;
        const Ir = class {
            constructor() {
                Cr.set(this, void 0),
                Rr.set(this, void 0),
                Pr.set(this, !0);
                const e = document.getElementById("ui");
                if (null == e)
                    throw new Error("UI element not found");
                (0,
                R.GG)(this, Cr, e, "f"),
                (0,
                R.GG)(this, Rr, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Rr, "f").className = "game-ui",
                (0,
                R.gn)(this, Cr, "f").appendChild((0,
                R.gn)(this, Rr, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Cr, "f").removeChild((0,
                R.gn)(this, Rr, "f"))
            }
            get element() {
                return (0,
                R.gn)(this, Rr, "f")
            }
            get isVisible() {
                return (0,
                R.gn)(this, Pr, "f")
            }
            set isVisible(e) {
                (0,
                R.gn)(this, Pr, "f") != e && ((0,
                R.GG)(this, Pr, e, "f"),
                e ? (0,
                R.gn)(this, Rr, "f").classList.remove("hidden") : (0,
                R.gn)(this, Rr, "f").classList.add("hidden"))
            }
        }
        ;
        var Lr = i(6249)
          , Nr = {};
        Nr.styleTagTransform = u(),
        Nr.setAttributes = l(),
        Nr.insert = s().bind(null, "head"),
        Nr.domAPI = r(),
        Nr.insertStyleElement = h();
        t()(Lr.A, Nr);
        Lr.A && Lr.A.locals && Lr.A.locals;
        var zr, Ur;
        zr = new WeakMap,
        Ur = new WeakMap;
        const Dr = class {
            constructor() {
                zr.set(this, void 0),
                Ur.set(this, void 0);
                const e = document.getElementById("ui");
                if (null == e)
                    throw new Error("UI element not found");
                (0,
                R.GG)(this, zr, e, "f"),
                (0,
                R.GG)(this, Ur, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ur, "f").className = "session-end-ui",
                (0,
                R.gn)(this, zr, "f").appendChild((0,
                R.gn)(this, Ur, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Ur, "f").parentElement == (0,
                R.gn)(this, zr, "f") && (0,
                R.gn)(this, zr, "f").removeChild((0,
                R.gn)(this, Ur, "f"))
            }
        }
        ;
        function Br(e, t, n) {
            return e + (t - e) * n
        }
        function Gr(e, t, n) {
            const i = new C.PTz(e.quaternion.x,e.quaternion.y,e.quaternion.z,e.quaternion.w)
              , r = new C.PTz(t.quaternion.x,t.quaternion.y,t.quaternion.z,t.quaternion.w)
              , a = (new C.PTz).slerpQuaternions(i, r, n)
              , s = [];
            for (let i = 0; i < 4; i++) {
                const r = e.wheelContact[i]
                  , a = t.wheelContact[i];
                if (null != r && null != a) {
                    const e = new C.Pq0(Br(r.normal.x, a.normal.x, n),Br(r.normal.y, a.normal.y, n),Br(r.normal.z, a.normal.z, n)).normalize();
                    s[i] = {
                        position: {
                            x: Br(r.position.x, a.position.x, n),
                            y: Br(r.position.y, a.position.y, n),
                            z: Br(r.position.z, a.position.z, n)
                        },
                        normal: {
                            x: e.x,
                            y: e.y,
                            z: e.z
                        }
                    }
                } else
                    s[i] = null
            }
            return {
                frames: Math.round(Br(e.frames, t.frames, n)),
                speedKmh: Br(e.speedKmh, t.speedKmh, n),
                hasStarted: t.hasStarted,
                finishFrames: e.finishFrames,
                nextCheckpointIndex: e.nextCheckpointIndex,
                hasCheckpointToRespawnAt: e.hasCheckpointToRespawnAt,
                position: {
                    x: Br(e.position.x, t.position.x, n),
                    y: Br(e.position.y, t.position.y, n),
                    z: Br(e.position.z, t.position.z, n)
                },
                quaternion: {
                    x: a.x,
                    y: a.y,
                    z: a.z,
                    w: a.w
                },
                collisionImpulses: [],
                wheelContact: [s[0], s[1], s[2], s[3]],
                wheelSuspensionLength: [Br(e.wheelSuspensionLength[0], t.wheelSuspensionLength[0], n), Br(e.wheelSuspensionLength[1], t.wheelSuspensionLength[1], n), Br(e.wheelSuspensionLength[2], t.wheelSuspensionLength[2], n), Br(e.wheelSuspensionLength[3], t.wheelSuspensionLength[3], n)],
                wheelSuspensionVelocity: [Br(e.wheelSuspensionVelocity[0], t.wheelSuspensionVelocity[0], n), Br(e.wheelSuspensionVelocity[1], t.wheelSuspensionVelocity[1], n), Br(e.wheelSuspensionVelocity[2], t.wheelSuspensionVelocity[2], n), Br(e.wheelSuspensionVelocity[3], t.wheelSuspensionVelocity[3], n)],
                wheelDeltaRotation: [Br(e.wheelDeltaRotation[0], t.wheelDeltaRotation[0], n), Br(e.wheelDeltaRotation[1], t.wheelDeltaRotation[1], n), Br(e.wheelDeltaRotation[2], t.wheelDeltaRotation[2], n), Br(e.wheelDeltaRotation[3], t.wheelDeltaRotation[3], n)],
                wheelSkidInfo: [Br(e.wheelSkidInfo[0], t.wheelSkidInfo[0], n), Br(e.wheelSkidInfo[1], t.wheelSkidInfo[1], n), Br(e.wheelSkidInfo[2], t.wheelSkidInfo[2], n), Br(e.wheelSkidInfo[3], t.wheelSkidInfo[3], n)],
                steering: Br(e.steering, t.steering, n),
                brakeLightEnabled: t.brakeLightEnabled,
                controls: {
                    up: t.controls.up,
                    right: t.controls.right,
                    down: t.controls.down,
                    left: t.controls.left,
                    reset: t.controls.reset
                }
            }
        }
        var Fr, Or, Wr, Vr, Hr, jr, Kr, qr, Qr, Jr, Xr, Yr, Zr, $r, ea, ta, na, ia, ra, aa, sa, oa, la, ca, ha, da, ua, pa, fa, ga, ma, Aa, va, ya, wa, ba, xa, Sa, Ea, Ta, ka, Ma, _a, Ca, Ra, Pa, Ia, La, Na, za, Ua, Da, Ba, Ga, Fa, Oa, Wa, Va, Ha, ja, Ka, qa, Qa, Ja, Xa, Ya, Za, $a, es, ts, ns, is, rs, as, ss, os, ls, cs, hs, ds, us;
        Or = new WeakMap,
        Wr = new WeakMap,
        Vr = new WeakMap,
        Hr = new WeakMap,
        jr = new WeakMap,
        Kr = new WeakMap,
        qr = new WeakMap,
        Qr = new WeakMap,
        Jr = new WeakMap,
        Xr = new WeakMap,
        Yr = new WeakMap,
        Zr = new WeakMap,
        $r = new WeakMap,
        ea = new WeakMap,
        ta = new WeakMap,
        na = new WeakMap,
        ia = new WeakMap,
        ra = new WeakMap,
        aa = new WeakMap,
        sa = new WeakMap,
        oa = new WeakMap,
        la = new WeakMap,
        ca = new WeakMap,
        ha = new WeakMap,
        da = new WeakMap,
        ua = new WeakMap,
        pa = new WeakMap,
        fa = new WeakMap,
        ga = new WeakMap,
        ma = new WeakMap,
        Aa = new WeakMap,
        va = new WeakMap,
        ya = new WeakMap,
        wa = new WeakMap,
        ba = new WeakMap,
        xa = new WeakMap,
        Sa = new WeakMap,
        Ea = new WeakMap,
        Ta = new WeakMap,
        ka = new WeakMap,
        Ma = new WeakMap,
        _a = new WeakMap,
        Ca = new WeakMap,
        Ra = new WeakMap,
        Pa = new WeakMap,
        Ia = new WeakMap,
        La = new WeakMap,
        Na = new WeakMap,
        za = new WeakMap,
        Ua = new WeakMap,
        Da = new WeakMap,
        Ba = new WeakMap,
        Ga = new WeakMap,
        Fa = new WeakMap,
        Oa = new WeakMap,
        Wa = new WeakMap,
        Va = new WeakMap,
        Ha = new WeakMap,
        ja = new WeakMap,
        Ka = new WeakMap,
        qa = new WeakMap,
        Qa = new WeakMap,
        Ja = new WeakMap,
        Xa = new WeakMap,
        Ya = new WeakMap,
        Za = new WeakMap,
        $a = new WeakMap,
        es = new WeakMap,
        Fr = new WeakSet,
        ts = function() {
            if (null == (0,
            R.gn)(this, za, "f"))
                (0,
                R.gn)(this, ra, "f").call(this);
            else {
                let e;
                e = (0,
                R.gn)(this, za, "f").multiplayerConnection instanceof Wn ? (0,
                R.gn)(this, Kr, "f").get("Are you sure you want to quit?") + "\n\n" + (0,
                R.gn)(this, Kr, "f").get("All connected players will be disconnected!") : (0,
                R.gn)(this, Kr, "f").get("Are you sure you want to quit?"),
                (0,
                R.gn)(this, $r, "f").showConfirm(e, (0,
                R.gn)(this, Kr, "f").get("Cancel"), (0,
                R.gn)(this, Kr, "f").get("Confirm"), null, ( () => {
                    (0,
                    R.gn)(this, ra, "f").call(this)
                }
                ))
            }
        }
        ,
        ns = function() {
            return null != (0,
            R.gn)(this, xa, "f") || null != (0,
            R.gn)(this, Sa, "f") || null != (0,
            R.gn)(this, Ea, "f") || (0,
            R.gn)(this, $r, "f").isOpen
        }
        ,
        is = function() {
            return !((0,
            R.gn)(this, La, "f").hasFinished() || !(0,
            R.gn)(this, La, "f").hasCheckpointToRespawnAt() || !(0,
            R.gn)(this, Ra, "f") || null != (0,
            R.gn)(this, Ia, "f") && (new Date).getTime() - (0,
            R.gn)(this, Ia, "f").getTime() < 250)
        }
        ,
        rs = function() {
            null != (0,
            R.gn)(this, ba, "f") || (0,
            R.gn)(this, Va, "f") || (0,
            R.gn)(this, La, "f").hasFinished() || ((0,
            R.gn)(this, Yr, "f").getSettingBoolean(P.A.CockpitCameraToggle) ? (0,
            R.gn)(this, qr, "f").camera == (0,
            R.gn)(this, La, "f").cameraOrbit ? (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraCockpit) : (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraOrbit) : (0,
            R.gn)(this, Yr, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraOrbit) : (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraCockpit))
        }
        ,
        as = function() {
            (0,
            R.gn)(this, Xa, "f").isEnabled || (0,
            R.gn)(this, La, "f").hasFinished() || (0,
            R.gn)(this, Yr, "f").getSettingBoolean(P.A.CockpitCameraToggle) || ((0,
            R.gn)(this, Yr, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraCockpit) : (0,
            R.gn)(this, qr, "f").setCamera((0,
            R.gn)(this, La, "f").cameraOrbit))
        }
        ,
        ss = function() {
            I.Xx() || (0,
            R.gn)(this, Va, "f") || ((0,
            R.gn)(this, La, "f").hasFinished() && (0,
            R.gn)(this, za, "f")?.gameMode != en.Competitive ? I.RN().finally(( () => {
                (0,
                R.gn)(this, Va, "f") || ((0,
                R.gn)(this, Fr, "m", os).call(this),
                (0,
                R.gn)(this, Fr, "m", cs).call(this))
            }
            )) : ((0,
            R.gn)(this, Fr, "m", os).call(this),
            (0,
            R.gn)(this, Fr, "m", cs).call(this)))
        }
        ,
        os = function() {
            const e = (0,
            R.gn)(this, qr, "f").camera == (0,
            R.gn)(this, La, "f").cameraCockpit;
            (0,
            R.gn)(this, La, "f").dispose(),
            (0,
            R.GG)(this, La, (0,
            R.gn)(this, Fr, "m", ls).call(this, e), "f")
        }
        ,
        ls = function(e) {
            var t;
            const n = (0,
            R.gn)(this, Jr, "f").getCurrentUserProfile();
            (0,
            R.gn)(this, Fr, "m", us).call(this);
            const i = (0,
            R.gn)(this, Vr, "f").getStartTransform();
            if (null == i)
                throw new Error("Start transform is null");
            const r = (0,
            R.GG)(this, Ha, (t = (0,
            R.gn)(this, Ha, "f"),
            ++t), "f");
            let a;
            if (null != (0,
            R.gn)(this, za, "f")) {
                const e = (0,
                R.gn)(this, za, "f");
                a = t => {
                    e.multiplayerConnection.sendCarUpdate(e.sessionId, r, t)
                }
                ,
                (0,
                R.gn)(this, za, "f").multiplayerConnection.sendCarReset(e.sessionId, r)
            } else
                a = null;
            const s = new N.A((0,
            R.gn)(this, Or, "f"),i,null,(0,
            R.gn)(this, Pa, "f"),(0,
            R.gn)(this, qr, "f"),(0,
            R.gn)(this, Qr, "f"),(0,
            R.gn)(this, Hr, "f"),(0,
            R.gn)(this, Vr, "f"),(0,
            R.gn)(this, ca, "f"),(0,
            R.gn)(this, Yr, "f"),a);
            return s.notificationAudioEnabled = !0,
            s.addResetCallback(( () => {
                (0,
                R.gn)(this, Pa, "f").reset = !1,
                (0,
                R.GG)(this, Ra, s.getControls().up || s.getControls().down, "f"),
                (0,
                R.gn)(this, Ra, "f") && (0,
                R.GG)(this, Ia, new Date, "f")
            }
            )),
            s.addCheckpointCallback((e => {
                const t = (0,
                R.gn)(this, Fr, "m", hs).call(this)
                  , n = s.getTime();
                let i = null;
                if (null != t && t.checkpoints.length > e && (i = t.checkpoints[e].time),
                (0,
                R.gn)(this, va, "f").showCheckpointTime(n, i),
                null != t && t.checkpoints.length > e) {
                    const n = t.checkpoints[e].speedKmh;
                    (0,
                    R.gn)(this, Aa, "f").showCheckpointSpeed(s.getSpeedKmh(), n)
                }
                try {
                    if (null == t || t.checkpoints.length <= e || null == i)
                        return;
                    const r = (0,
                    R.gn)(this, Yr, "f");
                    let a = r.getSettingFloat(P.A.HuSplitsSize)
                      , o = r.getSettingFloat(P.A.HuSplitsHeight)
                      , l = r.getSettingFloat(P.A.HuSplitsOpacity);
                    const c = r.getSettingBoolean(P.A.HuSplitsShowSpeed);
                    Number.isFinite(a) || (a = .5),
                    Number.isFinite(o) || (o = .1),
                    Number.isFinite(l) || (l = 1);
                    const u = n.difference(i)
                      , d = u.numberOfFrames / 1e3
                      , p = e => null == e ? "---" : (e => {
                        const t = Math.abs(e.numberOfFrames)
                          , n = Math.floor(t / 6e4)
                          , i = Math.floor((t - 6e4 * n) / 1e3)
                          , r = t - 6e4 * n - 1e3 * i;
                        return n.toString().padStart(2, "0") + ":" + i.toString().padStart(2, "0") + "." + r.toString().padStart(3, "0")
                    }
                    )(e)
                      , f = s.getSpeedKmh() - t.checkpoints[e].speedKmh
                      , m = document.getElementById("ui");
                    if (null == m)
                        return;
                    const g = document.createElement("div");
                    g.style = `
                position: fixed;
                top: ${100 * o}%;
                left: 50%;
                opacity: ${l};
                transform: translateX(-50%);
                font-family: ForcedSquare;
                font-style: normal;
                font-size: ${4 * a}rem;
                color: white;
                display: flex;
                flex-direction: column;
                gap: 2px;
                user-select: none;
                pointer-events: none;
                z-index: 9999;
                `;
                    const v = document.createElement("div");
                    v.style = "display: flex;";
                    const y = document.createElement("div");
                    y.style = `
                padding: 4px 8px;
                text-align: center;
                flex: 1;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                `;
                    const b = document.createElement("div");
                    b.style = `
                padding: 4px 8px;
                text-align: center;
                flex: 1;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                `;
                    const w = document.createElement("div");
                    w.style = "display: flex;";
                    const k = document.createElement("div");
                    k.style = `
                padding: 4px 8px;
                text-align: center;
                flex: 1;
                background-color: rgba(0, 0, 0, 0.7);
                display: flex;
                align-items: center;
                justify-content: center;
                `;
                    const S = document.createElement("div");
                    S.style = `
                display: flex;
                justify-content: left;
                `;
                    S.innerHTML = `
                <p style="
                    margin: 0;
                    padding: 4px 8px;
                    font-weight: bold;
                    background-color:${d >= 0 ? "#f55" : "#334bffcc"};
                    text-align: center;
                ">
                    ${d >= 0 ? "+" : ""}${d.toFixed(3)}
                </p>
                `;
                    y.textContent = s.getSpeedKmh().toFixed(1);
                    b.innerHTML = `
                <p style="
                    margin: 0;
                    font-weight: bold;
                    color: ${f < 0 ? "#f55" : 0 === f ? "#808080" : "#5f5"};
                ">
                    ${f <= 0 ? "" : "+"}${f.toFixed(1)}
                </p>
                `;
                    k.textContent = p(n);
                    v.appendChild(y),
                    v.appendChild(b),
                    w.appendChild(k),
                    c && g.appendChild(v),
                    g.appendChild(w),
                    g.appendChild(S),
                    m.appendChild(g),
                    setTimeout(( () => {
                        g.remove()
                    }
                    ), 2e3)
                } catch (e) {
                    console.error(e)
                }
            }
            )),
            s.addFinishCallback((e => {
                const t = e.getTime()
                  , i = e.getRecording()
                  , r = e.getCarStyle();
                let a;
                const s = (0,
                R.gn)(this, Ka, "f");
                if (null == (0,
                R.gn)(this, Ka, "f") || t.lessThan((0,
                R.gn)(this, Ka, "f").time)) {
                    if (a = (async () => {
                        if ((0,
                        R.gn)(this, ia, "f")) {
                            const e = (0,
                            R.gn)(this, Jr, "f").profileSlot
                              , n = (0,
                            R.gn)(this, Xr, "f").getRecordTime(e, (0,
                            R.gn)(this, ca, "f").getId());
                            if (null == n || t.lessThan(n)) {
                                const n = "official" == (0,
                                R.gn)(this, ha, "f") || "community" == (0,
                                R.gn)(this, ha, "f");
                                return (0,
                                R.gn)(this, Xr, "f").setRecord(e, (0,
                                R.gn)(this, ca, "f").getId(), n, t, i)
                            }
                        }
                        return Promise.resolve(null)
                    }
                    )(),
                    null == (0,
                    R.gn)(this, za, "f"))
                        if (0 == (0,
                        R.gn)(this, Na, "f").length)
                            (0,
                            R.gn)(this, Na, "f").push({
                                car: null,
                                carId: null,
                                hasEnded: !1,
                                loadedFrames: 0,
                                maxFrames: 0,
                                settings: {
                                    recording: i,
                                    carStyle: r,
                                    nickname: n.nickname,
                                    time: t,
                                    isSelf: !0
                                },
                                replay: null,
                                checkpoints: [],
                                finishSpeedKmh: null
                            }),
                            (0,
                            R.gn)(this, wa, "f").setWatchButtonEnabled(null != (0,
                            R.gn)(this, aa, "f"));
                        else {
                            const e = (0,
                            R.gn)(this, Na, "f").find((e => e.settings.isSelf));
                            null != e && (e.settings = {
                                recording: i,
                                carStyle: r,
                                nickname: n.nickname,
                                time: t,
                                isSelf: !0
                            }),
                            (0,
                            R.gn)(this, wa, "f").setWatchButtonEnabled(null != (0,
                            R.gn)(this, aa, "f"))
                        }
                    (0,
                    R.GG)(this, Ka, {
                        time: t,
                        position: a.then((e => e?.newPosition ?? null)),
                        recording: i
                    }, "f")
                } else
                    a = Promise.resolve(null);
                const o = (0,
                R.gn)(this, qa, "f");
                if ((null == (0,
                R.gn)(this, qa, "f") || t.lessThan((0,
                R.gn)(this, qa, "f").time)) && (0,
                R.GG)(this, qa, {
                    time: t,
                    recording: i
                }, "f"),
                null != (0,
                R.gn)(this, za, "f")) {
                    let e;
                    switch ((0,
                    R.gn)(this, za, "f").gameMode) {
                    case en.Casual:
                        null != s && (0,
                        R.gn)(this, Ka, "f").time.equals(s.time) ? e = null : ((0,
                        R.gn)(this, za, "f").multiplayerConnection.sendRecord((0,
                        R.gn)(this, za, "f").sessionId, (0,
                        R.gn)(this, Ka, "f").time),
                        e = (0,
                        R.gn)(this, Ka, "f"));
                        break;
                    case en.Competitive:
                        null != o && (0,
                        R.gn)(this, qa, "f").time.equals(o.time) ? e = null : ((0,
                        R.gn)(this, za, "f").multiplayerConnection.sendRecord((0,
                        R.gn)(this, za, "f").sessionId, (0,
                        R.gn)(this, qa, "f").time),
                        e = (0,
                        R.gn)(this, qa, "f"));
                        break;
                    default:
                        (0,
                        R.gn)(this, za, "f").gameMode,
                        e = null
                    }
                    if (null != e)
                        if (0 == (0,
                        R.gn)(this, Na, "f").length)
                            (0,
                            R.gn)(this, Na, "f").push({
                                car: null,
                                carId: null,
                                hasEnded: !1,
                                loadedFrames: 0,
                                maxFrames: 0,
                                settings: {
                                    recording: e.recording,
                                    carStyle: r,
                                    nickname: n.nickname,
                                    time: e.time,
                                    isSelf: !0
                                },
                                replay: null,
                                checkpoints: [],
                                finishSpeedKmh: null
                            });
                        else {
                            const t = (0,
                            R.gn)(this, Na, "f").find((e => e.settings.isSelf));
                            null != t && (t.settings = {
                                recording: e.recording,
                                carStyle: r,
                                nickname: n.nickname,
                                time: e.time.clone(),
                                isSelf: !0
                            })
                        }
                }
                let l = null;
                const c = (0,
                R.gn)(this, Fr, "m", hs).call(this);
                if (null == c || c.settings.isSelf || (l = {
                    record: c.settings.time,
                    nickname: c.settings.nickname
                }),
                null == (0,
                R.gn)(this, za, "f"))
                    (0,
                    R.GG)(this, ya, new nt((0,
                    R.gn)(this, ua, "f").element,(0,
                    R.gn)(this, Kr, "f"),(0,
                    R.gn)(this, Qr, "f"),(0,
                    R.gn)(this, la, "f").name,t,s?.time ?? null,"personal-best",l,a), "f");
                else
                    switch ((0,
                    R.gn)(this, za, "f").gameMode) {
                    case en.Casual:
                        (0,
                        R.GG)(this, ya, new nt((0,
                        R.gn)(this, ua, "f").element,(0,
                        R.gn)(this, Kr, "f"),(0,
                        R.gn)(this, Qr, "f"),(0,
                        R.gn)(this, la, "f").name,t,s?.time ?? null,"personal-best",l,Promise.resolve(null)), "f");
                        break;
                    case en.Competitive:
                        {
                            let e;
                            e = null != s && (0,
                            R.gn)(this, Ka, "f").time.equals(s.time) ? "session-best" : "personal-best",
                            (0,
                            R.GG)(this, ya, new nt((0,
                            R.gn)(this, ua, "f").element,(0,
                            R.gn)(this, Kr, "f"),(0,
                            R.gn)(this, Qr, "f"),(0,
                            R.gn)(this, la, "f").name,t,o?.time ?? null,e,l,Promise.resolve(null)), "f");
                            break
                        }
                    default:
                        (0,
                        R.gn)(this, za, "f").gameMode
                    }
                null != c?.finishSpeedKmh && (0,
                R.gn)(this, Aa, "f").showCheckpointSpeed(e.getSpeedKmh(), c.finishSpeedKmh)
            }
            )),
            s.setCarStyle(n.carStyle),
            e ? (0,
            R.gn)(this, qr, "f").setCamera(s.cameraCockpit) : (0,
            R.gn)(this, qr, "f").setCamera(s.cameraOrbit),
            (0,
            R.gn)(this, Xa, "f").isEnabled = !1,
            (0,
            R.gn)(this, ya, "f")?.dispose(),
            (0,
            R.GG)(this, ya, null, "f"),
            (0,
            R.gn)(this, va, "f").hideCheckpointTime(),
            (0,
            R.gn)(this, Aa, "f").hideCheckpointSpeed(),
            (0,
            R.gn)(this, Pa, "f").reset = !1,
            (0,
            R.GG)(this, Ra, !1, "f"),
            (0,
            R.GG)(this, Ia, null, "f"),
            s
        }
        ,
        cs = function() {
            if ((0,
            R.gn)(this, Yr, "f").getSettingBoolean(P.A.GhostCarEnabled))
                for (const e of (0,
                R.gn)(this, Na, "f")) {
                    null != e.car && (e.car.dispose(),
                    e.car = null);
                    const t = (0,
                    R.gn)(this, Vr, "f").getStartTransform();
                    if (null == t)
                        throw new Error("Start transform is null");
                    if (e.settings.recording != e.replay?.recording && (null != e.carId && ((0,
                    R.gn)(this, Wr, "f").deleteCar(e.carId),
                    e.carId = null),
                    e.replay = null),
                    null == e.replay) {
                        const n = e.settings.time.numberOfFrames + (0,
                        R.gn)(this, es, "f")
                          , i = new Vt
                          , r = [];
                        let a = 0;
                        const s = (0,
                        R.gn)(this, Wr, "f").createCar(t, (0,
                        R.gn)(this, Hr, "f").getMountainVertices(), (0,
                        R.gn)(this, Hr, "f").getMountainOffset(), (0,
                        R.gn)(this, ca, "f"), e.settings.recording, (t => {
                            i.push(t),
                            t.nextCheckpointIndex > a && (r.push({
                                time: new wt.A(t.frames),
                                speedKmh: t.speedKmh
                            }),
                            a = t.nextCheckpointIndex),
                            null == e.finishSpeedKmh && null != t.finishFrames && (e.finishSpeedKmh = t.speedKmh),
                            t.frames >= n && null != e.carId && (null != t.finishFrames && t.finishFrames == e.settings.time.numberOfFrames || (0,
                            R.GG)(this, ja, !0, "f"),
                            (0,
                            R.gn)(this, Wr, "f").deleteCar(e.carId),
                            e.carId = null),
                            e.loadedFrames = t.frames,
                            e.maxFrames = n
                        }
                        ));
                        i.push(s.carState),
                        (0,
                        R.gn)(this, Wr, "f").startCar(s.id, new wt.A(n)),
                        e.carId = s.id,
                        e.loadedFrames = 0,
                        e.maxFrames = n,
                        e.replay = {
                            replay: i,
                            recording: e.settings.recording
                        },
                        e.checkpoints = r
                    }
                    if (null == (0,
                    R.gn)(this, za, "f")) {
                        const n = new N.A(null,t,e.settings.recording,null,(0,
                        R.gn)(this, qr, "f"),(0,
                        R.gn)(this, Qr, "f"),(0,
                        R.gn)(this, Hr, "f"),(0,
                        R.gn)(this, Vr, "f"),(0,
                        R.gn)(this, ca, "f"),(0,
                        R.gn)(this, Yr, "f"),null);
                        n.setCarStyle(e.settings.carStyle),
                        n.audioVolume = (0,
                        R.gn)(this, $a, "f"),
                        (0,
                        R.gn)(this, Fr, "m", ds).call(this),
                        e.car = n,
                        e.hasEnded = !1
                    }
                }
        }
        ,
        hs = function() {
            let e = null;
            for (const t of (0,
            R.gn)(this, Na, "f"))
                (null == e || t.settings.time.lessThan(e.settings.time) || t.settings.time.equals(e.settings.time) && t.settings.isSelf) && (e = t);
            return e
        }
        ,
        ds = function() {
            const e = (0,
            R.gn)(this, La, "f").getPosition()
              , t = (0,
            R.gn)(this, Na, "f").map((e => e.car)).filter((e => null != e)).concat(Array.from((0,
            R.gn)(this, Wa, "f").values()).map((e => e.car)));
            for (const n of t) {
                const t = n.getPosition().distanceTo(e)
                  , i = Math.max(0, Math.min(1, t / 5));
                n.setOpacity(i)
            }
        }
        ,
        us = function() {
            if (null != (0,
            R.gn)(this, za, "f")) {
                let e;
                switch ((0,
                R.gn)(this, za, "f").gameMode) {
                case en.Casual:
                    e = (0,
                    R.gn)(this, Ka, "f")?.time ?? null,
                    (0,
                    R.gn)(this, wa, "f").setRecord((0,
                    R.gn)(this, Ka, "f"));
                    break;
                case en.Competitive:
                    e = (0,
                    R.gn)(this, qa, "f")?.time ?? null,
                    (0,
                    R.gn)(this, wa, "f").setRecord(null == (0,
                    R.gn)(this, qa, "f") ? null : {
                        time: (0,
                        R.gn)(this, qa, "f").time,
                        position: Promise.resolve(null)
                    });
                    break;
                default:
                    (0,
                    R.gn)(this, za, "f").gameMode,
                    e = null
                }
                (0,
                R.gn)(this, va, "f").record = e,
                (0,
                R.gn)(this, va, "f").nickname = null
            } else {
                (0,
                R.gn)(this, wa, "f").setRecord((0,
                R.gn)(this, Ka, "f"));
                const e = (0,
                R.gn)(this, Fr, "m", hs).call(this);
                (0,
                R.gn)(this, va, "f").record = e?.settings.time ?? null,
                null == e || e.settings.isSelf ? (0,
                R.gn)(this, va, "f").nickname = null : (0,
                R.gn)(this, va, "f").nickname = e.settings.nickname
            }
        }
        ;
        const ps = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A, v, y, w, b, x, S, E, T, k, M) {
                if (Fr.add(this),
                Or.set(this, void 0),
                Wr.set(this, void 0),
                Vr.set(this, void 0),
                Hr.set(this, void 0),
                jr.set(this, void 0),
                Kr.set(this, void 0),
                qr.set(this, void 0),
                Qr.set(this, void 0),
                Jr.set(this, void 0),
                Xr.set(this, void 0),
                Yr.set(this, void 0),
                Zr.set(this, void 0),
                $r.set(this, void 0),
                ea.set(this, void 0),
                ta.set(this, void 0),
                na.set(this, void 0),
                ia.set(this, void 0),
                ra.set(this, void 0),
                aa.set(this, void 0),
                sa.set(this, void 0),
                oa.set(this, void 0),
                la.set(this, void 0),
                ca.set(this, void 0),
                ha.set(this, void 0),
                da.set(this, !0),
                ua.set(this, void 0),
                pa.set(this, void 0),
                fa.set(this, null),
                ga.set(this, null),
                ma.set(this, void 0),
                Aa.set(this, void 0),
                va.set(this, void 0),
                ya.set(this, null),
                wa.set(this, void 0),
                ba.set(this, null),
                xa.set(this, null),
                Sa.set(this, null),
                Ea.set(this, null),
                Ta.set(this, null),
                ka.set(this, null),
                Ma.set(this, null),
                _a.set(this, void 0),
                Ca.set(this, void 0),
                Ra.set(this, !1),
                Pa.set(this, void 0),
                Ia.set(this, null),
                La.set(this, void 0),
                Na.set(this, []),
                za.set(this, void 0),
                Ua.set(this, null),
                Da.set(this, null),
                Ba.set(this, null),
                Ga.set(this, null),
                Fa.set(this, null),
                Oa.set(this, null),
                Wa.set(this, new Map),
                Va.set(this, !1),
                Ha.set(this, 0),
                ja.set(this, !1),
                Ka.set(this, void 0),
                qa.set(this, null),
                Qa.set(this, void 0),
                Ja.set(this, void 0),
                Xa.set(this, void 0),
                Ya.set(this, null),
                Za.set(this, null),
                $a.set(this, void 0),
                es.set(this, 1e4),
                (0,
                R.GG)(this, Or, e, "f"),
                (0,
                R.GG)(this, Wr, t, "f"),
                (0,
                R.GG)(this, Vr, n, "f"),
                (0,
                R.GG)(this, Hr, i, "f"),
                (0,
                R.GG)(this, jr, r, "f"),
                (0,
                R.GG)(this, Kr, a, "f"),
                (0,
                R.GG)(this, qr, s, "f"),
                (0,
                R.GG)(this, Qr, o, "f"),
                (0,
                R.GG)(this, Jr, l, "f"),
                (0,
                R.GG)(this, Xr, c, "f"),
                (0,
                R.GG)(this, Yr, d, "f"),
                (0,
                R.GG)(this, Zr, u, "f"),
                (0,
                R.GG)(this, $r, p, "f"),
                (0,
                R.GG)(this, ea, f, "f"),
                (0,
                R.GG)(this, ta, g, "f"),
                (0,
                R.GG)(this, na, h, "f"),
                (0,
                R.GG)(this, ia, x, "f"),
                (0,
                R.GG)(this, ra, E, "f"),
                (0,
                R.GG)(this, aa, T, "f"),
                (0,
                R.GG)(this, sa, k, "f"),
                (0,
                R.GG)(this, oa, M, "f"),
                (0,
                R.GG)(this, Ka, w, "f"),
                (0,
                R.GG)(this, la, m, "f"),
                (0,
                R.GG)(this, ca, A, "f"),
                (0,
                R.GG)(this, ha, v, "f"),
                null != b ? (0,
                R.GG)(this, za, {
                    multiplayerConnection: b.multiplayerConnection,
                    sessionId: b.sessionId,
                    gameMode: b.gameMode
                }, "f") : (0,
                R.GG)(this, za, null, "f"),
                n.loadTrackData(A),
                n.generateMeshes(),
                i.generateMountains(n.getBounds()),
                (0,
                R.GG)(this, Na, y.map((e => ({
                    car: null,
                    carId: null,
                    hasEnded: !1,
                    loadedFrames: 0,
                    maxFrames: 0,
                    settings: e,
                    replay: null,
                    checkpoints: [],
                    finishSpeedKmh: null
                }))), "f"),
                d.getSettingBoolean(P.A.GhostCarSoundsEnabled) ? (0,
                R.GG)(this, $a, .35, "f") : (0,
                R.GG)(this, $a, 0, "f"),
                (0,
                R.GG)(this, Pa, new Ot(d), "f"),
                (0,
                R.gn)(this, Pa, "f").addChangeCallback((e => {
                    !e.up && !e.down || (0,
                    R.gn)(this, Ra, "f") || ((0,
                    R.GG)(this, Ra, !0, "f"),
                    (0,
                    R.GG)(this, Ia, new Date, "f"))
                }
                )),
                (0,
                R.GG)(this, Xa, new yt(s,d), "f"),
                (0,
                R.gn)(this, Xa, "f").addToggleListener((e => {
                    e ? ((0,
                    R.gn)(this, ua, "f").isVisible = !1,
                    s.setCamera((0,
                    R.gn)(this, Xa, "f").camera)) : ((0,
                    R.gn)(this, ua, "f").isVisible = (0,
                    R.gn)(this, da, "f"),
                    (0,
                    R.gn)(this, Yr, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
                    R.gn)(this, qr, "f").setCamera((0,
                    R.gn)(this, La, "f").cameraCockpit) : (0,
                    R.gn)(this, qr, "f").setCamera((0,
                    R.gn)(this, La, "f").cameraOrbit))
                }
                )),
                u.setCursorHiddenWhenInactive(!0),
                (0,
                R.GG)(this, _a, new It((0,
                R.gn)(this, Pa, "f"),(0,
                R.gn)(this, Qr, "f"),(0,
                R.gn)(this, Yr, "f"),( () => {
                    (0,
                    R.gn)(this, Fr, "m", rs).call(this)
                }
                ),( () => {
                    (0,
                    R.gn)(this, Fr, "m", as).call(this)
                }
                ),( () => {
                    !I.ip() && (0,
                    R.gn)(this, La, "f").hasStarted() && ((0,
                    R.gn)(this, Fr, "m", is).call(this) ? (0,
                    R.gn)(this, Pa, "f").reset = !0 : ((0,
                    R.gn)(this, Fr, "m", ss).call(this),
                    (0,
                    R.gn)(this, Pa, "f").reset = !1))
                }
                )), "f"),
                (0,
                R.gn)(this, _a, "f").isEnabled = (0,
                R.gn)(this, ea, "f").touchEnabled,
                (0,
                R.GG)(this, ua, new Ir, "f"),
                (0,
                R.GG)(this, pa, new Pe((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Kr, "f"),(0,
                R.gn)(this, ea, "f"),(0,
                R.gn)(this, Yr, "f")), "f"),
                null != (0,
                R.gn)(this, za, "f") ? (0,
                R.GG)(this, ga, new Er((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Yr, "f")), "f") : (0,
                R.GG)(this, fa, new mi((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Kr, "f"),(0,
                R.gn)(this, Yr, "f")), "f"),
                (0,
                R.GG)(this, ma, new pe((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Vr, "f").getTotalNumberOfCheckpointIndices(),(0,
                R.gn)(this, Yr, "f")), "f"),
                (0,
                R.GG)(this, Aa, new Ve((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Yr, "f")), "f"),
                (0,
                R.GG)(this, va, new He.A((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Kr, "f"),(0,
                R.gn)(this, Yr, "f")), "f"),
                (0,
                R.GG)(this, wa, new ii((0,
                R.gn)(this, ua, "f").element,(0,
                R.gn)(this, Qr, "f"),(0,
                R.gn)(this, Kr, "f"),(0,
                R.gn)(this, Yr, "f"),(0,
                R.gn)(this, ea, "f"),(0,
                R.gn)(this, la, "f"),(0,
                R.gn)(this, za, "f"),( () => {
                    (0,
                    R.gn)(this, Fr, "m", ts).call(this)
                }
                ),( () => {
                    (0,
                    R.gn)(this, Na, "f").length > 0 && null != (0,
                    R.gn)(this, aa, "f") && (0,
                    R.gn)(this, aa, "f").call(this, (0,
                    R.gn)(this, la, "f"), (0,
                    R.gn)(this, ca, "f"), (0,
                    R.gn)(this, ha, "f"), (0,
                    R.gn)(this, Na, "f").map((e => e.settings)))
                }
                ),(0,
                R.gn)(this, sa, "f"),( () => {
                    if (!((0,
                    R.gn)(this, za, "f")?.multiplayerConnection instanceof Wn))
                        throw new Error("Multiplayer connection is not a host");
                    null != (0,
                    R.gn)(this, Sa, "f") && ((0,
                    R.gn)(this, Sa, "f").dispose(),
                    (0,
                    R.GG)(this, Sa, null, "f")),
                    null != (0,
                    R.gn)(this, Ea, "f") && ((0,
                    R.gn)(this, Ea, "f").dispose(),
                    (0,
                    R.GG)(this, Ea, null, "f")),
                    null != (0,
                    R.gn)(this, xa, "f") ? ((0,
                    R.gn)(this, xa, "f").dispose(),
                    (0,
                    R.GG)(this, xa, null, "f")) : (0,
                    R.GG)(this, xa, new Qi((0,
                    R.gn)(this, ua, "f").element,(0,
                    R.gn)(this, Qr, "f"),(0,
                    R.gn)(this, Kr, "f"),(0,
                    R.gn)(this, za, "f").multiplayerConnection,( () => {
                        (0,
                        R.gn)(this, xa, "f")?.dispose(),
                        (0,
                        R.GG)(this, xa, null, "f")
                    }
                    )), "f")
                }
                ),( () => {
                    if (null == (0,
                    R.gn)(this, za, "f"))
                        throw new Error("Multiplayer is null");
                    null != (0,
                    R.gn)(this, xa, "f") && ((0,
                    R.gn)(this, xa, "f").dispose(),
                    (0,
                    R.GG)(this, xa, null, "f")),
                    null != (0,
                    R.gn)(this, Ea, "f") && ((0,
                    R.gn)(this, Ea, "f").dispose(),
                    (0,
                    R.GG)(this, Ea, null, "f")),
                    null != (0,
                    R.gn)(this, Sa, "f") ? ((0,
                    R.gn)(this, Sa, "f").dispose(),
                    (0,
                    R.GG)(this, Sa, null, "f")) : (0,
                    R.GG)(this, Sa, new Ar((0,
                    R.gn)(this, ua, "f").element,(0,
                    R.gn)(this, Qr, "f"),(0,
                    R.gn)(this, Kr, "f"),(0,
                    R.gn)(this, $r, "f"),(0,
                    R.gn)(this, za, "f").sessionId,(0,
                    R.gn)(this, za, "f").multiplayerConnection,( () => {
                        (0,
                        R.gn)(this, Sa, "f")?.dispose(),
                        (0,
                        R.GG)(this, Sa, null, "f")
                    }
                    )), "f")
                }
                ),( () => {
                    const e = (0,
                    R.gn)(this, za, "f");
                    if (null == e)
                        throw new Error("Multiplayer is null");
                    const t = e.multiplayerConnection;
                    if (!(t instanceof Wn))
                        throw new Error("Multiplayer connection is not a host");
                    null != (0,
                    R.gn)(this, xa, "f") && ((0,
                    R.gn)(this, xa, "f").dispose(),
                    (0,
                    R.GG)(this, xa, null, "f")),
                    null != (0,
                    R.gn)(this, Sa, "f") && ((0,
                    R.gn)(this, Sa, "f").dispose(),
                    (0,
                    R.GG)(this, Sa, null, "f")),
                    null != (0,
                    R.gn)(this, Ea, "f") ? ((0,
                    R.gn)(this, Ea, "f").dispose(),
                    (0,
                    R.GG)(this, Ea, null, "f")) : ((0,
                    R.gn)(this, ua, "f").isVisible = !1,
                    (0,
                    R.GG)(this, Ea, new vr.A(null,(0,
                    R.gn)(this, Kr, "f"),(0,
                    R.gn)(this, Qr, "f"),(0,
                    R.gn)(this, Xr, "f"),(0,
                    R.gn)(this, ta, "f"),(0,
                    R.gn)(this, Jr, "f"),(0,
                    R.gn)(this, $r, "f"),(0,
                    R.gn)(this, na, "f"),"cancel",!0,( () => {
                        (0,
                        R.gn)(this, Ea, "f")?.dispose(),
                        (0,
                        R.GG)(this, Ea, null, "f"),
                        (0,
                        R.gn)(this, ua, "f").isVisible = !0
                    }
                    ),( (n, i, r) => {
                        (0,
                        R.gn)(this, Ea, "f")?.hide(),
                        (0,
                        R.GG)(this, Ta, new kr.A(!0), "f"),
                        r().then((i => {
                            t.startNewSession(e.gameMode, n, i),
                            (0,
                            R.gn)(this, Ea, "f")?.dispose(),
                            (0,
                            R.GG)(this, Ea, null, "f"),
                            (0,
                            R.gn)(this, ua, "f").isVisible = !0
                        }
                        )).catch((e => {
                            if (!(e instanceof Tr.A))
                                throw e;
                            (0,
                            R.gn)(this, $r, "f").show((0,
                            R.gn)(this, Kr, "f").get("Failed to load track"), (0,
                            R.gn)(this, Kr, "f").get("Ok"), ( () => {
                                (0,
                                R.gn)(this, Ea, "f")?.show()
                            }
                            ))
                        }
                        )).finally(( () => {
                            (0,
                            R.gn)(this, Ta, "f")?.dispose(),
                            (0,
                            R.GG)(this, Ta, null, "f")
                        }
                        ))
                    }
                    )), "f"),
                    (0,
                    R.gn)(this, Ea, "f").show())
                }
                )), "f"),
                null == (0,
                R.gn)(this, za, "f"))
                    (0,
                    R.gn)(this, wa, "f").setRecord((0,
                    R.gn)(this, Ka, "f"));
                else
                    switch ((0,
                    R.gn)(this, za, "f").gameMode) {
                    case en.Casual:
                        (0,
                        R.gn)(this, wa, "f").setRecord((0,
                        R.gn)(this, Ka, "f"));
                        break;
                    case en.Competitive:
                        (0,
                        R.gn)(this, wa, "f").setRecord(null == (0,
                        R.gn)(this, qa, "f") ? null : {
                            time: (0,
                            R.gn)(this, qa, "f").time,
                            position: Promise.resolve(null)
                        });
                        break;
                    default:
                        throw (0,
                        R.gn)(this, za, "f").gameMode,
                        new Error("Unknown multiplayer game mode")
                    }
                if ((0,
                R.gn)(this, wa, "f").setWatchButtonEnabled((0,
                R.gn)(this, Na, "f").length > 0 && null != (0,
                R.gn)(this, aa, "f")),
                (0,
                R.gn)(this, ea, "f").touchEnabled ? ((0,
                R.gn)(this, fa, "f")?.setOverridePosition(!0),
                (0,
                R.gn)(this, ga, "f")?.setOverridePosition(!0),
                (0,
                R.gn)(this, ma, "f").setOverridePosition(!0),
                (0,
                R.gn)(this, va, "f").setOverridePosition(!0),
                (0,
                R.gn)(this, Aa, "f").setOverridePosition(!0)) : ((0,
                R.gn)(this, fa, "f")?.setOverridePosition(null),
                (0,
                R.gn)(this, ga, "f")?.setOverridePosition(null),
                (0,
                R.gn)(this, ma, "f").setOverridePosition(null),
                (0,
                R.gn)(this, va, "f").setOverridePosition(null),
                (0,
                R.gn)(this, Aa, "f").setOverridePosition(null)),
                (0,
                R.gn)(this, _a, "f").isEnabled = (0,
                R.gn)(this, ea, "f").touchEnabled,
                (0,
                R.gn)(this, Fr, "m", us).call(this),
                (0,
                R.gn)(this, ea, "f").addChangeListener((0,
                R.GG)(this, Ca, (e => {
                    e ? ((0,
                    R.gn)(this, fa, "f")?.setOverridePosition(!0),
                    (0,
                    R.gn)(this, ga, "f")?.setOverridePosition(!0),
                    (0,
                    R.gn)(this, ma, "f").setOverridePosition(!0),
                    (0,
                    R.gn)(this, va, "f").setOverridePosition(!0),
                    (0,
                    R.gn)(this, Aa, "f").setOverridePosition(!0)) : ((0,
                    R.gn)(this, fa, "f")?.setOverridePosition(null),
                    (0,
                    R.gn)(this, ga, "f")?.setOverridePosition(null),
                    (0,
                    R.gn)(this, ma, "f").setOverridePosition(null),
                    (0,
                    R.gn)(this, va, "f").setOverridePosition(null),
                    (0,
                    R.gn)(this, Aa, "f").setOverridePosition(null))
                }
                ), "f")),
                null != b) {
                    const e = e => {
                        const t = (0,
                        R.gn)(this, Vr, "f").getStartTransform();
                        if (null == t)
                            throw new Error("Track has no start");
                        const n = e.getPlayers();
                        for (const e of n) {
                            if (e.isSelf)
                                continue;
                            let n = (0,
                            R.gn)(this, Wa, "f").get(e.id);
                            null == n && (n = {
                                car: new N.A(null,t,null,null,(0,
                                R.gn)(this, qr, "f"),(0,
                                R.gn)(this, Qr, "f"),(0,
                                R.gn)(this, Hr, "f"),(0,
                                R.gn)(this, Vr, "f"),(0,
                                R.gn)(this, ca, "f"),(0,
                                R.gn)(this, Yr, "f"),null),
                                time: 0,
                                resetCounter: 0,
                                bufferedCarStates: []
                            },
                            n.car.audioVolume = (0,
                            R.gn)(this, $a, "f"),
                            (0,
                            R.gn)(this, Wa, "f").set(e.id, n)),
                            n.car.setNameTag(e.countryCode, e.nickname),
                            n.car.setCarStyle(e.carStyle)
                        }
                        for (const [e,t] of (0,
                        R.gn)(this, Wa, "f"))
                            n.some((t => t.id == e)) || (t.car.dispose(),
                            (0,
                            R.gn)(this, Wa, "f").delete(e))
                    }
                    ;
                    e(b.multiplayerConnection);
                    const t = .15;
                    if (b.multiplayerConnection.addConnectionLostCallback((0,
                    R.GG)(this, Ua, (e => {
                        S(e)
                    }
                    ), "f")),
                    b.multiplayerConnection.addPlayersChangedCallback((0,
                    R.GG)(this, Da, (t => {
                        t == b.sessionId && e(b.multiplayerConnection)
                    }
                    ), "f")),
                    b.multiplayerConnection.addCarResetCallback((0,
                    R.GG)(this, Ba, ( (e, n, i) => {
                        if (e != b.sessionId)
                            return;
                        const r = (0,
                        R.gn)(this, Wa, "f").get(n);
                        if (null != r && i > r.resetCounter) {
                            const e = (0,
                            R.gn)(this, Vr, "f").getStartTransform();
                            if (null == e)
                                throw new Error("Track has no start");
                            const n = {
                                frames: 0,
                                speedKmh: 0,
                                hasStarted: !1,
                                finishFrames: null,
                                nextCheckpointIndex: 0,
                                hasCheckpointToRespawnAt: !1,
                                position: {
                                    x: e.position.x,
                                    y: e.position.y,
                                    z: e.position.z
                                },
                                quaternion: {
                                    x: e.quaternion.x,
                                    y: e.quaternion.y,
                                    z: e.quaternion.z,
                                    w: e.quaternion.w
                                },
                                collisionImpulses: [],
                                wheelContact: [null, null, null, null],
                                wheelSuspensionLength: [N.A.suspensionResetLengthFront, N.A.suspensionResetLengthFront, N.A.suspensionResetLengthRear, N.A.suspensionResetLengthRear],
                                wheelSuspensionVelocity: [0, 0, 0, 0],
                                wheelDeltaRotation: [0, 0, 0, 0],
                                wheelSkidInfo: [0, 0, 0, 0],
                                steering: 0,
                                brakeLightEnabled: !1,
                                controls: {
                                    up: !1,
                                    right: !1,
                                    down: !1,
                                    left: !1,
                                    reset: !1
                                }
                            };
                            r.car.setCarState(n, !0),
                            r.time = -t,
                            r.resetCounter = i,
                            r.bufferedCarStates.length = 0
                        }
                    }
                    ), "f")),
                    b.multiplayerConnection.addCarUpdateCallback((0,
                    R.GG)(this, Ga, ( (e, n, i, r) => {
                        if (e != b.sessionId)
                            return;
                        const a = (0,
                        R.gn)(this, Wa, "f").get(n);
                        if (null != a)
                            if (i > a.resetCounter)
                                a.car.setCarState(r, !0),
                                a.time = r.frames / 1e3 - t,
                                a.bufferedCarStates.length = 0,
                                a.resetCounter = i;
                            else if (r.frames / 1e3 > a.time) {
                                let e = a.bufferedCarStates.length;
                                for (let t = 0; t < a.bufferedCarStates.length; t++)
                                    if (r.frames < a.bufferedCarStates[t].frames) {
                                        e = t;
                                        break
                                    }
                                a.bufferedCarStates.splice(e, 0, r)
                            }
                    }
                    ), "f")),
                    b.multiplayerConnection.addEndSessionCallback(b.sessionId, (0,
                    R.GG)(this, Fa, ( () => {
                        (0,
                        R.gn)(this, Va, "f") || ((0,
                        R.GG)(this, Va, !0, "f"),
                        (0,
                        R.gn)(this, wa, "f").setChangeTrackEnabled(!1),
                        (0,
                        R.gn)(this, _a, "f").dispose(),
                        (0,
                        R.gn)(this, ma, "f").dispose(),
                        (0,
                        R.gn)(this, va, "f").dispose(),
                        (0,
                        R.gn)(this, Aa, "f").dispose(),
                        (0,
                        R.gn)(this, ya, "f")?.dispose(),
                        (0,
                        R.GG)(this, ya, null, "f"),
                        (0,
                        R.GG)(this, ka, new Dr, "f"),
                        null == (0,
                        R.gn)(this, Sa, "f") && (0,
                        R.GG)(this, Sa, new Ar((0,
                        R.gn)(this, ua, "f").element,(0,
                        R.gn)(this, Qr, "f"),(0,
                        R.gn)(this, Kr, "f"),(0,
                        R.gn)(this, $r, "f"),b.sessionId,b.multiplayerConnection,( () => {
                            (0,
                            R.gn)(this, Sa, "f")?.dispose(),
                            (0,
                            R.GG)(this, Sa, null, "f")
                        }
                        )), "f"))
                    }
                    ), "f")),
                    b.multiplayerConnection.addNewSessionCallback(b.sessionId, (0,
                    R.gn)(this, oa, "f")),
                    b.multiplayerConnection.addServerMessageCallback((0,
                    R.GG)(this, Oa, (e => {
                        (0,
                        R.gn)(this, ga, "f")?.show(e)
                    }
                    ), "f")),
                    0 != y.length)
                        throw new Error("Ghost settings should not be provided in multiplayer");
                    if (b.gameMode == en.Casual && null != (0,
                    R.gn)(this, Ka, "f")) {
                        b.multiplayerConnection.sendRecord(b.sessionId, (0,
                        R.gn)(this, Ka, "f").time);
                        const e = (0,
                        R.gn)(this, Jr, "f").getCurrentUserProfile();
                        (0,
                        R.GG)(this, Na, [{
                            car: null,
                            carId: null,
                            hasEnded: !1,
                            loadedFrames: 0,
                            maxFrames: 0,
                            settings: {
                                recording: (0,
                                R.gn)(this, Ka, "f").recording,
                                carStyle: e.carStyle,
                                nickname: e.nickname,
                                time: (0,
                                R.gn)(this, Ka, "f").time,
                                isSelf: !0
                            },
                            replay: null,
                            checkpoints: [],
                            finishSpeedKmh: null
                        }], "f")
                    }
                }
                const _ = (0,
                R.gn)(this, Yr, "f").getSettingBoolean(P.A.DefaultCameraMode);
                if ((0,
                R.GG)(this, La, (0,
                R.gn)(this, Fr, "m", ls).call(this, _), "f"),
                (0,
                R.gn)(this, Fr, "m", cs).call(this),
                window.addEventListener("keydown", (0,
                R.GG)(this, Qa, (e => {
                    if (!I.ip()) {
                        if (!(0,
                        R.gn)(this, Xa, "f").isEnabled && !(0,
                        R.gn)(this, Fr, "m", ns).call(this))
                            if ((0,
                            R.gn)(this, Yr, "f").checkKeyBinding(e, me.A.VehicleCheckpointReset))
                                e.repeat || null != (0,
                                R.gn)(this, ba, "f") || (0,
                                R.gn)(this, Va, "f") || (0,
                                R.gn)(this, La, "f").hasStarted() && ((0,
                                R.gn)(this, Fr, "m", is).call(this) ? (0,
                                R.gn)(this, Pa, "f").reset = !0 : ((0,
                                R.gn)(this, Fr, "m", ss).call(this),
                                (0,
                                R.gn)(this, Pa, "f").reset = !1)),
                                e.preventDefault();
                            else if ((0,
                            R.gn)(this, Yr, "f").checkKeyBinding(e, me.A.VehicleStartReset))
                                e.repeat || null != (0,
                                R.gn)(this, ba, "f") || (0,
                                R.gn)(this, Va, "f") || (0,
                                R.gn)(this, La, "f").hasStarted() && (0,
                                R.gn)(this, Fr, "m", ss).call(this),
                                e.preventDefault();
                            else if ((0,
                            R.gn)(this, Yr, "f").checkKeyBinding(e, me.A.VehicleCockpitCamera))
                                e.repeat || (0,
                                R.gn)(this, Fr, "m", rs).call(this),
                                e.preventDefault();
                            else if (d.checkKeyBinding(e, me.A.ToggleUI))
                                (0,
                                R.GG)(this, da, !(0,
                                R.gn)(this, da, "f"), "f"),
                                (0,
                                R.gn)(this, ua, "f").isVisible = (0,
                                R.gn)(this, da, "f"),
                                e.preventDefault();
                            else if (d.checkKeyBinding(e, me.A.Pause)) {
                                if (null == (0,
                                R.gn)(this, ba, "f")) {
                                    if (null == (0,
                                    R.gn)(this, za, "f") && (0,
                                    R.gn)(this, La, "f").hasStarted() && !(0,
                                    R.gn)(this, La, "f").hasFinished()) {
                                        const e = new Date;
                                        (null == (0,
                                        R.gn)(this, Ma, "f") || Math.abs(e.getTime() - (0,
                                        R.gn)(this, Ma, "f").getTime()) > 1e3) && (I.bQ(),
                                        (0,
                                        R.GG)(this, ba, new ci((0,
                                        R.gn)(this, ua, "f").element,a), "f"),
                                        (0,
                                        R.GG)(this, Ma, e, "f"))
                                    }
                                } else
                                    (0,
                                    R.gn)(this, ba, "f").startFadeOut(( () => {
                                        I.tU(),
                                        (0,
                                        R.gn)(this, ba, "f")?.dispose(),
                                        (0,
                                        R.GG)(this, ba, null, "f")
                                    }
                                    ));
                                e.preventDefault()
                            }
                        if ("Escape" == e.code && ((0,
                        R.gn)(this, $r, "f").isOpen || ((0,
                        R.gn)(this, Xa, "f").isEnabled ? (0,
                        R.gn)(this, Xa, "f").isEnabled = !1 : null != (0,
                        R.gn)(this, ba, "f") ? (0,
                        R.gn)(this, ba, "f").startFadeOut(( () => {
                            (0,
                            R.gn)(this, ba, "f")?.dispose(),
                            (0,
                            R.GG)(this, ba, null, "f")
                        }
                        )) : null != (0,
                        R.gn)(this, xa, "f") ? ((0,
                        R.gn)(this, xa, "f").dispose(),
                        (0,
                        R.GG)(this, xa, null, "f")) : null != (0,
                        R.gn)(this, Sa, "f") ? ((0,
                        R.gn)(this, Sa, "f").dispose(),
                        (0,
                        R.GG)(this, Sa, null, "f")) : null != (0,
                        R.gn)(this, Ea, "f") ? ((0,
                        R.gn)(this, Ea, "f").dispose(),
                        (0,
                        R.GG)(this, Ea, null, "f")) : (0,
                        R.gn)(this, Fr, "m", ts).call(this),
                        e.preventDefault())),
                        d.checkKeyBinding(e, me.A.ToggleSpectatorCamera) && !(0,
                        R.gn)(this, Fr, "m", ns).call(this)) {
                            if (null == (0,
                            R.gn)(this, ba, "f") && !(0,
                            R.gn)(this, Va, "f")) {
                                (0,
                                R.gn)(this, Xa, "f").camera.position.copy((0,
                                R.gn)(this, qr, "f").camera.position);
                                const e = new C.O9p(0,0,0,"YXZ").setFromQuaternion((0,
                                R.gn)(this, qr, "f").camera.quaternion);
                                e.x = Math.round(1e4 * e.x) / 1e4,
                                e.y = Math.round(1e4 * e.y) / 1e4,
                                e.z = 0,
                                (0,
                                R.gn)(this, Xa, "f").camera.quaternion.setFromEuler(e),
                                (0,
                                R.gn)(this, Xa, "f").toggle()
                            }
                            e.preventDefault()
                        }
                    }
                }
                ), "f")),
                window.addEventListener("keyup", (0,
                R.GG)(this, Ja, (e => {
                    (0,
                    R.gn)(this, Yr, "f").checkKeyBinding(e, me.A.VehicleCockpitCamera) && (0,
                    R.gn)(this, Fr, "m", as).call(this)
                }
                ), "f")),
                "official" == v)
                    if ("Winter 1" == m.name) {
                        let e = !1
                          , t = null
                          , n = null;
                        (new ie.B).load("data:application/octet-stream;base64,Z2xURgIAAAAYCAAAnAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2NC41LjQ5IiwidmVyc2lvbiI6IjIuMCJ9LCJzY2VuZSI6MCwic2NlbmVzIjpbeyJuYW1lIjoiU2NlbmUiLCJub2RlcyI6WzAsMV19XSwibm9kZXMiOlt7Im1lc2giOjAsIm5hbWUiOiJUaW0ifSx7Im1lc2giOjEsIm5hbWUiOiJTY2FyZiJ9XSwibWVzaGVzIjpbeyJuYW1lIjoiSWNvc3BoZXJlIiwicHJpbWl0aXZlcyI6W3siYXR0cmlidXRlcyI6eyJQT1NJVElPTiI6MH0sImluZGljZXMiOjF9XX0seyJuYW1lIjoiU2NhcmYiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjoyfSwiaW5kaWNlcyI6M31dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjQwLCJtYXgiOlsxLjkyMjk4MTczOTA0NDE4OTUsMC45Nzk5NTkyNDk0OTY0NiwxLjkyMzk4MzIxNjI4NTcwNTZdLCJtaW4iOlstMS42MTkzMzUxNzQ1NjA1NDY5LC0wLjAwMjY1NzAwMzcwMDczMzE4NSwtMS45MjM5ODMyMTYyODU3MDU2XSwidHlwZSI6IlZFQzMifSx7ImJ1ZmZlclZpZXciOjEsImNvbXBvbmVudFR5cGUiOjUxMjMsImNvdW50Ijo3MiwidHlwZSI6IlNDQUxBUiJ9LHsiYnVmZmVyVmlldyI6MiwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjE0LCJtYXgiOlsxLjQ5NTIwMDYzNDAwMjY4NTUsMC41OTcwMjg1NTM0ODU4NzA0LDEuMjg1MDA5OTgwMjAxNzIxMl0sIm1pbiI6WzAuODM5NDA1NjU1ODYwOTAwOSwtMC4wMTMxNjYyNjc0MjQ4MjE4NTQsLTAuNjU4NzMyNjUyNjY0MTg0Nl0sInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3IjozLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzYsInR5cGUiOiJTQ0FMQVIifV0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjQ4MCwiYnl0ZU9mZnNldCI6MCwidGFyZ2V0IjozNDk2Mn0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjE0NCwiYnl0ZU9mZnNldCI6NDgwLCJ0YXJnZXQiOjM0OTYzfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MTY4LCJieXRlT2Zmc2V0Ijo2MjQsInRhcmdldCI6MzQ5NjJ9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo3MiwiYnl0ZU9mZnNldCI6NzkyLCJ0YXJnZXQiOjM0OTYzfV0sImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjg2NH1dfSAgYAMAAEJJTgBgRs+/YpiSPQAAAIBUcna/AMwauc/3376kvJ0/AMwauTbgHb9EJPY/AMwauQAAAIBXf44/pXkNPwAAAIBQz4W+z7tLPhi/4L1EV2a+LoNNPkZ8Nr4xLLW/BCckPY5Crb9FUK2/fkQrPaFSs78Qv1w9wPYNPjgebL6XDwY+KCYNPthudb6yhgG+QPbzusId8799m0q9ICEuu9ZH9L9r71A/2cMlPvQabL6OwGQ/hUMmPtgbZ760d4g/APt4OhVF9r8xJJI/gFO8OngJ9L+yXLA/cHmqPnAe2r0hV9c/nN56P15KMb+yqrI/3jWXPnDwEL4hpdk/1DxxP6xCOr+6sfa9qS39PgAAAIBUcna/AMwauc/33z6kvJ0/AMwauTbgHT9Qz4W+z7tLPhi/4D1EV2a+LoNNPkZ8Nj4xLLW/BCckPY5CrT9FUK2/fkQrPaFSsz8Qv1w9wPYNPjgebD6XDwY+KCYNPthudT6yhgG+QPbzusId8z99m0q9ICEuu9ZH9D9r71A/2cMlPvQabD6OwGQ/hUMmPtgbZz60d4g/APt4OhVF9j8xJJI/gFO8OngJ9D+yXLA/cHmqPnAe2j0hV9c/nN56P15KMT+yqrI/3jWXPnDwED4hpdk/1DxxP6xCOj8CAAEABAADAAIABAAVAAEAAAAGAAcABQAKAAsACQAOAA8ADQASABMAEQAVAAQAAQAGAAgABwAKAAwACwAOABAADwASABQAEwAXAAQAFgADAAQAFwAVAAAAFgAZABgAGgAdABwAHgAhACAAIgAlACQAJgAVABYABAAZABoAGwAdAB4AHwAhACIAIwAlACYAJwBK41Y/peMVP7g6E72b84U/3dYYP2TXM7ybmHo/VLdXvLSiKL9Dzpc/VLdXvLSiKL/JEIE/4L2wuqf7Nj+/kps/QrYmPPRfPT+bmHo/NGwPP6A3zLxDzpc/vOsWPwIPKLyor4I/GGnJO/ibLD8svpw/GGnJOy/fIj8TwZs/GGnJOztykz8UqLE/GGnJO9KDhD+ELa0/GGnJOzV7pD+8Yr8/GGnJO3A3kT8AAAEAAwAAAAMAAgABAAAABAABAAQABQACAAMABwACAAcABgAGAAcACQAGAAkACAAIAAkACwAIAAsACgAKAAsADQAKAA0ADAA=", (i => {
                            if (!(i.scene.children[0]instanceof C.eaF))
                                throw new Error("Model is not a mesh");
                            if (!(i.scene.children[1]instanceof C.eaF))
                                throw new Error("Model is not a mesh");
                            t = i.scene.children[0],
                            n = i.scene.children[1],
                            e ? (t.geometry.dispose(),
                            t.material.dispose(),
                            t = null,
                            n.geometry.dispose(),
                            n.material.dispose(),
                            n = null) : (t.geometry.computeVertexNormals(),
                            t.material = new C.G_z({
                                color: 4464662,
                                side: C.$EB
                            }),
                            t.position.set(161.8860081067957, .22, -436.26312438336595),
                            t.rotation.set(0, 2.85, 0),
                            t.scale.set(.05, .05, .05),
                            s.scene.add(t),
                            s.addMaterial(t.material),
                            n.geometry.computeVertexNormals(),
                            n.material = new C.G_z({
                                color: 10358543,
                                side: C.$EB
                            }),
                            n.position.copy(t.position),
                            n.rotation.copy(t.rotation),
                            n.scale.copy(t.scale),
                            s.scene.add(n),
                            s.addMaterial(n.material))
                        }
                        )),
                        (0,
                        R.GG)(this, Ya, {
                            dispose: () => {
                                null != t && ((0,
                                R.gn)(this, qr, "f").scene.remove(t),
                                t.geometry.dispose(),
                                t.material.dispose(),
                                s.removeMaterial(t.material)),
                                null != n && ((0,
                                R.gn)(this, qr, "f").scene.remove(n),
                                n.geometry.dispose(),
                                n.material.dispose(),
                                s.removeMaterial(n.material)),
                                e = !0
                            }
                            ,
                            update: () => {
                                null != t && (t.visible = !(0,
                                R.gn)(this, Xa, "f").isEnabled),
                                null != n && (n.visible = !(0,
                                R.gn)(this, Xa, "f").isEnabled)
                            }
                        }, "f")
                    } else if ("Summer 3" == m.name) {
                        const e = (new C.Tap).load("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIgAAACdCAYAAABvoTB6AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH6AsJEBUoIj2gSgAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAACAASURBVHjaXLxJr13Zcuf3i9Xt5nS3IZnMzPf0SvXUPJdkoQxU2WP7Sxiwh/4C/gr+Op564JkBe1CABwVYUqkklUvSa5nJTF7e5pyzm9XE8mBt3ieYAEFc8nCfvfeKFSvi34T8j//dX+D7HdY5rAtY5zHG8uVXrQqAaqHkjJZMrRWoGGOxziPGUFWptaIlA2BdoFKpqpQcAcGHDhc6QICKqiIiUCulZHJcyXFBS/sejMH5rt2XddSqlJwoOb1+j7EOYx2hHwn9iA8BY9zvr5cSpSSqKqqlPU/l9RmsD/jQY4x5vf9aa/sZXn8WZHueAki773/2Xqh1e6z6+ndVK9YFwrDDhw4Rg/UeAUrJ7VoiiJjf/9+SSetCzhGqbvcJIoIxDrGWqtrevQ9023OLCLUqKSaW6UqcJ2otIGCMeX33ZnuPaZ1Zpws5Le09Gof1oa29GJwPOBeQ/+G//XOM8xjr2o1WRcRgXNhuyrY/raNSKSmS1gXVgrUe4zxUyClhrCUMA855xEh7uFrJKVJyQkTaTRpLrZVaFc2ZnBMlraiW16Brb8UgIttv0+7RGKiVFGdyXFHVds/GIsYgxr4GeMnxn12zBX+tSi2FWivWeVwIiNj296pUtmCoipYWUF+u3XYMW/BsC4eAbAFf9HXjGOvax7VQSqZsQV9V231u31Frbdf//23IL0EBgnGuXXO7j9eggXYtEUrO5LRu9yVbvNVt4+rvn0PMtlny6yZrgbttwnYTsAWc8/2u7YRSyLlFk/OB+rpLK8Y6nAsg0navFqhKKQmk4kJPH0ZUlZIieV0oObVF2L7YWo9Yi4hFjAXVlpG2LGKdx0mHWNc+70J7GMA5BwJVdVuITKXHWPe6e1VbRqpJEe+wziK+LXzOmekysy5PAHRDT9cFtEZKyVjnELFoSeS0oqVsz+2xLmBE2mbYdm9O6+sLf81MW2BZ1zZSyzwK0jJnMCNacsssW2CoFnTbHG3R2+Ib6zDm94smYoC2ofIaX4PoNRBFtswGgtmCs6KloFRqteRYqHVtG1crVcE4jyAtK5XKuk7tuZ3D+bahHJUt9VZCN+JCh/WhbZUtCqlbVBrBhb6lvi3CW0QWVPX1oV53+vYZ1UJaF+IyUXLeHlhw3rcHfw2WArVSq2zR7uiGAbrudddqyZSUSHFti5kztcp23y24QChlC5wSqVrwHkLoX7OMtO2N5kLJ8fVl+2583UHWeay1LfCqsp0ILQuKbceYLi1TlQxiyKnt+qoFMW2xqlasdZRSWOeJtCyotgwltj1j6DzOtyBULa+boZTUMtl2PIqYrQxogZi2I/k1aKxDjGxHhSBSUY0gGWMEYwwmBFzo2rG0ZTgRSxhP+O3ZvpwA7nD7junyRK2Frt/zV+kd3379BxjXIcZxGkeOu5GsSqmC2HbRChhrKWqoVTFVqCIIirGCloq121ldldEaLJkudBjj28stBYyhVkErOGvobKHG37CWHeru8QasPuCkYsIt3o8E5wDdAmsiJsWHgaoZyjPL9A+gid3hX2PcyDJ9RPSMQcj2DTGDk2d0/Q3i7kn1RMkPOFOoMmLMiM+/QuQNMX+k0JHNG7w5ks0AJN7JbwnhkWlNaA1EHUhVmeUPqEDnMn23x7ojKSklPRHswqwd/e49qlAUrAFrIa6lPb8XpLasGYtijZBKYVoyFSHlTPAerRUj4KzFbpk2lkywtn3GGhRQrTgrDN5gBGJMvMwrORdSXHHGEGzFSuV3333P+k//junlmTAM5Jhw6zxtyUKIy0S/H1vR5jusDYR+oDqPt8JgHaW2Ast5R8kwhIBKpZSK95ZlWdFa8cEhVYlZCd5BiXhRel9w1lHtyHV6QsqC9TtKBd+NqCYEz1FfYPiWpAJ5T89HuiCo6dtxUAWMZX/YUfNK8AOxZLQI3t/g6yPCf6bUE3234OWFIXRc8oBLC719og4BrYqpP5DVoMZAdYyhcHIGw2ee10KuiZgjQX6N736Ck477MLOo41jBisGYwjX1PCRP1Ipqhw93BAeHoSDxiVoTTu5ZVRiHQBc6RCrP54njccAZsEjbYFqZrwv7XU9dE6MNGITrEhlCwDkLtMU/9oGoymXNlKL0w4AVEAMpV1LK+K5DNXHoe1w/klIm5UxOkc5VHh7P5ApGlZILxhhyTrgUl60AcizTExw8vusxLnDa7wneYm2HGDAiOOswthWKBMFZQ1bFOUEMhF4oueJ9O2JCZ2mnjceWjOhErSspDmA7vJ0JfL+d4fdIOOH6r5D0j4g8sbj3+PE9d+YB0q/IzNT+X1FN4HL5QEoWKxfi8iuqeHIJVArGB7xZEfNEyS2TDV3A1o5pmTCaUTF4mzH5kVV3YDqkvnAIEVMvWGdxGby13A3PgDK4X7PvRxRHXSPGWpwNpKKsTOzMSmeOWHdCTIcrj4z2idAvXNdKNic6t6NzDkHw3uKcZ1nOhNBjrcc7S9GKCR2aMuMwoNpeuQuBofMYY2jJuZC1Is5hiyUTOR5Gqla0VIoUrLFU6ykYMoKaTDWGVAsJQ47KUi1qOgxgrGBdgFpxxhhUla4b0Bxf28TdMNKFgFbIYth5RxcCzjvWmDAI1llUK8YIQmvVjE1IbxFRvHWkonTeQi2gMAj0sqLpeyJvSHLA6UyQiPWPVCZU3oG5wfGBffc12R6w5hcc64TWZ9b8n5jlW5z5QNYjVTyDPeOsw/uOy+JRSfTBUetKLIq4gSqQsmJ9j6uOORaCEcbdgSUHEBhtpnNKKgGtgrU9x8FxM8LT9cquq3gnvEyZ0PU4I2RaZ9ML1HwmZgFzQvUTN8OFg/sRxJHNDSbvSLXVNy1ADCk+sd919P0RY1r3My0LYoTdYaDWyppyq8PWhHWeLnicNUgVSi3EXNk7GLXDO0OtBrXK4OC8TEylYoxjLYWcFMRgfdcahloJqWB8t3WL9hW6cC505NS+VMQSgieEjuAd3jmwjlIFHwKlwnSdORxPmFqpUtl1HakoKWUQWgGFkPKZdXnheHqDswPWQIwdvevZ57/E9xeWOjLXG0R+SsePjEFZ5xeC/UTMgeATxn3Hxd1i7FvS+p6j+R1GfoT1SnIjsayY+plcytbeGozdMTjFybXtNGeY655J3xKrBXUEI3jXoyVzOjjc0l7aqbMoQrAwzRM3g3B36Pg8Z/a7IztfiGrwvUNqbtdeMtZUtBqCudKHF7x/IRbDTs5435GzsvI1wzhgVZCtaF3mzyAr97ffsB93PDxfSQgZjw+C1kouCe88tcI4WJw1jH3XOhAxLDmx81smN4YueOJ2TMwx451DgTVFSqnQBXLOBDdwvU6UlHhzOvDp8TNSy2u3ZmzAfQF8xBis67DW0XcdfdcRQiBXIXhP6LpWO8wrKRfcVpdobW0x0irklDKHXc/lmpB6ZZo+0Q9vscZgLWQcZrjn2I+4WKnrhbmc+GG546QPHG3k3Q08Pn9HJGDKP+J1x+d1wGLo+4XeQhiumGT4cdpx7GagspSCMyuGEWscBgjWcD8YPj28UFPlup7ZdxlJz7zpdxwHOPaeO1+pNYIBzRFKYddBLM/YdeUoPaYI/W7kelkwYnDeE1XBGDKZVJXgKoNVhm4mxcLQVSoLrrunzzPn+AHpfkLoPGV+ZNUXxN7iQuDhsnCOytAFMJndbsCJ4TJNjL0neE9KDfzaDR0xF0pVeteTSkVjIoQOEfCuMi2JNWb2Y08qrQgupTKtrayYYyt4x97jjfKbcWAuBQHSOtPv9rgvII8AYi3GGkr9PdgzuEDXuZaag2M3WuYYSbWyC32rnEXoQtgQSIvFIHYg9DdovmJkRiSwrBe+vRt4mU44GzD1E8EUrBGmqbJGxwNvcNMDznmsVqgLJv97bPwWlcTaGW4GcHZgKAUtETE9xz7yODvWtDKYHwha8HLmCLgM/+Ik9J0SHIjpEdc3xNdYSkkNWMpnxHj86Q1aUgP5Ykasx4WxtbO1Ir3lEiPOD3z69EIRmJPifcfzeuB0utB5cN5jEawIU7ni+TuM/oTb8ecs0/es63eMu59i7IGUW/vtvZBK5jCOBGc4jAPGCtMSiXkh+IAxoBU670laWWKhIuRScc6w6zyn3cAPzxc+nWecs+QKXWiZwTpHShGDYkn0RrhOVwYfWKThIloy/XDA8c/gZdkg1lwrqQqughUhF6Uay3VdsdYR2lsmqdKFjhjbee+sYY6JDHRdRyzCEDylLFATzhau85WYVh7Ucze+4zi8YOzM+337zI/Xe1Z9S9TKYCcOvefhHHm3f2RJC3FN+H2g85BK4pt7eLoUxDgGU3m5PjGGnrf7nrc3XzM6S+8tJa8btqAgDoxgcJQScdZTNaMmgLGQEpSVim2pXSMk8KZSrSO4wLE3rKXi7w48Xq788nlmdzOyRE/KhbkmlMBh6DDOM10XrLEEszA//iW4yDDc0w8nhv6EtZ5QK9SZooX92JDsOSaWmBHjWGI71m9PPVRBgSpCUlppUBveMqeMThNzKhx2O3JKdF2DHuKa6bxBqsUbxzRlHtOE1NY9NSi+gqlQFftv/+yPKDnjQiCtC/XdLxj3R6oYxBqM9YTgSKngvcWHBq2noqy5UCtkrRgDXQgsqXAYRwxC7z0u9BgJOAvOCGucQFeMwMvq8Vb59tZj6hOOGW8brlHNHd7Aocv0YaRqIqsSfGA3WAbnsK5jnhd665ivF74ehJ+dev7w7S1fv72jMwXvKlUTIgm04sOItQY0Iwrk1olA67qs7TAYEIdztnVuzkEu1BwbAtmWhiAwdJbb/ci7U8dynTmMEaVQpdUIY7D87uxYY2EXhNuDQ8oHTLjH93+ACTfEXKmaKfN3SF3A7kml4SEIKIL3jq5r1Mbj8wWs5zKv9J3HWbt1kxXFUCpYYzgvkaJgnDD4VhR3wSEl8+7uQEyZ8xJ5eL5ymWZyjsQPf0ucr1jfQdV2xDTUrD30ru+42fVMKhTAuoZ6dl0PUrHWNthEG7RcAGOENSnB/75/nmOiDwEpwjDu0WxJuaOmM2gEI2ix/BDfIi+G990E9SPOzBy6iafrI4t/x8tcCH7hZY3EVBjEMZcBt75QEtwf7hmsxZ0GrGSkgjgLGrGimCIgtmEz/Q5jOrTMlDxRpYBxGNM1stIKpcxoXjDSahExjrwuLfFoRaRixGKkUsuMZjBu4G6/Z+8da8l8Ohe+O1/o+h2/zB1TFL469Hx76/lxSiQcOb1wnj/C1hTU+R8Zwxk3/ClzrMDCfm85HW5bwWkNPz69sKyK9YE1Zax1xFKJq6Lk1ixYcKZ1LGJs48+yYJw0bESE7DwfPl8ouRBL4bAfuZxbZrUuoFpwoUNLbkeMGENOCYDd2JFSwvkev7VAxlgqQiwKpZJTYxaNCFqVKoaxD6gISmWKiSleqXVl7EdiVMR1DfSye9Bn1pJxtifGzO+eBj6sO/7V+xvy8gmk0PuM61ael46aCjlfqBuE/fj5iTffvuF0sthacCYjOLQYcl6pFGwFckZFEOPwfocWIcYr1lh8f8L6ccN4Kuv8hNYVTVc0Lw3ux6A5bS18C46aZ0rNGOOIy4wNHmMzNb0QrMNJZny34+5g+KtfT3yYR06nHe9uYGHlOq/sQoexii8zGgRfP0L/kcRXvKwDtWbq+j1LONFHzzRPPF4uLLnjeLzlGiPeOJTKj08XarXshtBwHmMQI8TcupfBG7RW1lJaJtTCy5KoVTDWo1UYnMPsdjw9P2PsF7KzcUL2v/6LP210e4ogQrz7lxxPtzjvGYeBoe/wIVCxjdTaoPE+hAYc9YFd3xGcZVoiWStV2r+XMrWUieEalawVawNOKlIj+9BhJYHpEXdgXZ4ZQyGWSCwOVxVv4OkyMw4jKS0EEX7xzS2nocMDaKKWjJaE5kjXHXF2QHMCLVg7UDVREfrxlr6/xbmh8Rqup8QXdJ2oaWadnjCYFgipoKlsmRI0RkAx4sgxUWMmLxOa2wZy1iEVjCgGxYvw9nRk5wquWt68Gfn46cLOw/0Apy4zpZkSE3b5j1Q1rObnGAq+/JbOJ7RYljhxnhbEnnB+wCCEvjHQWYU1K10XcEZwzlJUEYHOGTpnWVJBqxCTcplmFOF5WllzQWthXVZ2g+fpfGWeF8r3f8s6X18ZcWetIxNfO5AlV4pWROuGbsKyRsQ5OuNIqohtRBdVsAbWNeJMxbJSqgUJVAS1ezAz8/UDPtxgwhHBksoeZ56pvHAYj1ymzxRVVGZSAWN6MJbjfqAPno8Pz5AN78YDf/L1Lb6uWJ0ap1YbOaY1YXxAacHiuo6ohXaQN8QxxQvICyWVRgOcP4BGNCtimw6maGOoxVjIK6qZ9TKzLjNoQxifHx8ptTQCLlXu39/jO0/Xd/j9DsTinGFvHD9/a5Cu42k+8/a4Y+w7duHCrx8eiclzCBnfK5c8EeL/w24ITNWzpBswiSKBbrilCyO5LFiTEeu45oqzluM4NM4LEKktk2fFGtOO/qK8XK8YsVjreH6aKLXirSFrYUmRD5+u1ELj21JCBEpJeDvgvugyvmgNnLOUWhB0K0QzxgWoUKqSStkItxYj85LovCfmFdITloroW5YsZFUIe5yNmPxbOnNDVMM8zXjboWnF8MxpWEh54jpd+BwTh7GjVuGcOj4+ruyHG77aKz9/fwPz00b3tyNRqsWYgMVuAVMxtVDmFfJKWvMr6HO9PDSaAEOJC1pS00/kit/vcC6wTBdqUgzC5fmZ6/XKsixozfTjCRtXfB9Yp5V1SWiyfP7hE7vdiH1zT2dGkErNEUOi942J9ruez+czZPi8Zp7nDlMTOztjQmBJGe8f0eTZ7X6BSQPYG1y4aRjP9AErCenvOOzuKBopRTnd7LjMC7k0sYoRmFIir4ZclFgKc6p0DqytKJXgPSUnLtPCWpS0FCh564Aae/yFNXavQpkmDmGJSiwVq5UlF0ws9NLaXcEiAsuyYsSgIlgjfD7PeAteBV+vrMs/gH+LsQeWNRPciRhfSPFXUC0kR4oenCOlC6ILUi9UTaSiaA2MIbDMiaqFb/aGX7w/kS4/ojlSS6aiaG6/S4oYF3DBM9y9BzGUNBGXeZPeGHKKiIANe6yHXDPS9azzgkpBkxJLRGPi5fMzAkzzFa0G2w0468F4bHDEuCKuwxKxxrLGmbg+Y3zP4Y1BrFDygiYwUqEknLG8PZ24rBe+fzizrIGbvScEwxQTJWeCsxBOPJ1XfH8k+B2uXrhcP5Fygu6ew3ALGnEmcRhGghVq55li4bysXKaVNSYUQQvkWjn0A2PvWWLEe09JieuyEFMh54pWUFVyiazzlRznJp9wviGpqgXVjDGWpJU5K8FWqimIUUJXqSjGCLVU+s5TSztO8sYrYCrVHinrhSAzcfk1+PdE2aP0iHtPzRWvv6GzCmroXMDLQqUQs1LVcHe6Y50nSqocB9ibF/743Tvi4295+fQJ73uWmLFOeXl6IS4J33ek5ZGhH7mvhuFwIq4XlnVlXVeGfo+Y1qXJYqlZ0JpBBTBYI5ATJUNaFubpgjiH8Q6Lp9JTMeQ8tzbYDhi3thfuOrphz/TyiYcfPrDbd4zHEy4I1lpyfMaGHdb0jYtyhm9uDsjjxNh1vEwz51mwRjGu5zpd2O++oWC4Pv8D3gmdH/D9V4T+LaqJl/OV4Pf0wTTxT630oXVQcykolpwzu85jncEbs/17wVpFi2nZ1pl2FHlHqk1KGecrtW6yUeuw/+bP/oh1vmwiHrje/iGnmxNd17Pre8aupyI435RVZdMhdGbCcaEkxdmeLjh86ClF0PWBnfsRVwtLDVTj2guWPbVaAp85ukd24cr9jgYsRWFJjuenMz99d0dNL7w/eH52dyA/f+T7X/4Tnz49cJ0SBQ8SWFPBdjsqTZbw/PwMapleHpinC2vMrDHy8vxCmpskMl4v5NSAQSuBdZrISbm8PHF++sy8LCxrxoaRSofmRDUN/yklUdQg0ghO3/X4LjQdl6nkOPP08MDt7QnrLcYKYk2DBkpqMsOidMFwewzEDCkJu3HEhpEpCr1LSH5knj4i6YVqR9R+xfHwNcv8xMvzrxAJqHR4I5wOIzFmxAhP52uTdVrPYej46mZg37dOZYmRvEkVwyZTtAbENqVeKZkSVy5//+8wzhL6Pd24x+XUFFfW+6aKKoVOIFg2sUpGMczXzN3+gBXbUmHxiL5g8pU+gLVHjA2s9kjtfkLNHzmGj3gJnGthv/+ac7RkviX0R0L9GyT+E8sSsBkO/S1PzwteHNenT/zp+z33o0HKRCqJJQdcf8ewG9ECT88Xai1YC9Za1tXg+xuuc0JLbFlNKstSiTEz1ciSClYKlIJYyOmLqqtxUFogDEdqmUmlqapULBpXhnFkcEfWNW1dS8MLUioYEXJp7xAtLNOEHx01aVOoiaVuLbQYQZPFhIH7fUewV65F+O13PxCcpdgMCMH0aPeOGH5CP74jzZ+Q/COGivUj11U5jFBSInjL87RwHAeSKmAIBnZjA+icFx6n1Pg2Y0ALwVuc6bACcY4YDKsqNoQmN/ShyTH/9R//hFISoWutX3n3Cw6HA9U4otJAJioYoXeWXRfw3lGNZ0mJOD0RpMnujA2sGGbtKHLgzfDM16cVyQuaC8ENnHY7vBu4vnzg1J2xYlvfnxRUuBuu/Jt/+Z67vkOXZ6aXz3z+9JklVrwfqKrEGMmlHXmoYDbpY9e14hbrKCqUrDhrN3W8R9UipkdFWHPFdUfG3T2lNgbX+gMpa2Nz/YDQOrr9bkc/nOj7wybJg5wK1ni06KZ3VyDR+UBcC/fv3jUUdFPBG3FoyYipGAyaC8ZZjLM8nK+8rILWQtHciE85sJi/YCkjZfqI0c8YmZlW4TpHglO+ur9t2JAYYm4NRUqFx+cXjuNILqnJL7Xyw/OZOSmossaIs4Kqsq6RaVmIMbMuK/XDX9GN+1cXwVakNoq3lEQVQ9KKKQVjK1EVK4LZ9KnBGfLW9cxlR/XvWPInvD6Sp0zRE4UOGb/lbAy78nfs7Uf6euFlPTP690zrJsCpha4PXK8rVir/4s2BP/n6Dxg1UuPKep15elzIGhAmprnR985axMBuv6MLTS+RYqLrAun5hZKUrI2VLJrRKjjjQdrZW4rDWYc1DjD44FlX0FopVdEtCI+nHTddT4or1gTEOMImlB73e8QYBlWm6YyxPbUo1+cX3r+75fL8zHjaNXlmWSjiEXHNilArlpm8RrAjPSvrHEkieBc4GqX3Slr+BmvGTdMCUStFbvHBcth/xZIKnRPO00oVw7RGUm5Sz+dp2tT6C2LguNvROU9KiZlK5wxrbfWLNfZVzW6dJ3RDcyKk1NrcTV28+T8gV/BiWnTWTM6ezgtD6HDOsi4rUZWKww33OPGY+B2DT5zPD/juDbV6kvmaH9bI2+4fOdkLw/IE9TtiuSHmhX5wvFxXOmvobeFPvjpwEEVrYnp54nyOqDrO52dKWVr9YncthQaL26wM0PCJ4D32emWaGx1fasUajzOg1Wy62SauZtNir+vS0GCtIAXQ5gehtkJvF5oMwhi0rlAdPgRUBSgt24SelJTLtYFSKS1Yu6eUuolvPKpg+x397o7r83dUCqIV8sKbvecnp5W//lAYdz1nXcjlCe8vVOlBYCqC2vfY7lsO+6/Ravj444eGFLs9tRqW5cw1KTkpz1PGOUtwDucN1lQMli4YBMeua2jp7X7g0Ft+uS5YKyTVV6U+0FTtxv7eLFVFEGl0sq0VodHHY9dxHDv0C2RblF3neHMz8nw2qFSQF479TOETfQi4cCSt7/luLgz5/+Wbw4S1T5h+Zlorj5OhrCtfDYU/ev9TxroyP1+wzhDXibgqRTPGOdYIMS44N2BcT9c5nGskYkyF4A0lR+Zp3lwhBpEM0oRAVZteRTeiLedMrV88M42Uax4bsxmODFVb+2dd2NjuRlQ2IbYBaZaKlJemHi+KdR5tDBXO9S34ALEd+5uftaLaOOL1I2l5pHOOJUW+2Xd8PhYuGrjfd9zsDU/TTNEV60bO6T1+/C9J2TFfHij6BOI53PyUh0vkMi2EbqAfPNFUUi70wdF5x1qUkgrPZSU4QRSuSyLGiGjBiGkF6yYwz2mFCtY5XKUSuqEBZTQF04bLNbcDhiFYdr3HO1hjO25ElSE4cikUPOre8ZIsoysMpoA+U+YZ52+Z5Ru0RqydOfRQ08Qqe0qKrJdHbu7fcDs4yvSMmILmwvX5mYeHZ6pUMJbD4Ya4FPq+Y7fbbwxsJefCujYhtOaFUpQW1i19ppTQWgl+IGsDk7quo5TSugwqMTbuxVq/nf+Gokroe8S4pr8oGzdDyzK1KkULOadX/4vxDieO4+n4aqSqkinZEsaBZT5zGO8Ydl9R8kKKT61BwHE8nvi3h8pvHmaOx7GFmFWWdeKqX+G7P8GlCau/Yy1CcXd8fnrCdm8I4chIU62NXtiFQEy6Bae2ek1a7fKYV8bQUTfP07ourOuXE8Fs5F7aDGiukXVfKtYvNsCKvNoTixYezxN931ErXNeECqiCl8plimhVVIUqI+v8QL/riatSCcS4ooxU/44qf09wlvvTkUPxhHLF2IFv706U5bHZAGsT4+6PBx6frqRaWacnRALOBmKMOB8Z+r4hohtoVlWbS85Ia2M3baV1HUnXJmxyDiuGnLVhFHmhC4FgHLFkrG32Da3t+a01rQCmYqQ56GQzTHkvpDlSa6aUihbB2bGlcutfHXFZMyKBUhKmRtLymbTOWNMQYM2x0QW60BnHT+8Dv/n8hJod3hnenu7IzyMm/xXT+plV7jD9nzPpiWiPfP+SGdwTtkQsE/OqJHPHSzQsqbDvOvrg+fRyJeWMMcq0pGaLKMplWtASKSm/OgXF2FdXoftiJ4ybq6p5PMFIs/ZZBLXCskbO80rSQqVhATlnFMBszrey4kxESmDwhWm9MM1XxO8Zhj1r9Fxkxrgjzgo33crNzT0731OWGRE2913F2nUp9QAAIABJREFU9QEXhJKb3k21IK7g3I6qwvm64Kyh9QRNFZdSQbVi3aYUyxWlHYm1VkyV31soaeRWS6uCM4ZUEgYH1SIVUox03YBIs4N+MX1pbbIGYxrmgFaiFrwP9J3DdzvCOCDGUlLB9x05RwY/kNOV+fJraokgoVHsArWWZhPVTGeEx3nlzftbXqYfyfEBoSJ24Brf0LPj3c2B3gkfvv9HfHjB2oyYnoUbpLesOVMVlnUmzle0pmZuE4+3HgT63jEtC1oMzjqS8MrmlpzIKbYuRksmzldCPzQxzZaevbUMnafrA7uhY40ZZyzeG+Y1EYInZkU3FjNVociRrIEyv9BZoQSL8Ei5fk8NHc5mbH/DX/6Hv+Snh8jP378HTUjT22/tIsQ4Y73DlMgw7nCh2RDH3UgurSX23qC12Q2ddU1Q1HWUtDSEkYrzprGszlA2B2Gl4JylCwO5tNZQxCK1/t4LbC3rOqOq3N3eg0k0x2ijHLQ262O1DsqKSDt2vA3oZh0oJeK7kfHwBhDS0uorLZXleqUfe4zryOsVg6BpwVjhfuxYY+Jvf/kBsZXglNN+JE6O3kNePnKJv6a3F96FK0UgFcGFN3j/LdYP+MsLlQnShHVQtYFr1oYW2JshK1fFWkMtbDxVa9pFDDmtOC0F3VzzYnZb/aEMzrALluBtqzmk7TprIF0/4HXC6AGjBhf21FqI5Zmb+5+zPv8WZ1cEZQx7XP41o1/57mHl2J8oT79i7xP3h1tEF3Jem+aiNkzEuNYpjH2PpsR1zdjBtNqgtF3snGwMpeCMYr1F1HM4HHh5WtsOV2lmaSuo5s1O2rJDyQV1rd1tBWtz9Bux7XhVRRWcFV6ePyMC427fitBqKLkQXEfeIICUnltn1YFzpuEZZKoJKErXHZinT5RcEDzejVgfkLphNHnCGgsm4FUZQ2H+tPLm7sR+8ASv3O8qO/3AdR2p9Zlr2nM4HfjwLKh7x67/BlMrojOdeSbm1BR9YSRkB6V1qV/ceM1r0zaSsXbLurlZS50jzTOO7Sgx1m8KpOb2Ntsx0ipc19K4MVsqPHNwE54zO2cx4plWQy0ry9OZod+zzhe8OxPzI+jKqleCs3z4+MA3dyM/vb/hzb7j1fBaQUxF8Ijp6XYed15Zlh8auXR+oh9PFL3QdTu87xqOIWB8peSVdZ6b/cE5ZFO059z6FrGmdWC2yRpizKQU8d41BZVt1xLJLVhLC5h1WdFasMYhXLdbNZSiWCfNXI1gjaFowlQPtIyk2+gL77vWRldIacb7VmSXtG73Wjf4vmyaEsPd6PnZXeExKk+60sWV++OJTmZ6F1l0IKWvSNwhXcCYAGXGUMkV+n7POA70/ZGneaE3FeKKF8tuDExTZFrTBmVALNpQc82IsVixJLPgmlHXtBkTtAr+Cy8D4F3TO2qFUpQuOKp7R5HvCHVq2L5VjM8c/bkBL/Yta41YMxLkBZFWRbtamRbl4eHMz97c4LynkjA2NHrce3JMCBbjA6c3b0lx5fHxhZQia5zowh7NM+K2uRrVUFLi/HJu5mvvMMY3YU+OdF2zCqTSJP6GSioJqtsyUjN4sZGWiIApjZis20gH07CiaZ6xrh1BKSsSK33XNxecNRjjmxnJtsWuIvhuR8oJK3WzrB6wfgQspZwJ4cRy+YGKYM2AsYakGUPhZ1/d8P1/fuI07Nl3zVsrxlNq4WX1VBtwCHtzxXaC9T3GDeTapikojseXCamV4BxGwGglbxbNWDJGhJQTtWy93zZ75MvUBNfaxVactK62+WRiyQy1UjRjrWCMJ5UmRLH+SGQE/cRgJqpeCLZgNTEMsOoLh/1ATk3A0jPirWVdIzVl3r95yzhug2kq1NhEKrLtOGsVsT2+61FVQugZxjtSyRRVUlIqV9Y4YY0npYyxht1uwDj7pQRlXa+sS9zsjZZSmhDIiGwL/WVmRjM5e+9epxo0S0QzKzViT1hKoZQGIOVS6bwn5+bit9binWXY3xJ2PbW2nVi2gj/HK9Z6hv071vnC6e3PePrx78lpQUwgL83qWU0TSUutWFf4xfs9q+txVrguV6oV5iRN18sDKoU3d98w7t7yvMCSK2YrFFIprDnhnCeXZrjPVVvjUevWBtemt0Vfa4+q2roaMbg2OMZubvmClvpa5StQagOdVBUnlbz+iEXA7JjqO5KpHOUze/mM4YqWKzejo4uex3VhKcqcMsegONtxCgvBZjpLm1fBNqGobrWF70nxivcBkcA0Z9DCulzohj0lLYhprrRGlClaK9a14qpxJW0QivOekp5JZWqiHR+aGKqara7ajjb5csoJIQRCGNsiUVubXppWwtg2OUhoR3DeJieJGIZhwHqP7ULLiNWiKFIy54d/QlU53v4hKc2keCUuE9buyPHcpippJmyOa6WJjjWt3HTCPzw9I92OaV54c3ugD4qbLc96Sym3zNNEKj+w6I4sA2IMKSmPl4WscJ0mpLSOrrYCa6snDSqmNQhVNvXd7yckbS5JeZ1so69DSOrGWwjB2O2CMHQdzgZsfcDnv2Oo36Na+CHe8WP9Y3T8c/rd12C/YZ6+4xh+4BQu5Or4PHX8+pPjuBsxkrHGN19pWdsAkza3CvEdrj8gxuP6PX/4X/xX3Lz5BtXI0+cPaG5p0RhpZFl7VrzzGBtQhZRaCs2qG+o6bLMxCmZDDBvF0CYdad20LgpIwPsRpKMah5iOrt8RfE/oerwf6IY9oTNN7LxOTUtj27yTFEuT7ZkvqrWIlsaVYIT1/IkQeubnH1ivP1LLDDW/mrFVM4il74+IWLy32BLJMTOEAW8qDiUYT11+x3z9Sy7TPxEVjGs0RIwJLcqubwhw8B7nHEM/vE6NautbsaL0zmHMhv8g2wyVVna438/Uak4ykS3tUHEi9GFTr2+7zIRbVnHs+TWSfktdnrHuPbmc+P56Io1/Tijfc9ifCOaJNS7cDU329zB/z9C9o3cWtLKmBe+7VsxpG2LiugMpxtZ2Wsfu+Harvg2Pnz+RUlNf+WARZ9FV2R/3BN+36T61tMlA1pJLRqwlxzaVIOVMybUp4zbltrUWtixU1LJEw7Re+fjDI3d3B+5PPYij60fiS2wwQBW866gqiESAhkbGQpwS1lZu3t3S724bzpFHvNsjYhmO90xPD9tB1rJQrYL3Aa0rYgPOdsT5gt0kBfd7z4uCDxZjMtclAp+a0Mv8IcP+zwjdPcVYnGxFuWrz5XgH1hBJJC2Nic/6ind9cTKUc95mvrj2Tmhgoqu1ojk2faY2Mav7wt5ucLGxFmccqnUbEDOC/1Os+4Bcvmcwv6Gm75u8XivX4viUdxzDwt1QuT8O/PjpI9/cH3HG4GijnsQ0aX0tGfM6yK1ZEJ0fqWpRKxjXUcpKUd0WtOEV4zjS9YawzT1r2QFqbdhGlUDOCXEDSluISlvAZmUo1NrazsbJOJaY+fd//Tv+t//j77m/DfxP//1/w8++vsF7oR/GVrw1kB/vK30/bsP9FO8dOSneB6zrKQXG4z16VqbzJ/rjzSaQHrh9+57z43eUvBD6nnV52PigSlxftgXMVCrHQfjx0xOfrj1raSzjOAwcd7dcr7cMuxu0wrrEFhw0K2ypyhgcRYSSSzNvbyz3mhVog3imqFzW9n5d6DdQMG0hvM0n+zJuSjAE6xi8p/NtJxrbTNlrLHjn20gm0/GiX/GsPyWzx7rEMfyO0fyKo/k7brqPiCiP15WHx2dyTgQbcNRmETCCxbYZXXndiqPaBuSVAjUhRKwxpDSRUtPB5lza2VkqJTexUMNFwutoK2sdWj1//fef+Z//l/+V//3/+hvEuG2UFNvAuMapmE1dFbqAsULfW375288khY+fI//n//2fSG1OHsa0GqXWgpZCXAspRubrhevlwrpNJ/Q+4LoB5x215jbD7XDz/xH1Jr2WZeeZ3rO63Z3uNtHciGzJFEmJRZYoUVRJsquzyhYMGEbBI8MDDwz/Ic/tX+CRDbgA2bCrbBQMyC5DlEqiSInJJjMiIyPidqfZ3Wo9+Pa9GuQgkUDEzXP32etb7/e+z7usA1pW58847d+TYmS1fULOJ2AixBFlBBlVkiwTC5rKrvFz5DRpUmmo6y2bbsPzM/GkztOEMRqrNboUdI4YJQ/HtqtZV45VU+OMwWKWz0jiHSiYQiAVuYbbZTuekyiv9kFeV0qTU6BSmrZyKAO6REIKxKIp2mG0/IJSUdyfJkyZaRxAR+8VVT1hy5esupphOKB1pqj8+Iv7+INP0dM7NDIjFG0gLXA6o1CqwVYbYhwZhxNNs8KPe/x4WAbYRWlV5RFOZ6sGrc0yP2WMscxz4vZm4r/7H/4VQVX87//Xz/n9713R1tDVFQrRLBRya7HWoY3GVZAS/NGPvsNPfnG32Aka2ZVovcw8GW0s/XBgHkZSjjRNRdPtZClmRB/JMZA04EdimFlvXy5m5oHkZ8bhns3ZJcPpDSkfsNoQcyKMJ+rukhwirurwwZNz5vmuwU8Vzy6eUBvPlAuvbt6T4kQZNVm94LxtCSmQYsb7gfuDp3Idq/WOlBWbrsKHyDAHVFZkmwheyXJTKYpW4opbGG0pBKxQBg3GKvw4oRSEGGmso3bLN91aUi5YLTNKzgUfEjWBRt+jVKKrDbFsMPo5J98TUfjBUylNbQxd3dE6xzRGQpr+PrJgeDTSaKMpKZGCx1YdpQRu37xmPPXM3hMWlKaQGGWRVnKWYwSNsYp5njkeR/6Pf/tTSrE4bfjB9z6icpbaKSpXkWICI9tKpSS7qhH8Ui6a73zziv/yP/8DDseJH33/JRrRTWIWf4lSEa1q6lqhjAh8qIwxiIw+HGm2a+puQwoBUy3wmvFAv3+HUhlrNP3hPTneC7wnZar2guF0RBtHSYoYxK2mjeZs3fH57cBb9vjQi5LsKmp1Q8meMN5znC1FnzHFTKZjt33Cqt1StOMwSd7Hx8gcHhazy45LydGdk1giUhTgnfezuNqVsiJmGS3J/lxotSIk2W6mGGmqBPlAiZk0jIAllp6pvMUCSq3F3R0/QOe3rMxIU3nC5Alo+uPXnPYWSqBxK8gzqizqIX9PBpznW1JJuGbDPJ6YjnsOd0dSkXu50hUpZVJKqNpRUZMTIpAZI1fGOPEbnz7l/N9fc36x5l/84adoIpWtRfBTCm1WgogqjpT3pOzxU6Tu1tQrzR/9zkuOx56m8iidSUmu6TFMDMNBQCxKk3OkqerHTLBKGpUduTi0a1BqxhhHf/cl4+EaSNhmi9IVOhdgTUiattmScsFVW4lFao0yVh5+FamtZaUCQYkDbN3WnK1rTmPPjT8ns6HbvCTqLVWBrGpKKUwxcxyOxKw59J6Ul11XjOQYFg/MAgheEJzTsBdr5zhifvib33jUQYKf4JMfUle1+DuVoXaOxskV0lnLNB8ge1T2OD1jVcYZkaVTmAlRYhB5+pLaFGJKhFTojOHpzsmQq6BkhbOdyMyohVAoYDptxVta1R2UGT8OHPsTyjYyqxS5Dj6YluVWnnG2IniP1pnNumHTrvn+ty55cl5oayPRDBTOfcDzD37Iqrmi/+oAlRCRWJhfCg9F5gCr5QMVaG9g6E+yutcCiasqh1VxsQPIUbc+O+fs6hPqds3h5nPi7MlhRGlHvT5ffl4r6qWp2Zx/hJ97QLNanxHD9EhhJgvawlYNsx84xlq0nywazGnODN5S6BmmA/PsMabBmgbjHJWztHWFj5n9MKNlPCdRUGWRN0ohhFnYcu9/xnDck5KkLS2Aqyr8HJazR5Y3MRVmPC5YuqYGZTBVjaOimIGKgTAfAYfSI8F7nJmo7ETwA8puyLlHac3QD1yuI1olrBIvqF7mEqUcyQ8o58ghUa03xCBgmJgMStfMKRNLhVPCEbNaQdZoNdEfb8kp0202lGWPIMaomR9875K6svKBJr9oPTNGT8RxJL695/7Nl7RGU1xZhjbxdsQ4UzIMg0crg6sMMYblKJE3ny6aeewZU8TVG7QpdI1ltVvjXEMplnb3AWHoCXGi21yKcrpI2ko72u2OlCOr7RX98YZhuCPHibo+E8l7WZ7GOFNXjmnvef60BSKznzGmoisjvkgOJ3DDYT/i6ue06ysa21A7x+gi66YmlwTJEceJYAomi9uOIjcoMT+VBaduBf9gnKOMGW0tOUv2ZQwerSqKUqSSsRj8HJenecsQapLdErOn2EhKe5zeU5s9NvY4PYlFXxtcUXz0bE3jGnkwlh/IuJowHh+9sMpYUkzy9JKhVMJbtTWbbUUuotCknDAolDJoXbBuRQyJiR6NkV0LhbYGpROUSMqTvCmzZRpvuX33t4S7CXORyFoIQyi5NXjviTGJy8wKKC4u849zDUZnUhiIYVx472usFd779uwc7Rx+HqlXkjFuN5cYZ/DTgTAPqCKKbrs5E4P0cCToenHeCwU5l0KKnqqRP3s8vae2hjmMfH2XsHaNcx1Nd0bdriHtcM1TfHZctmdEZYgJRh/xqfDu0BOTJ8ZM7SyxpGXQf+Du60dW/MPNzjonbxCz4KaqpmNeNHmtZbLNKeODfDObqiLlgk+BHCXOoEoSXT9rZjaoaFi7A6YEUi6gKygjXXXOg9sgFy3XzrTkgq0jxwgYjG1wtdjzope1vdGKMJ/wIYBxrJuGGGZSEVaaVlYyJTnjo0ctnhbvBb8kD6om5SLmHO2Z/BtiHSkqyPbTtMsvJS6ej4dl4BLe1HK0lZwpWqFMgy6WyghRUBvLqltjbEPVXpBNt/hSDQqHrQWL2WyuSCkQpxMpB+IgeoNxlrG/R5XEavdEjpySmKd7dLdDW8vZbsdvfthy9DCGjrFccD99RNU+x9UNmIrDNHEKE2fbNVopxhSIITPMiTlEQir4EBZWu0jvMgyLHyTFKCjwpdRBlhaqYF1FLpaJIiSeRY59XOYtuEyjZbvrVKTkPcQ9ioAOE/VqQ6Gm94kzB9bWTCHx7HyH0aK3yP1bP2KhWcD22hpy0gvLXT3itG3lODvfUjnH/eG4bBMi1mnZlyznfoiFnBBfiFqSKjmRk6yhUBnR4tLiQAOlozzEZHIOeB8wiwr78MUxy/KvPDYvFGIMhJAWu4FoMLZqxHhTIIRA11bkNOPHkTDdyjU4CPGH4gm+p2hDVa8er9MrrUlBrsVhOqBMlH1SmoCIKhZnDTWJrh257/+OWp3YD0DznPthklYH6/AhEmPCx0RRApLxBXEE5rjcZMXfk5bPWylBfxvrlmB7lm3ug1qqivg/Hn0hRYDwPmpcSrROsExKFypzxn2YsGam4TXn3YBze/ppRVVPkndNkctVQ2tE6zeqlvhmmghhhqTRSCi6lEzRkZRGtN3gqg2okaruKNmT/AmdhQ6crcNUookoZbBW9ijGGqyzsq9ZGiVY9gss13O9yMkF2cJaZR4jDqXIjibFLP/dgk5iTTRV9VgYEKN8mPJNszjdktIgFsWuAW2Zxj0pDOQ4U0pkGu6wrpMShCgWB2XE0zKPI4oBP9wtMY6M0QunXZfHHRO5EFPm65sTm3WHVYl1e0sd/5qjf4tNl5zvvsUU5BhxztGi6KcJp+VNZ7SRXJMSI1AJ5bFpwilDXP5NG0laWhHI4uNbwiww+SlErFKMQZ7iEBOH/kRtCxdri48FX60gK6z/mTB884Qrr9EUUq7YdJe8uTVs1ImPtzXoxRRdMqbawtLpIqmz/HhtlF88GFfjmhXkS+bxgNY3Io2raqneEDnay/8IJYtvU8bzhRMv1H5CENW0WL1QkxQxyoejtXDitRHPRi5Zjia9wO6jWiRsQVlJtjfLt32Gudxx/vSKzcVLst7wqy9OsidKkQ8/vKJuJlIYULYVPIXVxGCwriGGiabbMg53NKtzkbmThzJRokepRPAHjGmZ/ciDLDHOs3DfEgT/nkbdYk3LdPMe23xEyFsiLQlFSFA5gxqzbJgXiL/V4veJMaApj2/uB6pUTgErVjwnauaCnKJonNVUrkIZTUiZKgWUGRmO79kYSxzvee4SK5eo2gil4jQZNrUjmw3HYWJ/mpn8GS8udyg1AV7oxdU5dXvBcHyPcYt/I0GJAbfqiH4geU+9vSB4T0wTVbPiyfMPePf2DdM8sVqtZOdhDMY4eSMRlxYVvTQjPBw1MoQpnUl5XJRUJX+pypTixJdCppSENWLsNcqQciKTyb6gSOQ8Q86E8UhOM7komvVz9sOWv/zlgV+9ecvhVLDasNudU/RPsfnE97634zvf/phVW5PzSOVajKmx1UAYB6Z+z2Z7gZ/uadbnjEOPQtxpWmtylPRhYywXnSEpKTDwWTPlDU1TcTh5lD5wd/PXGNMxxbW8MdtnGLujc5rDJMRrShG3XRGPj7yg0mOIzhgrntQwT0sqP6JyQvwjUtHhjMKnxFxg1awoZoduLdfDPSZpyHd4ej7YnVjpiUsnusGYGta2ZU6Q0x0X2w1hPuLa7XKVNIRwoum2TP3tYlqWJZSfjsvQ1hJnT9NtOFzfUlmNqwxXLz7ifn+QmMbilywZCVMXtdBxynJlKzRVQzZlQRqILpPy4ulQko2LixdFK4s1TmyERgvpUSlK1hTiopjKjFGUYgia9/cbfvLjyOCvUabBWvngu67C3x4xBoJXfPGnX/Ov/83X/P7vf8z3vvuUi7NqaWyosVXh4vknWNsSfSOVKgMoW0n6fjn6CoWYM3VdKLbjfkh48zFHrsjmCamNpBwY40Qskv9BJYppMMayag39FPGliGVyWQ7mBQacFGhrF8FMSp3M9z99St2slrM3wMt/QNU0uKp5LJupnVsg/oaCw9bnVNWOw2gZ0pa5rBlyTVrKgBpn2K0qVs5Rl8Dldk3txC+g0eQSsVa+STH2yw0hP/7CtXWULDcDowoleZStQCVOhxv8OFHUI0NLinNyIaZZtIrFU2WNxii7LPQe7veLxIyCYlFKyoX0wl57cIcVJem0OcpGNZeCT4kpQF8Mt33D376t+ckXO3w5w1YtpShpvagaYpIsTVVVy7fSEbPhF1/s+eLLAzFGvvHpFSlMhOlAzomq3UmeOHj5HNQSAtNOgkha8eXdxJv7geN4kmtqgpAsPoyEOGKUYYyFkBxZN2jTUUxNTIW2cvgg3T55sYTFGBfT9UIWev2XYldM0rVjeSAsl4JPo5xDy+tWL+bVegH5pxSotEfPN5T0CpMSvtQMsWOMa67HExs70piZ1vTUJjKOJ+pD4cmmxRog6yWY5CQ0tIhGD4YhV62w9Zocksjap6MUHGmLbTcYpbD2nlIETuu9l2C1EuBJXlxxMQdRWm3ElmoZvaR8oKglgqk0BkPK4HNimjLGFLQVxtjsYQgJdGBOkdupcHOA/qg43ncMp5ZuJfREax2mWrghzmGdIcwTIYTlgRQvQgHeXHvu/u/XvL+75V/8k8/kNlQS0+kaYzQxDNTdlrmflyFbo7RDWc3lzlKMZoqekDXO3DHwgmjWaF1hqxV1CahYmEPBGYg+YJRit9pgjearmyNh6MX/oQ1Z+FXiy5knVGuYxwltNFZpLQ4jU4h+glRoFDRGAj11ZTFK4YPHqMg8vcHyFsuXNMZiS0tt1kTfA5PctUPNuzlhdcKPDsXA5aZBFQsqo6nIcYKkxbQ7vEOblqq6JMwjqAHnWnnqu3P8dBBnOY6MwTYt05Awdk2cTvgwkkrAuYqqbvExUFdbaUEIEWUtp3lGoQhpXj4Mx2YjhuZpEE9rRGGwpGA5nkb2vearuyPDOBODoqiaFDvyXBODpWlaQNggZe6x2i03JHG1CdUxM49BAL7LskxCZ4W//qvAcPgJf/KffEajNCV7StYkH5jpAYfWZak/gzmcmGNi0zrcXLidZM1QfE90jUACVcV2ragrx3GYaSqDj4ngo7wx/AxFTNnTJJtipeWo0UozhxlXCxkSo7Elp0cbWk4RjcIqTWW1pOWB2lqygsY5kr5gHANVebMAVjZM3tPaRG0GLDOUEZISEnipJaATRmIRtoapWkoMFCXClFnsdiiNIuOHG+ai0a4iJYdxDl3EYea6Hf00M4REP85yE9CKr+89fQzcDz2VUVy2NVbDum348n3P25seaouqE/ve48KGf/w7L3j2ovDjn73m3c0tt30gzpZ+yPS+sDKOner4LG54oVvqasffxcDnaSYXLZlgJ2+kkgXplHNinufFFqAk1W+dmHFcBSoslW6aYR55f7/jX/1v7/iX/9l3qOmp64Y+CvsshRldCS4co+mniTf3im1XsVvVnJ2tGaKiv37LPEJd/x5gGSfPZtWw6xoqZ5hjYlQzc/BYZ6ic/Bh15ZjnmZQyD+EnqUqLoArRz5jf/uwlzXqHUkpsbh//HnXlqOuKlBWrtmG7bjBLzUTIFdnsOOVnBPUCb18weQXlgDNg7BbSxKo2wkF1aypVeL5R1HVHyXGhAFvCPEodWfKURbPL4SgeTQvGNnINrtZgG4oqixg18/7+a/7i1Vv+6s0tv7oN/PWbzM9fe97uM+8Pii9vFV9eB15/daT/cubJXPhH/+w3efJkx9vecvf5e6affMUn3/0h3/r4iidna6Y48eYmoorh5eqCT3rHZ2XHB9WOM+PolOEiWTYRpmxIzj22ZyqlljBSXtgjhlzERilhKZnB3JKDrpzDWMv9/sTNzcT+MPDt77xEqYSratlFhV7KmBR4v6foM6JyDL4wzTPjdOTQDwxTJKQjmKe45lzyPD5IhNYorFGyOgAO/UhWShx3i84VY1qqYxPxl/9O2qlSJIQRa1y9ZCE0ru5Ii8weE1ASwzzzzGygZOmPUYkpQmBDKjMmZdbdJRZFcpbJ39DoozyJ6imncUWOp0WJlQRbmHtQDutWUAKlVGhdk/yBkieUtfjgcWoGU0h5IMUTlESOA8oEUjlilOM015j6isq1bJ6sqJ0Mwk3KPN/fcnHzmupK8Vv/6XdwF/CXXx54ve/pnp4z//zA3/z3f8rzbz1l+xsX/PF3v8eke9SyAAAgAElEQVQPP1a8/tUN+aueVeOos8UltSTPFM5ENrXhpU/8xTzxKw1zzljjiIhAl1LGOUPymaLTY0Wq9x6t9YIRLcxjWAZoxU9+ume3+jl/8sefgVZ05y8pN5GSR4KfSCUzFEM/TsQ40nSWru1gLhwTGL0GFfBhxtXCiU8p42ePtpaurXn19hYfC4dpJi3lDWoRFNVDM3Dh8edVwqZrHi2HSikMsGpqcsm0dQsUhmnkctsxzydqMg0DNt1SKY8tE2sGapPRueDsexJ2iVQHvv9x4NWXk7xZ8kIqXtBIpQRyHkgx4OOAdbKTSBSM06Q8oHLEx4lShCIQcmCeC+9uMv34KY15RlO/pFGOVV2jw0h7+oKz8AWfPM+8+A++yeW3n3E7XfPz94E//XcHTkpxfT/yrqr5vD/wm3/+BS//6i10lrquaOs1bbWipsJp+egoBl1kX+Fj5On5ln88T6zuev5coJzknKirDopimsTjmcg0tajV3s/CNPGeqnKEsFyHoyekyP/3F9dsVpY/+J2nzPOR8XhH3WzJ84GsNUOccNYSigS35jlw8k+J6iNcuyPQkXKmtZZTPxNzwRrN7c2Ry92K0+xlzogJrcpjUE4ge1JoYJaqNG0sxtVYtRgqUgxSYrcA2erWYVTibLUmhJlxHJmG98JxjzOdOeJUpK0myEdqZxjnyFxarHlC5WaS7/nyduLWr5ijoqFAEdpgiZEURgHilofzOlFUkgcHSXZpNAXBhM/zwDB73t1k3h0+o9n8PslqfIg0VcXZ5mv+8DcG0t17njz/kHbdQt1ymDN/8YuG/+XHW3LZgP6Sw+0tMSraqyv+7KuvWfX3fKN3/ODyU56cvcAsXgyiOOxLWrQTa5bKr0zV1PzOs5oxKX56v8day6nvUWjarsFqjY/SUpEWtbqUgjJCp865MM8BWxmBEvvM//pvfs39qz/nt761YjjeUdktOYzUT87Qq4qUZW9jbKGqFE/sHtd7kv6IPS8xTY1Vivth5tgPqCX7Mt2dJISmHvK5wkDRWrQjtSisxpgl/6ywrsY+xOzU0m7woKZZJeFoHyJdUzPEyH6SIhqrCsZuGYNnDBFXPec4VGh9ATmzqa9Z6QPVbsOv3/f4onl7e8+LjSz6VFpk3RKWCJusng2KlA8SJDfLXiQZcpYmg/vDicMw83evfoPo/kNilCVjQZZZ3/nI8/KlJj97hjY7Xr+z/PtftXz1vmIML3neiaw+ecdo7vmNTz5gnkfMyxe8fvUKNyf+8fklbbtGpUTygawlUEZm2dEIqVkXxCaoNX+wXlF84vNpZNV1+BAWG6R84LlIBEE/tncrqsrJPkcvCbeMvB3mwE9/qfn4ZcTPiXncE4PHJU3aGsb6gkAg14ldt6HtDE09kfJPOUvv+GL4Jkpd4OeyGMGU7NRyYtPWAhN87LqT5KR6sFss3cjRzwsGQosOkmLAVfUSw5PXlzQaGVpniRlytpyfXfH25g2ozBQiIReSvsCZhs6CTUdW7p6L9ZFxnLjbH3Eaahe56yde7nYU4pLekutVjAHjCirPpAg59eIu04WcG8Ay+URKmX4MfPn+jFP8hxitqJuOGBKqchhV8/nrHZ++OHAcOv7qF1s+f9VgnByTlYPtpiHlxOG45en2gpzjowutqiuakKVhskiWVpGWlH9ZUv3C3DBaE+YR13RkBZvo+ee7jrWf+PE4Ypv6sSA9hIBT9u9jpoulIKiItVoGyJSWTLRiniOHXKNUQ7e20mA+DaSYmO4PxF1Hvd0wTrdcH07s1i0xV/jkwChCBO1vaEtcyhVbMCtKsQzDKA+pKkuwPMpD/8Cmy/mxMV0q6hY/SCl5aWHUhFIErF9g8p7KVUtm0+DUTKPuhEemV2i9pVaBJn7Fyr7DqiPbuiF5Ac9crB0hQaMNThtCFk6n0XmJOso3SJXl6lcGQSaUglYbquYMsmL2cHe45e5oedf/gKa9YJoCIc48f3bBOI9U1nEaLP/jv27oug0+GDYbxzCM7M62pJSIMVJX8PLqBVX5iuvrrwBDXdWcbXZc5cyqqSlkkperHlr4IuKmZwmYSw9tSQmNIc8BXSI/3HX07/b8Mhew9nGpF5fCR/lSSG+cUg9ma2mFslZJdpnEB0/bJdwF1jU0WgiJdSnMYSQPDTRPSO6COR0xVpBPc7rg/PJjinacM3N8dwOqkNSS1S2gYlp+F2HRPxaA3wLhSdFjnZQ9mnaFVctyRpxlFckofC7y1igKnwpt4xDGnce1HzCXFmc17fgLGvU5uUycxomrteN8vaTmteF4HEjsOMyKN8d3rNWRl5fnoBI57cXBlHtKKlAMOc0oOowFrVpimIghMvgTo2/4/N1Tkn4JxfDJR894d3PL69dvCF7RrRqMVvi4ZsUGPx1RWt4IMUqh35Qi3arBTz1VVXNxds5uu+Pnn3+OKopNLBIkdwZTO+I4i6HbpMU6oEkhUjX1QgIolBAxdU2KoHLi95+cMd7c8abU0nq90I1YVMtUMuM4UlcObSU0X1UOSmToTxhmvvvZmlJGEc1SwpgaFKSsqIwc85vNhzz7+J9yN43Mw68Zp1swmf7wc5J+yYfPPuR2UIyThKWg0DjxiVityWhaq3Ftw6wh+EL0ZUGiWqKfpFq+lLwAU9Ii6BRCgt4HaTOKkSkEDIaqfUa3eokxFaH/O1I5ch2u6PMlCsM8H7nvT3x5e8fd6URRBh9aat2w7VZU1RLYLiMwQ5mXOSSR4lGGpKoWNzCyZRznE8Pk+fpOcTd8E2tbLi52vH1/TSmZ1WpHVVfs1iuM0VxenHHsB9pVw267ISWpTXOVw2jLZr1Zgt+Bs+2O06nn8uIcP89Ui2+lLMOx1hq1lB2ANIMbrZknuXkVVVDGEGYJeBul6VThj87WbO72OAtVVS1Rgizb0xBp65qUItM0oIF+6Lm+veH5ueWf/MM1T84yMfjFHypHgFgRA6okQpjo79/y1Rd/R4wtuvtdwuoPcat/wHr7MZtuhaZw1lU0lWFdV4+5G9nfSFfM2abh+dmGdds8riqUMthFq1FKY1NcXoNRENOqgDXy+o8lM8bF1fRw188z66biZnpKT43iBptGnm4bWlf4ar8H5cAkpK31mkRhnAObtkKrEyUN0hZBQusiWVxTCQIp+8UzqwlhFpZpgCF8i932Cit9hPgY2W239MeJ9apGG7g43+Eqx6k/0XWVsLiW9L5RkkG9vrnDe0nubbbn+BC4uDjnzavXDFoc3qoICE87AwZUFLDbPPTYqkIrJ7sqpJNXK5ZjUaHIrFLhTz76gP/pi1f4JxfkJGv1lJIoxjnj/US3arBKoq9tZfijH2y4XE9o5Vl1a5HssyfGKOF0ELxWkt9NPn5BffFNIppCg6p2uALTHAkJPnyyY1Vb5lg4nGTDm9xClMpJjOpZeK21c0zTJIyVqlmQEEg1u7EVZeFHKCPTtl3Op1wUXV2jUUQvdgBXtdjmuahvFHR6x6ujRpOo3TljOud4nanLXjypuuHbT17TNkDMFFWW4LAX5JFrl6tkIMY96C0qR0II9NPM3aHh5D9AAa1r2O+PWGu4vzvw7Oo5yXtOp5FpChirCd4zHCRLK6rt4g1JhabuePv2C3ScOPUnmrZhHAeaqib0M9lHjBOgTMkJXbsldVio2powB/QCv4s+SHtCkTzuQ2uXc5qti/xHV0/4n69vsdsNbVPjQyB4CTBtNh0pSdcOGZ5uCp3rMdYQfKJyYuAWiI88kIW89OTK27ComcPhLdkcqWzHuul4ez/QuJq2Nkxz5NluzX4KrLuK+2PPHGHyhco6wZgGCEZQENKcbmUeXYqfbfQTdbsi+lky/UWCqGrxhACM84yqa6Yo5pnT5OV8SgrnHI264LwOpBy4PbaEQXEx/Iq1nUnVjhcvFZuuJwWHeYQXpUWQqdDaENMkf7ep0UbEuxATpzFzffgmZ2ef0I8TzjmOx4Fus8atDX6aqG2FcVJzOo4jeeGWnoaJ43HkxYszGutIzuJjpq42tN0lp9NRAlAlc31/xzfMRipelSZrJYTmIS7OMnFZUQQZaSuLNsLUSDFhVFhSagZURKuKl5uG/7h6yv95dyQugLySC9M4UleGtgGdZ37vu2s+ulIoNYgPx1VSLaYLlZF5R1tDmjJV1eHTSNu2VBefEbZPGKaBvv8bhvwGqz8lZ8u+D2zaBoXUuc6xUDsrQlplMCWzaWqC04x+YvSzjKJLbMTVjRjKZSXuhDeaEyzwFaEEyqvzOEVSQbwRJYmAlCbOynu+2/0tv/3ic1rzinF2NIcbnu//H87tHS4faOI1DHtMEYxk8DNKSVBaKU1Kor1oHFo5jF2TYpJFXonkWDOHj7m5uRUuiJL6jP44kGJmOE0cDidiCEx+QhshBVlrF5hc4nSaSSkyjKJkPnvynK7dcHe356MPP6Ztu0VzKeKlLYocMyWJyhhmacSIs19W9+UxRD4NAyongp8wRpx5Ck0JGRUjH+D5L370CS/PHLVKTMd7/DThh5lOj/zxj8745CpjTVoIBXrhhC2xDiU+2xj84ucd0BYSnqY7Y7t5Rl21hPnA/d1f4m//LSruSSmjVOE0jkvEMmO1wOvWTY0xmvth4M3dnvvTKDiMxcGfUlo0m4IWTobYsnJOjy6jiLQVLYERfJBlji2eM33Hd5qf8FsXP0bFn/CrtwfeDB9z6p9RH3/NqikoFTDO4oyi33vu3/dMp0ROhqIajN1BKThrUCWQ89J0nYKQfHJknAJf3z7nfrREFB+8vGK16qR0EKnzCClx6Ae8z9KbguVsdwZkrp4+RWlNP81o7bi725Nj4uZmTz/JzWboe069QGYv6hajpOVA5UiKM7nEpeggkTIoZ3GuWiDDWQSvklFZEAtmiYBSAqpkaqM523/Nf/tf/YD/5r/+bf75P/2AWhc6F/mDH1xytn3Yfs8L5C4saHS9GLQSMXpx7NsWMJArJp843v+cuT+w6S5Yr18Qi2MM77i/+X/J4UhYfp6F049zlrZycsuMhcMw08+BVB4Y7Sy0hfCIf7Di7JJJPyePVouza9nNpFywpqCIWP+KtX5P53pu+z1fnzb48gO8usSmwKX/My4vN/i5x9gGiiyuSIrhqBlOnm7b8fzDjSAOFtZoTMIoy4AqUd4eqWaaK17fXdGtd2gM+33P23fXrDZrVquGX/zyFVXluLp6yv39HqU0Pnia+pykFW+vryk5sttsOfQjddOw2nTc3t8zeaE6fv7LX5JKInrP7mqNskqYqrNMt36c0cbh6oZ5EoNSXUv7ZI4Bo8UMlBFlVWtNKhFjxfytNHDMpPtbPnx5zst/+bv80e99g+m4Z93C3c3PBbWgNAZLXXeEkMWLaiwsAXO0DMpKW3zU6HrLPA0c3/2cT77xuzx98j2MWpF0pOmekdjSVI67YWLymfvjyLZrKBS5+hbAmEeIjOSBldyechbqNWvZ5ooLKwiW6AG9XFimcmlTpESygXuesM+f0psagyOFIzrNtO9/zGXzFlA09foRqiLnsuAolVKMB8/1V/ecXYrhmBIfjzLZyQCmJWXN3fGMbv1NhiliK8Pd/rgYkuF0GqirmhBnhrEXG0BWzJPn+vqOzaplv+/54MMX9KcDq9UZOSU0ibatmDijNK30tU2J1lXURokvQsvnIA0PZVndFyEm90F66uYB65askKvIwWOtlY2t0igl7raYIyYbxl/f0jw5w49HLreankTfD1TVCpzw6cvye1DaSm18LpQ8y+1SmSV1YGl1hVrt2H3wA2J1xTBKZ99HH/2A3ovF4NXtka/v7ni775mjiGGDn3HWcuwnfAr4KL8bcYxnqZ9COm6in4Rnoo2hpAQKsfYpaeG2VjIyLGEhZVtm9YnAZEoERoJ/T0l7OmO5NG8J0xFnLFnbZVsrZ5mchzLdG2OZh8DbcebsiadbL+HtJa+i7JoQxanez8/oB0/brpmW4j9jLXEB9rddxWW3pe97nj674HgYKdGKVa5yaKU4HgaU0tzc3PPi6pK2qbm4OOOwhy/eB853a5yF1lo2riHOHqskmW2speSCDzN115FKxlknjVJ1jbJAjvJzPexclBaMBTLUSoOsZv83N2x/85ucffQRYTox+yPWJ8I8Evz49/CWIlGOrATWq0wR7liQZL4yGqUSx/tXTPUHtM/P0M6SfCZmOM2F+9Hzi6/vmXOCopYHrDD6zDDJkhBtBFcRM1qFhdFflqCcIgVPEkymGHW1sWglE6xGJvOy3N0rY3DGsF3VWGNwylIZQ9Ve4lbfAq+obcaYinE6Pt6CHvCS1pol8JyJPghkLmZOfQW0aFNh7Iq63ZKyIReFrlra1Qu6pdnB+8A8zThtub/bUwqPf+6Tp5dohM1hK7nJ3N4daLqKGCKVlR7f46lnvz+hUGy3O6pqx7u37zgejxSt8CEBy5LKOXnj6AdubKGkLMFzo8FKHw1KEWOWbzvyJgghLkirShzjuaCy4fDqHc1qi+s2rC9e4qpKxDfj0LaQ0kxY2B1aO5q2QympPMmlEFLEh0Czu+Liw98l12cMIXNzdyvcNldxcxo5TpFYNHMQ2E18qCRRiLyuWQodJQNc8oLfRmZOvUDsllNEPabQZBjLKGOonIhM1mgqY2gqK1SgIpkJW21RZiNO8Pk9VklSv203gqA09pH5/rjFZIlWYiS8TUPOFnSFrTpS1hhbYUzDav2SX7860XUd4+jxPuKDpx8H6rrGOUPlKhF3SiH6yDzPGG0WfEVFiuLnbLuGkgo313uMqyRFB5xdPBf8VNXgbCXuLdG0xZey4CBzlurVvAxuJSZKDJDzUg1rRXFNslNSSsS8FGTwLmGmeMX+r18ThwMxeZRWNOuWqq4wrkabDqUctqrIMTEMe8bxhNKZwiTpQQxudc4+KeoX38e7KyItrtnRdBtuTiPv70+8vb1n8qPcehYEuUQmhFOWl2VpXgZtHoPwGmNE93FLRYwuy/1cmBVS9+WMwhn9iIV21jAH6RAJUTa5Sj2Euwtj3jL6QG1rrHGPbiZra5xzywMoiO9MkobFnJjHeQHLWQqGnJ1M6aqhPzne7zX3d/fsdhvq2rHb7bDWMo2jSMFktqsVw6nneBypnCMEz/3xyC++eM00B+qm4ub2HusMMWV+/cXXnPqZeQ6ksuL93YFx9DjjFiq4Xq6Y8pnIbUIRvPhMp34Qq0IulJiJcyDEgJ+Gx88wBGlKyDlIq5QGrS3x7cjNq2vqZo11LdvLKwrSfSdvb8089QzDnuF0vWSAZ3JWxKww7Yb27AX6/Bt8+f4VTR0436w42245zoH9aSIkmJO8KbSSE6BEyCmI+rq8CUXKkKE6LnaAuDR5xjDj6k7KEMQxLdYzhfShlCJSNkXyJcdhYrNacxrlrLJK0VWW41hkGk4nqk5W1iUs07sqS3pfnlZnawG45EQqEZVEnQyzQGNNJSzTlOSh/NnnI9psyMA4jbjKMo7iqDLW0HU1q7ZbviFCMXx+9YR3724gw9WTp5yGiXEOXOzWmKVK7TGcXeDDFx/z1Rcv6E/vaJTCVBVKF3JM8pCgly+NYMhRGtwCw1uQ1dlHQZVri1Li8TDGEqaIrRQxJ6wWBZZiCPcTRhtWu5eUPLA9+5qb8ddYnTkc3tEP9xTtqOot2Jp+HojunNX5J6yff4Nkz3n65BvY057j4Zq7u1esNi8pWVFZS91U5HGSuMQyQmqt8DFS18KmzQ/7pawezUM5mcVuKl5hY4VVpsuCHXoAwRklFOK4PGU5J8EqhLBw2GFVW7rKCAIi3LOuX2MaxTD1xOXt8vBPUzdyC8iZsjCwHqxuWlfcvS/MsyJGSNFhzYqUO7643kqqv6q4vz1itaVrGzbLHHR+dsb9/YHXX72X9gJnefP1W2JMrFYtbevo+5FxnDHWMk+e1aqTbuC+Zxpnphm+/70fMU0TicxUPJhMyoG5Fw+GSESCqLAL4RGgaVrSsstIOYKRo0sbsxTtSJ63qqUJqiD+i9NXb4XmGHpO91+iTGR9vsP7PcZBriqiMUTX0itLXH1I9+k/4q75gLT6Br254raHfm558ey3+OTDb8n+xFo26+4xa7xadWSlKA+beiM3Mbl3CCxHKbmpaXnJUVmzBNgelQ5syXmpwBTjkHoQVbRM40bLk9lWTgJFSrFqHTnN1OkrTP4JlYP9vWKDUAGcq2THopSUDhWJPtplEHZWPw7B45zposVl+Z802jGHisMpoW3GVoZV23A6DmhT2Kwu+fiDS+5ur3ny7IL4YOjRluv7W5qmZrfbokrh6vmlXEOVYrtacXd3IKfMi6un9MPAME0YapqmoTHSDlGWYi5Kxlgr5OOiFn65sGSNNvhxJodIUtC0NWGOqCLLOK3zEtEUeI02DxTGwvHzV6ScmYavON79BEyLV4F0tubWVOyrZ7iimYrmycsf0T75Dm9u3uHDyJdvvsJWl6zPnHzpknDrfcykojgNM9PsyQWOQy9vdxQ5RmHT8wgPWlKJSkxMWlYfJZdFAwlUtpUWjAfDUAwzrqoIGUzJuJKonUiy1lgq5/AxoWsjf1H2YDWh/jZ+msH/Ga1+j9Na4kcG4tJbG0smlbTMH8u5rg3FKOaYmWPN027zyAKb4jO01UzzTF2vCElMvU5r9vsTH3/0kqsX57x5d0OMgtTcH45cvXjK6dTT1I66qnjetXz+i1fM44Sqa+Z5ZhgGctqyXTfE7ChFYH0+xaXQccF0l4K2iuhlYC05krzgJ1huA7py1E1N8F46emtDKuIdscYyTAPWCVJUcjIa1zmUVczzNcXA5O95N8Dnx453wxPqZkNjwRAJwxH71V+h7XMuLz+jqxTDOOLnka5ZU1c1Ywj0k2cMhZtDT7/MirKd11j0wmstSD5OJAVieszlKgUGFuC/+JOt2zGPvVAOUxJrnbGOUHi8O7dLuj9l6CcvJaAKcluD6qjaz8BGBnXivrtjO91TKRbndlqWWUp6dxdyX84L6ts4eVhcTYxBBCKliblwGDRt24GC2/s9dVXTteaR/rfbNvz0Z79inBONc0yT9L5s1mvW3YrT8UhTOW6urzk727BqBLK7Pd8SUsJYS/CBXDJn5zs+ePltDm9+yuADVHphr1do6yAtR2sl+VhdWYrOaG1JaIzVjGNY8OVO+CVF9iBWSztoKlC0RulE/awlzve05x9x++or3p4yrwZDKB3nZ59gbEWIE+dnzyAFMoX15orNaosuiafrS76+6zkOnsyJfppR2hFTYPKZEBLOaDBSjtRUgvOurNzKrIE8ZjyZ0UfMYlKHIn1+3hN9eCy51DnLw/HgKtPLt8gai0+ZKWQZ0nKUqlSjGWcPxi7QFktUBvXk+1yf/SGnAlmZZStoKMU8FiU6V+OMoyhFUWCbivrJhlnDFGUhqHTD3Z0nLmbp7WYtZ6sqzCGx3qzRWvPByxfc3x346OMXdKtatpvO4aeRtmk4HE4yV5XCzd2en//yFa/eXDPHzP1+wFUV4zgRfCIX6IeZMUZSUuS8xCd9EDDewnR/bLxcNrIpRvrjAaUSVVORYlhmNtFHlFZLj4xFGYNX0L40DNNbbvdvedU3fH56ymw/pWrPqfQtOgc2qyucWdM2T3nx/HtoU/Pm7c+5P13jo0RMtbEMc2JVN1xuOi63LZ++uKQxhXXj2LYtq9qhtehau3X3qGvJHCitXSxZmIzkkyUCsySZrZMZRC3r7AdWpoDiMuMse4jJi3nGGHFIOSuTMEbhvaetayptmfyK+9VnpLCn9QOVU4utXjQSpR2hzKALzdphVg0HZTD2CVPSoDzOrklLDUeImmPvaSp5AFIJDNPM3aFnGnqqpubrr68ppeBDhiKT+uk0obXGh8AcMilm1uuWw2kWv8UinoknI1O5FUUpphiJrlAZKzimIJtulCaGQE4yAZrKoW1mOvWSPtysRHPJQVCYPpKMhK2Tj2QVsU1DCnA63XD75Xv2ZcvPrltss6Nig9KZMH9NKm9x9QofIodhpFufk+LE5D374xe8u37L+cW3WG/OFh+KUBCthhA855sN2hgO47gw1URN9bOnIFC7kv5/qt5sWbYrvc77Zru67HZzGgBVqGKVSFaRIimTlB2WTEY4LCqsC9vh93D4tfQqvrMcvJBIF1kdCgc4zW4yc3Wz9cW/zi45cIM4CAC5c68159+M8Y1NgVqEWiAclc8FrcF6/2LTsGXTIMZloR16+cVvz5B3lrbpRFe55cmmmHDGkQusKZJLobeZ89MvKGYgv/2fOccz89M/YvM/cquudKZluY6YnLCNwbWG6uEpJXJzZIyaV75njZHKwjC8wrrMvESa1tH3PcsUuI4jTWP59OnCeH7aTjVP6z3X+UI/tIzjlRATd7cnHi9X0Xf4DqULP/3RDd98+4G8gVNSTLRNy/2rO77/tZfRM5slsVbiml7QVmWrUdhw5CLRFPJ5WBK1asDJTshKNaiNY5kDysK6jKRaeDhb3lvLsx4wfo+zEoMe4kypHq0KXos9VdvMN+/+C94dsLbDWse6zEzLlbbbse87jC5MITNNAW8Up77FWk3fGGKq7PoGrzXXNfJwHQUguGEf8mbnED+ujCWatmfOkbJhL6xcBUoyTbbT4/MpooHBW0ItUBWDbwkxQM2kjfFecmSKT+jmB3TNHqU1S7ashz+kLolrzrj1SsNvaX1mf3/D4xx4KgZtLdMc2DUaVR2Pa4PXMOysFKZFows8P5+5O93wdBnZ73c8Pj2hasE7QwyJxjte3Z24PF84n2fO15m4iXoOu47rdZUa4QSH48B37x4YpxGlFeO80raScWfLBrrbBmFt121tbUUZYaVIq29QaMbLIg9OBe+aTWFn0c5QNciBYlBWHAKRwnfPFvPVD3BZvVgeUlk3RX+Dcx1KKxo/sK4zujxR04rzBw7DK5Z2z253y37f8zyuW0qowTqH1wqtI6pCY0XB1liRchyHhttDz2UOzPOCtYZaxBbAMnMAACAASURBVKloUYQq7kDftszj04vn2Pqmp+SE0qIFMNu9tO10yTnTtY66CUga70UbuQXwdU2H0b0MY2KRFEqniElh2z8G05Cp5PHvqYdf8Zu1sqojbetwKlKAQwNzmrmuhl3jcObCPEMt0ulo7ajAcb/n8jzinOZPfv4v+PUvf8u7d++xjeV+GNj1nvEqq2xrLH3nJD3aRow1/OKff8MSMsd9T4yRxktxNwwHagGvBKmpjQZtKHHTSJBp+o6wKenyljzRtA3juILRzMuCNWIb0FZwoWKMDrS7EyVVTKNp7wd0NxDnEa0S6ETRGaM9jT8xtIctX6/FGkdRkvfdecM37/4LKIdzPWu1nC8r3ltiTBtzXuwlbesl2sUZxmnl9e2Bh8vEod0kk84xh4izBqfBGVjCjNri2Kn1ZfWirfOkGLFOHN1G6U00JKvgWDIxyRcVo8SAzVFW3vqz4myaebpOL8lPzlkOxy9odm9phhuMLuyGFfyeMXassXI7tJJAWWaszqwx4p1mjQuFCd90jNOEd47GN0zzQqmFaZ7JpfCbX3/Dfj/w6tU9YU2EmDHG0LaCcHz16sTd7YlPD88ii2w9NzdHrPXcnI4SNqQ0rRcemXcW5SxiLJTVgLYa7SzKWPGsFFGY11IJS2CdZwlWrhrnHM576XYolDXivcW5LZrMakJN2NYQ5gshzNT4gKkjYPCuw3ElhI+A4dOn97y5/5Kb0w/Z7e4Bh/N71lz4p2/+iafzMyFlrFbcHncc9wOWyv1BSIpaa2KS6e/jeSQlkXCqWvBW0TpF7w1D66AWiX7ZlpIxrBvjTX+OJKsSAyFpPIKkVLxI/Oo2PMvb3dy3HbkUUsp4L2jMqmS7ugTJlclFoskpAW9m1mK4rJFYCneDRdcr52nG6MTQtYRcGecrIUe+P0+kNLOmRIgrKSeGYaCUwul4wGjLze0Nr1/fbRNBxW++eccaE9dpxjnHb7/5jm+//8jN3Ylh6Mi5cDzteXV7Yhon9vsjT88XDqc90/QEqjKvC5pAXKTIVVajGrelWMobFdaVdYn4VgpnKugq2tw1CMejVkFXlALWtxIT32rswaEHT9NkwWr0HYMvtL7F1Cs1P6PqTNd4rFVM00hJBmN65lWzP/yIr776S17f/4S26TjsevrO403FWc1u19N5Yanmsu1hamVexfjeOMPNaUfTOLw1GKVonMgkc5EZSC2FHERiWUuRLoZasb6FihyNFYySZyeXii5V2Bxa9JiSrwreWkqq7LpO4kGcZa0Zr/3LwClnizMtmMBlNfRWYdXMh+dAKppD20iBlBTOVZz1TM2XdMPCMA8M3SCO+pjJMfP8eAWT+fDR0neivJ7GmefLxD//9h2H3Y6UYdh1YkgPAe0t+6Hnw6cHnp5GUJlYErenIx8/fuC7d7/CZBlDx1TwRmyKSmuawRIWCTyKSpK9qzECw4txiyWrzNMoWKuc0aWgVEYZI/pVMkllxibTtB1KRXqfUarBK4VzJ7QaCPM3LOuFeX5P07wWOpJyONOzP3jWbbTfND051830XSVybBWT+cfLlTUIWWnzf2KtnHA+F9YYMV2/Ic+FVRaLdK3S9vJ7x52IlouMo60XDeSmQ63bDkYUVRvtD4nFCEnYpHenPSGXl/yRlDMxBWqptI3fTqDCdP3AkjxOa049XOdRsu6NofFaxEk2Y60lV4X2im44sYTAeZooKRFCpt1a3VrhOo4sS8I3HdpqQS2tiW9+946Pn87M08S6Rrz1jJeJEGaWZeV4PJBS5PJ85TqOGKc4Hfd4wFcI2pA2bHdNmfHhkRwCaVwhJqES5FWum1JJIRBjfIH4ag0YR1WwxEBC8gC193DXU2xPVvc0do8ynjmuAvcxb+iGn+CcY9d33Ny8ousOHPYn1jXQNi23t/cYVVCqMAwDS5BB2hLLFhUvi7e2cRx3Pft9z2HXc+g6YhBDuZAJMo3zLFsrPcUsXVjeHMVaBEObVMNsEWBs8rPP4coCTNn6Ghn6bIu2ZdM0TkugazwxiXhYBkSGmLeYs5So6SI7l9DRe0fMAbAY5emceunTlZYorKocyll8d0vX7rDWsT8eiHEVjyuG62Xk7u6OD5+e+O233/P8dOYw7FjXiDENXd8SUmK3H9BWlmYpZqzWPDw+Ya3j6x9+iXUOSuXDxw/oWGnahiUVlnEWiG1eSatEaKzTVcbUWWwJzlmct2ir6XsJBNJKkVfxvozzAspQs3rJlqnHV0KQNjf0p3/NEhUhVWoNTPOMMicOh59hdM9p9xXHw1d4d2Q/HHl4eibEgHY96ypmt3FJfHyaiEl+Nkpl1zZQYdc2OCvems6JEMx7x+A9u8bLqbcmLtdZlPibOF1mVmx/ptFqQ1CK5V8GRBpkPL5tAdP2tnxmmLeNpXEyUY0pSXpA+v1SS0CJcmSl8JGQK9rcEmpHqRqtWzJ7lHvFh/GeX31MzKlhCkJZjnHCusiuH0ip8Px0ZlnFE3M47Dkcjnz/3Ucen65437DbHblMKzFklnml5Mhhv2McJ3Gsl8put6PpBArXuIb9rqWmxKu7Pcs0sWtarhsjJeVI03VobRmGHc5Y+v0gLWtVrEvmfL5ux7LfjveN+ryurPOC1QqDDB+996whMdy/phQNJXG+PtJ2r9FK8fD4K0ouWN1wc/NDDqev+Pb9d1yuE9oaht0J7XZ8/+kTyxo5HA4sQXZCxjZQNF3j5BSNiZgzD5crMcmI3VojS7kit0NGMcVE2MRhasuQESuK+r15SimJRa21EMNKM+xE07HJz3IubCYzQTbUgnOarpHUp618ZV4FrZRKJuVC4zVrFBe58l9wOhjGp18SowDf5txyjTd8WnaoOmGqxk4PnPaWUDuWMNJ0QvZ5fLqib/egxHqQcuX29kRMK8si1bb//EZbLfuPTRl2d3eLM5rHcmFeA23Tsc4fuDsdWOaZvmsYx4+s08SdtVCqtHkqS4eCwqpKTAHrNGEZaZqekhW1rqxLoOaNsaG1CLC1petaGmvAipsvoVhCQlWNSpW+70lZUUpLYzPOdFg38fbVz3n3/tttXL9jngNTvrDrdmjj6fsTjfc0zpMz3PaWEDNP48TQ7bnZdzycF5x1sg7JmTkExjVsN4RiXiPvn0Y+PU8bl1+WdGz1pkUQ6LYRBbxOMW4WB/0y+xA254ajVXUzUclV44198ZpOS8A7x65v6TYhjaLitrZwXCJVd4yXJ9YwcU0D5/SKMd2wlnuS6sA07Nornck8jq95fzkSyoAfBrpjx27YM44Tu6Hn/v6WYdcyTiM1F47Hw/a0Wy7XJ/a7lmHwzNMMtTJeL6zLgveW42nH+XLlB199IWkV1nE5n/nw/j1pnijTyqlpaVqP7hpUK/4W4yyukexgbwS8nze5Yc5Zsmm0JuVIRdMPA26LTclFkAtziCzK8errv8Y3b1gW0OaG2+MPMUWxswmnHnj3/a8otePheeRyfaIfBvzmGzr2ntvjXlKmpokYpJ4Aae/nNXEeV5SGeQmA5v2nZ0pVnMcFraFrDK13dI3bYrpkah43NZlCyUxMqU2wXdDrLEst10ggjmPLtt9Uz7UWJGtGilnBERisMVhrNqSzRqlCYw2N99RaaLzDGU1NM9d5phv+EO2+JnNkf/gz2nZgOP0I035J1xSc11TliNkTk+V5OnP/gxva1rMbTqzLyu++e8eHjx9FlKQ1z89nns4jSlcOhx0xJYa+ofENpVYeH88M+55S4OnpzPU6EVNgXhY+PT5hrOb121v2+z2FxDVc+VifeS5XTOvQjQT8qE2NlkqiakUueVvCaZS12Kbh9tU91npqEjO09V6CDFMS3ujdW0x/IpaBaZ5J6wOn3X4zSa1QA8+Xb7hOV4q5JdWEMQpvK8/nj2glYujWO7xztK0jxs/BB4rrnPj+4UJIhSkEPjxdhFaI1J7GWEnP0nLuG7N5ef6r+kO8UelFL1JrQacYsK6ROBBtUEYUt1WJoLVuyQgiQTOsMYluoFRuDvvfK820pXUSZExFdKdZNKfD/itc0zFNT+wOP+N4fIVyd1yngnInPq1fMOUG74U3ugaNtp721NEeG2ISb+luL+iGcQmEmJmmha7zrOtCrYrvPj6ijeH2Zi9e3FIYp4VlDXRtSwyR0/HAOF23NQH8+tffYG3l3/6vf8rf/p//gX/3f/wdf/h3f0jZMBC1ZOqa8a7Bty1N22CdtNelFrwxcp0UULHSaAslE6bNhZ9kLuRPt5tk0+Ibzxq+FxqQu2EOipR2fP3Df01Isof5+us/pWSF3yJEvnv/jfh0SkHVijH/fy59KonLsvL+4ZnnccIZJXS3VLHGEFPkPK88TivP0yKTcCWNR+M8xiic1cQYXp6FLeTQv0Sal5xeUhBliadeZIfzIljfpnHblFVtXo1Nf0pliQs5JeZFctm6pqfvjhQM07Jyc/eHTMnyOEZ2uxvapkEbD/YL1nLAdT/Ce5E1LqmwlMTXf/QD9ocerSwfPj7y6u5OuO9Vczqd2HcNx92eUiretVznhWHfUFWm73t2+56mkSIRbeh3A223o+1kV/Htd+/5n/7dj/hX/+Zr+tvMVN6xdiuXUkm6SvyZMSitSWt6WfANQ4e3jrxKW5/iitGQUpQppGWzTCbBO9zeoTdjknedZMjMC4fjn7O//SuGw9ekOnD3+icY1wiGVBtSMTT9Hdo2jPNCCJGu9aQsv4P7047TvsNbTe89fdvRGM9x17NrHd5pvLXEVMFYvvnwzLpNnY0Wtqv6rC+sQtv+LEFVWmObrhdZWskvWsRS60sSVNmU7Z8fmnGpDO3nFGtN4z3WGqbLiPeWrnWEVF+0mRo4DB0xGpYs0oKQwKlM38oXZft7zk8joe5Y1gmlRDOyhMy+cexvZQ8S00rXe4w98P77Bw7HPW1juTnumeeVh8cHagmstydykQnrw8czXef57v17nLc8PD7w+vWRxrX88le/YY7vmdzP+U+/eiSblYdLR/jtmR/vb8iPZ2pN5FoI1wm8pW17zk/PKA3LvFJLxuUEWSSVSinKJsLKyN8bIA0dulRSsVgcd7s/4P72Ncs6odVrqm549xz4/nkmRzgepElQruJdg3P3UBV9K/XNvISXOBRHoWsbkRuqSsiJVDJabyFBNdE2jjEkGquJpRKj7HiM2R6ez7u3FHBNL3WIa0RRJhBgLWSZKu0tWdTQZQvSbJ1C6006p60wxQqklEhGS4xqLcQkQ5jL9cr93S3jMqIy6O2uvDvuBOAC234l83CZGLofEWIh4USv6hpMKZyv3/Lqi9eka+Y6Tjw8nHFWM+y6LTBIMU4zX335mq9/8JbvP3xkDgFvpbBMUTgjQ+M57CwpZbRqGMeRrh/4wU//JbUxPERPWDoelgFjJ6q6EGOk81ZS3I2GAiGsOC/iZWOMCIOzWAmafcs4jqAdISfipoVxriEfTlhnOOxuuenvUOmCtw5FzxIWlBv4h999h1aau+MepTRGwXWOdM7JSwl8eLxQ0SjjGOfwwkIdl8jjdaQUtuLVcLmO3B+PWGPYdRo9Kazd83xd0Aq8hjVmls2jL6WI3phlCAL981Luc9KhHDuQ6xbhpSCUxHEviqRCIcaEMVo2t8aQPusba2UJUSLTrWVZF4lTL5XXdzdYo7hcJ3JJpJy4Oe5oO0socFkr1zVimh9R9QGtGqHgxDN0DtsamqblMiV2++PmP5EJ6+P5Qs6Jd9+9J+fMzenAGiLOWm5u9pxOPU3ruY4T77//SAhBhELe8eb+p0IiMBdKndntbjjedVSdpN1M8ib71oPRLHHler1u2lSF9YLc9l46t5Bkmqx0QeuK1pBQ3Ly5x1tNZw1vTid2/V6K2AwRxf/9i18zrSveWWJKnMeJnEXt9TjOjGtkXiNrzC81oDGG5/OVx/PMeV5R2nLa7eicZ5pnhs4zh4VUAksoLKsAe7zReC2iZafZBqLSBlsryrjPnhkLMvWslY0NJlJ4tem7jYZxXnk2F7q2hSiFa0wSmuesFdbE84Wu8zgj3lnvHbVUGmu4PR14/+mRWhStF7wiRf67n54e8a6RoY1uMLVyOn2N1ntinJnziUsMHN7seXqcWdaZd99/QG9BygCn04FXr06M40TOmffvP9G1HSi4nEf6vuHh+sz1suKbVvS3RlT789Xj+oBrDdpG2sZw03j8wZHfe8q8bjMYKc5zzRi3LcNUoYaIs4pYG0JYUUaYIqlKeFHNlfDFHU3XcE2ZPI8YfeR0esXHpwtVW/7puwu/+fAoulMtcaRzqsS4gFI8nC9cxll2O6Ww61vY3AZKDZRama/xpagu28u9BulQrHHMQa68XBXOWtpGfEoxF4wCrxRRbcED+TPHvcgVUze4GVUWdWKRlLxcMByHlmWNGOe32K5EjNIz0/ZbvpvekqAXWu9xiFVzrplcZlLO2w8kDIwYCsPgOAyizv7u8Zm1aKqG8xxR+kqJM63f4b3A2E53A9N0IcbA6WbHeDlz3O+4XCY+fHwkpkTftdzenLhOM+O88uHhgX9x/CGn4x5nW1KOxFiIWU65ru14/KQ4velo+59ibUO9XtBKEZPgLSXoxmCVpiS2SLPIsgTspjed14BC4Y0m1kIsFW0tSisOf/6vMM7jcsAYxWVcqSYyZcVvv3/gH99d2Q87Ma1p+Ob9Jxqj+cGbe6ZFJtxTSFhTWWPiPM54J1k+bWMkUUIr2s23o5XCNQ325cEWcF3KW+JWTuSaOV8X5iVitGA46gbu+5y7k+KK/ex8E6tgpiqoZMCRc+GyJvqqOO53FNQWsSn/w9YK/6vWStu2NM7QN/IB5mXl0PdM80zXt9wcdtRciSmKCKlrKDmy3+0kDDk9EVKk8xqjJTTRmYa2HfBehnN2Z2g76UiEc95zuV5pmobny0Lfy1JquG8lsDgVXOOw3vJmf8/1uvCf/+Ef+Iv/4b/lP//jP1Mz7HYDn77tefPqLzgcviamyJzeEsYPojJzDuM08zRTa8EZh1Iyi8hEalRUpH4zSqOdJq9BBo9WEA7Nm3usVgzeMOOp2vA8LvzDuyd+9+lZJJ9JZIrnxzNOWbq2kSK1Kk5DT4qB/dBJivaaUErqvVIzIYlnupTfExFJWThkTgsfLQQaC2vW1GJ5nq6kFGm9Zl3Z/j1eILq1iC7E/Dd/9DVQWKcZ2zSor/4l3llxt1dFxgjPTyl2XcOaRNIfUqRkGYjlJLK8nIXaY7Tgqvf9sHlMshida0Up+5JJv9/1klFS4ePziEbozlqJAdsg+s9UCpd55c2rW+J1JSyFeZ2wur5AYGVoJ8FAHz58wlnPhw+PvHn9in/8xa9oG48xEo70dH7kep0EDmwNMa7sb07c3X3BsoyQngn/8GvSpxHnPCpnrNMs81YXlLpRD5wIpIzDe7FWiBdaGGc4ixp6Xv3bvwHnuEwTxnmUhqc5882nM1UpYspUpUilMriGP3h7zxoyl0kwmc4o3tyfUGT61qG1wjvLGiNaibtgnoPIQak0RtE1DcaIAcwqRddJqse+64gxUZLk/uYUsVtAQc6Z8Ov/JNvcJLkxNqdIRrawJSXY9CAoJcF+yCzgeZIUa+8aSY1qNMuysKaMs47r5YL3Daf9IAuo5wuPl2dqlgIubSnUOQb6rqExhufLgtHwdFlIOXPcd9gtO+46jQxdT4grOVaWlDCN4fj6QE3w7fcrMReOQ8c6r7TOMoeV1jQS+b4lSkzzzPG45//95W/44s1rrLM8n5/R2rCuQQhHURGCYppWnNH43R1pf8uaPxFzpISCtrKRpcisQ2kFxv4eyqcUBTFx5VJQzpIVpMOepMCkTCpgqyIXuC6B1jmpH1Il10IOmXZoiWnB6kq/6zkMLZbKZRwJITGtMnhbQ9hiWwpD13F3c5D3riZ671nCyr7vpSOtIu5aYkaruPlgxL+kzWczvEg5askoY9G6EpYZW7LoC3zbvfgyc/3MjaloU2mdYdd1XOeFvbI03uCcQhWPLlC3xd24zDyPM8deevXXNzd44LvHM0/PE+u6bjsBS9807HY7xmkhbabhvuvJMRAzKGOZlhWUCHNK0Xz76YnbY8eXxqF05Te/+ZbYFPrdbsMoWFJIxCXgrGZeZnH0FVFxr2sg2888FM398cD1fOV8UdTS4azBase4VpLkdQuXzIqzDqXRVsKCQhB+qbYOYxUxROZZYHDaWkJJjOPK6//w77HeUlUhpkTbicJsmlf2racouCwrOSa0UjydR3785o7bvSKkSAgru8MOVxyP8SISZaX48Q/e8PB0ERpSKaS84owRJHdML6FFIUbBZiIhjSFHmYaXQggRXSU71xq9ReZuvFfhjwthSCjCLTnJEaW0ItWCq0WSDbRCaegbwSqWUqRTccKSUErR9zvKNKK1oWka1hj47TfveHVz4On5ibu7e1LumKaZlBYuU5ahTpQHq3Ge6+UsHzzJMb1rWwqRHMW0lUohmYIfLDfHnun2huenBzRwuSr2u45QEre3J67jlePNQMmVftjjzpaPD5+wBl6/vhe32VbbnG5eY00jUr1tNG19h2o88zRhtaMxQkD4fL93W73DCz5LYkgzEEIkqsyndeL17S3OWdAO7xP7oeP7xyv7riXVyrunM1rBV69ueHPc8Xyd+fjpga5pUUZhtWaaZ7kejVy5yxp49/0HKoqQpChNRaJWrNWgM07D43mksZqHObAmGZI5Z9FaHpKQM1ZBiHEDJcvUXNdCTgHj3OdBmZENZBRdg64Kg6a10vvHmFC9RmvwG5crZrCq4rz8c6h0bctlWlkWgeH5xnKdI7enGwkr1Ia7wx7vbjlfL6AV5/W6Ya8yy5qoKOFlbLsBrSzFyLrcODlVvnj7GrVGvsj3NE6zG3reffc9/dCyrCvOOoZhhy+JdY3EsMI2xPNNRwyFvm/Z7waatuHDh0c+fv+eH/zwhhAil/MjMWnyumKNETfdhsJQiKQhXzPd0G3fRaRqRf08QNzy965tw93bt7im5boE+r7d5i9WZioh0Tcebx2tqZx2DVZXnD8yLgvLstD2A8eh5zrOWC0v67xUmZwGWehpJBZlWgOxZEpSZKOwtmCr2nDhEaUyVasXEqMKcYua88SchDRU65ZwkQGNZcugN9aJCmRb+2rAWrmnxlUUUs44rDG0jUMX0V/GmOm7jhgCWMkg8Vaycx/PzzRNy77vCcmxbmiIWuT0WdYVbwxTiKw54o3CKEvbWKZlQeseo5BNaq4sIeGd5bwsHN4eCEvipt6QQsBaw+PTM7eng1gmk9zbTjus1psj0L7oNCtK3qIwczh2vP3yjjXJINC1N5wLuKpEMliEQN1ZDwVMYwW7GVdKrhirSTVv4t9CVHBeF05//eekqnl4POO7TorRGnBaUyobxLcyNJYYIx8ezwxdh1KacQ44Y1Cl8PR8pvUN3untF3qk8R41LbS14rTm6Tpj9YbDyhmFIVfPvMp+zWlond/oQhmvFX7nqakQskKrKoHRld+nlpciSYLONTJQcf7zolf+qtA3DamKqFURWLOCNVMwHPuONUR0FRXadZ23aepK3+43S0Al5sgcFnKqNFZRVMU6y2ANxjq8l3jOUiJt22O0YZwC8xpIOeBMgyGTi/DNns4Xbr98jdk13LiWX/zil3St4fuPD6giUoXdvmNdE37n6bueXvdM80LbNjw8Xrgzmvr0zPGw4/vvPvH4dOVnf/UTlK4YWuyreyqKUg1ZwVISNVasVtJS+s+cDSSLTwkvLeTInBO/fvrIfTtQimQir2HjtVeY1nUTXYkOV2mNcY7rPDOtQqBOJdM2Hd5vYY9FfC8pFUqBZY3EGHAGDrsjUDabbCSsQk3unED4qlK8Pu1YQuY8C9HaGvn9msbz8XJhClkkktuYXRtLqRlb6+9D94w15BfxUGWNhZgLO++3QtJQMKAtTglct2wmqq61LMXSWJH/r+tK33SyqEqZ1rdc40TnRTIARtjlSWwPvfdc54VSxX+jtWKN8rqvIUiIT0popTmPM9MaUI382Zu396zTxOPTlet04e3bN1ynEecs33z7O9p2YDfIG7w+Xzke9/RdCyXx4f0HrG/oh4bjvmOcM8Z07L/+EY9W4wqknLBf3DM9PsG0YDfjulaaxjpKgVQqpaxc08pvz8/4P/tTvvzjnzGtK6ZpmdeI0xrrNbeHHeM80znL4B2XccZh6duWxjvmWRCVH58ujFdN17XEFAFDDDJsQ1X2XU/XyrVrrWGcJ2qB+33L7XFPSDKO+DxWUIpN1wshK1Cah/PEEgtpE4VJnk3CGEsqSQZlLwzmjapqzSYgoXJZFnpncI0XKVvImxqpUqqYfucYebgGGufwzpCrxnxOjlCakjM5iVbVaMvQe8IaSUmgac5aSqkvd2GplcNuYFoz85zRRhaHjRdqoTaG94/PHIcejKVcZqY18ur1HdfLyNOTmKV2+56UT2htub+/YbfvCCGzG7oNNQWnvWJZnxijTCG990zLQn//msubV+y/eUc28PP//d+jQuT9P/2Scrny/Hjh47vvMCFArqQoHcJ34yM3f/kXfPU3f8fx7ZcsqWB04TR0DK2j1MKSCuMqZvCboePVccAYRS6FaZlZY9yoQJv5HUF9aSpd21NKEvVc63l8PtNtvFeq4rjv2HeeOQQZbNZCYy1r2pKtrGWdA6HCeF3IORHS5nvaNuAgZUfJE1Zru6150wsWUag8kErGVEks0rluy6e6wVbFJ1M3HLXgHaQoDSmJs78WDruevAouQSuBwtQqffbQtbCslFJx3qKqzBiMUngr42vrHCktW3ChAy1KqI/PF7q+R2lo9i3pY8GqyhdfvOHx8cw4SltdUTjvaFpPWCZaC0+PHxl6xX//V3/AzbHln3/zjt9MlofLFWuF+LeUwo//t/+Fb//jfyR9+ITpd6j7hi+/eAsl8YNSiNPCNF755pe/JiyB4XDkT+9vSTc/hG5PLIXTocd7txEiMynDw/NIqfUcwAAAIABJREFUTUk8PEXayaZxjNO8De8infU03tF6xxozVYk3aE2Bfd9QSuH9wxOH3UDjPGsIWxi2ZY0yXUVB6zRLzlxG4btdp0W4+0HmIjlJ3VS280HgN7I6SSFi/urnP5Eg3lmMQuqLP8Fah9uCf71zKC2iE1F3lM07I2r4XMsWq5lZooQPWSNWimVeUNZQkU0vFQ47cfGvSVK+2aBvu84TYhK/6NY+r2GW7WgMKAVN08lboDVoRUwy6NJGc/10xVCZplVOsqZhWRdijgzDADXTNYZPH9/x53/yBf/j3/4JzgTGaeHjZebuq69pGmGwe+9Yl5V+f6Tc3/Dx+QPvP33ih3/4U9CGrAzVWFTb0OyP3P/wh7z6+mvMzS2/eI68+cGPOOwGjDF0TcO6fS8Kcegdhoah7Uibxygn4aBqbVjWwNA5hq6lMfpFqJ02L63ZuGJLWNDKMPQtKSXabgtstprGOdKGMF3XQKrwNE6kIpvhNYjyPcQkuQw5i+A8RMo3f//CiI3rivnLP/6xaDOen3CuJb/9Gc57rDNY6zdJu6ZvxUqotNkowhpvJRdekIqZ67xirJa5v7NYrckoWV0XcI1nXlYRBmvJZ62CJSUXSVAQo5ZYQPu2o3FmkzWCNk6SIbQsqFJODF2HNpoUA/N5pOtkq/p8HWlazx/86EseH5/Zd5U/+snA3/6bn/HF2z3TeGYcA1MsPCbP/nTCWMc4r5uiH0IMHO5fcfzJH3N8+xW//vZ7dNtirXvJvElF8TwHfvu88N2iORxvOO13KLQEP+a8wePkoa+lEnLhsgTO15kQ4zZLgpg2M1njqKnQNBIhFlN5ERtrIxaGppHfjTcaay3zvFJqQVOZQxafUk4U4NsPj1zmyJKl1vjM4Q8hvlwpMQZSjNTf/b3wQbaRh/0sUA3LzO5Gy9h9k5blklE4VK2sQWRquUoF3Taa1mq6pqWkRNEyhKlFTFZ926BqJeVKLgpnDOM4MXQta5TTQ1tD3lxhWWla3xBywhk4bwVr37TcHPacrxLjrlCs6ypAXgUfHh8Y2ha/8xzcHb/55bccdjeUMdO1O+KaKGnlb/67P8LozOV6JeXMOE3YpuNKw+5mIOfCh6dHnFHY7aE97AaWMPMcM1+9eos9veLjvPDNZcGbAlU8yEusfPnmK45Ws+886xIxjaJtGpSGcUlMa6SiiDHANkl13pI3GWMMYqX0zpHidiqjUdrSNvWF5iySzkDTSDbgGiLWCn1pCYHmdCCsgb51xBS5zpGCJJnbbWdl3OdGQItctIgeShtJGFebeV9bI6N2YzfLIFX4VkCtentDMo3brgkg5rxBaTNLVC8Zu1RRMi0hwbbaTynind2kbYrGS3EoZJtCNYoQFtqmp/GbFGBJ7JqOuxtLjpk1JdqmEcFLylTEspCSzFRiLMwq4IHjcaA7NrRNQ3MehY5MQ8qGv/+H31Fr4OPDwn7vuFye+Mmf/jnN/sA8zjxdRlCKu8MNKUX+6be/5uc//QPe3NzyPC68+/jEcb+ja3t2/UDfeknwNIo1JLSqYrqKkaqN+GVDIsXCp8sssJYKQ9cQU5HpKpW+b2VAVRTTOqOQdjmmwON1xChN3U6KnETW6H0jzPwYKbUyLVLUKqV4PF9prKHzHd5t+K8q5OfrPDMviaEVSlTvDdd53Ta4dsvN1XyGK2tjMX/24y9wjScsV5p+R/ny53jnaRtP1ULUscbhrHlBOH9GN+eUmIJQ9ayWHzDlRN1ELUop+kaGcKDoW4fa2mUAowzGWppGDrIlRCENokhbN2OtYY2bf6NK2lXO8oDpKuFBwmNt0Np9Tosm50QMiXEayQXevZ94/xB4ugamZDm9/RK337OExHVaqUpx2HU4Z/j0/MyHxyfeP51p2obb4wFjZMu87zxKy4koUadiELNWhEIhZR4vIw9TYAqJ7z48MYaIQZT+96c9RsGytZs115cGsvWyoogxyiAxSGcYQiGsKyVnFDIaF5uppubMfrcjxUDnPYetW7IaYk7cHnqGztM3Tvy4QZyQcWt/pyWKPiRl0YD89v/Z9EFiIrOfwarGiJmmZFntf8ZQqaoouWzBh3LvVurLhzOf5/slo1F46yhZriS3JTOsQZTepVqssTJI8z2gOV+eGafK7c2JOUZqVTxdJ7xRuMZx6FuGrsNbWfvn1jNOQQxdWm8RHJFcK4GK2g0YFPf7nufHZ3KI+JgpBo43Bxrv2O0HdruWJa3klLmsEWrmZr+xQa3j1e0tt8cD379/4NuaeH13T+s90xZiNM4LXeNpvUBexnEihUjOhVQUbS+zi6bx1GWlb7wYlkqmdYbTrufpInICZxUxi75314uWJYZE5xxt47E6oUxD46SAv14Fr+ksqG1Msb87iF7FGpxWOOuwQaSDIURu9x3TvPLmNHBdJL1qXgPGGsxm1chRC3rqv4pxta7tJCet7V5qj5LlQlFovBGxstEaZzUhV5x1MoBBUiLWNeAbGcPnqshV0ALGVM5TIGwx5eO80jSy8Ho4P9M27dZzez49XphjousaliiT2utl5Hmc0VXRdS0FkdnZnWFdF5TaVuvacJ0W1M7ION1ZtDe8PX5J6xRrymirNxGyTHevy8o4j6Qq1+Zx6Mlo1iBV2NB3KAV3tzc8XkfO88plWnjQWgZ7jWUOWY5kMuO4cGw9yyb7i0HqgMFb9t39Rg1yPI/jpikVHv48zyRv6TpPa61MSTcURd+0GxZM9KHn67TJLAulJKz2G6ID1riFGMUsMoNNQFSKLE5SjNucSlTvpXiqEsmAVkqueyUwZW3sRmnU2LbfMZ0f8E0v1TRlayELjRZ1mTHiMEOJospbRamaphVw/2fzlFaaEBPeGmGFhABakzcBbFwWnB2EK+4b1ijaBK8LzjuWlLmMkyzoqkRzxFxkahvSy33qrKXWhr7bcn5jJgLnccK5xLHfYTvH87QwZ2kVVZLs2hAyfetZc0J5RxhXdn2P0prffXrEbcCcN3c3rMtKXBdUlWNdG4dBbdm6wp+/zAlNwetK2zXs/IFTrXw6zygFrfdclpV1WdBGcZ4jxhi80ew6T9N4nBXosOTxeVyQ1btCXshSCjGKJMIajXcaquxlzuNMLtA2TsIRNjmAiZk1iAjoZi/CLOs005q2kCglDUQsGCX0aKk/Ms4PLPOIajW2aXvOn97hN7q/s2obmCCq9a2lxIjYdVzjZtMz2weXt7JsmfaN9y/eTrdxJmIqtE7TNFKLeN8ILsFC6+SXrJWiayxH2/E0jlynFWM03ov0LscouE3vaJ2VBdmGjTbG0bZ7lnXhvCzEywUzKZy2+CymMGtluJcpJJWIKTOtM7313B52hJgk/KgkQpQAxF3b4FxFacMSI4+XCWrhbevFKP08ch5X4rLwo7dHlpQYrwu2bfnm/YPgJBbZwv7kqzfEnOga2X7fHncsy0LjNsxGETJySJk1Z/kZNcQ10jYN0/kq0SaNo3Xmxex02vfiPtCa8yQPU7eBgysQo5Chvv10EZKUsaRYWHPZSgtFLbIu+ZzaqbQRZXstWK01KQoFULQAv+eBoJRks23wdylk5D4Mq/C8lTKULTPKGMOaI1YbpnUllcyuadj1RTJ3t7dvCZJy3bUtOa0S+LN5XhvvsHNl37UCdi2ZvCVhpyREH0pljommlaJUfU6jUXKfplqIobCQaVzesuRkqdY4Q12lEHx12vHV7UmYXkrmKqFA3WIS6raZ7rqWLll2rSeFVVRzVNrGoseZvmlZtnSH87wSLjPeifP+uN/TNg0fHs+0jadrPd4ZPj6dyVUx+MJcxO4alpU1ZFIVr8tnaOD5OqJK5dXtkZyy0JOrtKVLENDLkhS+aXm6jOggV5CEMEjIctFOou5T4OMUuE4ywfZWxvi5iFj9c+FdsgitbE4SgrORHGTVK4NX8XzWSk2V4uV/Zp3bylf5AruuJcaVoWvFTTavqFpRRhZpqxLioO8bGcwARhuOhwFyodvteTpPeO+pRXYLKMNp3/P++SyY7lLBWkqt7Nqekuo2Cs6bp0PELkPrsU5znQJLkWjzaVnRWtMaJ0isWl9CpI+7geu8kEqVMKKNj2KtETYsFeeNRKxby7wUWtfx4fHM25ujJCwMHdPzM96dmGPB+RbXKsK6MlgHQGM1t/c3fHo+k1KQE1ML0DcVw5oy0xKJ2wvVesu8rJJoFSKNb1ANrKtQFj9dZoxWXOcFpTX3xz1PTyOVKnkx1wXvLM/jRAyBu9OJaV0pFC7TyrhE2SDLkkUY+elz/Hsmx/D7TvOv/+SnrMuIa8Splt/8jL7vcM5hrRXgi5E21lgJFMoFdl1DiomwpUPXnEVorBR3x4FSxTsqHGBeOqG28eTtTm+ssEKv87qlIxWex4mh78ULvDFJqaJgM1rTOkvbyGfTSpFSFlzk9owf+5YQCgW9RRtIcicbGrNuRWlVinlJfHiaNjN4lGvRGoa2wRlEj4EQl2tKNE0jcwM013kRwvMaMFQ+PV/QW1xqXFd2Qy8Lr5IZWuncQqrcHoZNkZc4dN22PZXP8xn3tcZE33mMVtzudxLGpBV+A+WlDS2xpi0ethSWsIF+t593ColPl5mQKktMhFSItTAviVykE1XbKVlLlbFCLky/+L+2ba4MzGwMC9aJ4lkIQ2K1VErhjdkg9Ooly67UJMd9lLc3lAylshZNuI7UUnh1HBjnWToOo1hW4YtL/Kk487Sq2P3AEiOpQA4FbRRN41G10liRDqSSwTuWtDnY51W0ocbQOpEMohTzsuC947rEF91mquL8q+X33hDzOXaswhSioDxLxTRW3Hito3WaoW3Y96046bVmaBxP44yzjrZxG3bTst8bHj5EfNuz2/UM2z5nXiMhV/quEWzXlkb56TJxu+9pXMMaZlI1VBQ3+4ElyHhbGcsyTxvySx78EDJLTVueHMRUUcrwOM2oSUKdS0h4JzutKQSMNqCFJtRY9/JAGSMFe61ymudcEP6eYKfWeaTpBnIM2JRkHp+TxKJ+7qu10i/BhEpVrHNYo+mNlZ69VPZtQ1hkY6qV5LqGlMilcrPfMy0BY6BthD5UaiYmgciXDL97/0EQTluOmlQyCmO0XIdK01vxoBotp1UqkM4XmkYCglOqHIaeQ9+RamVZJYP3dt8xr5ZxWWm7RnL0tNk6hpVl/bxSr9SSmNeEVhZnLE/nEWcGwqopKKZleZlPdI17QYC+fz7TNJZCYdgNKGANkSkkzteJtmkZc8Iaw7wEhq4jZfju4YxRhk8Pj5xuThJ1tp7xTiQH83rGe09KmXdLkG9GGaZp3ATGRkC/FEKSSao24mnSS6DfZjNV1ZcY+Vw3U36VBandgg5qzRQKa4lsO13iukopYT1WoTYyEJQy0xgrX6T+TBySs1tklhq1xXFVrYRKs7HLGy/TuZAL4zrjt9iv6f9r6mxibFvTuv57v9dae1fVqXP6dtNABxpRmoY0QhsNJiYGUVQS0WiMARKjjh05dOrMmSMTBpgYozEGYpyQmKgEY8QQEEEaRKWF0Lf73ns+qvbea63328Hz7n36TO5N5aTq1Nrr/Xie5////dedECbhljU1SuGI6iMYwBnm6YBRnVzEGN66XKyMFm/wYfLMzXOcphEPP5hpWlPIMptBLmzGGGnb98bjwfHiKHTFa8qBtpptNXz2haFW5K6UM8c5oLVh2zeM0TydZXv2zkh7vHa23NBdtl/nhNWatwtVDS/QOBJrEz1FGSvSez9K7CT9BTp7zhyOB7QGheIwzeKNKZU7L1y0mDKn5zO1VZZpYZ6WW6KEprOEQPSNVPSwripSbZTaZYDZB0ysy/BTQqIEGaaGpCINfY/Vopy7okNrThjrsdcSQGlNThE3sAFaybi4a+neyQOWdjNdDMQxCfC/1c40eepWcVZTcmOPhclbXj7esw0Z3TwJH3wKTiD5WnEXAq03rNFsqtBqZQqe5xJxzjI5OzSsk9CBkmbPMtfwTnO/BDSKxTsueyLXxhIC1o7LpXdsWwQD3jku24btjRd3D4RgqKWxJ0nQzrny8sUdOScuaxezc3PsseC9EAumaeJgJKDn3evX6JZ48fjIIQiy4vmyi36jNZqSD+jpfKbVzmGaBPxiFPOsmZ0mt8YeRY2ecsFqqEVo1krJ2L91ceFTK0Z1Hh8fmL1j33deHie2XAZVTjJfOkjMmFJ0pcfvJgLlydphv2x8E3SM3vogDYn952bmblXkRGqkQIGcRa13ShsTPqWJJUvmSZF2uNKK2hSBwUJdd+GfBwnViVWMweueub87sG6ROQRyk3zbnJNcWJskUJmR0yqDIs1xDigl7XtlDTnvzFMQluolorVinoSuWHPh1YsjL1pj26XqcdZw2Ta2bcMawxwc1hq5XHvHm6cnQggsYaJ2xb5LW3qaAi/vj/R+5rJl9phwzlH2yBSCVE29czd7juaBu8NMGQ8z5sKrhyPq+YyaJow1vH0+c5hnJh+ElDCO05gKKBlvKCV3lJISjw93tN65bJE1phtuq9XEEjyHeSbGyOV8ppTCshyGblicBa2IfMA5yx4LzhsJdqoKoyqvjkdKq1xKoo4MOwk2NOQsWlQXJpyfUdpgfvB7voNWM8aK1kB/2/fjQqB0hfcObwRuX1u/he3GIoASpRUx5hsuUym5PyilpUM4snNzLgPB2EkpjzNVbu2tXuvuIsM7I9Q9hVQ8rTapgIDLvhP3zLrtYj1oshK80WxxZx4fAhqsVQTvOCwT8+Swxg543QgLarLaYsrsSQzRKSWMlkrHOVHAz2EieHuTYGol6vpSK85Y1iIVwpYkZeG6i715OrHGwpYST+cLW0x8/PbEFguXLVJLJ9aMGamU275zOErFsqXMukt/43iYxX3v3Oh+FvYc0drxwatHjNFc9iIB1kZjlZTkf/h7/5ftk6/xmc9+llgyz2/e8m9+5p9wef0RH3z222hXj0+/Wkklbi3/v1+l0wnzUeJOfugL3yFhhlpkZuFzXwJ9TUlwaCs4IrSiMThmkjEtJGWaWDJ9GAGGDEKAlFISKiQ70xwCtYq6yll76/Zpawne0WtHK8nonYMb7vQmtABrURimYJkny/P5jHN+rEB5KXOpPK8X9j3zfD7RUbx9OrHtYhjvcKsUnNYsk0xPaxcURfByES+5isuyyuo+zIGYJBFj8oG3z2e2PZIrvDmtlFzpyvD6eWXPdajh5V5wRZvTOsHLc3UjflUrkV2W2piniTXuIrrSMjANYQJgWSZBa18htyiCMaBEZKW0JjiDMnJV+N//8zf46q//Eqd3H6P8xPHxFb/4736ev/m3f4q0Jn7pP/4C3/WFL9GGRjCXTM6ZWjPpq78qs7kg+TRWupvmBpApA+yuEDlhrp2uZQ7Te8UYiYxQRervYC1PpzPOSn+jlpEYoaWxpTAwzr7eOss8U6qgupWC0znydD7zcJx5ebfIS6ACa8w4A0uQ3kQpFdUz3gSet5XZWYKDNqLcS6n0mmmjtNXWctkivWuxYmQpdVGaScvF8927M8sSiE9nghcdhlay8ygQ5/yeSDGiBwjOoPj2z7xivVwkLVTBy4cj9EZMwmJL2XBYFvK2EaMYpu4mz3GeREl22bAUPni8x6jOum60qQqYb7BfQWFrpbZKLpYYC7k27g6ThF97i3eWqhreyZ3xo+fK23Pkq7/5y/zET/5dvvaNj/jd3/kKj9/2XZxef8hv/ebv8J9+7l/yvV/+MmhwCI6q875y7a1hnRcCNl5U7aLrtNQckS8zmOwVO0IghLwrA51t31AIsVhrzeF4T+ky4OvI5XHbVpy1BKuIJROskYwS54c6vY72fsE50b4+n8+iXndhSPML7JXznjkeJrSzBO95fLjnoVbSmAW9u6y8uLuXCXIHax01tVtylDEaPyLZ6TLcmx8nzhepph6OR9web6xzpbqo57ViWcRQ3lrj4W7hfIl8/aNPOC4TvRbm4Fj3jDGdx+PE/d3C81kiS7zz3C1Ie92akYKdeTgMVMYk+ozlMKGRjur9YYKuOe+CZtBaBpSHeeF5Xcm5ij2lVi6XwquHRdz6vXNwirhdyDnz1T/8hBxXchLdifcT/+Ff/wwPLx75kR//azyVwZ3rRYKNjCb3K3pKRgrOz5gvf/G7pDJRA6L6uT8+OooObSze+9FskoCaVip5pE6X1ganvdFrJZVKRW7PYgSWEiuVyhTsaDHrIeip1CquPIVi8ob7ZcENIG/KGbqA/p8uFy575LRuXLYNY9UQBDsZhSs9GKhVYi5s5zAv5JJpA0nhnOHpJMfOtkWeT2ehEI0ZVK3iz/HWUuugTDuD9+4mlDbmmmBt0Vpxd3fHmopQe4xmmf1AZEs3tJTMYfZi9zASmXoNRqhFvD+5SCpDLkWSs4N0UJ0xtCaplLU2Ykw4H6hdGn7WStbL82UTPsiYcz3lznndeff6G/z2r/03vvO7v5s3r98RTOZH/8ZPs66RNx+/5oPPfadcAkbsR4qJUgvx934FFyZyXJnmI1ZrUUaVoQPoA9nch46gD04WSpOTmI/bLv2RLRaskTQoeZBSg19qQgHOyL3Ae0cqhSl4zqtMO2tr0ukbjTE9kjD1KL6OyzxCmEV1VmrB6HHc1IyuIkXYo7jTjgcLWjF7UdjPXjO7Iw04b4mUCp96+RKrDOu6Mk2By/nE4TgTrOKDx5dchg5WG41F9C0xjvAkJZPq02VHAU+nE2jPx+/O9Nb5lpcPvHkWEfI5jvFlb0ze4pwToXUVPITWiik4nIKYFM/rxjxJeGJrDVRjmi0zIgP03vF8uhCjTFg7kGJksnKP2lLhtCWe90wsnc9/6U9Cy/zaL/57fvhH/gI//89/lp/6+/+AbA788I//dX7hX/0sh9//HJ/6zGdRvVNrHyml+iYWusoPrTYCEak5SpUyyi7nRgq1ljF5mAS+knJldhNaVazxpFzxI3jYGlEhrbHgzFgpA0ew7Zm7uXBYZmjDQW+ln7BtohOpm2gv9NhhGhWtw6gYDFuM9CYZ870rLrtUONTO7D29F7Yo6Ulvn8883h/w1lNO6+CKyu90f7dgTceoGW0s94eJ1ioxF7lsx8K+R4r3cg+pwiZ9/eEzRkMvhccXD5x2KUWPIdBaZS+NhiLmxME7Hu8PclyVTMmRaXIDCQXruvHqxYFpEn1psJbTGmnOcT5f0APC631g2xPGaO7uZoyWBayRz2KLO6nCh+edWOSzQmu+8iu/wue/8Ef42te/wfd9//fS3UIuEvHy+S/8oODHr020Ac0VxflIfBjaVKsQzQYjoFCNNwg1evatkVOi6eHJMAZjOl7LzVzTWbxjy51p9PVrFxOUNQoTHDmDtxMdOJ0vgkaaxM8BCDahtmEWd5K2aBDda2tD6t8JTnysl03cfpJno1icH3wLx3nN1BalmrhEVF+pdLaUqOdnUqp866sHnJVZ5rbtnM5nDoeDuOq2nd4UYRqBxC7wtJ3oHayzmN5xk3Qg350uEn4YPPseybXTVGUJsv0bI4rx1pvobrt0nJXW7ArenndyLbw4zHgnU+TLnvFeslyUNhJ23CRI0lrhxXsvFaC1hbvF8+YS6aeIpnN+fubXf/k/c/7wK/y5v/V3+LX/8l+lV9Wlg6u74nd/6zf40z/2lym9YRD8du3S++pDc8z4uu1IDWyco0QZvEnjRI+HLlL4WhtNKfYccUahpiCj8945rwJOMUaDaoQRBR6coza5BFktR4k3An8tpTBNnpzlLmKsxU0O1TW5RFKppJJZdymJ/TVdicyeK9Z2coMtJrYiGITW5Iw/R9EzSN6JwGO0krr/YRH7ZbCG++OMt5Z3pxXjLDFKk2majLjrreG0rQLS6VBqJ+4XvNEUHQghYJQR2vNB9KylN7QyHCfHZd8xRpT3PjicEdnltssRvO8ZbTVvTxvPl42745HDcRYD9roxefm9lzDjnGdPidoab56kgtIjTar3Tt5W/u2/+GcoNr74A1/iM3/qJ9HzK/7oF7+Pn/un/xjMkeXxFX/wf77Cj/zFH6UfHgVC2OqQHWqxcg6gchtaHNuqTAitC/RaKaM2rrWjahse1op3ch9QVUntXqL4RbWSraoWylCbq0FmBlGbb2nElffOed/xzqN6o+1Qmhiyt/OJt2eJgc9pxVkZSPWm6NsuE8xacS7Qa+PptA0ZpMyfBPjW8U4QVkrB63eJ4zLz4jhTqsJZsYfWLJ3ekiqpCG1nMop5mcitc1lXHg6BXBX3i+F+EanAhx99Qi+FhmNPO84aPv3qXqQJqmOUAO1yTmwxsm776L9ITwSNyCdLEnKjC8zBcl43Goo3T09opOV/XALz5FkvG4/3E5o2ZilIMdAkqnXPUuX97m/9d/7sX/oxXnz6W+lGTFq1wotv+Rx/7x/+I776lf/BcW588a/8BMUd2Pd0i7+9osa06jcgjmAw6zV5Wzqk1k/kIcFvYyh3/VN6RRVhqE/O0buM5i9rxFvRKqRayanc7IGnPWKTmHpyKVjdMMpISjZQ6zZK0YbRMrFkYJ+6AtOlq9pap6UicVq1M/kwAos0rUoH0ahh8DaGXCveTzKJ7td4jE4rhlYyk5eX9rLvBKsFep8y94cFrQ21G16fI7or9pw4Tg6jO4vX7E2xxcjd8Y7PfPCKd6czx8MCg7pkjSWXxjw5llkmwKctkUdq6DIFmnJsuYpYp1em4IQBPwtTrJaCsXJZf3G/cJi8WDdHKsNxmkYnW/Pm+cKeC3/sB/4EW4amRehkr4NWpVH+nu/58p8ZVWWnFdnlmhIBVcxycnTkOJeh4wDc9d4wxtF7RauhdVQIh9O8N0RZoyl9yBBHpltO4r7qaDEn184cJnISX0VtjbtlwfpGTInJGoIVcbLREniYSkV1mZ3cAHDWkVrnaA1KyXnuBjh2nvzAP/ZrMrRoYZ1iCWJmylUoQClllhB4vkhPQvys4wJcMq129i4UQecc5yTb6v0y4bLYKWJW3N8t7NuaEgKXAAAPyUlEQVSOsxpzPHDvPQp48/QsoqWYxswK9ngBNG9PzyzLIuWn0Wwpct52nrdEzIXJKr7lZeC0ZaYK94eARsTDOngsnVIbl5xJuWINOB+ERdIyWrvRp3KUXsnN0nW7JZW29p5A2Qbv9irpuC7K4DREhUGKEqss2jhy2tHGUXMU6+X1xlqLCJI1ImQVr2jHDv1AKXI/OW+71OreoREtZx3onl4hloRGurIxilfEalntp7QNgazYvVqDptptCGitSPRr62gaLw8LRjWs0qhe2dZtmI461lrKUNRcLpW8SANKjeZSpxFL4uFu4fmy4ZxMMsMUKFmoRh+/fUtrnSk4UfJ7T311T0qZFBOHZaFWCNZwfHxBTImKppRGzlGkEJOMAlLKLPOEs4Y3p8pHb55x1lFRbHEXBu3QmxqjeL5cpL9iDU9rlvI8jMwdJSx7O0iIXTm+9uHHHJeJz37qkY/fXQDFZRdz9+Q95JF3qxXWaFqpWCPa2N7eL27bG80M1IfWmHGt0F1K87xvTId70cYKB0K2q5ITjUZFxMmdkYuiFIkksNgmmGmlxZbpjEXrRiziEBdDtnhKnRkiFaVkXjIwSLnkoY2QM7V1JSN/ayi9chwXSac7zkm26zJiSHrTdK3FagEYq9FoatWk3FimwF4KMVcu+4bqgvMc6aFsqfDR84q3RoZezmAQRAJ0LtvG7389YbXmuAj58ZO3J14ePft+4dXLO94+C8ri7niQB240qTSUFvbXXirTNKPdxB9+8o5aC8oa7ADVzsEyOWnArSmzTB5vNU1lrA3DlqBRRrOnhDWO03qmKxkb/P7XP6F04eprYHFqjD0cKWYeJo/S8jld1oQ3hslp0BM5Vybj5YJax+fcpY3AoG3XIsNbpfU3o7jfWwB7l5xcMX43nHWo4QXRxkDMQ8muKL2ghgpaK0l71kq+Lv8VzmpvUhmF0G/hzcYYuViOGI2YBcu4r6tMVZXi6bwxOZm2OqN5cVwwqo+mjiLthVIK8ywZLpddwoVSypJfJ1oZFJ3n0wZKMXmHUZLIpZQMuq7yRaMNzknqVu+N87rhVacU6cb20XL/8N3Kb//B129SgqdLZPKa+8MR7zzrurHuQjvIWVi0rYFzBtW1cN3p3C+T6HONkkj1ASTOpXDZy/AVSSVXSuO0S6kcU+Zu8jwcAy+Bp23n3WXHz45l9GWCVtAMe6psMcpRF8XHQ++3JDGjNL1ndJf3wLowrCsOq0TSJAhMpVCdgcyugiHokFvDa0NXkgQRvB0Qtga6C4apy4RXIdPL4QWnqCrdzzGO7r0NIrOVnaiLQKbVMlIkpb2vxccgZWKp5NokHGdYJi7nCy8e7khNsJ29NS6XFe8NtVQR3nSZdqJkSz8uE0ZLh/cYPE9akQvMk0j9zjWylUwqkYfjEbpIGD7/7Z/Cym+Gs46vvT7x1W98TBmX6TwMS3vuXF6fxKju5FzXug93m6JrCE7Mac5agnO33cIo8f6U3rFovLccgoBuU8pi1moCfdmzNCJLKZwuTaqkUli8o7RRKRrw2rJ4i+qKtXfOW5RZi9QCErcm/4d3lhKjGPiHy1IpLdNcRpidGVO8XBtulDoKWOOGMwdabhTT8VbkhNoMGaFWt0umd/Km65EYAaJz7a0jh1bHjGqlj21dUNoakF3DO4tqomBTCtxksClK5FmqFCrTdVtumtm7IaHTCBhY5HS1dawWpkjrBWU0U/CUlNhTwlnFliKvTwkNxJpJCbxVHJtoLHqHX/1ff8B3fPol0+T4xts3PJ8j+3D0S+fZoFUT6JuVbmlvFlTBaEdYgjDNxi7MEA4rCS5GqyY5e23IAkeCKMD5vI77VIYmz8wFCzQua+b+bpHki64I08SHr5/GQtcYJT6jGDMPsxi615ilAWY0ucpdTtFRQ9V3tbRI47TKEXPtwYseVPSpDKCLN9yy14wxtApbLXhjb5HeOe03ucDVhASSFd9Gjq5O0pChJbR247VoI7UAelXkJlqKnCp+UI20UYKl0iKeVoNzlnvltO6SbGCF3JOK7A5b2qGYwV8tkgWsDW+fVtwuiKsleLpSnHfR0UrTT8B0a8q8eZau8TUE8Pc+ektO4kvxfiI4yxoLtQipWmstxKTWcEbxeJQR/xYTe85ipezC9GhNXPq5FBRCss5JLJHdGbaY8daSUhIpI0gneDS5YxREph0DvWCG0zAmFmfkDpYK3kykmDE0rIKjV6ybXAdSrVJOd0WjsQTL5dK4xsOYcexbsfk7sTUMH4iiDS9KxYwhWclZbA/jniL/WJliWi0QOsEnignnfciytJCL7fSe8U5SMb21aKqsCO/xwaMQo1ZMCTNKNejMTrNFaQ4ZDb0V0avUPsjGSVZKrmjVMdawx0gubZTqneMy44NjXXeskv5KbVJKtlbGYNLQdRuRJXJ5o3MTAV0ZHXuULV9rMZXNI4HKOUss0g/RvaFa5X4SI9RlT0JOQjF5z54TTmlJpNRKQLZDamiMwqggRCENRmmcnUlF0F0ikBKpxJ6qAPuNGLEWb3FW7nMlJ9oIzr5siZjrsGkqShZ2qgb2VilF3+6f18pWaS0viHUObb3sAq2im7xxpcsPr7XgjKP2KuKQLizvVosMewZCqdMxXeHGsCfXBqqTy34Txa67pCTo3jFACHK608Z21+FustQ6qHzIjMhqmWB2a0BDzg3rZEbTBv7aWamc9ix+F2+EydF6l+nrUOX2IWwqreG0lPStldGs68I215opaHJu0KRKuLFAjLkJf50xOBR+8nhrueyZpDrrlpitoTeRIF5XPCB+XSMLwCrpVCs9dupWxDMzjO3v9bVR0jeqKMuuhrWWFbMz0CrBac4xSiNSyWTdKsF5pzIY7gNzJXcUxu/XRMXO1d1QB5myIMwowFox/FKbtMFrEWdYKZJG3RsauXs0JbsL7WbSlF+wdbox8g9mNKOaGKLoDKdeZ3Z2SAESGmmOydVNGm50aFUuU2qgsGq9xqXJCnf2ijfopMFV3VPCGT38H405eJpV1CRdSGUsWvVxLBmosJfEfZioQ+ZQe6VVUFR5mMMqsQQvXtfe8coQiyZoi7bSrZ2NtPKz6RzmwOWys22RZRFHwEdPz9KANHIcfvDijhhXvPPUXtCaQTAw7HuiVNHwWht4PgspYK/S3V68Q7eO0nJQb3u6IcDXMfIXl977PkdrcnToXgXx0CvKigRB9c5kFaeUB4JbFn/eL9ic0q3mFVe3GJs7GhtA907vDo1M+pSS6kBc4VJutquGhE4rBd3ckO/LKjVdrJcpRYzSvE0Zb4ecWnn2lHmxHEYahCLlsQ2WKtl4AzF9nfWYAV6rTY4xFNI5rX1oUwuzN6gu6G5rIFgBzjbVcUF4q7Nz1CqzF2ulSqtVTObWAEVepMkbdG83n/Cl7uInBVIpzD5w3hJtl5yVdTQS97yj1koX+x7Pl11kDlrz4SdveVw8Ne+0q8cIjVIV1RV7FBBdZx1Q4TIWmsKphhllc2+duEsTrrRGrQptlRz5DWKtY2SiqXXIN3rFAXvJ7CkR40YLYXzWbeTeNHLcsDluhHmRxsmoYra0Y1slEHDOycR1JBgNfxBNq3GmQsPcsnQbULLsHEbLA8+q37ZliwFdiAlqy5xXI1ShpwsAh2CwymC0Gb0YOWpylS2SMU/wVsxLvY4wozY0tAP2Zrtl7Yac5AV7SgWrNVNwbBdR5V+ure3Bum6VocfV1KpGpEgWLpsWeUAasV4K8N6yp8TpssO47Clg8RN7zdwdAm/jLnzTXKE2SklkOjo49CQNv5il7G+9CX7DOagV3Tq1S39J1UJritYUa68cvBY68nDmGyMBDG30UK6e6DpYHkJKlGaYblJV5lrZdkFbvXleOe+Xa9NINEKlYHNc0ebTcp9oDZ2jBOC0ThuQEWfdoPkUutZy59Dc5IVXXYZCyeUSwVqGyfHqMPHJ0zNaNT49Bz5+d0YZM1rz/abWZhwysRt20a2glayANDylarSGZeAkqQfL5Dlay9ZELG1VxXqLUpWgRtu+1tEKj0yjQeONlhy3lATwW0V/UQfdZ+/DszuU5MaLz+SSpF9zDVqSWxJYZdBaXlRGdfKUo1R0TXDizlmCsQMgp4n7Kr0G1VA1S7WG5bRuOCtdbOcMqjZeeEVqnecYKQUafsSuVdnMht5DCNdtiLXqCIhqKNFVUar823PK1BFru64bT4PyoIwV1dpo2au/+oPfSbi7w08zznuM86Jq7p0cd2oRm8BV3Hw9ir65A3stlVtrwpWoRQAkXLux/SbZV8pgXcA4L13Z1ilFRs/XMOerHqGPKgbkZ13VTte50U397QIuTLdqrGRRcNUcB4zNY6yAga8l/XUrlZRpfesFSQ+j3n6+fC2P43X8/YFokjmK5zquoHfMgAC3Vmi1UHK6RpzfRDitVrR1+DBLykbv1JLGI9C0WojbRdK8jSXMR6EvDMXfdRxfizznkosc7dZirX3f+ByGuOuf6/+Li8FIuECO1DIqtuFwsD5g3SRFy0//+R+SsBoXcD6MQLsmaG6FCFOG1fAqDdBKhES1JNK+keOFWoVDZlzAWC/8CeNu4+NSMq3K0dNrGalPjms0/BWV0Mdc6PoyiuJevket5fbh9xHw7MJ0u//UazBja8O/KxWYUgY/LVjnbvekWousmPGwGDjyUsSXqm4UP3ULTerjRee6WNR1AHbNum+83+sYTahBirQOfQUFDiSmXAbr7XvKyu03mYU28n3N4Iy0Wm5HuTFuJFWOl12bm4G+Xxdqq7KIh/Pv+uFfP+dWKyWn20ZQciTHjdbKeLYz1rpJmiJaZnp96EBuF1eujTT5ZnXQiK6r0k8zYTneokRKTqR9peZEHytFUr0DKizUkYTNOB/znrC24YPkxaoR7JtTlGOPfqP9XCPkW5EXzLoO6eotff9QjQ+3r7mRKi6r8jx2iHbLp78+dAYtWmlFWI435bkQhyWuw1h7K/9qSePvjxcFQXe1gXayzqGNBABRC3vcbj9HjPBiNbEujEVoxovdB59MStocd+LlRMnSJrc+SLatztysteqb0yrbrVvbB5z/an7ro6l5Ggvs/Y5oxgvVcX5BaTWSUCPWTxKtlbeVOFTdYZ4I0yRvGo2Wo/QTRg2u1bVrOjJHvkkuUHO65fC21m5vd94vlBLF7T4dCMvd7SgrKY7dSHaA6/dQSr9nwg9IrQQuWnyYZdpchqqtdUraqCWJXWM64MJ8E0CXlMlpl/uEczgf0MbdDMsikBr46laGcUijrbT7hbwjO6gZ+b/Xo4iBJjcuYJ2/xan025FScC5gvRxHvXVaFby4sXZ0LUV7WsaxeFN7KY1fjkz6/rYrtFropdz6OtejpBe5R8luBphvQnMZJy/i1Sl51aLWMp6/KAt7a9KXUYZpvuf/A3odtCaPyZYiAAAAAElFTkSuQmCC")
                          , t = new C.V9B({
                            map: e
                        })
                          , n = new C.bdM(136 / 157 * 2,2)
                          , i = new C.eaF(n,t);
                        i.position.set(-640, 2, -249.95),
                        i.visible = !1,
                        s.scene.add(i),
                        (0,
                        R.GG)(this, Ya, {
                            dispose: () => {
                                (0,
                                R.gn)(this, qr, "f").scene.remove(i),
                                n.dispose(),
                                t.dispose(),
                                e.dispose()
                            }
                            ,
                            update: () => {
                                i.visible = !(0,
                                R.gn)(this, Xa, "f").isEnabled
                            }
                        }, "f")
                    }
                Pt.EM && (0,
                R.GG)(this, Za, new _i(s,n), "f")
            }
            get multiplayerConnection() {
                return (0,
                R.gn)(this, za, "f")?.multiplayerConnection ?? null
            }
            dispose(e=!0, t=!0) {
                null != (0,
                R.gn)(this, za, "f") && (t ? (0,
                R.gn)(this, za, "f").multiplayerConnection.dispose() : (null != (0,
                R.gn)(this, Ua, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removeConnectionLostCallback((0,
                R.gn)(this, Ua, "f")),
                null != (0,
                R.gn)(this, Da, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removePlayersChangedCallback((0,
                R.gn)(this, Da, "f")),
                null != (0,
                R.gn)(this, Ba, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removeCarResetCallback((0,
                R.gn)(this, Ba, "f")),
                null != (0,
                R.gn)(this, Ga, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removeCarUpdateCallback((0,
                R.gn)(this, Ga, "f")),
                null != (0,
                R.gn)(this, Fa, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removeEndSessionCallback((0,
                R.gn)(this, Fa, "f")),
                (0,
                R.gn)(this, za, "f").multiplayerConnection.removeNewSessionCallback((0,
                R.gn)(this, oa, "f")),
                null != (0,
                R.gn)(this, Oa, "f") && (0,
                R.gn)(this, za, "f").multiplayerConnection.removeServerMessageCallback((0,
                R.gn)(this, Oa, "f"))),
                (0,
                R.GG)(this, za, null, "f")),
                (0,
                R.gn)(this, Zr, "f").setCursorHiddenWhenInactive(!1),
                (0,
                R.gn)(this, $r, "f").hide(),
                (0,
                R.gn)(this, _a, "f").dispose(),
                (0,
                R.gn)(this, ea, "f").removeChangeListener((0,
                R.gn)(this, Ca, "f")),
                (0,
                R.gn)(this, ua, "f").dispose(),
                (0,
                R.gn)(this, pa, "f").dispose(),
                (0,
                R.gn)(this, fa, "f")?.dispose(),
                (0,
                R.GG)(this, fa, null, "f"),
                (0,
                R.gn)(this, ga, "f")?.dispose(),
                (0,
                R.GG)(this, ga, null, "f"),
                (0,
                R.gn)(this, ma, "f").dispose(),
                (0,
                R.gn)(this, Aa, "f").dispose(),
                (0,
                R.gn)(this, va, "f").dispose(),
                (0,
                R.gn)(this, ya, "f")?.dispose(),
                (0,
                R.GG)(this, ya, null, "f"),
                (0,
                R.gn)(this, wa, "f").dispose(),
                (0,
                R.gn)(this, ba, "f")?.dispose(),
                (0,
                R.GG)(this, ba, null, "f"),
                (0,
                R.gn)(this, xa, "f")?.dispose(),
                (0,
                R.GG)(this, xa, null, "f"),
                (0,
                R.gn)(this, Sa, "f")?.dispose(),
                (0,
                R.GG)(this, Sa, null, "f"),
                (0,
                R.gn)(this, Ea, "f")?.dispose(),
                (0,
                R.GG)(this, Ea, null, "f"),
                (0,
                R.gn)(this, Ta, "f")?.dispose(),
                (0,
                R.GG)(this, Ta, null, "f"),
                (0,
                R.gn)(this, ka, "f")?.dispose(),
                (0,
                R.GG)(this, ka, null, "f"),
                e && (0,
                R.gn)(this, Vr, "f").clear(),
                (0,
                R.gn)(this, Hr, "f").clearMountains(),
                (0,
                R.gn)(this, Pa, "f").dispose(),
                (0,
                R.gn)(this, La, "f").dispose();
                for (const e of (0,
                R.gn)(this, Na, "f"))
                    e.car?.dispose(),
                    e.car = null,
                    null != e.carId && ((0,
                    R.gn)(this, Wr, "f").deleteCar(e.carId),
                    e.carId = null),
                    e.replay = null;
                for (const e of (0,
                R.gn)(this, Wa, "f").values())
                    e.car.dispose();
                (0,
                R.gn)(this, Wa, "f").clear(),
                window.removeEventListener("keydown", (0,
                R.gn)(this, Qa, "f")),
                window.removeEventListener("keyup", (0,
                R.gn)(this, Ja, "f")),
                (0,
                R.gn)(this, Xa, "f").dispose(),
                (0,
                R.gn)(this, Ya, "f")?.dispose(),
                (0,
                R.gn)(this, Za, "f")?.dispose()
            }
            update(e) {
                const t = !I.ip() && null == (0,
                R.gn)(this, ba, "f") && !(0,
                R.gn)(this, Va, "f");
                let n;
                if (n = (0,
                R.gn)(this, Xa, "f").isEnabled && null == (0,
                R.gn)(this, za, "f") || !t ? 0 : e,
                t) {
                    if ((0,
                    R.gn)(this, La, "f").update(n),
                    (0,
                    R.gn)(this, La, "f").updateCameras(n),
                    (0,
                    R.gn)(this, Xa, "f").isEnabled && null == (0,
                    R.gn)(this, za, "f") ? ((0,
                    R.gn)(this, La, "f").isPaused = !0,
                    (0,
                    R.gn)(this, La, "f").audioVolume = 0) : ((0,
                    R.gn)(this, La, "f").isPaused = !1,
                    (0,
                    R.gn)(this, La, "f").audioVolume = 1),
                    (0,
                    R.gn)(this, La, "f").isControlsDisabled = (0,
                    R.gn)(this, Xa, "f").isEnabled || (0,
                    R.gn)(this, Fr, "m", ns).call(this),
                    !(0,
                    R.gn)(this, Xa, "f").isEnabled) {
                        const e = (0,
                        R.gn)(this, Pa, "f").getControls();
                        (e.up || e.down) && ((0,
                        R.gn)(this, La, "f").hasStarted() || (0,
                        R.gn)(this, La, "f").start()),
                        (0,
                        R.gn)(this, La, "f").hasStarted() && !(0,
                        R.gn)(this, La, "f").hasFinished() ? I.tU() : I.bQ(),
                        (0,
                        R.gn)(this, La, "f").hasStarted() || (0,
                        R.gn)(this, ja, "f") && ((0,
                        R.gn)(this, $r, "f").show((0,
                        R.gn)(this, Kr, "f").get("Invalid replay detected!"), (0,
                        R.gn)(this, Kr, "f").get("Ok"), ( () => {
                            (0,
                            R.gn)(this, $r, "f").hide()
                        }
                        )),
                        (0,
                        R.GG)(this, ja, !1, "f"))
                    }
                    (0,
                    R.gn)(this, La, "f").getTime().numberOfFrames >= re.A.maxFrames && (0,
                    R.gn)(this, Fr, "m", ss).call(this),
                    (0,
                    R.gn)(this, Za, "f")?.updateCar((0,
                    R.gn)(this, La, "f"));
                    for (const e of (0,
                    R.gn)(this, Na, "f"))
                        if (null != e.car) {
                            if (!e.hasEnded) {
                                const t = (0,
                                R.gn)(this, La, "f").getTime().numberOfFrames;
                                for (let n = e.car.getTime().numberOfFrames + 1; n <= t; n++) {
                                    const t = e.replay?.replay.getFrame(n);
                                    if (null == t) {
                                        e.hasEnded = !0,
                                        e.car.setVisible(!1);
                                        break
                                    }
                                    e.car.setCarState(t, !1)
                                }
                                e.car.update(n)
                            }
                            e.hasEnded || (0,
                            R.gn)(this, Xa, "f").isEnabled ? e.car.audioVolume = 0 : e.car.audioVolume = (0,
                            R.gn)(this, $a, "f")
                        }
                    for (const e of (0,
                    R.gn)(this, Wa, "f").values()) {
                        if (e.car.isPaused = !1,
                        e.car.audioVolume = (0,
                        R.gn)(this, $a, "f"),
                        e.bufferedCarStates.length > 0) {
                            const t = e.bufferedCarStates[e.bufferedCarStates.length - 1].frames / 1e3 - e.time
                              , i = .15
                              , r = .1;
                            let a = e.time + n;
                            t < i - r ? a -= .5 * r : t > i + r && (a += .5 * r);
                            const s = Math.floor(1e3 * a);
                            for (; e.bufferedCarStates.length > 0; ) {
                                const t = e.bufferedCarStates[0];
                                if (!(t.frames <= s))
                                    break;
                                e.car.setCarState(t, !1),
                                e.bufferedCarStates.shift()
                            }
                            if (e.bufferedCarStates.length > 0) {
                                const t = e.bufferedCarStates[0]
                                  , n = e.car.getCarState()
                                  , i = t.frames - n.frames;
                                if (i > 0) {
                                    const r = (s - n.frames) / i;
                                    if (r > 0) {
                                        const i = Gr(n, t, r);
                                        e.car.setCarState(i, !1)
                                    }
                                }
                            }
                            e.time = a
                        } else {
                            const t = .15;
                            e.time = e.car.getCarState().frames / 1e3 - t
                        }
                        e.car.update(n)
                    }
                    (0,
                    R.gn)(this, Fr, "m", ds).call(this),
                    (0,
                    R.gn)(this, Xa, "f").update(e),
                    (0,
                    R.gn)(this, wa, "f").setVisible(!(0,
                    R.gn)(this, La, "f").hasStarted() || (0,
                    R.gn)(this, La, "f").hasFinished() || !(0,
                    R.gn)(this, Ra, "f") || (0,
                    R.gn)(this, ea, "f").touchEnabled || !(0,
                    R.gn)(this, Zr, "f").isCursorHidden || (0,
                    R.gn)(this, wa, "f").hasFocus())
                } else {
                    (0,
                    R.gn)(this, La, "f").isPaused = !0,
                    (0,
                    R.gn)(this, La, "f").audioVolume = 0,
                    (0,
                    R.gn)(this, La, "f").update(n),
                    (0,
                    R.gn)(this, La, "f").updateCameras(n);
                    for (const e of (0,
                    R.gn)(this, Na, "f"))
                        null != e.car && (e.car.isPaused = !0,
                        e.car.audioVolume = 0,
                        e.car.update(n));
                    for (const e of (0,
                    R.gn)(this, Wa, "f").values())
                        e.car.isPaused = !0,
                        e.car.audioVolume = 0,
                        e.car.update(n);
                    (0,
                    R.gn)(this, wa, "f").setVisible(!I.ip())
                }
                const i = (0,
                R.gn)(this, Na, "f").reduce(( (e, t) => e + t.loadedFrames), 0)
                  , r = (0,
                R.gn)(this, Na, "f").reduce(( (e, t) => e + t.maxFrames), 0);
                let a;
                a = r > 0 ? i / r : 1,
                (0,
                R.gn)(this, _a, "f").isEnabled = (0,
                R.gn)(this, ea, "f").touchEnabled && !(0,
                R.gn)(this, Fr, "m", ns).call(this),
                (0,
                R.gn)(this, pa, "f").update((0,
                R.gn)(this, La, "f"), e, t && null == (0,
                R.gn)(this, xa, "f") && null == (0,
                R.gn)(this, Sa, "f")),
                (0,
                R.gn)(this, fa, "f")?.update(a),
                (0,
                R.gn)(this, Aa, "f").update((0,
                R.gn)(this, La, "f")),
                (0,
                R.gn)(this, va, "f").update((0,
                R.gn)(this, La, "f")),
                (0,
                R.gn)(this, ma, "f").update((0,
                R.gn)(this, La, "f")),
                (0,
                R.gn)(this, _a, "f").setResetCheckpointAvailable((0,
                R.gn)(this, Fr, "m", is).call(this)),
                (0,
                R.gn)(this, Ya, "f")?.update(),
                (0,
                R.gn)(this, Hr, "f").update((0,
                R.gn)(this, Vr, "f")),
                (0,
                R.gn)(this, jr, "f").update(n, (0,
                R.gn)(this, qr, "f").camera, (0,
                R.gn)(this, Vr, "f").sunDirection),
                (0,
                R.gn)(this, Qr, "f").update(e, !1, (0,
                R.gn)(this, qr, "f")),
                (0,
                R.gn)(this, qr, "f").update((0,
                R.gn)(this, Vr, "f").sunDirection)
            }
        }
        ;
        var fs = i(9507)
          , gs = i(6830)
          , ms = {};
        ms.styleTagTransform = u(),
        ms.setAttributes = l(),
        ms.insert = s().bind(null, "head"),
        ms.domAPI = r(),
        ms.insertStyleElement = h();
        t()(gs.A, ms);
        gs.A && gs.A.locals && gs.A.locals;
        var As = i(2927)
          , vs = {};
        vs.styleTagTransform = u(),
        vs.setAttributes = l(),
        vs.insert = s().bind(null, "head"),
        vs.domAPI = r(),
        vs.insertStyleElement = h();
        t()(As.A, vs);
        As.A && As.A.locals && As.A.locals;
        var ys, ws;
        ys = new WeakMap,
        ws = new WeakMap;
        const bs = class {
            constructor(e, t, n) {
                ys.set(this, void 0),
                ws.set(this, void 0),
                (0,
                R.GG)(this, ys, e, "f"),
                (0,
                R.GG)(this, ws, document.createElement("div"), "f"),
                (0,
                R.gn)(this, ws, "f").className = "loading-ui",
                e.appendChild((0,
                R.gn)(this, ws, "f"));
                const i = document.createElement("p");
                i.textContent = t.get("Loading") + "...",
                (0,
                R.gn)(this, ws, "f").appendChild(i);
                const r = document.createElement("div");
                (0,
                R.gn)(this, ws, "f").appendChild(r);
                const a = document.createElement("div");
                r.appendChild(a);
                const s = document.createElement("div");
                a.appendChild(s),
                n.addProgressListener((e => {
                    s.style.width = (100 * e).toString() + "%"
                }
                ))
            }
            fadeOut(e) {
                (0,
                R.gn)(this, ws, "f").classList.add("fade-out"),
                setTimeout(e, 250)
            }
            dispose() {
                (0,
                R.gn)(this, ys, "f").removeChild((0,
                R.gn)(this, ws, "f"))
            }
        }
        ;
        var xs = i(5734)
          , Ss = {};
        Ss.styleTagTransform = u(),
        Ss.setAttributes = l(),
        Ss.insert = s().bind(null, "head"),
        Ss.domAPI = r(),
        Ss.insertStyleElement = h();
        t()(xs.A, Ss);
        xs.A && xs.A.locals && xs.A.locals;
        const Es = {
            "Checkpoint order": {
                ar: "  ",
                "de-DE": "Kontrollpunktreihenfolge",
                "es-ES": "Orden de puntos de control",
                "fr-FR": "Ordre des points de contrle",
                "it-IT": "Ordine dei checkpoint",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Kolejno punktw kontrolnych",
                "pt-BR": "Ordem dos Pontos de Verificao",
                "pt-PT": "Ordem dos Pontos de Verificao",
                "ru-RU": "  ",
                "tr-TR": "Kontrol noktas sras",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Height: {
                ar: "",
                "de-DE": "Hhe",
                "es-ES": "Altura",
                "fr-FR": "Hauteur",
                "it-IT": "Altezza",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wysoko",
                "pt-BR": "Altura",
                "pt-PT": "Altura",
                "ru-RU": "",
                "tr-TR": "Ykseklik",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Exit: {
                ar: "",
                "de-DE": "Beenden",
                "es-ES": "Salir",
                "fr-FR": "Quitter",
                "it-IT": "Esci",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wyjcie",
                "pt-BR": "Sair",
                "pt-PT": "Sair",
                "ru-RU": "",
                "tr-TR": "k",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Random: {
                ar: "",
                "de-DE": "Zufllig",
                "es-ES": "Aleatorio",
                "fr-FR": "Alatoire",
                "it-IT": "Casuale",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Losowe",
                "pt-BR": "Aleatrio",
                "pt-PT": "Aleatrio",
                "ru-RU": "",
                "tr-TR": "Rastgele",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Switch Profile": {
                ar: "  ",
                "de-DE": "Profil wechseln",
                "es-ES": "Cambiar perfil",
                "fr-FR": "Changer de profil",
                "it-IT": "Cambia profilo",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Zmie profil",
                "pt-BR": "Trocar Perfil",
                "pt-PT": "Mudar Perfil",
                "ru-RU": " ",
                "tr-TR": "Profili Deitir",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Primary: {
                ar: "",
                "de-DE": "Primr",
                "es-ES": "Primario",
                "fr-FR": "Principal",
                "it-IT": "Primario",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Gwny",
                "pt-BR": "Principal",
                "pt-PT": "Primrio",
                "ru-RU": "",
                "tr-TR": "Birincil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Secondary: {
                ar: "",
                "de-DE": "Sekundr",
                "es-ES": "Secundario",
                "fr-FR": "Secondaire",
                "it-IT": "Secondario",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Dodatkowy",
                "pt-BR": "Secundrio",
                "pt-PT": "Secundrio",
                "ru-RU": "",
                "tr-TR": "kincil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Frame: {
                ar: "",
                "de-DE": "Rahmen",
                "es-ES": "Marco",
                "fr-FR": "Cadre",
                "it-IT": "Telaio",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Rama",
                "pt-BR": "Estrutura",
                "pt-PT": "Estrutura",
                "ru-RU": "",
                "tr-TR": "ereve",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Rims: {
                ar: "",
                "de-DE": "Felgen",
                "es-ES": "Llantas",
                "fr-FR": "Jantes",
                "it-IT": "Cerchioni",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Obrcze",
                "pt-BR": "Aros",
                "pt-PT": "Aros",
                "ru-RU": "",
                "tr-TR": "Jantlar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Paint: {
                ar: "",
                "de-DE": "Lackierung",
                "es-ES": "Pintura",
                "fr-FR": "Peinture",
                "it-IT": "Vernice",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Lakier",
                "pt-BR": "Pintura",
                "pt-PT": "Pintura",
                "ru-RU": "",
                "tr-TR": "Boya",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Pattern: {
                ar: "",
                "de-DE": "Muster",
                "es-ES": "Patrn",
                "fr-FR": "Motif",
                "it-IT": "Motivo",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wzr",
                "pt-BR": "Padro",
                "pt-PT": "Padro",
                "ru-RU": "",
                "tr-TR": "Desen",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Exhaust: {
                ar: "",
                "de-DE": "Auspuff",
                "es-ES": "Escape",
                "fr-FR": "chappement",
                "it-IT": "Scarico",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wydech",
                "pt-BR": "Escape",
                "pt-PT": "Escape",
                "ru-RU": "",
                "tr-TR": "Egzoz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Would you like to watch an ad to unlock this item?": {
                ar: "       ",
                "de-DE": "Mchten Sie eine Anzeige ansehen, um diesen Artikel freizuschalten?",
                "es-ES": "Te gustara ver un anuncio para desbloquear este artculo?",
                "fr-FR": "Voulez-vous regarder une annonce pour dbloquer cet article ?",
                "it-IT": "Vuoi guardare una pubblicit per sbloccare questo oggetto?",
                "ja-JP": "",
                "ko-KR": "     ?",
                "pl-PL": "Czy chcesz obejrze reklam, aby odblokowa ten przedmiot?",
                "pt-BR": "Gostaria de assistir a um anncio para desbloquear este item?",
                "pt-PT": "Gostaria de ver um anncio para desbloquear este item?",
                "ru-RU": "  ,    ?",
                "tr-TR": "Bu enin kilidini amak iin reklam izlemek ister misiniz?",
                "uk-UA": "  ,    ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Ad not completed": {
                ar: "   ",
                "de-DE": "Anzeige nicht abgeschlossen",
                "es-ES": "Anuncio no completado",
                "fr-FR": "Annonce non termine",
                "it-IT": "Annuncio non completato",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Reklama nie zostaa ukoczona",
                "pt-BR": "Anncio no concludo",
                "pt-PT": "Anncio no concludo",
                "ru-RU": "  ",
                "tr-TR": "Reklam tamamlanmad",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to exit without saving?": {
                ar: "        ",
                "de-DE": "Sind Sie sicher, dass Sie ohne Speichern beenden mchten?",
                "es-ES": "Ests seguro de que deseas salir sin guardar?",
                "fr-FR": "tes-vous sr de vouloir quitter sans sauvegarder ?",
                "it-IT": "Sei sicuro di voler uscire senza salvare?",
                "ja-JP": "",
                "ko-KR": "  ?",
                "pl-PL": "Czy na pewno chcesz wyj bez zapisywania?",
                "pt-BR": "Tem certeza de que deseja sair sem salvar?",
                "pt-PT": "Tem a certeza de que deseja sair sem guardar?",
                "ru-RU": " ,     ?",
                "tr-TR": "Kaydetmeden kmak istediinizden emin misiniz?",
                "uk-UA": " ,     ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to switch profile without saving?": {
                ar: "          ",
                "de-DE": "Sind Sie sicher, dass Sie das Profil ohne Speichern wechseln mchten?",
                "es-ES": "Ests seguro de que deseas cambiar de perfil sin guardar?",
                "fr-FR": "tes-vous sr de vouloir changer de profil sans sauvegarder ?",
                "it-IT": "Sei sicuro di voler cambiare profilo senza salvare?",
                "ja-JP": "",
                "ko-KR": "   ?",
                "pl-PL": "Czy na pewno chcesz zmieni profil bez zapisywania?",
                "pt-BR": "Tem certeza de que deseja trocar de perfil sem salvar?",
                "pt-PT": "Tem a certeza de que deseja mudar de perfil sem guardar?",
                "ru-RU": " ,      ?",
                "tr-TR": "Kaydetmeden profili deitirmek istediinizden emin misiniz?",
                "uk-UA": " ,      ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "All changes will be lost!": {
                ar: "   !",
                "de-DE": "Alle nderungen gehen verloren!",
                "es-ES": "Todos los cambios se perdern!",
                "fr-FR": "Tous les changements seront perdus !",
                "it-IT": "Tutte le modifiche andranno perse!",
                "ja-JP": "",
                "ko-KR": "   !",
                "pl-PL": "Wszystkie zmiany zostan utracone!",
                "pt-BR": "Todas as alteraes sero perdidas!",
                "pt-PT": "Todas as alteraes sero perdidas!",
                "ru-RU": "   !",
                "tr-TR": "Tm deiiklikler kaybolacak!",
                "uk-UA": "   !",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Car saved!": {
                ar: "  !",
                "de-DE": "Auto gespeichert!",
                "es-ES": "Coche guardado!",
                "fr-FR": "Voiture sauvegarde !",
                "it-IT": "Auto salvata!",
                "ja-JP": "",
                "ko-KR": " !",
                "pl-PL": "Samochd zapisany!",
                "pt-BR": "Carro salvo!",
                "pt-PT": "Carro guardado!",
                "ru-RU": " !",
                "tr-TR": "Araba kaydedildi!",
                "uk-UA": " !",
                "zh-CN": "",
                "zh-TW": ""
            },
            Test: {
                ar: "",
                "de-DE": "Test",
                "es-ES": "Prueba",
                "fr-FR": "Test",
                "it-IT": "Test",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Test",
                "pt-BR": "Testar",
                "pt-PT": "Testar",
                "ru-RU": "",
                "tr-TR": "Test",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Starting point is missing!": {
                ar: "  !",
                "de-DE": "Startpunkt fehlt!",
                "es-ES": "Falta el punto de inicio!",
                "fr-FR": "Point de dpart manquant !",
                "it-IT": "Punto di partenza mancante!",
                "ja-JP": "",
                "ko-KR": "  !",
                "pl-PL": "Brak punktu startowego!",
                "pt-BR": "Ponto de partida est faltando!",
                "pt-PT": "Ponto de partida em falta!",
                "ru-RU": "  !",
                "tr-TR": "Balang noktas eksik!",
                "uk-UA": "  !",
                "zh-CN": "",
                "zh-TW": ""
            },
            Generate: {
                ar: "",
                "de-DE": "Generieren",
                "es-ES": "Generar",
                "fr-FR": "Gnrer",
                "it-IT": "Genera",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Generuj",
                "pt-BR": "Gerar",
                "pt-PT": "Gerar",
                "ru-RU": "",
                "tr-TR": "Olutur",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to generate a new track?\n\nYour current track will be lost!": {
                ar: "        \n\n   !",
                "de-DE": "Sind Sie sicher, dass Sie eine neue Strecke generieren mchten?\n\nIhre aktuelle Strecke geht verloren!",
                "es-ES": "Ests seguro de que deseas generar una nueva pista?\n\nTu pista actual se perder!",
                "fr-FR": "tes-vous sr de vouloir gnrer une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
                "it-IT": "Sei sicuro di voler generare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
                "ja-JP": "\n\n",
                "ko-KR": "  ?\n\n  !",
                "pl-PL": "Czy na pewno chcesz wygenerowa now tras?\n\nTwoja obecna trasa zostanie utracona!",
                "pt-BR": "Tem certeza de que deseja gerar uma nova pista?\n\nSua pista atual ser perdida!",
                "pt-PT": "Tem a certeza de que deseja gerar uma nova pista?\n\nA pista atual ser perdida!",
                "ru-RU": " ,     ?\n\n    !",
                "tr-TR": "Yeni bir rota oluturmak istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
                "uk-UA": " ,     ?\n\n    !",
                "zh-CN": "\n\n",
                "zh-TW": "\n\n"
            },
            Load: {
                ar: "",
                "de-DE": "Laden",
                "es-ES": "Cargar",
                "fr-FR": "Charger",
                "it-IT": "Carica",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wczytaj",
                "pt-BR": "Carregar",
                "pt-PT": "Carregar",
                "ru-RU": "",
                "tr-TR": "Ykle",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Save: {
                ar: "",
                "de-DE": "Speichern",
                "es-ES": "Guardar",
                "fr-FR": "Enregistrer",
                "it-IT": "Salva",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zapisz",
                "pt-BR": "Salvar",
                "pt-PT": "Guardar",
                "ru-RU": "",
                "tr-TR": "Kaydet",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to load a new track?\n\nYour current track will be lost!": {
                ar: "        \n\n   !",
                "de-DE": "Sind Sie sicher, dass Sie eine neue Strecke laden mchten?\n\nIhre aktuelle Strecke geht verloren!",
                "es-ES": "Ests seguro de que deseas cargar una nueva pista?\n\nTu pista actual se perder!",
                "fr-FR": "tes-vous sr de vouloir charger une nouvelle piste ?\n\nVotre piste actuelle sera perdue !",
                "it-IT": "Sei sicuro di voler caricare un nuovo percorso?\n\nIl tuo percorso attuale verr perso!",
                "ja-JP": "\n\n",
                "ko-KR": "  ?\n\n  !",
                "pl-PL": "Czy na pewno chcesz wczyta now tras?\n\nTwoja obecna trasa zostanie utracona!",
                "pt-BR": "Tem certeza de que deseja carregar uma nova pista?\n\nSua pista atual ser perdida!",
                "pt-PT": "Tem a certeza de que deseja carregar uma nova pista?\n\nA pista atual ser perdida!",
                "ru-RU": " ,     ?\n\n    !",
                "tr-TR": "Yeni bir rota yklemek istediinizden emin misiniz?\n\nMevcut rotanz kaybolacak!",
                "uk-UA": " ,     ?\n\n    !",
                "zh-CN": "\n\n",
                "zh-TW": "\n\n"
            },
            "Track saved!": {
                ar: "  !",
                "de-DE": "Strecke gespeichert!",
                "es-ES": "Pista guardada!",
                "fr-FR": "Piste enregistre !",
                "it-IT": "Percorso salvato!",
                "ja-JP": "",
                "ko-KR": " !",
                "pl-PL": "Trasa zostaa zapisana!",
                "pt-BR": "Pista salva!",
                "pt-PT": "Pista guardada!",
                "ru-RU": " !",
                "tr-TR": "Rota kaydedildi!",
                "uk-UA": " !",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to save!": {
                ar: " !",
                "de-DE": "Speichern fehlgeschlagen!",
                "es-ES": "Error al guardar!",
                "fr-FR": "chec de l'enregistrement !",
                "it-IT": "Salvataggio non riuscito!",
                "ja-JP": "",
                "ko-KR": " !",
                "pl-PL": "Nie udao si zapisa!",
                "pt-BR": "Falha ao salvar!",
                "pt-PT": "Falha ao guardar!",
                "ru-RU": "  !",
                "tr-TR": "Kaydetme baarsz!",
                "uk-UA": "  !",
                "zh-CN": "",
                "zh-TW": ""
            },
            'Are you sure you want to overwrite "{0}"?': {
                ar: '        "{0}"',
                "de-DE": 'Sind Sie sicher, dass Sie "{0}" berschreiben mchten?',
                "es-ES": 'Ests seguro de que deseas sobrescribir "{0}"?',
                "fr-FR": 'tes-vous sr de vouloir craser "{0}" ?',
                "it-IT": 'Sei sicuro di voler sovrascrivere "{0}"?',
                "ja-JP": '"{0}" ',
                "ko-KR": '"{0}"() ?',
                "pl-PL": "Czy na pewno chcesz nadpisa {0}?",
                "pt-BR": 'Tem certeza de que deseja sobrescrever "{0}"?',
                "pt-PT": 'Tem a certeza de que deseja substituir "{0}"?',
                "ru-RU": ' ,    "{0}"?',
                "tr-TR": '"{0}" zerine yazmak istediinizden emin misiniz?',
                "uk-UA": ' ,    "{0}"?',
                "zh-CN": ' "{0}" ',
                "zh-TW": ' "{0}" '
            },
            Export: {
                ar: "",
                "de-DE": "Exportieren",
                "es-ES": "Exportar",
                "fr-FR": "Exporter",
                "it-IT": "Esporta",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Eksportuj",
                "pt-BR": "Exportar",
                "pt-PT": "Exportar",
                "ru-RU": "",
                "tr-TR": "Da Aktar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Help: {
                ar: "",
                "de-DE": "Hilfe",
                "es-ES": "Ayuda",
                "fr-FR": "Aide",
                "it-IT": "Aiuto",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Pomoc",
                "pt-BR": "Ajuda",
                "pt-PT": "Ajuda",
                "ru-RU": "",
                "tr-TR": "Yardm",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to exit the editor?": {
                ar: "        ",
                "de-DE": "Sind Sie sicher, dass Sie den Editor verlassen mchten?",
                "es-ES": "Ests seguro de que deseas salir del editor?",
                "fr-FR": "tes-vous sr de vouloir quitter l'diteur ?",
                "it-IT": "Sei sicuro di voler uscire dall'editor?",
                "ja-JP": "",
                "ko-KR": " ?",
                "pl-PL": "Czy na pewno chcesz wyj z edytora?",
                "pt-BR": "Tem certeza de que deseja sair do editor?",
                "pt-PT": "Tem a certeza de que deseja sair do editor?",
                "ru-RU": " ,     ?",
                "tr-TR": "Editrden kmak istediinizden emin misiniz?",
                "uk-UA": " ,     ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "All unsaved data will be lost!": {
                ar: "     !",
                "de-DE": "Alle nicht gespeicherten Daten gehen verloren!",
                "es-ES": "Se perdern todos los datos no guardados!",
                "fr-FR": "Toutes les donnes non sauvegardes seront perdues !",
                "it-IT": "Tutti i dati non salvati andranno persi!",
                "ja-JP": "",
                "ko-KR": "    !",
                "pl-PL": "Wszystkie niezapisane dane zostan utracone!",
                "pt-BR": "Todos os dados no salvos sero perdidos!",
                "pt-PT": "Todos os dados no guardados sero perdidos!",
                "ru-RU": "    !",
                "tr-TR": "Tm kaydedilmemi veriler kaybolacak!",
                "uk-UA": "     !",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track settings": {
                ar: " ",
                "de-DE": "Streckeneinstellungen",
                "es-ES": "Configuracin de la pista",
                "fr-FR": "Paramtres de la piste",
                "it-IT": "Impostazioni del percorso",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Ustawienia trasy",
                "pt-BR": "Configuraes da pista",
                "pt-PT": "Definies da pista",
                "ru-RU": " ",
                "tr-TR": "Rota ayarlar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Unnamed Track": {
                ar: "  ",
                "de-DE": "Unbenannte Strecke",
                "es-ES": "Pista sin nombre",
                "fr-FR": "Piste sans nom",
                "it-IT": "Percorso senza nome",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Bez nazwy",
                "pt-BR": "Pista sem nome",
                "pt-PT": "Pista sem nome",
                "ru-RU": " ",
                "tr-TR": "Adsz Rota",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track name": {
                ar: " ",
                "de-DE": "Streckenname",
                "es-ES": "Nombre de la pista",
                "fr-FR": "Nom de la piste",
                "it-IT": "Nome del percorso",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Nazwa trasy",
                "pt-BR": "Nome da pista",
                "pt-PT": "Nome da pista",
                "ru-RU": " ",
                "tr-TR": "Rota ad",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Author: {
                ar: "",
                "de-DE": "Autor",
                "es-ES": "Autor",
                "fr-FR": "Auteur",
                "it-IT": "Autore",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Autor",
                "pt-BR": "Autor",
                "pt-PT": "Autor",
                "ru-RU": "",
                "tr-TR": "Yazar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Unknown: {
                ar: " ",
                "de-DE": "Unbekannt",
                "es-ES": "Desconocido",
                "fr-FR": "Inconnu",
                "it-IT": "Sconosciuto",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nieznany",
                "pt-BR": "Desconhecido",
                "pt-PT": "Desconhecido",
                "ru-RU": "",
                "tr-TR": "Bilinmiyor",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Created: {
                ar: " ",
                "de-DE": "Erstellt",
                "es-ES": "Creado",
                "fr-FR": "Cr",
                "it-IT": "Creato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Utworzono",
                "pt-BR": "Criado",
                "pt-PT": "Criado",
                "ru-RU": "",
                "tr-TR": "Oluturuldu",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Environment: {
                ar: "",
                "de-DE": "Umgebung",
                "es-ES": "Entorno",
                "fr-FR": "Environnement",
                "it-IT": "Ambiente",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "rodowisko",
                "pt-BR": "Ambiente",
                "pt-PT": "Ambiente",
                "ru-RU": "",
                "tr-TR": "evre",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Summer: {
                ar: "",
                "de-DE": "Sommer",
                "es-ES": "Verano",
                "fr-FR": "t",
                "it-IT": "Estate",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Lato",
                "pt-BR": "Vero",
                "pt-PT": "Vero",
                "ru-RU": "",
                "tr-TR": "Yaz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Winter: {
                ar: "",
                "de-DE": "Winter",
                "es-ES": "Invierno",
                "fr-FR": "Hiver",
                "it-IT": "Inverno",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zima",
                "pt-BR": "Inverno",
                "pt-PT": "Inverno",
                "ru-RU": "",
                "tr-TR": "K",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Desert: {
                ar: "",
                "de-DE": "Wste",
                "es-ES": "Desierto",
                "fr-FR": "Dsert",
                "it-IT": "Deserto",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Pustynia",
                "pt-BR": "Deserto",
                "pt-PT": "Deserto",
                "ru-RU": "",
                "tr-TR": "l",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Sun direction": {
                ar: " ",
                "de-DE": "Sonnenrichtung",
                "es-ES": "Direccin del sol",
                "fr-FR": "Direction du soleil",
                "it-IT": "Direzione del sole",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Kierunek soca",
                "pt-BR": "Direo do sol",
                "pt-PT": "Direo do sol",
                "ru-RU": " ",
                "tr-TR": "Gne yn",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "How to use the editor": {
                ar: "  ",
                "de-DE": "Wie man den Editor benutzt",
                "es-ES": "Cmo usar el editor",
                "fr-FR": "Comment utiliser l'diteur",
                "it-IT": "Come usare l'editor",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Jak korzysta z edytora",
                "pt-BR": "Como usar o editor",
                "pt-PT": "Como usar o editor",
                "ru-RU": "  ",
                "tr-TR": "Editr nasl kullanlr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Camera controls": {
                ar: " ",
                "de-DE": "Kamerasteuerung",
                "es-ES": "Controles de la cmara",
                "fr-FR": "Contrles de la camra",
                "it-IT": "Controlli della telecamera",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Sterowanie kamer",
                "pt-BR": "Controles da cmera",
                "pt-PT": "Controlos da cmera",
                "ru-RU": " ",
                "tr-TR": "Kamera kontrolleri",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The camera can be moved by right clicking and dragging the mouse. Rotate the camera by clicking the middle mouse button (mouse wheel) or holding the control key and right clicking and dragging the mouse. Zoom in and out by scrolling the mouse wheel.": {
                ar: "        .         ( )           .        .",
                "de-DE": "Die Kamera kann durch Rechtsklick und Ziehen der Maus bewegt werden. Drehen Sie die Kamera, indem Sie die mittlere Maustaste (Mausrad) klicken oder die Steuerungstaste gedrckt halten und mit der rechten Maustaste ziehen. Zoomen Sie mit dem Mausrad rein und raus.",
                "es-ES": "La cmara se puede mover haciendo clic derecho y arrastrando el ratn. Gira la cmara haciendo clic con el botn central del ratn (rueda del ratn) o manteniendo presionada la tecla de control y haciendo clic derecho y arrastrando el ratn. Acrcate y aljate desplazando la rueda del ratn.",
                "fr-FR": "La camra peut tre dplace en cliquant avec le bouton droit et en faisant glisser la souris. Faites pivoter la camra en cliquant sur le bouton central de la souris (molette) ou en maintenant la touche de contrle enfonce et en cliquant avec le bouton droit et en faisant glisser la souris. Zoomez en avant et en arrire en faisant dfiler la molette de la souris.",
                "it-IT": "La telecamera pu essere spostata facendo clic con il tasto destro del mouse e trascinando. Ruota la telecamera facendo clic con il pulsante centrale del mouse (rotella) o tenendo premuto il tasto di controllo e facendo clic con il tasto destro del mouse e trascinando. Zoom avanti e indietro scorrendo la rotella del mouse.",
                "ja-JP": "",
                "ko-KR": "        .     ()           .        .",
                "pl-PL": "Kamer mona przesuwa, klikajc prawym przyciskiem myszy i przecigajc. Obr kamer, klikajc rodkowy przycisk myszy (koo myszy) lub przytrzymujc klawisz Ctrl i klikajc prawym przyciskiem myszy i przecigajc. Przybli i oddal obraz, przewijajc kko myszy.",
                "pt-BR": "A cmera pode ser movida clicando com o boto direito do mouse e arrastando. Gire a cmera clicando no boto do meio do mouse (roda do mouse) ou segurando a tecla de controle e clicando com o boto direito do mouse e arrastando. Amplie e reduza o zoom rolando a roda do mouse.",
                "pt-PT": "A cmera pode ser movida clicando com o boto direito do mouse e arrastando. Rode a cmera clicando no boto do meio do mouse (roda do mouse) ou segurando a tecla de controle e clicando com o boto direito do mouse e arrastando. Aproxime e afaste o zoom rolando a roda do mouse.",
                "ru-RU": "  ,       .  ,     ()    Ctrl        .    ,   .",
                "tr-TR": "Kameray sa tklayarak ve fareyi srkleyerek hareket ettirebilirsiniz. Kameray orta fare dmesine (fare tekerlei) tklayarak veya kontrol tuunu basl tutarak sa tklayarak ve fareyi srkleyerek dndrebilirsiniz. Fare tekerlei ile yaknlatrma ve uzaklatrma yapabilirsiniz.",
                "uk-UA": "  ,       .  ,     ( )    Control        .    ,   .",
                "zh-CN": "Ctrl",
                "zh-TW": "Ctrl"
            },
            "Alternatively, the camera can also be controlled using the following keyboard keys:": {
                ar: "            :",
                "de-DE": "Alternativ kann die Kamera auch mit den folgenden Tasten gesteuert werden:",
                "es-ES": "Alternativamente, la cmara tambin se puede controlar usando las siguientes teclas del teclado:",
                "fr-FR": "Alternativement, la camra peut galement tre contrle en utilisant les touches de clavier suivantes :",
                "it-IT": "In alternativa, la telecamera pu essere controllata utilizzando i seguenti tasti della tastiera:",
                "ja-JP": ":",
                "ko-KR": "        .",
                "pl-PL": "Alternatywnie, kamer mona rwnie sterowa za pomoc nastpujcych klawiszy na klawiaturze:",
                "pt-BR": "Alternativamente, a cmera tambm pode ser controlada usando as seguintes teclas do teclado:",
                "pt-PT": "Alternativamente, a cmera tambm pode ser controlada usando as seguintes teclas do teclado:",
                "ru-RU": " ,        :",
                "tr-TR": "Alternatif olarak, kamera aadaki klavye tular kullanlarak da kontrol edilebilir:",
                "uk-UA": "         :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move forwards:": {
                ar: " :",
                "de-DE": "Nach vorne bewegen:",
                "es-ES": "Mover hacia adelante:",
                "fr-FR": "Avancer :",
                "it-IT": "Muovi avanti:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Poruszaj si do przodu:",
                "pt-BR": "Mover para frente:",
                "pt-PT": "Mover para a frente:",
                "ru-RU": " :",
                "tr-TR": "leri hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move backwards:": {
                ar: " :",
                "de-DE": "Nach hinten bewegen:",
                "es-ES": "Mover hacia atrs:",
                "fr-FR": "Reculer :",
                "it-IT": "Muovi indietro:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Poruszaj si do tyu:",
                "pt-BR": "Mover para trs:",
                "pt-PT": "Mover para trs:",
                "ru-RU": " :",
                "tr-TR": "Geri hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move left:": {
                ar: " :",
                "de-DE": "Nach links bewegen:",
                "es-ES": "Mover a la izquierda:",
                "fr-FR": "Dplacer  gauche :",
                "it-IT": "Muovi a sinistra:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Poruszaj si w lewo:",
                "pt-BR": "Mover para a esquerda:",
                "pt-PT": "Mover para a esquerda:",
                "ru-RU": " :",
                "tr-TR": "Sola hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move right:": {
                ar: " :",
                "de-DE": "Nach rechts bewegen:",
                "es-ES": "Mover a la derecha:",
                "fr-FR": "Dplacer  droite :",
                "it-IT": "Muovi a destra:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Poruszaj si w prawo:",
                "pt-BR": "Mover para a direita:",
                "pt-PT": "Mover para a direita:",
                "ru-RU": " :",
                "tr-TR": "Saa hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate left:": {
                ar: " :",
                "de-DE": "Nach links drehen:",
                "es-ES": "Girar a la izquierda:",
                "fr-FR": "Pivoter  gauche :",
                "it-IT": "Ruota a sinistra:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Obr w lewo:",
                "pt-BR": "Girar para a esquerda:",
                "pt-PT": "Rodar para a esquerda:",
                "ru-RU": " :",
                "tr-TR": "Sola dndr:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate right:": {
                ar: " :",
                "de-DE": "Nach rechts drehen:",
                "es-ES": "Girar a la derecha:",
                "fr-FR": "Pivoter  droite :",
                "it-IT": "Ruota a destra:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Obr w prawo:",
                "pt-BR": "Girar para a direita:",
                "pt-PT": "Rodar para a direita:",
                "ru-RU": " :",
                "tr-TR": "Saa dndr:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The edited height can be changed either by using the height selection in the bottom left corner, or holding the shift key and scrolling the mouse wheel. Alternatively, you can use the following keyboard keys:": {
                ar: "                Shift   .         :",
                "de-DE": "Die bearbeitete Hhe kann entweder durch Verwendung der Hhenauswahl in der unteren linken Ecke gendert werden oder indem Sie die Umschalttaste gedrckt halten und das Mausrad scrollen. Alternativ knnen Sie die folgenden Tasten verwenden:",
                "es-ES": "La altura editada se puede cambiar ya sea usando la seleccin de altura en la esquina inferior izquierda, o manteniendo presionada la tecla de maysculas y desplazando la rueda del ratn. Alternativamente, puedes usar las siguientes teclas del teclado:",
                "fr-FR": "La hauteur modifie peut tre change en utilisant la slection de hauteur dans le coin infrieur gauche, ou en maintenant la touche Maj enfonce et en faisant dfiler la molette de la souris. Alternativement, vous pouvez utiliser les touches de clavier suivantes :",
                "it-IT": "L'altezza modificata pu essere cambiata utilizzando la selezione dell'altezza nell'angolo in basso a sinistra, o tenendo premuto il tasto shift e scorrendo la rotella del mouse. In alternativa, puoi utilizzare i seguenti tasti della tastiera:",
                "ja-JP": "Shift:",
                "ko-KR": "        Shift         .       .",
                "pl-PL": "Edytowan wysoko mona zmieni, korzystajc z wyboru wysokoci w lewym dolnym rogu lub przytrzymujc klawisz Shift i przewijajc kko myszy. Alternatywnie mona uy nastpujcych klawiszy na klawiaturze:",
                "pt-BR": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo ou segurando a tecla shift e rolando a roda do mouse. Alternativamente, voc pode usar as seguintes teclas do teclado:",
                "pt-PT": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo ou segurando a tecla shift e rolando a roda do mouse. Alternativamente, voc pode usar as seguintes teclas do teclado:",
                "ru-RU": "                Shift    .  ,     :",
                "tr-TR": "Dzenlenen ykseklik, sol alt kedeki ykseklik seimini kullanarak veya Shift tuunu basl tutarak ve fare tekerleini kaydrarak deitirilebilir. Alternatif olarak, aadaki klavye tularn kullanabilirsiniz:",
                "uk-UA": "   ,           Shift    . ,       :",
                "zh-CN": "Shift",
                "zh-TW": "Shift"
            },
            "Move up:": {
                ar: " :",
                "de-DE": "Nach oben bewegen:",
                "es-ES": "Mover hacia arriba:",
                "fr-FR": "Monter :",
                "it-IT": "Muovi su:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Przesu w gr:",
                "pt-BR": "Mover para cima:",
                "pt-PT": "Mover para cima:",
                "ru-RU": " :",
                "tr-TR": "Yukar hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move down:": {
                ar: " :",
                "de-DE": "Nach unten bewegen:",
                "es-ES": "Mover hacia abajo:",
                "fr-FR": "Descendre :",
                "it-IT": "Muovi gi:",
                "ja-JP": ":",
                "ko-KR": " :",
                "pl-PL": "Przesu w d:",
                "pt-BR": "Mover para baixo:",
                "pt-PT": "Mover para baixo:",
                "ru-RU": " :",
                "tr-TR": "Aa hareket et:",
                "uk-UA": " :",
                "zh-CN": "",
                "zh-TW": ""
            },
            Editing: {
                ar: "",
                "de-DE": "Bearbeiten",
                "es-ES": "Edicin",
                "fr-FR": "dition",
                "it-IT": "Modifica",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Edycja",
                "pt-BR": "Edio",
                "pt-PT": "Edio",
                "ru-RU": "",
                "tr-TR": "Dzenleme",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track parts can be selected in the menu on the right after which they can be placed by left clicking with the mouse.": {
                ar: "                .",
                "de-DE": "Streckenteile knnen im Men auf der rechten Seite ausgewhlt werden, danach knnen sie durch Linksklick mit der Maus platziert werden.",
                "es-ES": "Las partes de la pista se pueden seleccionar en el men de la derecha, despus de lo cual se pueden colocar haciendo clic izquierdo con el ratn.",
                "fr-FR": "Les parties de la piste peuvent tre slectionnes dans le menu de droite, aprs quoi elles peuvent tre places en cliquant avec le bouton gauche de la souris.",
                "it-IT": "Le parti del percorso possono essere selezionate nel menu a destra, dopodich possono essere posizionate facendo clic con il tasto sinistro del mouse.",
                "ja-JP": "",
                "ko-KR": "           .",
                "pl-PL": "Czci toru mona wybra w menu po prawej stronie, a nastpnie mona je umieci, klikajc lewym przyciskiem myszy.",
                "pt-BR": "As partes da pista podem ser selecionadas no menu  direita e, em seguida, podem ser colocadas clicando com o boto esquerdo do mouse.",
                "pt-PT": "As partes da pista podem ser selecionadas no menu  direita e depois podem ser colocadas clicando com o boto esquerdo do mouse.",
                "ru-RU": "      ,     ,    .",
                "tr-TR": "Paralar, fareyle sol tklayarak yerletirilebilecekleri sa taraftaki menden seilebilir.",
                "uk-UA": "      ,     ,    .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Alternatively, the track part currently hovered by the mouse can be selected with the following keyboard shortcut:": {
                ar: "                 :",
                "de-DE": "Alternativ kann das Streckenteil, ber das die Maus gerade schwebt, mit der folgenden Tastenkombination ausgewhlt werden:",
                "es-ES": "Alternativamente, la parte de la pista actualmente sobrevolada por el ratn se puede seleccionar con el siguiente atajo de teclado:",
                "fr-FR": "Alternativement, la partie de la piste actuellement survole par la souris peut tre slectionne avec le raccourci clavier suivant :",
                "it-IT": "In alternativa, la parte del percorso attualmente sotto il cursore del mouse pu essere selezionata con la seguente scorciatoia da tastiera:",
                "ja-JP": ":",
                "ko-KR": "            .",
                "pl-PL": "Alternatywnie, aktualnie zaznaczon cz toru mona wybra za pomoc nastpujcego skrtu klawiaturowego:",
                "pt-BR": "Alternativamente, a parte da pista atualmente destacada pelo mouse pode ser selecionada com o seguinte atalho de teclado:",
                "pt-PT": "Alternativamente, a parte da pista atualmente destacada pelo mouse pode ser selecionada com o seguinte atalho de teclado:",
                "ru-RU": " ,   ,    ,       :",
                "tr-TR": "Alternatif olarak, fare tarafndan zerine gelinen rota paras aadaki klavye ksayoluyla seilebilir:",
                "uk-UA": ",  ,      ,         :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The selected part can then be rotated using the following keyboard shortcut:": {
                ar: "          :",
                "de-DE": "Das ausgewhlte Teil kann dann mit der folgenden Tastenkombination gedreht werden:",
                "es-ES": "La parte seleccionada se puede girar usando el siguiente atajo de teclado:",
                "fr-FR": "La partie slectionne peut ensuite tre pivote en utilisant le raccourci clavier suivant :",
                "it-IT": "La parte selezionata pu quindi essere ruotata utilizzando la seguente scorciatoia da tastiera:",
                "ja-JP": ":",
                "ko-KR": "        .",
                "pl-PL": "Wybran cz mona nastpnie obrci za pomoc nastpujcego skrtu klawiaturowego:",
                "pt-BR": "A parte selecionada pode ento ser girada usando o seguinte atalho de teclado:",
                "pt-PT": "A parte selecionada pode ento ser girada usando o seguinte atalho de teclado:",
                "ru-RU": "        :",
                "tr-TR": "Seilen para aadaki klavye ksayoluyla dndrlebilir:",
                "uk-UA": "          :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track parts can be deleted by using the delete tool in the right side menu or by holding the following key:": {
                ar: "               :",
                "de-DE": "Streckenteile knnen mit dem Lschwerkzeug im Men auf der rechten Seite gelscht werden oder indem Sie die folgende Taste gedrckt halten:",
                "es-ES": "Las partes de la pista se pueden eliminar usando la herramienta de eliminacin en el men del lado derecho o manteniendo presionada la siguiente tecla:",
                "fr-FR": "Les parties de la piste peuvent tre supprimes en utilisant l'outil de suppression dans le menu de droite ou en maintenant la touche suivante enfonce :",
                "it-IT": "Le parti del percorso possono essere eliminate utilizzando lo strumento di eliminazione nel menu a destra o tenendo premuto il seguente tasto:",
                "ja-JP": ":",
                "ko-KR": "             .",
                "pl-PL": "Czci toru mona usun, korzystajc z narzdzia usuwania w menu po prawej stronie lub przytrzymujc nastpujcy klawisz:",
                "pt-BR": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito ou segurando a seguinte tecla:",
                "pt-PT": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito ou segurando a seguinte tecla:",
                "ru-RU": "              :",
                "tr-TR": "Rota paralar, sa taraftaki mendeki silme arac kullanlarak veya aadaki tua basl tutarak silinebilir:",
                "uk-UA": "   ,           :",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Starting points, checkpoints and the finish line": {
                ar: "     ",
                "de-DE": "Startpunkte, Kontrollpunkte und die Ziellinie",
                "es-ES": "Puntos de inicio, puntos de control y la lnea de meta",
                "fr-FR": "Points de dpart, points de contrle et ligne d'arrive",
                "it-IT": "Punti di partenza, checkpoint e linea di arrivo",
                "ja-JP": "",
                "ko-KR": " ,    ",
                "pl-PL": "Punkty startowe, punkty kontrolne i linia mety",
                "pt-BR": "Pontos de partida, checkpoints e linha de chegada",
                "pt-PT": "Pontos de partida, checkpoints e linha de chegada",
                "ru-RU": " ,     ",
                "tr-TR": "Balang noktalar, kontrol noktalar ve biti izgisi",
                "uk-UA": " ,     ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Starting points, checkpoints and finish lines can all be selected in the uppermost category in the right side menu.": {
                ar: "               .",
                "de-DE": "Startpunkte, Kontrollpunkte und Ziellinien knnen alle in der obersten Kategorie im Men auf der rechten Seite ausgewhlt werden.",
                "es-ES": "Los puntos de inicio, puntos de control y lneas de meta se pueden seleccionar en la categora superior del men del lado derecho.",
                "fr-FR": "Les points de dpart, les points de contrle et les lignes d'arrive peuvent tous tre slectionns dans la catgorie la plus haute du menu de droite.",
                "it-IT": "I punti di partenza, i checkpoint e le linee di arrivo possono essere selezionati nella categoria pi alta nel menu a destra.",
                "ja-JP": "",
                "ko-KR": " ,             .",
                "pl-PL": "Punkty startowe, punkty kontrolne i linie mety mona wybra we wszystkich kategoriach w menu po prawej stronie.",
                "pt-BR": "Pontos de partida, checkpoints e linhas de chegada podem ser selecionados na categoria mais alta do menu lateral direito.",
                "pt-PT": "Pontos de partida, checkpoints e linhas de chegada podem ser selecionados na categoria mais alta do menu lateral direito.",
                "ru-RU": " ,            .",
                "tr-TR": "Balang noktalar, kontrol noktalar ve biti izgileri, sa taraftaki mennn en st kategorisinde seilebilir.",
                "uk-UA": " ,               .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Each track must have at least one starting point. If there are multiple starting points, the last placed one will be used.": {
                ar: "          .            .",
                "de-DE": "Jede Strecke muss mindestens einen Startpunkt haben. Wenn es mehrere Startpunkte gibt, wird der zuletzt platzierte verwendet.",
                "es-ES": "Cada pista debe tener al menos un punto de inicio. Si hay varios puntos de inicio, se usar el ltimo colocado.",
                "fr-FR": "Chaque piste doit avoir au moins un point de dpart. S'il y a plusieurs points de dpart, le dernier plac sera utilis.",
                "it-IT": "Ogni percorso deve avere almeno un punto di partenza. Se ci sono pi punti di partenza, verr utilizzato l'ultimo posizionato.",
                "ja-JP": "1",
                "ko-KR": "       .          .",
                "pl-PL": "Kada trasa musi mie co najmniej jeden punkt startowy. Jeli istnieje wiele punktw startowych, zostanie uyty ostatnio umieszczony.",
                "pt-BR": "Cada pista deve ter pelo menos um ponto de partida. Se houver vrios pontos de partida, o ltimo colocado ser usado.",
                "pt-PT": "Cada pista deve ter pelo menos um ponto de partida. Se houver vrios pontos de partida, o ltimo colocado ser usado.",
                "ru-RU": "        .     ,    .",
                "tr-TR": "Her rota en az bir balang noktasna sahip olmaldr. Birden fazla balang noktas varsa, en son yerletirilen kullanlacaktr.",
                "uk-UA": "       .     ,    .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Checkpoints should be placed between the starting point and the finish line. When a checkpoint track part is selected there will be a tool in the bottom right to select the order of the checkpoint. This determines the order in which the checkpoints must be passed before driving to the finish line. Notice that it is possible to have multiple checkpoints with the same checkpoint order.": {
                ar: "        .                 .               .              .",
                "de-DE": "Kontrollpunkte sollten zwischen dem Startpunkt und der Ziellinie platziert werden. Wenn ein Kontrollpunkt-Streckenteil ausgewhlt ist, gibt es unten rechts ein Werkzeug, um die Reihenfolge des Kontrollpunkts auszuwhlen. Dies bestimmt die Reihenfolge, in der die Kontrollpunkte passiert werden mssen, bevor man zur Ziellinie fhrt. Beachten Sie, dass es mglich ist, mehrere Kontrollpunkte mit derselben Kontrollpunkt-Reihenfolge zu haben.",
                "es-ES": "Los puntos de control deben colocarse entre el punto de inicio y la lnea de meta. Cuando se selecciona una parte de la pista de punto de control, habr una herramienta en la parte inferior derecha para seleccionar el orden del punto de control. Esto determina el orden en que se deben pasar los puntos de control antes de conducir hacia la lnea de meta. Ten en cuenta que es posible tener varios puntos de control con el mismo orden de punto de control.",
                "fr-FR": "Les points de contrle doivent tre placs entre le point de dpart et la ligne d'arrive. Lorsqu'une partie de la piste de point de contrle est slectionne, il y aura un outil en bas  droite pour slectionner l'ordre du point de contrle. Cela dtermine l'ordre dans lequel les points de contrle doivent tre passs avant de conduire jusqu' la ligne d'arrive. Notez qu'il est possible d'avoir plusieurs points de contrle avec le mme ordre de point de contrle.",
                "it-IT": "I checkpoint devono essere posizionati tra il punto di partenza e la linea di arrivo. Quando viene selezionata una parte del percorso checkpoint, ci sar uno strumento in basso a destra per selezionare l'ordine del checkpoint. Questo determina l'ordine in cui i checkpoint devono essere superati prima di arrivare alla linea di arrivo. Nota che  possibile avere pi checkpoint con lo stesso ordine di checkpoint.",
                "ja-JP": "",
                "ko-KR": "       .             .          .            .",
                "pl-PL": "Punkty kontrolne powinny by umieszczone midzy punktem startowym a lini mety. Po wybraniu czci toru punktu kontrolnego pojawi si narzdzie w prawym dolnym rogu, ktre pozwoli wybra kolejno punktu kontrolnego. Okrela to kolejno, w jakiej punkty kontrolne musz by przechodzone przed dojazdem do linii mety. Zauwa, e moliwe jest posiadanie wielu punktw kontrolnych o tej samej kolejnoci.",
                "pt-BR": "Os checkpoints devem ser colocados entre o ponto de partida e a linha de chegada. Quando uma parte da pista de checkpoint  selecionada, haver uma ferramenta no canto inferior direito para selecionar a ordem do checkpoint. Isso determina a ordem em que os checkpoints devem ser passados antes de dirigir at a linha de chegada. Observe que  possvel ter vrios checkpoints com a mesma ordem de checkpoint.",
                "pt-PT": "Os checkpoints devem ser colocados entre o ponto de partida e a linha de chegada. Quando uma parte da pista de checkpoint  selecionada, haver uma ferramenta no canto inferior direito para selecionar a ordem do checkpoint. Isso determina a ordem em que os checkpoints devem ser passados antes de dirigir at a linha de chegada. Observe que  possvel ter vrios checkpoints com a mesma ordem de checkpoint.",
                "ru-RU": "         .                 .   ,            .  ,              .",
                "tr-TR": "Kontrol noktalar, balang noktas ile biti izgisi arasna yerletirilmelidir. Bir kontrol noktas rota paras seildiinde, kontrol noktasnn srasn semek iin sa alt kede bir ara bulunur. Bu, kontrol noktalarnn biti izgisine gitmeden nce geilmesi gereken sray belirler. Ayn kontrol noktas srasna sahip birden fazla kontrol noktas olabileceine dikkat edin.",
                "uk-UA": "         .      ,   '      .   ,            .  ,           .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The finish line is where the track ends but will only become active after all checkpoints have been passed. It is also possible to have multiple finish lines.": {
                ar: "                .         .",
                "de-DE": "Die Ziellinie ist der Ort, an dem die Strecke endet, wird aber erst aktiv, nachdem alle Kontrollpunkte passiert wurden. Es ist auch mglich, mehrere Ziellinien zu haben.",
                "es-ES": "La lnea de meta es donde termina la pista, pero solo se activar despus de que se hayan pasado todos los puntos de control. Tambin es posible tener varias lneas de meta.",
                "fr-FR": "La ligne d'arrive est l'endroit o la piste se termine mais ne deviendra active qu'aprs que tous les points de contrle aient t passs. Il est galement possible d'avoir plusieurs lignes d'arrive.",
                "it-IT": "La linea di arrivo  dove finisce il percorso, ma diventer attiva solo dopo che tutti i checkpoint sono stati superati.  anche possibile avere pi linee di arrivo.",
                "ja-JP": "",
                "ko-KR": "         .       .",
                "pl-PL": "Linia mety to miejsce, gdzie koczy si tor, ale staje si aktywna dopiero po przejciu wszystkich punktw kontrolnych. Moliwe jest rwnie posiadanie wielu linii mety.",
                "pt-BR": "A linha de chegada  onde a pista termina, mas s se tornar ativa depois que todos os checkpoints forem passados. Tambm  possvel ter vrias linhas de chegada.",
                "pt-PT": "A linha de chegada  onde a pista termina, mas s se tornar ativa depois que todos os checkpoints forem passados. Tambm  possvel ter vrias linhas de chegada.",
                "ru-RU": "  -  ,   ,          .      .",
                "tr-TR": "Biti izgisi, rotann bittii yerdir, ancak tm kontrol noktalar geildikten sonra aktif hale gelir. Birden fazla biti izgisi de olabilir.",
                "uk-UA": "  -  ,   ,          .      .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Starting point": {
                ar: " ",
                "de-DE": "Startpunkt",
                "es-ES": "Punto de inicio",
                "fr-FR": "Point de dpart",
                "it-IT": "Punto di partenza",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Punkt startowy",
                "pt-BR": "Ponto de partida",
                "pt-PT": "Ponto de partida",
                "ru-RU": " ",
                "tr-TR": "Balang noktas",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Checkpoint: {
                ar: " ",
                "de-DE": "Kontrollpunkt",
                "es-ES": "Punto de control",
                "fr-FR": "Point de contrle",
                "it-IT": "Checkpoint",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Punkt kontrolny",
                "pt-BR": "Checkpoint",
                "pt-PT": "Checkpoint",
                "ru-RU": " ",
                "tr-TR": "Kontrol noktas",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Finish line": {
                ar: " ",
                "de-DE": "Ziellinie",
                "es-ES": "Lnea de meta",
                "fr-FR": "Ligne d'arrive",
                "it-IT": "Linea di arrivo",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Linia mety",
                "pt-BR": "Linha de chegada",
                "pt-PT": "Linha de chegada",
                "ru-RU": " ",
                "tr-TR": "Biti izgisi",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Exporting the track": {
                ar: " ",
                "de-DE": "Exportieren der Strecke",
                "es-ES": "Exportando la pista",
                "fr-FR": "Exportation de la piste",
                "it-IT": "Esportazione del percorso",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Eksportowanie trasy",
                "pt-BR": "Exportando a pista",
                "pt-PT": "Exportando a pista",
                "ru-RU": " ",
                "tr-TR": "Rotann da aktarlmas",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "When the track is finished, a name for the track can be entered in top left after which the track can be exported using the export button. This will reveal a track code which can be sent to other users so they can import and play the track.": {
                ar: "                   .               .",
                "de-DE": "Wenn die Strecke fertig ist, kann oben links ein Name fr die Strecke eingegeben werden, danach kann die Strecke mit dem Export-Button exportiert werden. Dadurch wird ein Streckencode angezeigt, der an andere Benutzer gesendet werden kann, damit sie die Strecke importieren und spielen knnen.",
                "es-ES": "Cuando la pista est terminada, se puede ingresar un nombre para la pista en la parte superior izquierda, despus de lo cual se puede exportar la pista usando el botn de exportacin. Esto revelar un cdigo de pista que se puede enviar a otros usuarios para que puedan importar y jugar la pista.",
                "fr-FR": "Lorsque la piste est termine, un nom pour la piste peut tre entr en haut  gauche, aprs quoi la piste peut tre exporte en utilisant le bouton d'exportation. Cela rvlera un code de piste qui peut tre envoy  d'autres utilisateurs afin qu'ils puissent importer et jouer la piste.",
                "it-IT": "Quando il percorso  terminato,  possibile inserire un nome per il percorso in alto a sinistra, dopodich il percorso pu essere esportato utilizzando il pulsante di esportazione. Questo riveler un codice del percorso che pu essere inviato ad altri utenti in modo che possano importare e giocare il percorso.",
                "ja-JP": "",
                "ko-KR": "              .            .",
                "pl-PL": "Po zakoczeniu trasy mona wprowadzi jej nazw w lewym grnym rogu, a nastpnie mona j wyeksportowa, korzystajc z przycisku eksportu. To ujawni kod trasy, ktry mona przesa innym uytkownikom, aby mogli zaimportowa i odtworzy tras.",
                "pt-BR": "Quando a pista estiver pronta, um nome para a pista pode ser inserido no canto superior esquerdo e, em seguida, a pista pode ser exportada usando o boto de exportao. Isso revelar um cdigo de pista que pode ser enviado para outros usurios para que eles possam importar e jogar a pista.",
                "pt-PT": "Quando a pista estiver pronta, um nome para a pista pode ser inserido no canto superior esquerdo, aps o qual a pista pode ser exportada usando o boto de exportao. Isso revelar um cdigo de pista que pode ser enviado para outros usurios para que eles possam importar e jogar a pista.",
                "ru-RU": "  ,        ,         .     ,     ,        .",
                "tr-TR": "Rota tamamlandnda, rota iin bir ad girilebilir ve ardndan rota dmesini kullanarak rota da aktarlabilir. Bu, dier kullanclara gnderilebilecek bir rota kodunu ortaya karr, bylece rota ie aktarlabilir ve oynanabilir.",
                "uk-UA": "  ,      ,     ,   .    ,     ,       .",
                "zh-CN": "",
                "zh-TW": ""
            },
            Close: {
                ar: "",
                "de-DE": "Schlieen",
                "es-ES": "Cerrar",
                "fr-FR": "Fermer",
                "it-IT": "Chiudi",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zamknij",
                "pt-BR": "Fechar",
                "pt-PT": "Fechar",
                "ru-RU": "",
                "tr-TR": "Kapat",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Not set": {
                ar: " ",
                "de-DE": "Nicht festgelegt",
                "es-ES": "No establecido",
                "fr-FR": "Non dfini",
                "it-IT": "Non impostato",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Nie ustawiono",
                "pt-BR": "No definido",
                "pt-PT": "No definido",
                "ru-RU": " ",
                "tr-TR": "Ayarlanmad",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            or: {
                ar: "",
                "de-DE": "oder",
                "es-ES": "o",
                "fr-FR": "ou",
                "it-IT": "o",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "lub",
                "pt-BR": "ou",
                "pt-PT": "ou",
                "ru-RU": "",
                "tr-TR": "veya",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The camera can be moved by dragging with one finger. Rotate the camera by dragging with two fingers. Zoom in and out by pinching.": {
                ar: "        .         ( )           .        .",
                "de-DE": "Die Kamera kann durch Ziehen mit einem Finger bewegt werden. Drehen Sie die Kamera, indem Sie mit zwei Fingern ziehen. Zoomen Sie rein und raus, indem Sie kneifen.",
                "es-ES": "La cmara se puede mover arrastrando con un dedo. Gira la cmara arrastrando con dos dedos. Acrcate y aljate pellizcando.",
                "fr-FR": "La camra peut tre dplace en faisant glisser un doigt. Faites pivoter la camra en faisant glisser deux doigts. Zoomez avant et arrire en pinant.",
                "it-IT": "La telecamera pu essere spostata trascinando con un dito. Ruota la telecamera trascinando con due dita. Zoom avanti e indietro pizzicando.",
                "ja-JP": "12",
                "ko-KR": "      .       .      .",
                "pl-PL": "Kamer mona przesuwa, przecigajc jednym palcem. Obr kamer, przecigajc dwoma palcami. Przybli i oddal obraz, ciskajc palcami.",
                "pt-BR": "A cmera pode ser movida arrastando com um dedo. Gire a cmera arrastando com dois dedos. Amplie e reduza o zoom beliscando.",
                "pt-PT": "A cmera pode ser movida arrastando com um dedo. Rode a cmera arrastando com dois dedos. Aproxime e afaste o zoom beliscando.",
                "ru-RU": "  ,   .  ,   .    ,    .",
                "tr-TR": "Kameray bir parmakla srkleyerek hareket ettirebilirsiniz. Kameray iki parmakla srkleyerek dndrebilirsiniz. Yaknlatrmak ve uzaklatrmak iin sktrabilirsiniz.",
                "uk-UA": "  ,   .  ,   .    ,  .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The edited height can be changed by using the height selection in the bottom left corner.": {
                ar: "          .",
                "de-DE": "Die bearbeitete Hhe kann durch Verwendung der Hhenauswahl in der unteren linken Ecke gendert werden.",
                "es-ES": "La altura editada se puede cambiar usando la seleccin de altura en la esquina inferior izquierda.",
                "fr-FR": "La hauteur modifie peut tre change en utilisant la slection de hauteur dans le coin infrieur gauche.",
                "it-IT": "L'altezza modificata pu essere cambiata utilizzando la selezione dell'altezza nell'angolo in basso a sinistra.",
                "ja-JP": "",
                "ko-KR": "         .",
                "pl-PL": "Edytowan wysoko mona zmieni, korzystajc z wyboru wysokoci w lewym dolnym rogu.",
                "pt-BR": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo.",
                "pt-PT": "A altura editada pode ser alterada usando a seleo de altura no canto inferior esquerdo.",
                "ru-RU": "            .",
                "tr-TR": "Dzenlenen ykseklik, sol alt kedeki ykseklik seimi kullanlarak deitirilebilir.",
                "uk-UA": "   ,       .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track parts can be selected in the menu on the right after which they can be placed by tapping on the screen.": {
                ar: "               .",
                "de-DE": "Streckenteile knnen im Men auf der rechten Seite ausgewhlt werden, danach knnen sie durch Antippen des Bildschirms platziert werden.",
                "es-ES": "Las partes de la pista se pueden seleccionar en el men de la derecha, despus de lo cual se pueden colocar tocando la pantalla.",
                "fr-FR": "Les parties de la piste peuvent tre slectionnes dans le menu de droite, aprs quoi elles peuvent tre places en tapant sur l'cran.",
                "it-IT": "Le parti del percorso possono essere selezionate nel menu a destra, dopodich possono essere posizionate toccando lo schermo.",
                "ja-JP": "",
                "ko-KR": "          .",
                "pl-PL": "Czci toru mona wybra w menu po prawej stronie, a nastpnie mona je umieci, dotykajc ekranu.",
                "pt-BR": "As partes da pista podem ser selecionadas no menu  direita e, em seguida, podem ser colocadas tocando na tela.",
                "pt-PT": "As partes da pista podem ser selecionadas no menu  direita e depois podem ser colocadas tocando na tela.",
                "ru-RU": "      ,     ,  .",
                "tr-TR": "Paralar, ekrana dokunarak yerletirilebilecekleri sa taraftaki menden seilebilir.",
                "uk-UA": "      ,     ,   .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "The selected part can then be rotated by tapping the rotate button in the bottom left corner.": {
                ar: "             .",
                "de-DE": "Das ausgewhlte Teil kann dann durch Antippen der Drehen-Schaltflche in der unteren linken Ecke gedreht werden.",
                "es-ES": "La parte seleccionada se puede girar tocando el botn de rotacin en la esquina inferior izquierda.",
                "fr-FR": "La partie slectionne peut ensuite tre pivote en tapant sur le bouton de rotation dans le coin infrieur gauche.",
                "it-IT": "La parte selezionata pu quindi essere ruotata toccando il pulsante di rotazione nell'angolo in basso a sinistra.",
                "ja-JP": "",
                "ko-KR": "         .",
                "pl-PL": "Wybran cz mona nastpnie obrci, dotykajc przycisku obracania w lewym dolnym rogu.",
                "pt-BR": "A parte selecionada pode ento ser girada tocando no boto de rotao no canto inferior esquerdo.",
                "pt-PT": "A parte selecionada pode ento ser girada tocando no boto de rotao no canto inferior esquerdo.",
                "ru-RU": "   ,       .",
                "tr-TR": "Seilen para, sol alt kedeki dndr dmesine dokunarak dndrlebilir.",
                "uk-UA": "   ,       .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track parts can be deleted by using the delete tool in the right side menu.": {
                ar: "          .",
                "de-DE": "Streckenteile knnen mit dem Lschwerkzeug im Men auf der rechten Seite gelscht werden.",
                "es-ES": "Las partes de la pista se pueden eliminar usando la herramienta de eliminacin en el men del lado derecho.",
                "fr-FR": "Les parties de la piste peuvent tre supprimes en utilisant l'outil de suppression dans le menu de droite.",
                "it-IT": "Le parti del percorso possono essere eliminate utilizzando lo strumento di eliminazione nel menu a destra.",
                "ja-JP": "",
                "ko-KR": "         .",
                "pl-PL": "Czci toru mona usun, korzystajc z narzdzia usuwania w menu po prawej stronie.",
                "pt-BR": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito.",
                "pt-PT": "As partes da pista podem ser excludas usando a ferramenta de excluso no menu lateral direito.",
                "ru-RU": "          .",
                "tr-TR": "Paralar, sa taraftaki mendeki silme arac kullanlarak silinebilir.",
                "uk-UA": "   ,       .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to quit?": {
                ar: "     ",
                "de-DE": "Sind Sie sicher, dass Sie beenden mchten?",
                "es-ES": "Ests seguro de que quieres salir?",
                "fr-FR": "tes-vous sr de vouloir quitter?",
                "it-IT": "Sei sicuro di voler uscire?",
                "ja-JP": "",
                "ko-KR": " ?",
                "pl-PL": "Czy na pewno chcesz zakoczy?",
                "pt-BR": "Tem certeza de que deseja sair?",
                "pt-PT": "Tem a certeza de que quer sair?",
                "ru-RU": " ,   ?",
                "tr-TR": "kmak istediinizden emin misiniz?",
                "uk-UA": " ,   ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "All connected players will be disconnected!": {
                ar: "     !",
                "de-DE": "Alle verbundenen Spieler werden getrennt!",
                "es-ES": "Todos los jugadores conectados sern desconectados!",
                "fr-FR": "Tous les joueurs connects seront dconnects!",
                "it-IT": "Tutti i giocatori connessi verranno disconnessi!",
                "ja-JP": "",
                "ko-KR": "    !",
                "pl-PL": "Wszyscy poczeni gracze zostan rozczeni!",
                "pt-BR": "Todos os jogadores conectados sero desconectados!",
                "pt-PT": "Todos os jogadores conectados sero desconectados!",
                "ru-RU": "    !",
                "tr-TR": "Tm bal oyuncularn balants kesilecek!",
                "uk-UA": "    !",
                "zh-CN": "",
                "zh-TW": ""
            },
            Watch: {
                ar: "",
                "de-DE": "Zuschauen",
                "es-ES": "Ver",
                "fr-FR": "Regarder",
                "it-IT": "Guarda",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Ogldaj",
                "pt-BR": "Assistir",
                "pt-PT": "Ver",
                "ru-RU": "",
                "tr-TR": "zle",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Next Track": {
                ar: " ",
                "de-DE": "Nchste Strecke",
                "es-ES": "Siguiente pista",
                "fr-FR": "Piste suivante",
                "it-IT": "Traccia successiva",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Nastpny tor",
                "pt-BR": "Prxima pista",
                "pt-PT": "Prxima pista",
                "ru-RU": " ",
                "tr-TR": "Sonraki Para",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Invite: {
                ar: "",
                "de-DE": "Einladen",
                "es-ES": "Invitar",
                "fr-FR": "Inviter",
                "it-IT": "Invita",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zapro",
                "pt-BR": "Convidar",
                "pt-PT": "Convidar",
                "ru-RU": "",
                "tr-TR": "Davet et",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Players: {
                ar: "",
                "de-DE": "Spieler",
                "es-ES": "Jugadores",
                "fr-FR": "Joueurs",
                "it-IT": "Giocatori",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Gracze",
                "pt-BR": "Jogadores",
                "pt-PT": "Jogadores",
                "ru-RU": "",
                "tr-TR": "Oyuncular",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Change Track": {
                ar: " ",
                "de-DE": "Strecke ndern",
                "es-ES": "Cambiar pista",
                "fr-FR": "Changer de piste",
                "it-IT": "Cambia traccia",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Zmie tor",
                "pt-BR": "Mudar pista",
                "pt-PT": "Mudar pista",
                "ru-RU": " ",
                "tr-TR": "Paray Deitir",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Session Results": {
                ar: " ",
                "de-DE": "Sitzungsergebnisse",
                "es-ES": "Resultados de la sesin",
                "fr-FR": "Rsultats de la session",
                "it-IT": "Risultati della sessione",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wyniki sesji",
                "pt-BR": "Resultados da sesso",
                "pt-PT": "Resultados da sesso",
                "ru-RU": " ",
                "tr-TR": "Oturum Sonular",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "A new session will start shortly": {
                ar: "   ",
                "de-DE": "Eine neue Sitzung wird in Krze starten",
                "es-ES": "Una nueva sesin comenzar en breve",
                "fr-FR": "Une nouvelle session commencera bientt",
                "it-IT": "Una nuova sessione inizier a breve",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Wkrtce rozpocznie si nowa sesja",
                "pt-BR": "Uma nova sesso comear em breve",
                "pt-PT": "Uma nova sesso comear em breve",
                "ru-RU": "   ",
                "tr-TR": "Ksa sre iinde yeni bir oturum balayacak",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            'Are you sure you want to kick the player "{0}"?': {
                ar: '       "{0}"',
                "de-DE": 'Sind Sie sicher, dass Sie den Spieler "{0}" kicken mchten?',
                "es-ES": 'Ests seguro de que quieres expulsar al jugador "{0}"?',
                "fr-FR": 'tes-vous sr de vouloir expulser le joueur "{0}"?',
                "it-IT": 'Sei sicuro di voler espellere il giocatore "{0}"?',
                "ja-JP": "{0}",
                "ko-KR": ' "{0}"() ?',
                "pl-PL": 'Czy na pewno chcesz wyrzuci gracza "{0}"?',
                "pt-BR": 'Tem certeza de que deseja expulsar o jogador "{0}"?',
                "pt-PT": 'Tem a certeza de que quer expulsar o jogador "{0}"?',
                "ru-RU": ' ,     "{0}"?',
                "tr-TR": '"{0}" oyuncusunu atmak istediinizden emin misiniz?',
                "uk-UA": ' ,     "{0}"?',
                "zh-CN": "{0}",
                "zh-TW": "{0}"
            },
            Kick: {
                ar: "",
                "de-DE": "Kicken",
                "es-ES": "Expulsar",
                "fr-FR": "Expulser",
                "it-IT": "Espelli",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wyrzu",
                "pt-BR": "Expulsar",
                "pt-PT": "Expulsar",
                "ru-RU": "",
                "tr-TR": "At",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Loading replay": {
                ar: "  ",
                "de-DE": "Wiederholung laden",
                "es-ES": "Cargando repeticin",
                "fr-FR": "Chargement de l'enregistrement",
                "it-IT": "Caricamento riproduzione",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wczytywanie nagrania",
                "pt-BR": "Carregando replay",
                "pt-PT": "A carregar replay",
                "ru-RU": " ",
                "tr-TR": "Tekrar ykleniyor",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Press {0} to return to the last checkpoint": {
                ar: " {0}     ",
                "de-DE": "Drcken Sie {0}, um zum letzten Kontrollpunkt zurckzukehren",
                "es-ES": "Presiona {0} para volver al ltimo punto de control",
                "fr-FR": "Appuyez sur {0} pour retourner au dernier point de contrle",
                "it-IT": "Premi {0} per tornare all'ultimo checkpoint",
                "ja-JP": " {0} ",
                "ko-KR": "   {0}() ",
                "pl-PL": "Nacinij {0}, aby wrci do ostatniego punktu kontrolnego",
                "pt-BR": "Pressione {0} para retornar ao ltimo checkpoint",
                "pt-PT": "Pressione {0} para voltar ao ltimo checkpoint",
                "ru-RU": " {0},      ",
                "tr-TR": "Son kontrol noktasna dnmek iin {0} tuuna basn",
                "uk-UA": " {0},      ",
                "zh-CN": " {0} ",
                "zh-TW": " {0} "
            },
            "Press {0} to start over": {
                ar: " {0}   ",
                "de-DE": "Drcken Sie {0}, um von vorne zu beginnen",
                "es-ES": "Presiona {0} para empezar de nuevo",
                "fr-FR": "Appuyez sur {0} pour recommencer",
                "it-IT": "Premi {0} per ricominciare",
                "ja-JP": " {0} ",
                "ko-KR": "  {0}() ",
                "pl-PL": "Nacinij {0}, aby zacz od nowa",
                "pt-BR": "Pressione {0} para comear de novo",
                "pt-PT": "Pressione {0} para comear de novo",
                "ru-RU": " {0},   ",
                "tr-TR": "Batan balamak iin {0} tuuna basn",
                "uk-UA": " {0},   ",
                "zh-CN": " {0} ",
                "zh-TW": " {0} "
            },
            "Reset once to return to the last checkpoint": {
                ar: "        ",
                "de-DE": "Einmal zurcksetzen, um zum letzten Kontrollpunkt zurckzukehren",
                "es-ES": "Restablecer una vez para volver al ltimo punto de control",
                "fr-FR": "Rinitialisez une fois pour retourner au dernier point de contrle",
                "it-IT": "Resetta una volta per tornare all'ultimo checkpoint",
                "ja-JP": "1",
                "ko-KR": "     ",
                "pl-PL": "Resetuj raz, aby wrci do ostatniego punktu kontrolnego",
                "pt-BR": "Redefinir uma vez para retornar ao ltimo checkpoint",
                "pt-PT": "Repor uma vez para voltar ao ltimo checkpoint",
                "ru-RU": "  ,      ",
                "tr-TR": "Son kontrol noktasna dnmek iin bir kez sfrlayn",
                "uk-UA": "  ,      ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Reset again to start over": {
                ar: "      ",
                "de-DE": "Erneut zurcksetzen, um von vorne zu beginnen",
                "es-ES": "Restablecer de nuevo para empezar de nuevo",
                "fr-FR": "Rinitialisez  nouveau pour recommencer",
                "it-IT": "Resetta di nuovo per ricominciare",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Resetuj ponownie, aby zacz od nowa",
                "pt-BR": "Redefinir novamente para comear de novo",
                "pt-PT": "Repor novamente para comear de novo",
                "ru-RU": "  ,   ",
                "tr-TR": "Batan balamak iin tekrar sfrlayn",
                "uk-UA": "  ,   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Leaderboard: {
                ar: "",
                "de-DE": "Bestenliste",
                "es-ES": "Tabla de clasificacin",
                "fr-FR": "Classement",
                "it-IT": "Classifica",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Tabela wynikw",
                "pt-BR": "Quadro de Lderes",
                "pt-PT": "Tabela de Classificao",
                "ru-RU": " ",
                "tr-TR": "Liderlik Tablosu",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "{0} players": {
                ar: "{0} ",
                "de-DE": "{0} Spieler",
                "es-ES": "{0} jugadores",
                "fr-FR": "{0} joueurs",
                "it-IT": "{0} giocatori",
                "ja-JP": "{0} ",
                "ko-KR": "{0} ",
                "pl-PL": "{0} graczy",
                "pt-BR": "{0} jogadores",
                "pt-PT": "{0} jogadores",
                "ru-RU": "{0} ",
                "tr-TR": "{0} oyuncu",
                "uk-UA": "{0} ",
                "zh-CN": "{0} ",
                "zh-TW": "{0} "
            },
            Back: {
                ar: "",
                "de-DE": "Zurck",
                "es-ES": "Volver",
                "fr-FR": "Retour",
                "it-IT": "Indietro",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Powrt",
                "pt-BR": "Voltar",
                "pt-PT": "Voltar",
                "ru-RU": "",
                "tr-TR": "Geri",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Error: Failed to load leaderboard": {
                ar: ":   ",
                "de-DE": "Fehler: Laden der Bestenliste fehlgeschlagen",
                "es-ES": "Error: No se pudo cargar la tabla de clasificacin",
                "fr-FR": "Erreur : chec du chargement du classement",
                "it-IT": "Errore: impossibile caricare la classifica",
                "ja-JP": "",
                "ko-KR": ":   ",
                "pl-PL": "Bd: Nie mona wczyta tabeli wynikw",
                "pt-BR": "Erro: Falha ao carregar o quadro de lderes",
                "pt-PT": "Erro: Falha ao carregar a tabela de classificao",
                "ru-RU": ":     ",
                "tr-TR": "Hata: Liderlik tablosu yklenemedi",
                "uk-UA": ":     ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Unofficial versions of the game cannot access the leaderboard": {
                ar: "         ",
                "de-DE": "Inoffizielle Versionen des Spiels knnen nicht auf die Bestenliste zugreifen",
                "es-ES": "Las versiones no oficiales del juego no pueden acceder a la tabla de clasificacin",
                "fr-FR": "Les versions non officielles du jeu ne peuvent pas accder au classement",
                "it-IT": "Le versioni non ufficiali del gioco non possono accedere alla classifica",
                "ja-JP": "",
                "ko-KR": "      ",
                "pl-PL": "Nieoficjalne wersje gry nie mog uzyska dostpu do tabeli wynikw",
                "pt-BR": "Verses no oficiais do jogo no podem acessar o quadro de lderes",
                "pt-PT": "Verses no oficiais do jogo no podem acessar a tabela de classificao",
                "ru-RU": "         ",
                "tr-TR": "Oyunun resmi olmayan srmleri liderlik tablosuna eriemez",
                "uk-UA": "         ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Pending: {
                ar: " ",
                "de-DE": "Ausstehend",
                "es-ES": "Pendiente",
                "fr-FR": "En attente",
                "it-IT": "In sospeso",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Oczekujcy",
                "pt-BR": "Pendente",
                "pt-PT": "Pendente",
                "ru-RU": " ",
                "tr-TR": "Beklemede",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Verified: {
                ar: " ",
                "de-DE": "Verifiziert",
                "es-ES": "Verificado",
                "fr-FR": "Vrifi",
                "it-IT": "Verificato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zweryfikowany",
                "pt-BR": "Verificado",
                "pt-PT": "Verificado",
                "ru-RU": "",
                "tr-TR": "Doruland",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Invalid: {
                ar: " ",
                "de-DE": "Ungltig",
                "es-ES": "Invlido",
                "fr-FR": "Invalide",
                "it-IT": "Non valido",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Nieprawidowy",
                "pt-BR": "Invlido",
                "pt-PT": "Invlido",
                "ru-RU": "",
                "tr-TR": "Geersiz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Duplicate: {
                ar: "",
                "de-DE": "Duplikat",
                "es-ES": "Duplicado",
                "fr-FR": "Doublon",
                "it-IT": "Duplicato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Duplikat",
                "pt-BR": "Duplicado",
                "pt-PT": "Duplicado",
                "ru-RU": "",
                "tr-TR": "ift",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            You: {
                ar: "",
                "de-DE": "Sie",
                "es-ES": "T",
                "fr-FR": "Vous",
                "it-IT": "Tu",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Ty",
                "pt-BR": "Voc",
                "pt-PT": "Voc",
                "ru-RU": "",
                "tr-TR": "Sen",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Only verified": {
                ar: " ",
                "de-DE": "Nur verifizierte",
                "es-ES": "Solo verificados",
                "fr-FR": "Uniquement vrifis",
                "it-IT": "Solo verificati",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Tylko zweryfikowane",
                "pt-BR": "Apenas verificados",
                "pt-PT": "Apenas verificados",
                "ru-RU": " ",
                "tr-TR": "Sadece dorulanm",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Loading: {
                ar: " ",
                "de-DE": "Laden",
                "es-ES": "Cargando",
                "fr-FR": "Chargement",
                "it-IT": "Caricamento",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "adowanie",
                "pt-BR": "Carregando",
                "pt-PT": "A Carregar",
                "ru-RU": "",
                "tr-TR": "Ykleniyor",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to load recordings": {
                ar: "  ",
                "de-DE": "Aufnahmen konnten nicht geladen werden",
                "es-ES": "Error al cargar las grabaciones",
                "fr-FR": "chec du chargement des enregistrements",
                "it-IT": "Impossibile caricare le registrazioni",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nie udao si wczyta nagra",
                "pt-BR": "Falha ao carregar gravaes",
                "pt-PT": "Falha ao carregar as gravaes",
                "ru-RU": "   ",
                "tr-TR": "Kaytlar yklenemedi",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to load track": {
                ar: "  ",
                "de-DE": "Strecke konnte nicht geladen werden",
                "es-ES": "Error al cargar la pista",
                "fr-FR": "chec du chargement de la piste",
                "it-IT": "Impossibile caricare il tracciato",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nie udao si wczyta toru",
                "pt-BR": "Falha ao carregar a pista",
                "pt-PT": "Falha ao carregar a pista",
                "ru-RU": "   ",
                "tr-TR": "Para yklenemedi",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Cannot load recordings due to non-determinism": {
                ar: "      ",
                "de-DE": "Aufgrund von Nicht-Determinismus knnen keine Aufnahmen geladen werden",
                "es-ES": "No se pueden cargar las grabaciones debido a la no determinismo",
                "fr-FR": "Impossible de charger les enregistrements en raison du non-dterminisme",
                "it-IT": "Impossibile caricare le registrazioni a causa del non determinismo",
                "ja-JP": "",
                "ko-KR": "     ",
                "pl-PL": "Nie mona wczyta nagra z powodu nieterminizmu",
                "pt-BR": "No  possvel carregar gravaes devido a no determinismo",
                "pt-PT": "No  possvel carregar as gravaes devido ao no determinismo",
                "ru-RU": "   - ",
                "tr-TR": "Belirlenim dlktan dolay kaytlar yklenemiyor",
                "uk-UA": "     ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Ok: {
                ar: "",
                "de-DE": "Ok",
                "es-ES": "Aceptar",
                "fr-FR": "OK",
                "it-IT": "Ok",
                "ja-JP": "OK",
                "ko-KR": "",
                "pl-PL": "Ok",
                "pt-BR": "Ok",
                "pt-PT": "Ok",
                "ru-RU": "",
                "tr-TR": "Tamam",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Track is missing starting point": {
                ar: "   ",
                "de-DE": "Strecke hat keinen Startpunkt",
                "es-ES": "Falta el punto de inicio en la pista",
                "fr-FR": "La piste n'a pas de point de dpart",
                "it-IT": "Il percorso non ha un punto di partenza",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Brak punktu startowego na trasie",
                "pt-BR": "Pista est sem ponto de partida",
                "pt-PT": "A pista no tem ponto de partida",
                "ru-RU": "    ",
                "tr-TR": "Rota balang noktas eksik",
                "uk-UA": "    ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Some leaderboard features are disabled.": {
                ar: "    .",
                "de-DE": "Einige Bestenlistenfunktionen sind deaktiviert.",
                "es-ES": "Algunas funciones de la tabla de clasificacin estn desactivadas.",
                "fr-FR": "Certaines fonctionnalits du classement sont dsactives.",
                "it-IT": "Alcune funzionalit della classifica sono disabilitate.",
                "ja-JP": "",
                "ko-KR": "   .",
                "pl-PL": "Niektre funkcje tabeli wynikw s wyczone.",
                "pt-BR": "Alguns recursos do quadro de lderes esto desativados.",
                "pt-PT": "Algumas funcionalidades da tabela de classificao esto desativadas.",
                "ru-RU": "    .",
                "tr-TR": "Baz liderlik tablosu zellikleri devre d brakld.",
                "uk-UA": "    .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "WebRTC is not supported in this browser.": {
                ar: "WebRTC     .",
                "de-DE": "WebRTC wird in diesem Browser nicht untersttzt.",
                "es-ES": "WebRTC no es compatible con este navegador.",
                "fr-FR": "WebRTC n'est pas pris en charge dans ce navigateur.",
                "it-IT": "WebRTC non  supportato in questo browser.",
                "ja-JP": "WebRTC",
                "ko-KR": "  WebRTC  .",
                "pl-PL": "WebRTC nie jest obsugiwany w tej przegldarce.",
                "pt-BR": "WebRTC no  suportado neste navegador.",
                "pt-PT": "WebRTC no  suportado neste navegador.",
                "ru-RU": "WebRTC     .",
                "tr-TR": "WebRTC bu taraycda desteklenmiyor.",
                "uk-UA": "WebRTC     .",
                "zh-CN": "WebRTC",
                "zh-TW": " WebRTC"
            },
            "Please try another browser or device.": {
                ar: "     .",
                "de-DE": "Bitte versuchen Sie einen anderen Browser oder ein anderes Gert.",
                "es-ES": "Por favor, prueba otro navegador o dispositivo.",
                "fr-FR": "Veuillez essayer un autre navigateur ou appareil.",
                "it-IT": "Si prega di provare un altro browser o dispositivo.",
                "ja-JP": "",
                "ko-KR": "   .",
                "pl-PL": "Prosz sprbowa inn przegldark lub urzdzenie.",
                "pt-BR": "Por favor, tente outro navegador ou dispositivo.",
                "pt-PT": "Por favor, tente outro navegador ou dispositivo.",
                "ru-RU": ",     .",
                "tr-TR": "Ltfen baka bir tarayc veya cihaz deneyin.",
                "uk-UA": " ,     .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Multiplayer is experimental!": {
                ar: "  !",
                "de-DE": "Mehrspieler ist experimentell!",
                "es-ES": "El multijugador es experimental!",
                "fr-FR": "Le multijoueur est exprimental !",
                "it-IT": "Il multiplayer  sperimentale!",
                "ja-JP": "",
                "ko-KR": " !",
                "pl-PL": "Tryb wieloosobowy jest eksperymentalny!",
                "pt-BR": "O multiplayer  experimental!",
                "pt-PT": "O multijogador  experimental!",
                "ru-RU": "   !",
                "tr-TR": "ok oyunculu deneysel bir zelliktir!",
                "uk-UA": "   !",
                "zh-CN": "",
                "zh-TW": ""
            },
            "You may experience connectivity issues or other problems.": {
                ar: "       .",
                "de-DE": "Es knnen Verbindungsprobleme oder andere Probleme auftreten.",
                "es-ES": "Es posible que experimentes problemas de conectividad u otros problemas.",
                "fr-FR": "Vous pouvez rencontrer des problmes de connectivit ou d'autres problmes.",
                "it-IT": "Potresti riscontrare problemi di connettivit o altri problemi.",
                "ja-JP": "",
                "ko-KR": "       .",
                "pl-PL": "Moesz napotka problemy z cznoci lub inne problemy.",
                "pt-BR": "Voc pode enfrentar problemas de conectividade ou outros problemas.",
                "pt-PT": "Pode experimentar problemas de conectividade ou outros problemas.",
                "ru-RU": "        .",
                "tr-TR": "Balant sorunlar veya dier problemler yaayabilirsiniz.",
                "uk-UA": "        .",
                "zh-CN": "",
                "zh-TW": ""
            },
            Continue: {
                ar: "",
                "de-DE": "Fortsetzen",
                "es-ES": "Continuar",
                "fr-FR": "Continuer",
                "it-IT": "Continua",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Kontynuuj",
                "pt-BR": "Continuar",
                "pt-PT": "Continuar",
                "ru-RU": "",
                "tr-TR": "Devam et",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "You already have another instance of PolyTrack open.": {
                ar: "     PolyTrack .",
                "de-DE": "Sie haben bereits eine andere Instanz von PolyTrack geffnet.",
                "es-ES": "Ya tienes otra instancia de PolyTrack abierta.",
                "fr-FR": "Vous avez dj une autre instance de PolyTrack ouverte.",
                "it-IT": "Hai gi un'altra istanza di PolyTrack aperta.",
                "ja-JP": "PolyTrack",
                "ko-KR": "  PolyTrack   .",
                "pl-PL": "Masz ju otwart inn instancj PolyTrack.",
                "pt-BR": "Voc j tem outra instncia do PolyTrack aberta.",
                "pt-PT": "J tem outra instncia do PolyTrack aberta.",
                "ru-RU": "      PolyTrack.",
                "tr-TR": "Zaten PolyTrack'in baka bir rneini atnz.",
                "uk-UA": "      PolyTrack .",
                "zh-CN": "PolyTrack",
                "zh-TW": " PolyTrack "
            },
            "Please switch to that tab or window to continue.": {
                ar: "       .",
                "de-DE": "Bitte wechseln Sie zu diesem Tab oder Fenster, um fortzufahren.",
                "es-ES": "Por favor, cambia a esa pestaa o ventana para continuar.",
                "fr-FR": "Veuillez basculer vers cet onglet ou cette fentre pour continuer.",
                "it-IT": "Si prega di passare a quella scheda o finestra per continuare.",
                "ja-JP": "",
                "ko-KR": "    .",
                "pl-PL": "Prosz przeczy si na ten kart lub okno, aby kontynuowa.",
                "pt-BR": "Por favor, mude para aquela guia ou janela para continuar.",
                "pt-PT": "Por favor, mude para essa aba ou janela para continuar.",
                "ru-RU": ",      ,  .",
                "tr-TR": "Devam etmek iin ltfen o sekmeye veya pencereye gein.",
                "uk-UA": " ,      ,  .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Computer determinism check failed.": {
                ar: "   .",
                "de-DE": "Der Computer-Determinismus-Check ist fehlgeschlagen.",
                "es-ES": "Fall la comprobacin de determinismo del ordenador.",
                "fr-FR": "chec de la vrification du dterminisme de l'ordinateur.",
                "it-IT": "Verifica del determinismo del computer fallita.",
                "ja-JP": "",
                "ko-KR": "   .",
                "pl-PL": "Nie udao si sprawdzi determinizmu komputera.",
                "pt-BR": "Falha na verificao de determinismo do computador.",
                "pt-PT": "Falha na verificao de determinismo do computador.",
                "ru-RU": "    .",
                "tr-TR": "Bilgisayar belirlenim kontrol baarsz oldu.",
                "uk-UA": "  '  .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Non-deterministic game assets found.": {
                ar: "      .",
                "de-DE": "Nicht-deterministische Spiel-Assets gefunden.",
                "es-ES": "Se encontraron activos de juego no deterministas.",
                "fr-FR": "Actifs de jeu non dterministes trouvs.",
                "it-IT": "Asset di gioco non deterministici trovati.",
                "ja-JP": "",
                "ko-KR": "    .",
                "pl-PL": "Znaleziono nieterministyczne zasoby gry.",
                "pt-BR": "Assets de jogo no determinsticos encontrados.",
                "pt-PT": "Ativos de jogo no determinsticos encontrados.",
                "ru-RU": "   .",
                "tr-TR": "Belirlenim d oyun varlklar bulundu.",
                "uk-UA": "   .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Please try clearing your browser cache.": {
                ar: "      .",
                "de-DE": "Bitte versuchen Sie, Ihren Browser-Cache zu lschen.",
                "es-ES": "Por favor, intenta borrar la cach de tu navegador.",
                "fr-FR": "Veuillez essayer de vider le cache de votre navigateur.",
                "it-IT": "Si prega di provare a cancellare la cache del browser.",
                "ja-JP": "",
                "ko-KR": "    .",
                "pl-PL": "Prosz sprbowa wyczyci pami podrczn przegldarki.",
                "pt-BR": "Por favor, tente limpar o cache do seu navegador.",
                "pt-PT": "Por favor, tente limpar o cache do seu navegador.",
                "ru-RU": ",    .",
                "tr-TR": "Ltfen tarayc nbelleinizi temizlemeyi deneyin.",
                "uk-UA": "   .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Hardware acceleration is disabled. Performance may be reduced.": {
                ar: "   .    .",
                "de-DE": "Hardware-Beschleunigung ist deaktiviert. Die Leistung kann beeintrchtigt sein.",
                "es-ES": "La aceleracin de hardware est desactivada. El rendimiento puede verse reducido.",
                "fr-FR": "L'acclration matrielle est dsactive. Les performances peuvent tre rduites.",
                "it-IT": "L'accelerazione hardware  disabilitata. Le prestazioni potrebbero essere ridotte.",
                "ja-JP": "",
                "ko-KR": "   .    .",
                "pl-PL": "Przyspieszenie sprztowe jest wyczone. Wydajno moe by zmniejszona.",
                "pt-BR": "Acelerao de hardware est desativada. O desempenho pode ser reduzido.",
                "pt-PT": "Acelerao de hardware est desativada. O desempenho pode ser reduzido.",
                "ru-RU": "  .    .",
                "tr-TR": "Donanm hzlandrmas devre d brakld. Performans debilir.",
                "uk-UA": "  .    .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Please make sure hardware acceleration is enabled in your browser settings.": {
                ar: "          .",
                "de-DE": "Bitte stellen Sie sicher, dass die Hardware-Beschleunigung in Ihren Browsereinstellungen aktiviert ist.",
                "es-ES": "Por favor, asegrate de que la aceleracin de hardware est habilitada en la configuracin de tu navegador.",
                "fr-FR": "Veuillez vous assurer que l'acclration matrielle est active dans les paramtres de votre navigateur.",
                "it-IT": "Si prega di assicurarsi che l'accelerazione hardware sia abilitata nelle impostazioni del browser.",
                "ja-JP": "",
                "ko-KR": "      .",
                "pl-PL": "Prosz upewni si, e przyspieszenie sprztowe jest wczone w ustawieniach przegldarki.",
                "pt-BR": "Por favor, certifique-se de que a acelerao de hardware esteja ativada nas configuraes do seu navegador.",
                "pt-PT": "Por favor, certifique-se de que a acelerao de hardware esteja ativada nas configuraes do seu navegador.",
                "ru-RU": ", ,        .",
                "tr-TR": "Ltfen tarayc ayarlarnzda donanm hzlandrmasnn etkinletirildiinden emin olun.",
                "uk-UA": " , ,        .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Update 0.6.0": {
                ar: " 0.6.0",
                "de-DE": "Update 0.6.0",
                "es-ES": "Actualizacin 0.6.0",
                "fr-FR": "Mise  jour 0.6.0",
                "it-IT": "Aggiornamento 0.6.0",
                "ja-JP": " 0.6.0",
                "ko-KR": " 0.6.0",
                "pl-PL": "Aktualizacja 0.6.0",
                "pt-BR": "Atualizao 0.6.0",
                "pt-PT": "Atualizao 0.6.0",
                "ru-RU": " 0.6.0",
                "tr-TR": "Gncelleme 0.6.0",
                "uk-UA": " 0.6.0",
                "zh-CN": " 0.6.0",
                "zh-TW": " 0.6.0"
            },
            "Multiplayer & More Customization": {
                ar: "    ",
                "de-DE": "Mehrspieler & Mehr Anpassung",
                "es-ES": "Multijugador y ms personalizacin",
                "fr-FR": "Multijoueur et plus de personnalisation",
                "it-IT": "Multigiocatore e pi personalizzazione",
                "ja-JP": "",
                "ko-KR": "    ",
                "pl-PL": "Tryb wieloosobowy i wicej opcji personalizacji",
                "pt-BR": "Multijogador e mais personalizao",
                "pt-PT": "Multijogador e mais personalizao",
                "ru-RU": "    ",
                "tr-TR": "ok oyunculu ve daha fazla zelletirme",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Welcome to PolyTrack 0.6.0! This update introduces experimental multiplayer support, more car customization, editor copy/paste, optimizations and more!": {
                ar: "   PolyTrack 0.6.0!            /    !",
                "de-DE": "Willkommen zu PolyTrack 0.6.0! Dieses Update fhrt experimentelle Mehrspieler-Untersttzung, mehr Fahrzeuganpassung, Kopieren/Einfgen im Editor, Optimierungen und mehr ein!",
                "es-ES": "Bienvenido a PolyTrack 0.6.0! Esta actualizacin introduce soporte multijugador experimental, ms personalizacin de autos, copiar/pegar en el editor, optimizaciones y ms.",
                "fr-FR": "Bienvenue dans PolyTrack 0.6.0 ! Cette mise  jour introduit un support multijoueur exprimental, plus de personnalisation de voiture, copier/coller dans l'diteur, des optimisations et plus encore !",
                "it-IT": "Benvenuto in PolyTrack 0.6.0! Questo aggiornamento introduce il supporto multiplayer sperimentale, pi personalizzazione dell'auto, copia/incolla nell'editor, ottimizzazioni e altro ancora!",
                "ja-JP": "PolyTrack 0.6.0/",
                "ko-KR": "PolyTrack 0.6.0   !     ,    ,  /,   !",
                "pl-PL": "Witamy w PolyTrack 0.6.0! Ta aktualizacja wprowadza eksperymentalne wsparcie dla trybu wieloosobowego, wicej personalizacji samochodw, kopiowanie/wklejanie w edytorze, optymalizacje i wicej!",
                "pt-BR": "Bem-vindo ao PolyTrack 0.6.0! Esta atualizao introduz suporte multiplayer experimental, mais personalizao de carros, copiar/colar no editor, otimizaes e muito mais!",
                "pt-PT": "Bem-vindo ao PolyTrack 0.6.0! Esta atualizao introduz suporte multiplayer experimental, mais personalizao de carros, copiar/colar no editor, otimizaes e muito mais!",
                "ru-RU": "   PolyTrack 0.6.0!       ,   , /  ,    !",
                "tr-TR": "PolyTrack 0.6.0'a ho geldiniz! Bu gncelleme, deneysel ok oyunculu destei, daha fazla araba zelletirmesi, editrde kopyala/yaptr, optimizasyonlar ve daha fazlasn sunar!",
                "uk-UA": "   PolyTrack 0.6.0!       ,   , /  ,    !",
                "zh-CN": "PolyTrack 0.6.0/",
                "zh-TW": " PolyTrack 0.6.0/"
            },
            "Note: As with every major PolyTrack update, physics changes mean that records from previous versions are not compatible.": {
                ar: ":         PolyTrack          .",
                "de-DE": "Hinweis: Wie bei jedem groen PolyTrack-Update bedeuten nderungen an der Physik, dass Aufzeichnungen aus frheren Versionen nicht kompatibel sind.",
                "es-ES": "Nota: Como con cada actualizacin importante de PolyTrack, los cambios en la fsica significan que los registros de versiones anteriores no son compatibles.",
                "fr-FR": "Note : Comme pour chaque mise  jour majeure de PolyTrack, les changements de physique signifient que les records des versions prcdentes ne sont pas compatibles.",
                "it-IT": "Nota: Come con ogni aggiornamento importante di PolyTrack, i cambiamenti nella fisica significano che i record delle versioni precedenti non sono compatibili.",
                "ja-JP": "PolyTrack",
                "ko-KR": ":   PolyTrack  ,        .",
                "pl-PL": "Uwaga: Jak w przypadku kadej wikszej aktualizacji PolyTrack, zmiany fizyki oznaczaj, e rekordy z poprzednich wersji nie s kompatybilne.",
                "pt-BR": "Nota: Como em toda grande atualizao do PolyTrack, as mudanas na fsica significam que os registros de verses anteriores no so compatveis.",
                "pt-PT": "Nota: Como em toda grande atualizao do PolyTrack, as mudanas na fsica significam que os registros de verses anteriores no so compatveis.",
                "ru-RU": ":       PolyTrack,    ,      .",
                "tr-TR": "Not: Her byk PolyTrack gncellemesinde olduu gibi, fizik deiiklikleri nceki srmlerin kaytlarnn uyumlu olmad anlamna gelir.",
                "uk-UA": ":       PolyTrack,    ,       .",
                "zh-CN": "PolyTrack",
                "zh-TW": " PolyTrack "
            },
            Garage: {
                ar: "",
                "de-DE": "Garage",
                "es-ES": "Garaje",
                "fr-FR": "Garage",
                "it-IT": "Garage",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Gara",
                "pt-BR": "Garagem",
                "pt-PT": "Garagem",
                "ru-RU": "",
                "tr-TR": "Garaj",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Editor: {
                ar: "",
                "de-DE": "Editor",
                "es-ES": "Editor",
                "fr-FR": "diteur",
                "it-IT": "Editor",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Edytor",
                "pt-BR": "Editor",
                "pt-PT": "Editor",
                "ru-RU": "",
                "tr-TR": "Editr",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Settings: {
                ar: "",
                "de-DE": "Einstellungen",
                "es-ES": "Configuracin",
                "fr-FR": "Paramtres",
                "it-IT": "Impostazioni",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Ustawienia",
                "pt-BR": "Configuraes",
                "pt-PT": "Definies",
                "ru-RU": "",
                "tr-TR": "Ayarlar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Profile: {
                ar: " ",
                "de-DE": "Profil",
                "es-ES": "Perfil",
                "fr-FR": "Profil",
                "it-IT": "Profilo",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Profil",
                "pt-BR": "Perfil",
                "pt-PT": "Perfil",
                "ru-RU": "",
                "tr-TR": "Profil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Multiplayer: {
                ar: " ",
                "de-DE": "Mehrspieler",
                "es-ES": "Multijugador",
                "fr-FR": "Multijoueur",
                "it-IT": "Multigiocatore",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Tryb wieloosobowy",
                "pt-BR": "Multijogador",
                "pt-PT": "Multijogador",
                "ru-RU": "",
                "tr-TR": "ok oyunculu",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Play: {
                ar: "",
                "de-DE": "Spielen",
                "es-ES": "Jugar",
                "fr-FR": "Jouer",
                "it-IT": "Gioca",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Graj",
                "pt-BR": "Jogar",
                "pt-PT": "Jogar",
                "ru-RU": "",
                "tr-TR": "Oyna",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to load editor.": {
                ar: "   .",
                "de-DE": "Editor konnte nicht geladen werden.",
                "es-ES": "Error al cargar el editor.",
                "fr-FR": "chec du chargement de l'diteur.",
                "it-IT": "Impossibile caricare l'editor.",
                "ja-JP": "",
                "ko-KR": "  .",
                "pl-PL": "Nie udao si zaadowa edytora.",
                "pt-BR": "Falha ao carregar o editor.",
                "pt-PT": "Falha ao carregar o editor.",
                "ru-RU": "   .",
                "tr-TR": "Editr yklenemedi.",
                "uk-UA": "   .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to load garage.": {
                ar: "   .",
                "de-DE": "Garage konnte nicht geladen werden.",
                "es-ES": "Error al cargar el garaje.",
                "fr-FR": "chec du chargement du garage.",
                "it-IT": "Impossibile caricare il garage.",
                "ja-JP": "",
                "ko-KR": "  .",
                "pl-PL": "Nie udao si zaadowa garau.",
                "pt-BR": "Falha ao carregar a garagem.",
                "pt-PT": "Falha ao carregar a garagem.",
                "ru-RU": "   .",
                "tr-TR": "Garaj yklenemedi.",
                "uk-UA": "   .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Check your internet connection and try again.": {
                ar: "      .",
                "de-DE": "berprfen Sie Ihre Internetverbindung und versuchen Sie es erneut.",
                "es-ES": "Verifica tu conexin a internet y vuelve a intentarlo.",
                "fr-FR": "Vrifiez votre connexion Internet et ressayez.",
                "it-IT": "Controlla la tua connessione internet e riprova.",
                "ja-JP": "",
                "ko-KR": "    .",
                "pl-PL": "Sprawd swoje poczenie internetowe i sprbuj ponownie.",
                "pt-BR": "Verifique sua conexo com a internet e tente novamente.",
                "pt-PT": "Verifique a sua ligao  internet e tente novamente.",
                "ru-RU": "      .",
                "tr-TR": "nternet balantnz kontrol edin ve tekrar deneyin.",
                "uk-UA": "       .",
                "zh-CN": "",
                "zh-TW": ""
            },
            Version: {
                ar: "",
                "de-DE": "Version",
                "es-ES": "Versin",
                "fr-FR": "Version",
                "it-IT": "Versione",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wersja",
                "pt-BR": "Verso",
                "pt-PT": "Verso",
                "ru-RU": "",
                "tr-TR": "Srm",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "You cannot have duplicate user profiles": {
                ar: "      ",
                "de-DE": "Sie knnen keine doppelten Benutzerprofile haben",
                "es-ES": "No puedes tener perfiles de usuario duplicados",
                "fr-FR": "Vous ne pouvez pas avoir de profils d'utilisateur en double",
                "it-IT": "Non  possibile avere profili utente duplicati",
                "ja-JP": "",
                "ko-KR": "     ",
                "pl-PL": "Nie moesz mie zduplikowanych profili uytkownika",
                "pt-BR": "Voc no pode ter perfis de usurio duplicados",
                "pt-PT": "No pode ter perfis de utilizador duplicados",
                "ru-RU": "    ",
                "tr-TR": "ift kullanc profili oluturamazsnz",
                "uk-UA": "      ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to create user profile": {
                ar: "     ",
                "de-DE": "Benutzerprofil konnte nicht erstellt werden",
                "es-ES": "No se pudo crear el perfil de usuario",
                "fr-FR": "chec de la cration du profil utilisateur",
                "it-IT": "Impossibile creare il profilo utente",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Nie udao si utworzy profilu uytkownika",
                "pt-BR": "Falha ao criar perfil de usurio",
                "pt-PT": "Falha ao criar o perfil de utilizador",
                "ru-RU": "    ",
                "tr-TR": "Kullanc profili oluturulamad",
                "uk-UA": "    ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "This user profile does not exist on the server": {
                ar: "       ",
                "de-DE": "Dieses Benutzerprofil existiert nicht auf dem Server",
                "es-ES": "Este perfil de usuario no existe en el servidor",
                "fr-FR": "Ce profil utilisateur n'existe pas sur le serveur",
                "it-IT": "Questo profilo utente non esiste sul server",
                "ja-JP": "",
                "ko-KR": "     ",
                "pl-PL": "Ten profil uytkownika nie istnieje na serwerze",
                "pt-BR": "Este perfil de usurio no existe no servidor",
                "pt-PT": "Este perfil de utilizador no existe no servidor",
                "ru-RU": "      ",
                "tr-TR": "Bu kullanc profili sunucuda mevcut deil",
                "uk-UA": "      ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to download user profile from the server": {
                ar: "       ",
                "de-DE": "Benutzerprofil konnte nicht vom Server heruntergeladen werden",
                "es-ES": "No se pudo descargar el perfil de usuario desde el servidor",
                "fr-FR": "chec du tlchargement du profil utilisateur depuis le serveur",
                "it-IT": "Impossibile scaricare il profilo utente dal server",
                "ja-JP": "",
                "ko-KR": "    ",
                "pl-PL": "Nie udao si pobra profilu uytkownika z serwera",
                "pt-BR": "Falha ao baixar perfil de usurio do servidor",
                "pt-PT": "Falha ao descarregar o perfil de utilizador do servidor",
                "ru-RU": "      ",
                "tr-TR": "Kullanc profili sunucudan indirilemedi",
                "uk-UA": "      ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "User token is invalid": {
                ar: "   ",
                "de-DE": "Benutzertoken ist ungltig",
                "es-ES": "El token de usuario no es vlido",
                "fr-FR": "Le jeton utilisateur n'est pas valide",
                "it-IT": "Token utente non valido",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Token uytkownika jest nieprawidowy",
                "pt-BR": "Token de usurio invlido",
                "pt-PT": "Token de utilizador invlido",
                "ru-RU": "  ",
                "tr-TR": "Kullanc belirteci geersiz",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Are you sure you want to display your private key?": {
                ar: "       ",
                "de-DE": "Mchten Sie Ihren privaten Schlssel wirklich anzeigen?",
                "es-ES": "Ests seguro de que quieres mostrar tu clave privada?",
                "fr-FR": "tes-vous sr de vouloir afficher votre cl prive ?",
                "it-IT": "Sei sicuro di voler mostrare la tua chiave privata?",
                "ja-JP": "",
                "ko-KR": "  ?",
                "pl-PL": "Czy na pewno chcesz wywietli swj klucz prywatny?",
                "pt-BR": "Tem certeza de que deseja exibir sua chave privada?",
                "pt-PT": "Tem a certeza de que pretende mostrar a sua chave privada?",
                "ru-RU": " ,      ?",
                "tr-TR": "Gizli anahtarnz gstermek istediinizden emin misiniz?",
                "uk-UA": " ,      ?",
                "zh-CN": "",
                "zh-TW": ""
            },
            "DO NOT SHARE THIS KEY WITH ANYONE.": {
                ar: "      .",
                "de-DE": "TEILEN SIE DIESEN SCHLSSEL NICHT MIT JEMANDEM.",
                "es-ES": "NO COMPARTAS ESTA CLAVE CON NADIE.",
                "fr-FR": "NE PARTAGEZ PAS CETTE CL AVEC PERSONNE.",
                "it-IT": "NON CONDIVIDERE QUESTA CHIAVE CON NESSUNO.",
                "ja-JP": "",
                "ko-KR": "    .",
                "pl-PL": "NIE UDOSTPNIAJ TEGO KLUCZA NIKOMU.",
                "pt-BR": "NO COMPARTILHE ESTA CHAVE COM NINGUM.",
                "pt-PT": "NO PARTILHE ESTA CHAVE COM NINGUM.",
                "ru-RU": "      .",
                "tr-TR": "BU ANAHTARI KMSEYLE PAYLAMAYIN.",
                "uk-UA": "     .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "You need a free user profile slot to import a new user profile": {
                ar: "           ",
                "de-DE": "Sie bentigen einen freien Benutzerprofil-Slot, um ein neues Benutzerprofil zu importieren",
                "es-ES": "Necesitas un espacio libre de perfil de usuario para importar un nuevo perfil de usuario",
                "fr-FR": "Vous avez besoin d'un emplacement de profil utilisateur libre pour importer un nouveau profil utilisateur",
                "it-IT": "Hai bisogno di uno slot di profilo utente libero per importare un nuovo profilo utente",
                "ja-JP": "",
                "ko-KR": "        ",
                "pl-PL": "Potrzebujesz wolnego miejsca na profil uytkownika, aby zaimportowa nowy profil uytkownika",
                "pt-BR": "Voc precisa de um slot de perfil de usurio livre para importar um novo perfil de usurio",
                "pt-PT": "Necessita de um slot de perfil de utilizador livre para importar um novo perfil de utilizador",
                "ru-RU": "          ",
                "tr-TR": "Yeni bir kullanc profili eklemek iin bo bir kullanc profili yuvasna ihtiyacnz var",
                "uk-UA": "          ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Quit: {
                ar: "",
                "de-DE": "Beenden",
                "es-ES": "Salir",
                "fr-FR": "Quitter",
                "it-IT": "Esci",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wyjd",
                "pt-BR": "Sair",
                "pt-PT": "Sair",
                "ru-RU": "",
                "tr-TR": "k",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Fullscreen: {
                ar: " ",
                "de-DE": "Vollbild",
                "es-ES": "Pantalla completa",
                "fr-FR": "Plein cran",
                "it-IT": "Schermo intero",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Peny ekran",
                "pt-BR": "Tela Cheia",
                "pt-PT": "Ecr Inteiro",
                "ru-RU": "",
                "tr-TR": "Tam Ekran",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Windowed: {
                ar: "",
                "de-DE": "Fenstermodus",
                "es-ES": "Ventana",
                "fr-FR": "Fentr",
                "it-IT": "Finestra",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Okno",
                "pt-BR": "Janela",
                "pt-PT": "Janela",
                "ru-RU": "",
                "tr-TR": "Pencere Modu",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Music: On": {
                ar: ": ",
                "de-DE": "Musik: An",
                "es-ES": "Msica: Activada",
                "fr-FR": "Musique : Active",
                "it-IT": "Musica: Attivata",
                "ja-JP": "",
                "ko-KR": ": ",
                "pl-PL": "Muzyka: Wczona",
                "pt-BR": "Msica: Ligada",
                "pt-PT": "Msica: Ligada",
                "ru-RU": ": ",
                "tr-TR": "Mzik: Ak",
                "uk-UA": ": ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Music: Off": {
                ar: ": ",
                "de-DE": "Musik: Aus",
                "es-ES": "Msica: Desactivada",
                "fr-FR": "Musique : Dsactive",
                "it-IT": "Musica: Disattivata",
                "ja-JP": "",
                "ko-KR": ": ",
                "pl-PL": "Muzyka: Wyczona",
                "pt-BR": "Msica: Desligada",
                "pt-PT": "Msica: Desligada",
                "ru-RU": ": ",
                "tr-TR": "Mzik: Kapal",
                "uk-UA": ": ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Privacy Policy": {
                ar: " ",
                "de-DE": "Datenschutz-Bestimmungen",
                "es-ES": "Poltica de Privacidad",
                "fr-FR": "Politique de confidentialit",
                "it-IT": "Politica sulla privacy",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Polityka prywatnoci",
                "pt-BR": "Poltica de Privacidade",
                "pt-PT": "Poltica de Privacidade",
                "ru-RU": " ",
                "tr-TR": "Gizlilik Politikas",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Terms of Service": {
                ar: " ",
                "de-DE": "Nutzungsbedingungen",
                "es-ES": "Trminos de Servicio",
                "fr-FR": "Conditions d'utilisation",
                "it-IT": "Termini di servizio",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Warunki wiadczenia usug",
                "pt-BR": "Termos de Servio",
                "pt-PT": "Termos de Servio",
                "ru-RU": " ",
                "tr-TR": "Hizmet artlar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:": {
                ar: "       {0}.        :",
                "de-DE": "Es scheint, dass Sie eine inoffizielle Version von {0} spielen. Fr die aktuellste Version besuchen Sie bitte die Originalquelle:",
                "es-ES": "Parece que ests jugando una versin no oficial de {0}. Para la versin ms actualizada, visita la fuente original:",
                "fr-FR": "Il semble que vous jouiez  une version non officielle de {0}. Pour la version la plus rcente, veuillez visiter la source originale :",
                "it-IT": "Sembra che tu stia giocando a una versione non ufficiale di {0}. Per la versione pi aggiornata visita la fonte originale:",
                "ja-JP": "{0} :",
                "ko-KR": "{0}      .     :",
                "pl-PL": "Wyglda na to, e grasz w nieoficjaln wersj {0}. Aby uzyska najnowsz wersj, odwied oryginalne rdo:",
                "pt-BR": "Parece que voc est jogando uma verso no oficial de {0}. Para a verso mais atualizada, visite a fonte original:",
                "pt-PT": "Parece que est a jogar uma verso no oficial de {0}. Para a verso mais atualizada, visite a fonte original:",
                "ru-RU": ",      {0}.       :",
                "tr-TR": "{0} adl resmi olmayan bir srm oynuyor gibi grnyorsunuz. En gncel srm iin ltfen orijinal kayna ziyaret edin:",
                "uk-UA": ",      {0}.      :",
                "zh-CN": " {0} ",
                "zh-TW": " {0}"
            },
            Nickname: {
                ar: " ",
                "de-DE": "Spitzname",
                "es-ES": "Apodo",
                "fr-FR": "Pseudonyme",
                "it-IT": "Nickname",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Pseudonim",
                "pt-BR": "Apelido",
                "pt-PT": "Alcunha",
                "ru-RU": "",
                "tr-TR": "Kullanc Ad",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Choose a nickname to be shown in the leaderboard. Your nickname can be changed at any time.": {
                ar: "     .       .",
                "de-DE": "Whlen Sie einen Spitznamen, der in der Bestenliste angezeigt wird. Ihr Spitzname kann jederzeit gendert werden.",
                "es-ES": "Elige un apodo para que aparezca en la tabla de clasificacin. Puedes cambiar tu apodo en cualquier momento.",
                "fr-FR": "Choisissez un pseudonyme  afficher dans le classement. Vous pouvez changer votre pseudonyme  tout moment.",
                "it-IT": "Scegli un nickname da mostrare nella classifica. Puoi cambiarlo in qualsiasi momento.",
                "ja-JP": "",
                "ko-KR": "   .     .",
                "pl-PL": "Wybierz pseudonim, ktry bdzie wywietlany w tabeli wynikw. Moesz go zmienia w dowolnym momencie.",
                "pt-BR": "Escolha um apelido para ser exibido no quadro de lderes. Seu apelido pode ser alterado a qualquer momento.",
                "pt-PT": "Escolha uma alcunha para ser exibida na tabela de classificao. A sua alcunha pode ser alterada a qualquer momento.",
                "ru-RU": " ,      .       .",
                "tr-TR": "Liderlik tablosunda gsterilecek bir kullanc ad sein. Kullanc adnz istediiniz zaman deitirebilirsiniz.",
                "uk-UA": "      .      - .",
                "zh-CN": "",
                "zh-TW": ""
            },
            Country: {
                ar: "",
                "de-DE": "Land",
                "es-ES": "Pas",
                "fr-FR": "Pays",
                "it-IT": "Paese",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Kraj",
                "pt-BR": "Pas",
                "pt-PT": "Pas",
                "ru-RU": "",
                "tr-TR": "lke",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            None: {
                ar: " ",
                "de-DE": "Keine",
                "es-ES": "Ninguno",
                "fr-FR": "Aucun",
                "it-IT": "Nessuno",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Brak",
                "pt-BR": "Nenhum",
                "pt-PT": "Nenhum",
                "ru-RU": "",
                "tr-TR": "Yok",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Select your country to be shown in the leaderboard. This is optional and can be changed at any time. Only UN member states are listed.": {
                ar: "    .       .       .",
                "de-DE": "Whlen Sie Ihr Land, das in der Bestenliste angezeigt werden soll. Dies ist optional und kann jederzeit gendert werden. Es sind nur UN-Mitgliedstaaten aufgefhrt.",
                "es-ES": "Selecciona tu pas para que aparezca en la tabla de clasificacin. Esto es opcional y se puede cambiar en cualquier momento. Solo se enumeran los estados miembros de la ONU.",
                "fr-FR": "Slectionnez votre pays pour qu'il soit affich dans le classement. C'est optionnel et peut tre chang  tout moment. Seuls les tats membres de l'ONU sont rpertoris.",
                "it-IT": "Seleziona il tuo paese da mostrare nella classifica. Questa operazione  facoltativa e pu essere modificata in qualsiasi momento. Sono elencati solo gli stati membri delle Nazioni Unite.",
                "ja-JP": "",
                "ko-KR": "   .       . UN  .",
                "pl-PL": "Wybierz swj kraj, ktry bdzie wywietlany w tabeli wynikw. Jest to opcjonalne i mona to zmieni w dowolnym momencie. Wymienione s tylko pastwa czonkowskie ONZ.",
                "pt-BR": "Selecione seu pas para ser exibido no quadro de lderes. Isso  opcional e pode ser alterado a qualquer momento. Apenas os estados membros da ONU esto listados.",
                "pt-PT": "Selecione o seu pas para ser exibido na tabela de classificao. Isto  opcional e pode ser alterado a qualquer momento. Apenas os estados membros da ONU esto listados.",
                "ru-RU": "  ,      .         .     - .",
                "tr-TR": "Liderlik tablosunda gsterilecek lkenizi sein. Bu istee baldr ve istediiniz zaman deitirilebilir. Yalnzca BM ye devletleri listelenir.",
                "uk-UA": "       .  '      - .     - .",
                "zh-CN": "/",
                "zh-TW": ""
            },
            "Select country": {
                ar: " ",
                "de-DE": "Land auswhlen",
                "es-ES": "Seleccionar pas",
                "fr-FR": "Slectionner le pays",
                "it-IT": "Seleziona paese",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wybierz kraj",
                "pt-BR": "Selecionar pas",
                "pt-PT": "Selecionar pas",
                "ru-RU": " ",
                "tr-TR": "lke se",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Search country...": {
                ar: "  ...",
                "de-DE": "Land suchen...",
                "es-ES": "Buscar pas...",
                "fr-FR": "Rechercher un pays...",
                "it-IT": "Cerca paese...",
                "ja-JP": "...",
                "ko-KR": " ...",
                "pl-PL": "Szukaj kraju...",
                "pt-BR": "Pesquisar pas...",
                "pt-PT": "Pesquisar pas...",
                "ru-RU": " ...",
                "tr-TR": "lke ara...",
                "uk-UA": " ...",
                "zh-CN": "...",
                "zh-TW": "..."
            },
            "No countries found": {
                ar: "    ",
                "de-DE": "Keine Lnder gefunden",
                "es-ES": "No se encontraron pases",
                "fr-FR": "Aucun pays trouv",
                "it-IT": "Nessun paese trovato",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Nie znaleziono krajw",
                "pt-BR": "Nenhum pas encontrado",
                "pt-PT": "Nenhum pas encontrado",
                "ru-RU": "  ",
                "tr-TR": "lke bulunamad",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Export your private token. This token can be used to back up your account or restore it on another device.": {
                ar: "    .            .",
                "de-DE": "Exportieren Sie Ihr privates Token. Dieses Token kann verwendet werden, um Ihr Konto zu sichern oder es auf einem anderen Gert wiederherzustellen.",
                "es-ES": "Exporta tu token privado. Este token se puede usar para hacer una copia de seguridad de tu cuenta o restaurarla en otro dispositivo.",
                "fr-FR": "Exportez votre jeton priv. Ce jeton peut tre utilis pour sauvegarder votre compte ou le restaurer sur un autre appareil.",
                "it-IT": "Esporta il tuo token privato. Questo token pu essere utilizzato per eseguire il backup del tuo account o ripristinarlo su un altro dispositivo.",
                "ja-JP": "",
                "ko-KR": "  .           .",
                "pl-PL": "Eksportuj swj prywatny token. Token ten moe by uyty do tworzenia kopii zapasowej konta lub przywracania go na innym urzdzeniu.",
                "pt-BR": "Exporte seu token privado. Este token pode ser usado para fazer backup da sua conta ou restaur-la em outro dispositivo.",
                "pt-PT": "Exporte o seu token privado. Este token pode ser usado para fazer backup da sua conta ou restaur-la noutro dispositivo.",
                "ru-RU": "   .                .",
                "tr-TR": "zel belirtecinizi da aktarn. Bu belirte, hesabnz yedeklemek veya baka bir cihazda geri yklemek iin kullanlabilir.",
                "uk-UA": "   .                .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Delete your profile from this device. The profile will remain on other devices and can be restored using the private token.": {
                ar: "     .           .",
                "de-DE": "Lschen Sie Ihr Profil von diesem Gert. Das Profil bleibt auf anderen Gerten erhalten und kann mit dem privaten Token wiederhergestellt werden.",
                "es-ES": "Elimina tu perfil de este dispositivo. El perfil permanecer en otros dispositivos y se puede restaurar utilizando el token privado.",
                "fr-FR": "Supprimez votre profil de cet appareil. Le profil restera sur les autres appareils et pourra tre restaur  l'aide du jeton priv.",
                "it-IT": "Elimina il tuo profilo da questo dispositivo. Il profilo rimarr su altri dispositivi e potr essere ripristinato utilizzando il token privato.",
                "ja-JP": "",
                "ko-KR": "   .           .",
                "pl-PL": "Usu swj profil z tego urzdzenia. Profil pozostanie na innych urzdzeniach i mona go przywrci za pomoc prywatnego tokena.",
                "pt-BR": "Exclua seu perfil deste dispositivo. O perfil permanecer em outros dispositivos e poder ser restaurado usando o token privado.",
                "pt-PT": "Elimine o seu perfil deste dispositivo. O perfil permanecer em outros dispositivos e pode ser restaurado usando o token privado.",
                "ru-RU": "     .             .",
                "tr-TR": "Profilinizi bu cihazdan silin. Profil dier cihazlarda kalacak ve zel belirte kullanlarak geri yklenebilir.",
                "uk-UA": "     .             .",
                "zh-CN": "",
                "zh-TW": ""
            },
            Cancel: {
                ar: "",
                "de-DE": "Abbrechen",
                "es-ES": "Cancelar",
                "fr-FR": "Annuler",
                "it-IT": "Annulla",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Anuluj",
                "pt-BR": "Cancelar",
                "pt-PT": "Cancelar",
                "ru-RU": "",
                "tr-TR": "ptal",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Confirm: {
                ar: "",
                "de-DE": "Besttigen",
                "es-ES": "Confirmar",
                "fr-FR": "Confirmer",
                "it-IT": "Conferma",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Potwierd",
                "pt-BR": "Confirmar",
                "pt-PT": "Confirmar",
                "ru-RU": "",
                "tr-TR": "Onayla",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "User ID": {
                ar: " ",
                "de-DE": "Benutzer-ID",
                "es-ES": "ID de usuario",
                "fr-FR": "ID utilisateur",
                "it-IT": "ID Utente",
                "ja-JP": "ID",
                "ko-KR": " ID",
                "pl-PL": "ID uytkownika",
                "pt-BR": "ID de Usurio",
                "pt-PT": "ID de Utilizador",
                "ru-RU": " ",
                "tr-TR": "Kullanc Kimlii",
                "uk-UA": "ID ",
                "zh-CN": "ID",
                "zh-TW": " ID"
            },
            Paused: {
                ar: "",
                "de-DE": "Pausiert",
                "es-ES": "Pausado",
                "fr-FR": "En pause",
                "it-IT": "In pausa",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wstrzymano",
                "pt-BR": "Pausado",
                "pt-PT": "Pausado",
                "ru-RU": "",
                "tr-TR": "Duraklatld",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Graphs: {
                ar: " ",
                "de-DE": "Diagramme",
                "es-ES": "Grficos",
                "fr-FR": "Graphiques",
                "it-IT": "Grafici",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wykresy",
                "pt-BR": "Grficos",
                "pt-PT": "Grficos",
                "ru-RU": "",
                "tr-TR": "Grafikler",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Switch car": {
                ar: " ",
                "de-DE": "Auto wechseln",
                "es-ES": "Cambiar coche",
                "fr-FR": "Changer de voiture",
                "it-IT": "Cambia auto",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Zmie samochd",
                "pt-BR": "Trocar carro",
                "pt-PT": "Mudar de carro",
                "ru-RU": " ",
                "tr-TR": "Araba deitir",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Speed: {
                ar: "",
                "de-DE": "Geschwindigkeit",
                "es-ES": "Velocidad",
                "fr-FR": "Vitesse",
                "it-IT": "Velocit",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Prdko",
                "pt-BR": "Velocidade",
                "pt-PT": "Velocidade",
                "ru-RU": "",
                "tr-TR": "Hz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Steering angle": {
                ar: " ",
                "de-DE": "Lenkwinkel",
                "es-ES": "ngulo de direccin",
                "fr-FR": "Angle de braquage",
                "it-IT": "Angolo di sterzata",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Kt skrtu",
                "pt-BR": "ngulo de Direo",
                "pt-PT": "ngulo de Direo",
                "ru-RU": "  ",
                "tr-TR": "Direksiyon As",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Grip: {
                ar: "",
                "de-DE": "Grip",
                "es-ES": "Agarre",
                "fr-FR": "Adhrence",
                "it-IT": "Aderenza",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Przyczepno",
                "pt-BR": "Aderncia",
                "pt-PT": "Aderncia",
                "ru-RU": "",
                "tr-TR": "Tutu",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Suspension Length": {
                ar: " ",
                "de-DE": "Federweg",
                "es-ES": "Longitud de suspensin",
                "fr-FR": "Longueur de suspension",
                "it-IT": "Lunghezza sospensione",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Dugo zawieszenia",
                "pt-BR": "Comprimento da Suspenso",
                "pt-PT": "Comprimento da Suspenso",
                "ru-RU": " ",
                "tr-TR": "Sspansiyon Uzunluu",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Wheel Speed": {
                ar: " ",
                "de-DE": "Raddrehzahl",
                "es-ES": "Velocidad de la rueda",
                "fr-FR": "Vitesse de roue",
                "it-IT": "Velocit ruota",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Prdko koa",
                "pt-BR": "Velocidade da Roda",
                "pt-PT": "Velocidade da Roda",
                "ru-RU": " ",
                "tr-TR": "Teker Hz",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Average: {
                ar: "",
                "de-DE": "Durchschnitt",
                "es-ES": "Promedio",
                "fr-FR": "Moyenne",
                "it-IT": "Medio",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "rednia",
                "pt-BR": "Mdia",
                "pt-PT": "Mdia",
                "ru-RU": "",
                "tr-TR": "Ortalama",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Front Left": {
                ar: " ",
                "de-DE": "Vorne links",
                "es-ES": "Delantero izquierdo",
                "fr-FR": "Avant gauche",
                "it-IT": "Anteriore sinistro",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Przd lewy",
                "pt-BR": "Frente Esquerda",
                "pt-PT": "Frente Esquerda",
                "ru-RU": " ",
                "tr-TR": "n Sol",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Front Right": {
                ar: " ",
                "de-DE": "Vorne rechts",
                "es-ES": "Delantero derecho",
                "fr-FR": "Avant droit",
                "it-IT": "Anteriore destro",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Przd prawy",
                "pt-BR": "Frente Direita",
                "pt-PT": "Frente Direita",
                "ru-RU": " ",
                "tr-TR": "n Sa",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rear Left": {
                ar: " ",
                "de-DE": "Hinten links",
                "es-ES": "Trasero izquierdo",
                "fr-FR": "Arrire gauche",
                "it-IT": "Posteriore sinistro",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Ty lewy",
                "pt-BR": "Traseira Esquerda",
                "pt-PT": "Traseira Esquerda",
                "ru-RU": " ",
                "tr-TR": "Arka Sol",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rear Right": {
                ar: " ",
                "de-DE": "Hinten rechts",
                "es-ES": "Trasero derecho",
                "fr-FR": "Arrire droit",
                "it-IT": "Posteriore destro",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Ty prawy",
                "pt-BR": "Traseira Direita",
                "pt-PT": "Traseira Direita",
                "ru-RU": " ",
                "tr-TR": "Arka Sa",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Profiles: {
                ar: "",
                "de-DE": "Profile",
                "es-ES": "Perfiles",
                "fr-FR": "Profils",
                "it-IT": "Profili",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Profile",
                "pt-BR": "Perfis",
                "pt-PT": "Perfis",
                "ru-RU": "",
                "tr-TR": "Profiller",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            'Are you sure you would like to delete "{0}"?': {
                ar: '      "{0}"',
                "de-DE": 'Mchten Sie "{0}" wirklich lschen?',
                "es-ES": 'Ests seguro de que quieres eliminar "{0}"?',
                "fr-FR": 'tes-vous sr de vouloir supprimer "{0}"?',
                "it-IT": 'Sei sicuro di voler eliminare "{0}"?',
                "ja-JP": '"{0}"',
                "ko-KR": '"{0}" ?',
                "pl-PL": 'Czy na pewno chcesz usun "{0}"?',
                "pt-BR": 'Tem certeza de que deseja excluir "{0}"?',
                "pt-PT": 'Tem a certeza de que pretende eliminar "{0}"?',
                "ru-RU": ' ,    "{0}"?',
                "tr-TR": '"{0}" silmek istediinizden emin misiniz?',
                "uk-UA": ' ,    "{0}"?',
                "zh-CN": ' "{0}" ',
                "zh-TW": ' "{0}" '
            },
            Empty: {
                ar: "",
                "de-DE": "Leer",
                "es-ES": "Vaco",
                "fr-FR": "Vide",
                "it-IT": "Vuoto",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Puste",
                "pt-BR": "Vazio",
                "pt-PT": "Vazio",
                "ru-RU": "",
                "tr-TR": "Bo",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Reset: {
                ar: " ",
                "de-DE": "Zurcksetzen",
                "es-ES": "Restablecer",
                "fr-FR": "Rinitialiser",
                "it-IT": "Resetta",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Resetuj",
                "pt-BR": "Redefinir",
                "pt-PT": "Repor",
                "ru-RU": "",
                "tr-TR": "Sfrla",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Apply: {
                ar: "",
                "de-DE": "Anwenden",
                "es-ES": "Aplicar",
                "fr-FR": "Appliquer",
                "it-IT": "Applica",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Zastosuj",
                "pt-BR": "Aplicar",
                "pt-PT": "Aplicar",
                "ru-RU": "",
                "tr-TR": "Uygula",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Gameplay: {
                ar: " ",
                "de-DE": "Spielablauf",
                "es-ES": "Jugabilidad",
                "fr-FR": "Jouabilit",
                "it-IT": "Modalit di gioco",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Rozgrywka",
                "pt-BR": "Jogabilidade",
                "pt-PT": "Jogabilidade",
                "ru-RU": " ",
                "tr-TR": "Oynan",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Units: {
                ar: "",
                "de-DE": "Einheiten",
                "es-ES": "Unidades",
                "fr-FR": "Units",
                "it-IT": "Unit",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Jednostki",
                "pt-BR": "Unidades",
                "pt-PT": "Unidades",
                "ru-RU": " ",
                "tr-TR": "Birimler",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Metric: {
                ar: "",
                "de-DE": "Metrisch",
                "es-ES": "Mtrico",
                "fr-FR": "Mtrique",
                "it-IT": "Metrico",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Metryczne",
                "pt-BR": "Mtrico",
                "pt-PT": "Mtrico",
                "ru-RU": "",
                "tr-TR": "Metrik",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Imperial: {
                ar: "",
                "de-DE": "Imperial",
                "es-ES": "Imperial",
                "fr-FR": "Imprial",
                "it-IT": "Imperiale",
                "ja-JP": "",
                "ko-KR": "/ ",
                "pl-PL": "Imperialne",
                "pt-BR": "Imperial",
                "pt-PT": "Imperial",
                "ru-RU": "",
                "tr-TR": "ngiliz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Reset hint": {
                ar: "  ",
                "de-DE": "Hinweis zurcksetzen",
                "es-ES": "Restablecer pista",
                "fr-FR": "Rinitialiser l'astuce",
                "it-IT": "Resetta suggerimento",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Resetuj wskazwk",
                "pt-BR": "Redefinir dica",
                "pt-PT": "Repor dica",
                "ru-RU": " ",
                "tr-TR": "pucunu sfrla",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Disabled: {
                ar: "",
                "de-DE": "Deaktiviert",
                "es-ES": "Desactivado",
                "fr-FR": "Dsactiv",
                "it-IT": "Disattivato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wyczone",
                "pt-BR": "Desativado",
                "pt-PT": "Desativado",
                "ru-RU": "",
                "tr-TR": "Devre D",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Enabled: {
                ar: "",
                "de-DE": "Aktiviert",
                "es-ES": "Activado",
                "fr-FR": "Activ",
                "it-IT": "Attivato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wczone",
                "pt-BR": "Ativado",
                "pt-PT": "Ativado",
                "ru-RU": "",
                "tr-TR": "Etkin",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Ghost car": {
                ar: " ",
                "de-DE": "Geisterauto",
                "es-ES": "Coche fantasma",
                "fr-FR": "Voiture fantme",
                "it-IT": "Auto fantasma",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Duch samochodu",
                "pt-BR": "Carro Fantasma",
                "pt-PT": "Carro Fantasma",
                "ru-RU": " ",
                "tr-TR": "Hayalet araba",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Default camera": {
                ar: " ",
                "de-DE": "Standardkamera",
                "es-ES": "Cmara predeterminada",
                "fr-FR": "Camra par dfaut",
                "it-IT": "Telecamera predefinita",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Domylna kamera",
                "pt-BR": "Cmera Padro",
                "pt-PT": "Cmera Padro",
                "ru-RU": "  ",
                "tr-TR": "Varsaylan kamera",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Default: {
                ar: "",
                "de-DE": "Standard",
                "es-ES": "Predeterminado",
                "fr-FR": "Dfaut",
                "it-IT": "Predefinita",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Domylny",
                "pt-BR": "Padro",
                "pt-PT": "Padro",
                "ru-RU": " ",
                "tr-TR": "Varsaylan",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Cockpit: {
                ar: "",
                "de-DE": "Cockpit",
                "es-ES": "Cabina",
                "fr-FR": "Cockpit",
                "it-IT": "Cabina",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Kokpit",
                "pt-BR": "Cockpit",
                "pt-PT": "Cabine",
                "ru-RU": "",
                "tr-TR": "Kokpit",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Cockpit camera mode": {
                ar: "   ",
                "de-DE": "Cockpit-Kameramodus",
                "es-ES": "Modo de cmara en la cabina",
                "fr-FR": "Mode camra cockpit",
                "it-IT": "Modalit telecamera cabina",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Tryb kamery kokpitu",
                "pt-BR": "Modo de cmera do cockpit",
                "pt-PT": "Modo da cmera de cabine",
                "ru-RU": " ",
                "tr-TR": "Kokpit kamera modu",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Hold: {
                ar: "",
                "de-DE": "Halten",
                "es-ES": "Mantener",
                "fr-FR": "Maintenir",
                "it-IT": "Tieni",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Przytrzymaj",
                "pt-BR": "Manter",
                "pt-PT": "Manter",
                "ru-RU": "",
                "tr-TR": "Basl Tut",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Toggle: {
                ar: "",
                "de-DE": "Umschalten",
                "es-ES": "Alternar",
                "fr-FR": "Basculer",
                "it-IT": "Attiva/Disattiva",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Przecz",
                "pt-BR": "Alternar",
                "pt-PT": "Alternar",
                "ru-RU": "",
                "tr-TR": "Deitir",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Checkpoints: {
                ar: " ",
                "de-DE": "Kontrollpunkte",
                "es-ES": "Puntos de control",
                "fr-FR": "Points de contrle",
                "it-IT": "Checkpoint",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Punkty kontrolne",
                "pt-BR": "Pontos de Verificao",
                "pt-PT": "Pontos de Verificao",
                "ru-RU": " ",
                "tr-TR": "Kontrol Noktalar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Timer: {
                ar: "",
                "de-DE": "Timer",
                "es-ES": "Temporizador",
                "fr-FR": "Minuteur",
                "it-IT": "Timer",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Stoper",
                "pt-BR": "Temporizador",
                "pt-PT": "Temporizador",
                "ru-RU": "",
                "tr-TR": "Zamanlayc",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Speedometer: {
                ar: " ",
                "de-DE": "Tachometer",
                "es-ES": "Velocmetro",
                "fr-FR": "Compteur de vitesse",
                "it-IT": "Contachilometri",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Prdkociomierz",
                "pt-BR": "Velocmetro",
                "pt-PT": "Velocmetro",
                "ru-RU": "",
                "tr-TR": "Hzler",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Bottom: {
                ar: "",
                "de-DE": "Unten",
                "es-ES": "Inferior",
                "fr-FR": "Bas",
                "it-IT": "In basso",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "D",
                "pt-BR": "Inferior",
                "pt-PT": "Inferior",
                "ru-RU": "",
                "tr-TR": "Alt",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Top: {
                ar: "",
                "de-DE": "Oben",
                "es-ES": "Superior",
                "fr-FR": "Haut",
                "it-IT": "In alto",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Gra",
                "pt-BR": "Superior",
                "pt-PT": "Superior",
                "ru-RU": "",
                "tr-TR": "st",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Language: {
                ar: "",
                "de-DE": "Sprache",
                "es-ES": "Idioma",
                "fr-FR": "Langue",
                "it-IT": "Lingua",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Jzyk",
                "pt-BR": "Idioma",
                "pt-PT": "Idioma",
                "ru-RU": "",
                "tr-TR": "Dil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Graphics: {
                ar: "",
                "de-DE": "Grafik",
                "es-ES": "Grficos",
                "fr-FR": "Graphismes",
                "it-IT": "Grafica",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Grafika",
                "pt-BR": "Grficos",
                "pt-PT": "Grficos",
                "ru-RU": "",
                "tr-TR": "Grafikler",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Shadows: {
                ar: "",
                "de-DE": "Schatten",
                "es-ES": "Sombras",
                "fr-FR": "Ombres",
                "it-IT": "Ombre",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Cienie",
                "pt-BR": "Sombras",
                "pt-PT": "Sombras",
                "ru-RU": "",
                "tr-TR": "Glge",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Off: {
                ar: "",
                "de-DE": "Aus",
                "es-ES": "Apagar",
                "fr-FR": "Dsactiv",
                "it-IT": "Disattivato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wycz",
                "pt-BR": "Desligado",
                "pt-PT": "Desligado",
                "ru-RU": "",
                "tr-TR": "Kapal",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            On: {
                ar: "",
                "de-DE": "An",
                "es-ES": "Encender",
                "fr-FR": "Activ",
                "it-IT": "Attivato",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wcz",
                "pt-BR": "Ligado",
                "pt-PT": "Ligado",
                "ru-RU": "",
                "tr-TR": "Ak",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Minimal: {
                ar: "",
                "de-DE": "Minimal",
                "es-ES": "Mnimo",
                "fr-FR": "Minimal",
                "it-IT": "Minimale",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Minimalny",
                "pt-BR": "Mnimo",
                "pt-PT": "Mnimo",
                "ru-RU": "",
                "tr-TR": "Minimal",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Low: {
                ar: "",
                "de-DE": "Niedrig",
                "es-ES": "Bajo",
                "fr-FR": "Faible",
                "it-IT": "Basso",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Niska",
                "pt-BR": "Baixo",
                "pt-PT": "Baixo",
                "ru-RU": "",
                "tr-TR": "Dk",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Medium: {
                ar: "",
                "de-DE": "Mittel",
                "es-ES": "Medio",
                "fr-FR": "Moyen",
                "it-IT": "Medio",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "rednia",
                "pt-BR": "Mdio",
                "pt-PT": "Mdio",
                "ru-RU": "",
                "tr-TR": "Orta",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            High: {
                ar: "",
                "de-DE": "Hoch",
                "es-ES": "Alto",
                "fr-FR": "lev",
                "it-IT": "Alto",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wysoka",
                "pt-BR": "Alto",
                "pt-PT": "Alto",
                "ru-RU": "",
                "tr-TR": "Yksek",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Ultra: {
                ar: "",
                "de-DE": "Ultra",
                "es-ES": "Ultra",
                "fr-FR": "Ultra",
                "it-IT": "Ultra",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Ultra",
                "pt-BR": "Ultra",
                "pt-PT": "Ultra",
                "ru-RU": "",
                "tr-TR": "Ultra",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Clouds: {
                ar: "",
                "de-DE": "Wolken",
                "es-ES": "Nubes",
                "fr-FR": "Nuages",
                "it-IT": "Nuvole",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Chmury",
                "pt-BR": "Nuvens",
                "pt-PT": "Nuvens",
                "ru-RU": "",
                "tr-TR": "Bulutlar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Particles: {
                ar: "",
                "de-DE": "Partikel",
                "es-ES": "Partculas",
                "fr-FR": "Particules",
                "it-IT": "Particelle",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Czsteczki",
                "pt-BR": "Partculas",
                "pt-PT": "Partculas",
                "ru-RU": "",
                "tr-TR": "Partikller",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Skidmarks: {
                ar: " ",
                "de-DE": "Reifenspuren",
                "es-ES": "Marcas de derrape",
                "fr-FR": "Marques de drapage",
                "it-IT": "Segni di frenata",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "lady opon",
                "pt-BR": "Marcas de Derrapagem",
                "pt-PT": "Marcas de Derrapagem",
                "ru-RU": "  ",
                "tr-TR": "Lastik izleri",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Fog: {
                ar: "",
                "de-DE": "Nebel",
                "es-ES": "Niebla",
                "fr-FR": "Brouillard",
                "it-IT": "Nebbia",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Mga",
                "pt-BR": "Nvoa",
                "pt-PT": "Nvoa",
                "ru-RU": "",
                "tr-TR": "Sis",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Render scale": {
                ar: " ",
                "de-DE": "Render-Skalierung",
                "es-ES": "Escala de renderizado",
                "fr-FR": "chelle de rendu",
                "it-IT": "Scala di rendering",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Skala renderowania",
                "pt-BR": "Escala de Renderizao",
                "pt-PT": "Escala de Renderizao",
                "ru-RU": " ",
                "tr-TR": "Grnt lei",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Screen Pixel Density": {
                ar: "  ",
                "de-DE": "Bildschirm-Pixeldichte",
                "es-ES": "Densidad de pxeles de pantalla",
                "fr-FR": "Densit de pixels de l'cran",
                "it-IT": "Densit dei pixel dello schermo",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Gsto pikseli ekranu",
                "pt-BR": "Densidade de Pixels da Tela",
                "pt-PT": "Densidade de Pixels do Ecr",
                "ru-RU": "  ",
                "tr-TR": "Ekran Piksel Younluu",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Fixed: {
                ar: "",
                "de-DE": "Fest",
                "es-ES": "Fijo",
                "fr-FR": "Fixe",
                "it-IT": "Fisso",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Stay",
                "pt-BR": "Fixo",
                "pt-PT": "Fixo",
                "ru-RU": "",
                "tr-TR": "Sabit",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Auto: {
                ar: "",
                "de-DE": "Automatisch",
                "es-ES": "Automtico",
                "fr-FR": "Auto",
                "it-IT": "Automatico",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Automatyczny",
                "pt-BR": "Automtico",
                "pt-PT": "Automtico",
                "ru-RU": "",
                "tr-TR": "Otomatik",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Anti-aliasing (requires restart)": {
                ar: "  (  )",
                "de-DE": "Antialiasing (erfordert Neustart)",
                "es-ES": "Anti-aliasing (requiere reinicio)",
                "fr-FR": "Anticrnelage (ncessite un redmarrage)",
                "it-IT": "Anti-aliasing (richiede riavvio)",
                "ja-JP": "",
                "ko-KR": "  ( )",
                "pl-PL": "Anti-aliasing (wymaga restartu)",
                "pt-BR": "Anti-aliasing (requer reincio)",
                "pt-PT": "Anti-aliasing (necessita de reiniciar)",
                "ru-RU": " ( )",
                "tr-TR": "Kenar yumuatma (yeniden balatma gerektirir)",
                "uk-UA": " ( )",
                "zh-CN": "",
                "zh-TW": " ()"
            },
            Audio: {
                ar: "",
                "de-DE": "Audio",
                "es-ES": "Audio",
                "fr-FR": "Audio",
                "it-IT": "Audio",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Dwik",
                "pt-BR": "udio",
                "pt-PT": "udio",
                "ru-RU": "",
                "tr-TR": "Ses",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Master volume": {
                ar: " ",
                "de-DE": "Gesamtlautstrke",
                "es-ES": "Volumen maestro",
                "fr-FR": "Volume principal",
                "it-IT": "Volume principale",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Gono gwna",
                "pt-BR": "Volume Mestre",
                "pt-PT": "Volume Mestre",
                "ru-RU": " ",
                "tr-TR": "Ana ses seviyesi",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Sound effect volume": {
                ar: "  ",
                "de-DE": "Lautstrke Soundeffekte",
                "es-ES": "Volumen de efectos de sonido",
                "fr-FR": "Volume des effets sonores",
                "it-IT": "Volume degli effetti sonori",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Gono efektw dwikowych",
                "pt-BR": "Volume de Efeitos Sonoros",
                "pt-PT": "Volume dos Efeitos Sonoros",
                "ru-RU": "  ",
                "tr-TR": "Ses efekti ses seviyesi",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Music volume": {
                ar: " ",
                "de-DE": "Lautstrke Musik",
                "es-ES": "Volumen de msica",
                "fr-FR": "Volume de la musique",
                "it-IT": "Volume della musica",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Gono muzyki",
                "pt-BR": "Volume de Msica",
                "pt-PT": "Volume da Msica",
                "ru-RU": " ",
                "tr-TR": "Mzik ses seviyesi",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Checkpoint volume": {
                ar: "  ",
                "de-DE": "Lautstrke Kontrollpunkt",
                "es-ES": "Volumen de puntos de control",
                "fr-FR": "Volume des points de contrle",
                "it-IT": "Volume dei checkpoint",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Gono punktw kontrolnych",
                "pt-BR": "Volume dos Pontos de Verificao",
                "pt-PT": "Volume dos Pontos de Verificao",
                "ru-RU": "  ",
                "tr-TR": "Kontrol noktas ses seviyesi",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Ghost car sounds": {
                ar: "  ",
                "de-DE": "Geisterauto-Sounds",
                "es-ES": "Sonidos del coche fantasma",
                "fr-FR": "Sons de la voiture fantme",
                "it-IT": "Suoni dell'auto fantasma",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Dwiki ducha samochodu",
                "pt-BR": "Sons do Carro Fantasma",
                "pt-PT": "Sons do Carro Fantasma",
                "ru-RU": "  ",
                "tr-TR": "Hayalet araba sesleri",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Mobile: {
                ar: "",
                "de-DE": "Mobil",
                "es-ES": "Dispositivo mvil",
                "fr-FR": "Mobile",
                "it-IT": "Mobile",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Mobilny",
                "pt-BR": "Celular",
                "pt-PT": "Dispositivo Mvel",
                "ru-RU": "",
                "tr-TR": "Mobil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Vibration: {
                ar: "",
                "de-DE": "Vibration",
                "es-ES": "Vibracin",
                "fr-FR": "Vibration",
                "it-IT": "Vibrazione",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wibracja",
                "pt-BR": "Vibrao",
                "pt-PT": "Vibrao",
                "ru-RU": "",
                "tr-TR": "Titreim",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Steering control side": {
                ar: "   ",
                "de-DE": "Steuerungsseite",
                "es-ES": "Lado de control de direccin",
                "fr-FR": "Ct de contrle de la direction",
                "it-IT": "Lato del controllo dello sterzo",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Strona sterowania kierownic",
                "pt-BR": "Lado do controle de direo",
                "pt-PT": "Lado do Controle de Direo",
                "ru-RU": "  ",
                "tr-TR": "Direksiyon kontrol taraf",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Left: {
                ar: "",
                "de-DE": "Links",
                "es-ES": "Izquierda",
                "fr-FR": "Gauche",
                "it-IT": "Sinistra",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Lewo",
                "pt-BR": "Esquerda",
                "pt-PT": "Esquerda",
                "ru-RU": "",
                "tr-TR": "Sol",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Right: {
                ar: "",
                "de-DE": "Rechts",
                "es-ES": "Derecha",
                "fr-FR": "Droite",
                "it-IT": "Destra",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Prawo",
                "pt-BR": "Direita",
                "pt-PT": "Direita",
                "ru-RU": "",
                "tr-TR": "Sa",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Controls: {
                ar: "",
                "de-DE": "Steuerung",
                "es-ES": "Controles",
                "fr-FR": "Commandes",
                "it-IT": "Controlli",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Sterowanie",
                "pt-BR": "Controles",
                "pt-PT": "Controlos",
                "ru-RU": "",
                "tr-TR": "Kontroller",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Vehicle: {
                ar: "",
                "de-DE": "Fahrzeug",
                "es-ES": "Vehculo",
                "fr-FR": "Vhicule",
                "it-IT": "Veicolo",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Pojazd",
                "pt-BR": "Veculo",
                "pt-PT": "Veculo",
                "ru-RU": "",
                "tr-TR": "Ara",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Accelerate: {
                ar: "",
                "de-DE": "Beschleunigen",
                "es-ES": "Acelerar",
                "fr-FR": "Acclrer",
                "it-IT": "Accelerare",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Przyspiesz",
                "pt-BR": "Acelerar",
                "pt-PT": "Acelerar",
                "ru-RU": "",
                "tr-TR": "Hzlan",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Brake: {
                ar: "",
                "de-DE": "Bremsen",
                "es-ES": "Frenar",
                "fr-FR": "Freiner",
                "it-IT": "Frenare",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Hamuj",
                "pt-BR": "Freio",
                "pt-PT": "Travar",
                "ru-RU": "",
                "tr-TR": "Fren",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Turn left": {
                ar: " ",
                "de-DE": "Nach links lenken",
                "es-ES": "Girar a la izquierda",
                "fr-FR": "Tourner  gauche",
                "it-IT": "Svolta a sinistra",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Skr w lewo",
                "pt-BR": "Virar  Esquerda",
                "pt-PT": "Virar  Esquerda",
                "ru-RU": " ",
                "tr-TR": "Sola dn",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Turn right": {
                ar: " ",
                "de-DE": "Nach rechts lenken",
                "es-ES": "Girar a la derecha",
                "fr-FR": "Tourner  droite",
                "it-IT": "Svolta a destra",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Skr w prawo",
                "pt-BR": "Virar  Direita",
                "pt-PT": "Virar  Direita",
                "ru-RU": " ",
                "tr-TR": "Saa dn",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Checkpoint reset": {
                ar: "   ",
                "de-DE": "Kontrollpunkt zurcksetzen",
                "es-ES": "Restablecer punto de control",
                "fr-FR": "Rinitialisation du point de contrle",
                "it-IT": "Reset checkpoint",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Reset punktu kontrolnego",
                "pt-BR": "Redefinir Ponto de Verificao",
                "pt-PT": "Repor o Ponto de Verificao",
                "ru-RU": "  ",
                "tr-TR": "Kontrol noktas sfrla",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Start reset": {
                ar: "  ",
                "de-DE": "Start zurcksetzen",
                "es-ES": "Restablecer inicio",
                "fr-FR": "Rinitialisation du dpart",
                "it-IT": "Reset partenza",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Reset startu",
                "pt-BR": "Redefinir Incio",
                "pt-PT": "Repor o Incio",
                "ru-RU": " ",
                "tr-TR": "Balang sfrla",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Cockpit camera": {
                ar: " ",
                "de-DE": "Cockpit-Kamera",
                "es-ES": "Cmara en la cabina",
                "fr-FR": "Camra cockpit",
                "it-IT": "Telecamera cabina",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Kamera kokpitu",
                "pt-BR": "Cmera do Cockpit",
                "pt-PT": "Cmera de Cabine",
                "ru-RU": " ",
                "tr-TR": "Kokpit kamera",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate part": {
                ar: " ",
                "de-DE": "Teil drehen",
                "es-ES": "Girar parte",
                "fr-FR": "Pivoter la partie",
                "it-IT": "Ruota parte",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Obr cz",
                "pt-BR": "Girar Parte",
                "pt-PT": "Rodar Parte",
                "ru-RU": " ",
                "tr-TR": "Paray dndr",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Height modifier": {
                ar: " ",
                "de-DE": "Hhenmodifikator",
                "es-ES": "Modificador de altura",
                "fr-FR": "Modificateur de hauteur",
                "it-IT": "Modificatore altezza",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Modyfikator wysokoci",
                "pt-BR": "Modificador de Altura",
                "pt-PT": "Modificador de Altura",
                "ru-RU": " ",
                "tr-TR": "Ykseklik deitir",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Delete part": {
                ar: " ",
                "de-DE": "Teil lschen",
                "es-ES": "Eliminar parte",
                "fr-FR": "Supprimer la partie",
                "it-IT": "Elimina parte",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Usu cz",
                "pt-BR": "Excluir Parte",
                "pt-PT": "Eliminar Parte",
                "ru-RU": " ",
                "tr-TR": "Paray sil",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move forwards": {
                ar: " ",
                "de-DE": "Nach vorne bewegen",
                "es-ES": "Mover hacia adelante",
                "fr-FR": "Avancer",
                "it-IT": "Muovi avanti",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Poruszaj si do przodu",
                "pt-BR": "Mover para Frente",
                "pt-PT": "Mover para a frente",
                "ru-RU": " ",
                "tr-TR": "leri git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move backwards": {
                ar: " ",
                "de-DE": "Nach hinten bewegen",
                "es-ES": "Mover hacia atrs",
                "fr-FR": "Reculer",
                "it-IT": "Muovi indietro",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Poruszaj si do tyu",
                "pt-BR": "Mover para Trs",
                "pt-PT": "Mover para trs",
                "ru-RU": " ",
                "tr-TR": "Geri git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move left": {
                ar: " ",
                "de-DE": "Nach links bewegen",
                "es-ES": "Mover a la izquierda",
                "fr-FR": "Dplacer  gauche",
                "it-IT": "Muovi a sinistra",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Poruszaj si w lewo",
                "pt-BR": "Mover para a Esquerda",
                "pt-PT": "Mover para a esquerda",
                "ru-RU": " ",
                "tr-TR": "Sola git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move right": {
                ar: " ",
                "de-DE": "Nach rechts bewegen",
                "es-ES": "Mover a la derecha",
                "fr-FR": "Dplacer  droite",
                "it-IT": "Muovi a destra",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Poruszaj si w prawo",
                "pt-BR": "Mover para a Direita",
                "pt-PT": "Mover para a direita",
                "ru-RU": " ",
                "tr-TR": "Saa git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate view up": {
                ar: "  ",
                "de-DE": "Ansicht nach oben drehen",
                "es-ES": "Girar vista hacia arriba",
                "fr-FR": "Pivoter la vue vers le haut",
                "it-IT": "Ruota vista in alto",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Obr widok w gr",
                "pt-BR": "Girar Viso para Cima",
                "pt-PT": "Rodar a vista para cima",
                "ru-RU": "  ",
                "tr-TR": "Grnm yukar dndr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate view down": {
                ar: "  ",
                "de-DE": "Ansicht nach unten drehen",
                "es-ES": "Girar vista hacia abajo",
                "fr-FR": "Pivoter la vue vers le bas",
                "it-IT": "Ruota vista in basso",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Obr widok w d",
                "pt-BR": "Girar Viso para Baixo",
                "pt-PT": "Rodar a vista para baixo",
                "ru-RU": "  ",
                "tr-TR": "Grnm aa dndr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate view left": {
                ar: "  ",
                "de-DE": "Ansicht nach links drehen",
                "es-ES": "Girar vista a la izquierda",
                "fr-FR": "Pivoter la vue  gauche",
                "it-IT": "Ruota vista a sinistra",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Obr widok w lewo",
                "pt-BR": "Girar Viso para a Esquerda",
                "pt-PT": "Rodar a vista para a esquerda",
                "ru-RU": "  ",
                "tr-TR": "Grnm sola dndr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Rotate view right": {
                ar: "  ",
                "de-DE": "Ansicht nach rechts drehen",
                "es-ES": "Girar vista a la derecha",
                "fr-FR": "Pivoter la vue  droite",
                "it-IT": "Ruota vista a destra",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Obr widok w prawo",
                "pt-BR": "Girar Viso para a Direita",
                "pt-PT": "Rodar a vista para a direita",
                "ru-RU": "  ",
                "tr-TR": "Grnm saa dndr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move down": {
                ar: " ",
                "de-DE": "Nach unten bewegen",
                "es-ES": "Mover hacia abajo",
                "fr-FR": "Descendre",
                "it-IT": "Muovi gi",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Przesu w d",
                "pt-BR": "Mover para Baixo",
                "pt-PT": "Mover para baixo",
                "ru-RU": " ",
                "tr-TR": "Aa git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Move up": {
                ar: " ",
                "de-DE": "Nach oben bewegen",
                "es-ES": "Mover hacia arriba",
                "fr-FR": "Monter",
                "it-IT": "Muovi su",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Przesu w gr",
                "pt-BR": "Mover para Cima",
                "pt-PT": "Mover para cima",
                "ru-RU": " ",
                "tr-TR": "Yukar git",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Test track": {
                ar: " ",
                "de-DE": "Strecke testen",
                "es-ES": "Probar pista",
                "fr-FR": "Tester la piste",
                "it-IT": "Test percorso",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Testuj tras",
                "pt-BR": "Testar Pista",
                "pt-PT": "Testar Pista",
                "ru-RU": " ",
                "tr-TR": "Rota test et",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Pick part": {
                ar: " ",
                "de-DE": "Teil auswhlen",
                "es-ES": "Seleccionar parte",
                "fr-FR": "Choisir la partie",
                "it-IT": "Seleziona parte",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wybierz cz",
                "pt-BR": "Escolher Parte",
                "pt-PT": "Escolher Parte",
                "ru-RU": " ",
                "tr-TR": "Para se",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Spectator: {
                ar: "",
                "de-DE": "Zuschauer",
                "es-ES": "Espectador",
                "fr-FR": "Spectateur",
                "it-IT": "Spettatore",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Widz",
                "pt-BR": "Espectador",
                "pt-PT": "Espectador",
                "ru-RU": "",
                "tr-TR": "Seyirci",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Speed modifier": {
                ar: " ",
                "de-DE": "Geschwindigkeitsmodifikator",
                "es-ES": "Modificador de velocidad",
                "fr-FR": "Modificateur de vitesse",
                "it-IT": "Modificatore velocit",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Modyfikator prdkoci",
                "pt-BR": "Modificador de Velocidade",
                "pt-PT": "Modificador de Velocidade",
                "ru-RU": " ",
                "tr-TR": "Hz deitir",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Replay: {
                ar: "",
                "de-DE": "Wiederholung",
                "es-ES": "Repeticin",
                "fr-FR": "Rejouer",
                "it-IT": "Replay",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Powtrka",
                "pt-BR": "Repetir",
                "pt-PT": "Repetir",
                "ru-RU": "",
                "tr-TR": "Yeniden Oynat",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Step forward": {
                ar: " ",
                "de-DE": "Schritt vorwrts",
                "es-ES": "Paso adelante",
                "fr-FR": "Avancer d'une tape",
                "it-IT": "Passo avanti",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Krok do przodu",
                "pt-BR": "Passo  Frente",
                "pt-PT": "Passo em Frente",
                "ru-RU": " ",
                "tr-TR": "leri adm",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Step back": {
                ar: " ",
                "de-DE": "Schritt zurck",
                "es-ES": "Paso atrs",
                "fr-FR": "Reculer d'une tape",
                "it-IT": "Passo indietro",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Krok w ty",
                "pt-BR": "Passo para Trs",
                "pt-PT": "Passo para Trs",
                "ru-RU": " ",
                "tr-TR": "Geri adm",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Other: {
                ar: "",
                "de-DE": "Sonstiges",
                "es-ES": "Otro",
                "fr-FR": "Autre",
                "it-IT": "Altro",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Inne",
                "pt-BR": "Outro",
                "pt-PT": "Outro",
                "ru-RU": "",
                "tr-TR": "Dier",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Hide UI": {
                ar: "  ",
                "de-DE": "UI ausblenden",
                "es-ES": "Ocultar IU",
                "fr-FR": "Masquer l'interface utilisateur",
                "it-IT": "Nascondi UI",
                "ja-JP": "UI",
                "ko-KR": "UI ",
                "pl-PL": "Ukryj UI",
                "pt-BR": "Ocultar UI",
                "pt-PT": "Esconder UI",
                "ru-RU": " ",
                "tr-TR": "UI'yi gizle",
                "uk-UA": " ",
                "zh-CN": "UI",
                "zh-TW": " UI"
            },
            Pause: {
                ar: " ",
                "de-DE": "Pause",
                "es-ES": "Pausa",
                "fr-FR": "Pause",
                "it-IT": "Pausa",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Pauza",
                "pt-BR": "Pausar",
                "pt-PT": "Pausa",
                "ru-RU": "",
                "tr-TR": "Duraklat",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Toggle FPS counter": {
                ar: "    ",
                "de-DE": "FPS-Zhler umschalten",
                "es-ES": "Alternar contador de FPS",
                "fr-FR": "Basculer le compteur FPS",
                "it-IT": "Attiva/Disattiva contatore FPS",
                "ja-JP": "FPS",
                "ko-KR": "FPS  ",
                "pl-PL": "Przecz licznik FPS",
                "pt-BR": "Alternar Contador de FPS",
                "pt-PT": "Alternar Contador de FPS",
                "ru-RU": "  FPS",
                "tr-TR": "FPS sayacn deitir",
                "uk-UA": "  FPS",
                "zh-CN": "FPS",
                "zh-TW": " FPS "
            },
            "Toggle spectator camera": {
                ar: "  ",
                "de-DE": "Zuschauerkamera umschalten",
                "es-ES": "Alternar cmara de espectador",
                "fr-FR": "Basculer la camra spectateur",
                "it-IT": "Attiva/Disattiva telecamera spettatore",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Przecz kamer widza",
                "pt-BR": "Alternar Cmera de Espectador",
                "pt-PT": "Alternar Cmara de Espectador",
                "ru-RU": "  ",
                "tr-TR": "Seyirci kamerasn deitir",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Press any key...\n\nPress [Escape] to cancel.": {
                ar: "   ...\n\n [] .",
                "de-DE": "Drcken Sie eine beliebige Taste...\n\nDrcken Sie [Escape], um abzubrechen.",
                "es-ES": "Presiona cualquier tecla...\n\nPresiona [Escape] para cancelar.",
                "fr-FR": "Appuyez sur n'importe quelle touche...\n\nAppuyez sur [chap] pour annuler.",
                "it-IT": "Premi un tasto qualsiasi...\n\nPremi [Esc] per annullare.",
                "ja-JP": "...\n\n[Escape] ",
                "ko-KR": "  ...\n\n[Escape]  .",
                "pl-PL": "Nacinij dowolny klawisz...\n\nNacinij [Escape], aby anulowa.",
                "pt-BR": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
                "pt-PT": "Pressione qualquer tecla...\n\nPressione [Escape] para cancelar.",
                "ru-RU": "  ...\n\n [Escape],  .",
                "tr-TR": "Herhangi bir tua basn...\n\nptal etmek iin [Escape] tuuna basn",
                "uk-UA": " - ...\n\n [Escape],  .",
                "zh-CN": "...\n\n [Escape] ",
                "zh-TW": "...\n\n [Escape] "
            },
            Clear: {
                ar: "",
                "de-DE": "Lschen",
                "es-ES": "Borrar",
                "fr-FR": "Effacer",
                "it-IT": "Cancella",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Wyczy",
                "pt-BR": "Limpar",
                "pt-PT": "Limpar",
                "ru-RU": "",
                "tr-TR": "Temizle",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "NEW PERSONAL BEST": {
                ar: "   ",
                "de-DE": "NEUER PERSNLICHER BESTWERT",
                "es-ES": "NUEVO MEJOR RCORD PERSONAL",
                "fr-FR": "NOUVEAU MEILLEUR TEMPS PERSONNEL",
                "it-IT": "NUOVO RECORD PERSONALE",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "NOWY REKORD YCIOWY",
                "pt-BR": "NOVO RECORDE PESSOAL",
                "pt-PT": "NOVO RECORDE PESSOAL",
                "ru-RU": "  ",
                "tr-TR": "YEN KSEL REKOR",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "NEW SESSION BEST": {
                ar: "  ",
                "de-DE": "NEUER SITZUNGSBESTWERT",
                "es-ES": "NUEVO MEJOR RCORD DE SESIN",
                "fr-FR": "NOUVEAU MEILLEUR TEMPS DE SESSION",
                "it-IT": "NUOVO RECORD DI SESSIONE",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "NOWY REKORD SESJI",
                "pt-BR": "NOVO RECORDE DE SESSO",
                "pt-PT": "NOVO RECORDE DE SESSO",
                "ru-RU": "  ",
                "tr-TR": "YEN OTURUM REKORU",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Record: {
                ar: " ",
                "de-DE": "Rekord",
                "es-ES": "Rcord",
                "fr-FR": "Record",
                "it-IT": "Record",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Rekord",
                "pt-BR": "Recorde",
                "pt-PT": "Recorde",
                "ru-RU": "",
                "tr-TR": "Kayt",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Current: {
                ar: "",
                "de-DE": "Aktuell",
                "es-ES": "Actual",
                "fr-FR": "Actuel",
                "it-IT": "Attuale",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Aktualny",
                "pt-BR": "Atual",
                "pt-PT": "Atual",
                "ru-RU": "",
                "tr-TR": "Mevcut",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Difference: {
                ar: "",
                "de-DE": "Differenz",
                "es-ES": "Diferencia",
                "fr-FR": "Diffrence",
                "it-IT": "Differenza",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Rnica",
                "pt-BR": "Diferena",
                "pt-PT": "Diferena",
                "ru-RU": "",
                "tr-TR": "Fark",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Copy: {
                ar: "",
                "de-DE": "Kopieren",
                "es-ES": "Copiar",
                "fr-FR": "Copier",
                "it-IT": "Copia",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Kopiuj",
                "pt-BR": "Copiar",
                "pt-PT": "Copiar",
                "ru-RU": "",
                "tr-TR": "Kopyala",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Copied!": {
                ar: " !",
                "de-DE": "Kopiert!",
                "es-ES": "Copiado!",
                "fr-FR": "Copi!",
                "it-IT": "Copiato!",
                "ja-JP": "",
                "ko-KR": "!",
                "pl-PL": "Skopiowano!",
                "pt-BR": "Copiado!",
                "pt-PT": "Copiado!",
                "ru-RU": "!",
                "tr-TR": "Kopyaland!",
                "uk-UA": "!",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Error!": {
                ar: "!",
                "de-DE": "Fehler!",
                "es-ES": "Error!",
                "fr-FR": "Erreur!",
                "it-IT": "Errore!",
                "ja-JP": "",
                "ko-KR": "!",
                "pl-PL": "Bd!",
                "pt-BR": "Erro!",
                "pt-PT": "Erro!",
                "ru-RU": "!",
                "tr-TR": "Hata!",
                "uk-UA": "!",
                "zh-CN": "",
                "zh-TW": ""
            },
            Import: {
                ar: "",
                "de-DE": "Importieren",
                "es-ES": "Importar",
                "fr-FR": "Importer",
                "it-IT": "Importa",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Importuj",
                "pt-BR": "Importar",
                "pt-PT": "Importar",
                "ru-RU": "",
                "tr-TR": "e Aktar",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Invalid track code": {
                ar: "   ",
                "de-DE": "Ungltiger Streckencode",
                "es-ES": "Cdigo de pista no vlido",
                "fr-FR": "Code de piste invalide",
                "it-IT": "Codice del percorso non valido",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nieprawidowy kod trasy",
                "pt-BR": "Cdigo de pista invlido",
                "pt-PT": "Cdigo de pista invlido",
                "ru-RU": "  ",
                "tr-TR": "Geersiz rota kodu",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Invalid track code for track {0}": {
                ar: "     {0}",
                "de-DE": "Ungltiger Streckencode fr Strecke {0}",
                "es-ES": "Cdigo de pista no vlido para la pista {0}",
                "fr-FR": "Code de piste invalide pour la piste {0}",
                "it-IT": "Codice del percorso non valido per il percorso {0}",
                "ja-JP": " {0} ",
                "ko-KR": " {0}    ",
                "pl-PL": "Nieprawidowy kod trasy dla trasy {0}",
                "pt-BR": "Cdigo de pista invlido para a pista {0}",
                "pt-PT": "Cdigo de pista invlido para a pista {0}",
                "ru-RU": "     {0}",
                "tr-TR": "Rota {0} iin geersiz rota kodu",
                "uk-UA": "     {0}",
                "zh-CN": " {0} ",
                "zh-TW": " {0} "
            },
            "Failed to save track": {
                ar: "   ",
                "de-DE": "Fehler beim Speichern der Strecke",
                "es-ES": "Error al guardar la pista",
                "fr-FR": "chec de l'enregistrement de la piste",
                "it-IT": "Salvataggio del percorso non riuscito",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nie mona zapisa trasy",
                "pt-BR": "Falha ao salvar a pista",
                "pt-PT": "Falha ao salvar a pista",
                "ru-RU": "   ",
                "tr-TR": "Rota kaydedilemedi",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to save track {0}": {
                ar: "    {0}",
                "de-DE": "Fehler beim Speichern der Strecke {0}",
                "es-ES": "Error al guardar la pista {0}",
                "fr-FR": "chec de l'enregistrement de la piste {0}",
                "it-IT": "Salvataggio del percorso {0} non riuscito",
                "ja-JP": " {0} ",
                "ko-KR": " {0}  ",
                "pl-PL": "Nie mona zapisa trasy {0}",
                "pt-BR": "Falha ao salvar a pista {0}",
                "pt-PT": "Falha ao salvar a pista {0}",
                "ru-RU": "    {0}",
                "tr-TR": "Rota {0} kaydedilemedi",
                "uk-UA": "    {0}",
                "zh-CN": " {0} ",
                "zh-TW": " {0} "
            },
            'The track "{0}" already exists. Do you wish to overwrite it?': {
                ar: ' "{0}"  .     ',
                "de-DE": 'Die Strecke "{0}" existiert bereits. Mchten Sie sie berschreiben?',
                "es-ES": 'La pista "{0}" ya existe. Deseas sobrescribirla?',
                "fr-FR": 'La piste "{0}" existe dj. Souhaitez-vous l\'craser ?',
                "it-IT": 'Il percorso "{0}" esiste gi. Vuoi sovrascriverlo?',
                "ja-JP": "{0}",
                "ko-KR": '"{0}"   . ?',
                "pl-PL": "Trasa {0} ju istnieje. Czy chcesz j nadpisa?",
                "pt-BR": 'A pista "{0}" j existe. Deseja sobrescrev-la?',
                "pt-PT": 'A pista "{0}" j existe. Deseja substitu-la?',
                "ru-RU": ' "{0}"  .   ?',
                "tr-TR": '"{0}" rota zaten var. zerine yazmak istiyor musunuz?',
                "uk-UA": ' "{0}"  .   ?',
                "zh-CN": ' "{0}" ',
                "zh-TW": ' "{0}" '
            },
            Overwrite: {
                ar: " ",
                "de-DE": "berschreiben",
                "es-ES": "Sobrescribir",
                "fr-FR": "craser",
                "it-IT": "Sovrascrivi",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Nadpisz",
                "pt-BR": "Sobrescrever",
                "pt-PT": "Substituir",
                "ru-RU": "",
                "tr-TR": "zerine yaz",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Paste track data here...": {
                ar: "   ...",
                "de-DE": "Streckendaten hier einfgen...",
                "es-ES": "Pegar datos de la pista aqu...",
                "fr-FR": "Collez les donnes de la piste ici...",
                "it-IT": "Incolla dati del percorso qui...",
                "ja-JP": "...",
                "ko-KR": "   ...",
                "pl-PL": "Wklej dane trasy tutaj...",
                "pt-BR": "Cole os dados da pista aqui...",
                "pt-PT": "Cole os dados da pista aqui...",
                "ru-RU": "   ...",
                "tr-TR": "Rota verilerini buraya yaptr...",
                "uk-UA": "   ...",
                "zh-CN": "...",
                "zh-TW": "..."
            },
            Rank: {
                ar: "",
                "de-DE": "Rang",
                "es-ES": "Rango",
                "fr-FR": "Classement",
                "it-IT": "Posizione",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Ranking",
                "pt-BR": "Classificao",
                "pt-PT": "Classificao",
                "ru-RU": "",
                "tr-TR": "Sra",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Personal best": {
                ar: "  ",
                "de-DE": "Persnlicher Rekord",
                "es-ES": "Mejor marca personal",
                "fr-FR": "Meilleur temps personnel",
                "it-IT": "Miglior tempo personale",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Najlepszy wynik",
                "pt-BR": "Melhor pessoal",
                "pt-PT": "Melhor Pessoal",
                "ru-RU": " ",
                "tr-TR": "Kiisel en iyi",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Opponents: {
                ar: "",
                "de-DE": "Gegner",
                "es-ES": "Oponentes",
                "fr-FR": "Adversaires",
                "it-IT": "Avversari",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Przeciwnicy",
                "pt-BR": "Oponentes",
                "pt-PT": "Oponentes",
                "ru-RU": "",
                "tr-TR": "Rakipler",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "{0} opponent selected": {
                ar: "{0}  ",
                "de-DE": "{0} Gegner ausgewhlt",
                "es-ES": "{0} oponente seleccionado",
                "fr-FR": "{0} adversaire slectionn",
                "it-IT": "{0} avversario selezionato",
                "ja-JP": "{0} ",
                "ko-KR": "{0}  ",
                "pl-PL": "{0} przeciwnik wybrany",
                "pt-BR": "{0} oponente selecionado",
                "pt-PT": "{0} oponente selecionado",
                "ru-RU": "{0}  ",
                "tr-TR": "{0} rakip seildi",
                "uk-UA": "{0}  ",
                "zh-CN": "{0} ",
                "zh-TW": "{0} "
            },
            "{0} opponents selected": {
                ar: "{0}  ",
                "de-DE": "{0} Gegner ausgewhlt",
                "es-ES": "{0} oponente seleccionado",
                "fr-FR": "{0} adversaires slectionns",
                "it-IT": "{0} avversari selezionati",
                "ja-JP": "{0} ",
                "ko-KR": "{0}  ",
                "pl-PL": "{0} przeciwnikw wybranych",
                "pt-BR": "{0} oponentes selecionados",
                "pt-PT": "{0} oponentes selecionados",
                "ru-RU": "{0}  ",
                "tr-TR": "{0} rakip seildi",
                "uk-UA": "{0}  ",
                "zh-CN": "{0} ",
                "zh-TW": "{0} "
            },
            "Select opponents to race against from the leaderboard on the left": {
                ar: "        ",
                "de-DE": "Whlen Sie Gegner aus der Bestenliste links aus, gegen die Sie antreten mchten",
                "es-ES": "Selecciona oponentes con los que competir en la tabla de clasificacin de la izquierda",
                "fr-FR": "Slectionnez des adversaires contre lesquels courir dans le classement sur la gauche",
                "it-IT": "Seleziona gli avversari con cui gareggiare dalla classifica a sinistra",
                "ja-JP": "",
                "ko-KR": "    ",
                "pl-PL": "Wybierz przeciwnikw, przeciwko ktrym chcesz ciga si z tabeli wynikw po lewej stronie",
                "pt-BR": "Selecione os oponentes para competir no quadro de lderes  esquerda",
                "pt-PT": "Selecione os oponentes para competir na tabela de classificao  esquerda",
                "ru-RU": "       ",
                "tr-TR": "Soldaki liderlik tablosundan yarmak iin rakipleri sein",
                "uk-UA": "       ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "No record": {
                ar: "  ",
                "de-DE": "Kein Rekord",
                "es-ES": "Sin rcord",
                "fr-FR": "Pas de record",
                "it-IT": "Nessun record",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Brak rekordu",
                "pt-BR": "Sem recorde",
                "pt-PT": "Sem Registo",
                "ru-RU": " ",
                "tr-TR": "Kayt yok",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Official tracks": {
                ar: " ",
                "de-DE": "Offizielle Strecken",
                "es-ES": "Pistas oficiales",
                "fr-FR": "Pistes officielles",
                "it-IT": "Percorsi ufficiali",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Oficjalne trasy",
                "pt-BR": "Pistas Oficiais",
                "pt-PT": "Pistas Oficiais",
                "ru-RU": " ",
                "tr-TR": "Resmi rotalar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Community tracks": {
                ar: " ",
                "de-DE": "Community-Strecken",
                "es-ES": "Pistas de la comunidad",
                "fr-FR": "Pistes communautaires",
                "it-IT": "Percorsi della community",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Trasy spoecznoci",
                "pt-BR": "Pistas Comunitrias",
                "pt-PT": "Pistas da Comunidade",
                "ru-RU": " ",
                "tr-TR": "Topluluk rotalar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Custom tracks": {
                ar: " ",
                "de-DE": "Benutzerdefinierte Strecken",
                "es-ES": "Pistas personalizadas",
                "fr-FR": "Pistes personnalises",
                "it-IT": "Percorsi personalizzati",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Niestandardowe trasy",
                "pt-BR": "Pistas Personalizadas",
                "pt-PT": "Pistas Personalizadas",
                "ru-RU": " ",
                "tr-TR": "zel rotalar",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            'Are you sure you want to delete "{0}"?': {
                ar: '       "{0}"',
                "de-DE": 'Sind Sie sicher, dass Sie "{0}" lschen mchten?',
                "es-ES": 'Ests seguro de que deseas eliminar "{0}"?',
                "fr-FR": 'tes-vous sr de vouloir supprimer "{0}" ?',
                "it-IT": 'Sei sicuro di voler eliminare "{0}"?',
                "ja-JP": '"{0}" ',
                "ko-KR": '"{0}"() ?',
                "pl-PL": "Czy na pewno chcesz usun {0}?",
                "pt-BR": 'Tem certeza de que deseja excluir "{0}"?',
                "pt-PT": 'Tem a certeza de que deseja eliminar "{0}"?',
                "ru-RU": ' ,    "{0}"?',
                "tr-TR": '"{0}" silmek istediinizden emin misiniz?',
                "uk-UA": ' ,    "{0}"?',
                "zh-CN": ' "{0}" ',
                "zh-TW": ' "{0}" '
            },
            Delete: {
                ar: "",
                "de-DE": "Lschen",
                "es-ES": "Eliminar",
                "fr-FR": "Supprimer",
                "it-IT": "Elimina",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Usu",
                "pt-BR": "Excluir",
                "pt-PT": "Eliminar",
                "ru-RU": "",
                "tr-TR": "Sil",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "No community tracks": {
                ar: "   ",
                "de-DE": "Keine Community-Strecken",
                "es-ES": "No hay pistas de la comunidad",
                "fr-FR": "Pas de pistes communautaires",
                "it-IT": "Nessun percorso della community",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Brak tras spoecznoci",
                "pt-BR": "Sem pistas comunitrias",
                "pt-PT": "Sem pistas da comunidade",
                "ru-RU": "  ",
                "tr-TR": "Topluluk rotas yok",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Community tracks are coming soon": {
                ar: "   ",
                "de-DE": "Community-Strecken kommen bald",
                "es-ES": "Las pistas de la comunidad llegarn pronto",
                "fr-FR": "Les pistes communautaires arrivent bientt",
                "it-IT": "I percorsi della community arriveranno presto",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Trasy spoecznoci wkrtce",
                "pt-BR": "Pistas comunitrias em breve",
                "pt-PT": "Pistas da comunidade em breve",
                "ru-RU": "   ",
                "tr-TR": "Topluluk rotalar yaknda gelecek",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "No custom tracks": {
                ar: "   ",
                "de-DE": "Keine benutzerdefinierten Strecken",
                "es-ES": "No hay pistas personalizadas",
                "fr-FR": "Pas de pistes personnalises",
                "it-IT": "Nessun percorso personalizzato",
                "ja-JP": "",
                "ko-KR": "   ",
                "pl-PL": "Brak niestandardowych tras",
                "pt-BR": "Sem pistas personalizadas",
                "pt-PT": "Sem pistas personalizadas",
                "ru-RU": "  ",
                "tr-TR": "zel rotalar yok",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Create a track using the editor or import a track code": {
                ar: "       ",
                "de-DE": "Erstellen Sie eine Strecke mit dem Editor oder importieren Sie einen Streckencode",
                "es-ES": "Crea una pista usando el editor o importa un cdigo de pista",
                "fr-FR": "Crez une piste en utilisant l'diteur ou importez un code de piste",
                "it-IT": "Crea un percorso utilizzando l'editor o importa un codice percorso",
                "ja-JP": "",
                "ko-KR": "        ",
                "pl-PL": "Utwrz tras za pomoc edytora lub zaimportuj kod trasy",
                "pt-BR": "Crie uma pista usando o editor ou importe um cdigo de pista",
                "pt-PT": "Crie uma pista usando o editor ou importe um cdigo de pista",
                "ru-RU": "        ",
                "tr-TR": "Editr kullanarak bir rota oluturun veya bir rota kodu ie aktarn",
                "uk-UA": "        ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Search by track or author...": {
                ar: "    ...",
                "de-DE": "Suche nach Strecke oder Autor...",
                "es-ES": "Buscar por pista o autor...",
                "fr-FR": "Rechercher par piste ou auteur...",
                "it-IT": "Cerca per percorso o autore...",
                "ja-JP": "...",
                "ko-KR": "   ...",
                "pl-PL": "Szukaj wedug trasy lub autora...",
                "pt-BR": "Pesquisar por pista ou autor...",
                "pt-PT": "Pesquisar por pista ou autor...",
                "ru-RU": "    ...",
                "tr-TR": "Rota veya yazar arayn...",
                "uk-UA": "    ...",
                "zh-CN": "...",
                "zh-TW": "..."
            },
            "Invalid replay detected!": {
                ar: "    !",
                "de-DE": "Ungltige Wiederholung erkannt!",
                "es-ES": "Se detect una repeticin no vlida!",
                "fr-FR": "Rejouer invalide dtect!",
                "it-IT": "Riproduzione non valida rilevata!",
                "ja-JP": "",
                "ko-KR": "   !",
                "pl-PL": "Wykryto nieprawidowe nagranie!",
                "pt-BR": "Replay invlido detectado!",
                "pt-PT": "Replay invlido detetado!",
                "ru-RU": "  !",
                "tr-TR": "Geersiz tekrar algland!",
                "uk-UA": "  !",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Join Multiplayer Game": {
                ar: "    ",
                "de-DE": "Multiplayer-Spiel beitreten",
                "es-ES": "Unirse a la partida multijugador",
                "fr-FR": "Rejoindre une partie multijoueur",
                "it-IT": "Unisciti a una partita multiplayer",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Docz do gry wieloosobowej",
                "pt-BR": "Entrar no jogo multiplayer",
                "pt-PT": "Entrar no jogo multiplayer",
                "ru-RU": "   ",
                "tr-TR": "ok oyunculu oyuna katl",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Host Multiplayer Game": {
                ar: "   ",
                "de-DE": "Multiplayer-Spiel hosten",
                "es-ES": "Hostear partida multijugador",
                "fr-FR": "Hberger une partie multijoueur",
                "it-IT": "Hostare una partita multiplayer",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Hostowanie gry wieloosobowej",
                "pt-BR": "Hospedar jogo multiplayer",
                "pt-PT": "Hospedar jogo multiplayer",
                "ru-RU": "  ",
                "tr-TR": "ok oyunculu oyunu barndr",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Game Mode": {
                ar: " ",
                "de-DE": "Spielmodus",
                "es-ES": "Modo de juego",
                "fr-FR": "Mode de jeu",
                "it-IT": "Modalit di gioco",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Tryb gry",
                "pt-BR": "Modo de jogo",
                "pt-PT": "Modo de jogo",
                "ru-RU": " ",
                "tr-TR": "Oyun Modu",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            Casual: {
                ar: "",
                "de-DE": "Lssig",
                "es-ES": "Casual",
                "fr-FR": "Dcontract",
                "it-IT": "Casual",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Casual",
                "pt-BR": "Casual",
                "pt-PT": "Casual",
                "ru-RU": "",
                "tr-TR": "Gndelik",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Competitive: {
                ar: "",
                "de-DE": "Wettbewerbsfhig",
                "es-ES": "Competitivo",
                "fr-FR": "Comptitif",
                "it-IT": "Competitivo",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Konkurencyjny",
                "pt-BR": "Competitivo",
                "pt-PT": "Competitivo",
                "ru-RU": "",
                "tr-TR": "Rekabeti",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Players play to improve their personal best times.": {
                ar: "    .",
                "de-DE": "Spieler spielen, um ihre persnlichen Bestzeiten zu verbessern.",
                "es-ES": "Los jugadores juegan para mejorar sus mejores tiempos personales.",
                "fr-FR": "Les joueurs jouent pour amliorer leurs meilleurs temps personnels.",
                "it-IT": "I giocatori giocano per migliorare i loro tempi personali migliori.",
                "ja-JP": "",
                "ko-KR": "      .",
                "pl-PL": "Gracze graj, aby poprawi swoje najlepsze czasy.",
                "pt-BR": "Os jogadores jogam para melhorar seus melhores tempos pessoais.",
                "pt-PT": "Os jogadores jogam para melhorar os seus melhores tempos pessoais.",
                "ru-RU": " ,     .",
                "tr-TR": "Oyuncular kiisel en iyi zamanlarn gelitirmek iin oynar.",
                "uk-UA": " ,     .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Players compete to set the best time in the session.": {
                ar: "      .",
                "de-DE": "Spieler konkurrieren darum, die beste Zeit in der Sitzung zu erzielen.",
                "es-ES": "Los jugadores compiten para establecer el mejor tiempo en la sesin.",
                "fr-FR": "Les joueurs s'affrontent pour tablir le meilleur temps de la session.",
                "it-IT": "I giocatori competono per stabilire il miglior tempo nella sessione.",
                "ja-JP": "",
                "ko-KR": "      .",
                "pl-PL": "Gracze rywalizuj o najlepszy czas w sesji.",
                "pt-BR": "Os jogadores competem para definir o melhor tempo na sesso.",
                "pt-PT": "Os jogadores competem para definir o melhor tempo na sesso.",
                "ru-RU": "      .",
                "tr-TR": "Oyuncular, oturumda en iyi zaman belirlemek iin yaryor.",
                "uk-UA": "      .",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Maximum Players: {0}": {
                ar: "   : {0}",
                "de-DE": "Maximale Spieler: {0}",
                "es-ES": "Jugadores mximos: {0}",
                "fr-FR": "Joueurs maximum : {0}",
                "it-IT": "Giocatori massimi: {0}",
                "ja-JP": ": {0}",
                "ko-KR": " : {0}",
                "pl-PL": "Maksymalna liczba graczy: {0}",
                "pt-BR": "Jogadores mximos: {0}",
                "pt-PT": "Jogadores mximos: {0}",
                "ru-RU": "  : {0}",
                "tr-TR": "Maksimum Oyuncu: {0}",
                "uk-UA": "  : {0}",
                "zh-CN": ": {0}",
                "zh-TW": ": {0}"
            },
            "Select Track": {
                ar: " ",
                "de-DE": "Whlen Sie die Strecke",
                "es-ES": "Seleccionar pista",
                "fr-FR": "Slectionner la piste",
                "it-IT": "Seleziona il tracciato",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Wybierz tras",
                "pt-BR": "Selecionar pista",
                "pt-PT": "Selecionar pista",
                "ru-RU": " ",
                "tr-TR": "Parkur Se",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Enter invite code": {
                ar: "  ",
                "de-DE": "Geben Sie den Einladungscode ein",
                "es-ES": "Introduce el cdigo de invitacin",
                "fr-FR": "Entrez le code d'invitation",
                "it-IT": "Inserisci il codice di invito",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Wprowad kod zaproszenia",
                "pt-BR": "Digite o cdigo de convite",
                "pt-PT": "Digite o cdigo de convite",
                "ru-RU": "  ",
                "tr-TR": "Davet kodunu girin",
                "uk-UA": "  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Connecting...": {
                ar: " ...",
                "de-DE": "Verbinden...",
                "es-ES": "Conectando...",
                "fr-FR": "Connexion...",
                "it-IT": "Connessione...",
                "ja-JP": "...",
                "ko-KR": " ...",
                "pl-PL": "czenie...",
                "pt-BR": "Conectando...",
                "pt-PT": "Conectando...",
                "ru-RU": "...",
                "tr-TR": "Balanyor...",
                "uk-UA": "...",
                "zh-CN": "...",
                "zh-TW": "..."
            },
            "Error: The invite code has expired or is incorrect": {
                ar: ":       ",
                "de-DE": "Fehler: Der Einladungscode ist abgelaufen oder falsch",
                "es-ES": "Error: El cdigo de invitacin ha caducado o es incorrecto",
                "fr-FR": "Erreur : Le code d'invitation a expir ou est incorrect",
                "it-IT": "Errore: Il codice di invito  scaduto o non  corretto",
                "ja-JP": ": ",
                "ko-KR": ":     ",
                "pl-PL": "Bd: Kod zaproszenia wygas lub jest nieprawidowy",
                "pt-BR": "Erro: O cdigo de convite expirou ou est incorreto",
                "pt-PT": "Erro: O cdigo de convite expirou ou est incorreto",
                "ru-RU": ":     ",
                "tr-TR": "Hata: Davet kodunun sresi doldu veya yanl",
                "uk-UA": ":        ",
                "zh-CN": ": ",
                "zh-TW": ": "
            },
            "Error: The multiplayer server is full": {
                ar: ":    ",
                "de-DE": "Fehler: Der Mehrspielerserver ist voll",
                "es-ES": "Error: El servidor multijugador est lleno",
                "fr-FR": "Erreur : Le serveur multijoueur est plein",
                "it-IT": "Errore: Il server multiplayer  pieno",
                "ja-JP": ": ",
                "ko-KR": ":    ",
                "pl-PL": "Bd: Serwer wieloosobowy jest peny",
                "pt-BR": "Erro: O servidor multiplayer est cheio",
                "pt-PT": "Erro: O servidor multiplayer est cheio",
                "ru-RU": ":    ",
                "tr-TR": "Hata: ok oyunculu sunucu dolu",
                "uk-UA": ":    ",
                "zh-CN": ": ",
                "zh-TW": ": "
            },
            "Error: You were kicked from the game": {
                ar: ":    ",
                "de-DE": "Fehler: Du wurdest aus dem Spiel geworfen",
                "es-ES": "Error: Has sido expulsado del juego",
                "fr-FR": "Erreur : Vous avez t expuls du jeu",
                "it-IT": "Errore: Sei stato espulso dal gioco",
                "ja-JP": ": ",
                "ko-KR": ":   ",
                "pl-PL": "Bd: Zostae wyrzucony z gry",
                "pt-BR": "Erro: Voc foi expulso do jogo",
                "pt-PT": "Erro: Foste expulso do jogo",
                "ru-RU": ":     ",
                "tr-TR": "Hata: Oyundan atldnz",
                "uk-UA": ":    ",
                "zh-CN": ": ",
                "zh-TW": ": "
            },
            "Error: Failed to connect": {
                ar: ":  ",
                "de-DE": "Fehler: Verbindung fehlgeschlagen",
                "es-ES": "Error: Fall la conexin",
                "fr-FR": "Erreur : chec de la connexion",
                "it-IT": "Errore: Impossibile connettersi",
                "ja-JP": ": ",
                "ko-KR": ":  ",
                "pl-PL": "Bd: Nie udao si poczy",
                "pt-BR": "Erro: Falha ao conectar",
                "pt-PT": "Erro: Falha ao conectar",
                "ru-RU": ":   ",
                "tr-TR": "Hata: Balant baarsz",
                "uk-UA": ":   ",
                "zh-CN": ": ",
                "zh-TW": ": "
            },
            Join: {
                ar: "",
                "de-DE": "Beitreten",
                "es-ES": "Unirse",
                "fr-FR": "Rejoindre",
                "it-IT": "Unisciti",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Docz",
                "pt-BR": "Juntar-se",
                "pt-PT": "Juntar-se",
                "ru-RU": "",
                "tr-TR": "Katl",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            Host: {
                ar: "",
                "de-DE": "Host",
                "es-ES": "Anfitrin",
                "fr-FR": "Hte",
                "it-IT": "Host",
                "ja-JP": "",
                "ko-KR": "",
                "pl-PL": "Host",
                "pt-BR": "Host",
                "pt-PT": "Host",
                "ru-RU": "",
                "tr-TR": "Sunucu",
                "uk-UA": "",
                "zh-CN": "",
                "zh-TW": ""
            },
            "You were kicked from the game": {
                ar: "   ",
                "de-DE": "Du wurdest aus dem Spiel geworfen",
                "es-ES": "Has sido expulsado del juego",
                "fr-FR": "Vous avez t expuls du jeu",
                "it-IT": "Sei stato espulso dal gioco",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Zostae wyrzucony z gry",
                "pt-BR": "Voc foi expulso do jogo",
                "pt-PT": "Foste expulso do jogo",
                "ru-RU": "    ",
                "tr-TR": "Oyundan atldnz",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Lost connection to server": {
                ar: "  ",
                "de-DE": "Verbindung zum Server verloren",
                "es-ES": "Conexin perdida con el servidor",
                "fr-FR": "Connexion au serveur perdue",
                "it-IT": "Connessione al server persa",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Utracono poczenie z serwerem",
                "pt-BR": "Conexo perdida com o servidor",
                "pt-PT": "Conexo perdida com o servidor",
                "ru-RU": "   ",
                "tr-TR": "Sunucu ile balant kesildi",
                "uk-UA": " '  ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Creating invite...": {
                ar: "  ...",
                "de-DE": "Einladung wird erstellt...",
                "es-ES": "Creando invitacin...",
                "fr-FR": "Cration de l'invitation...",
                "it-IT": "Creazione dell'invito...",
                "ja-JP": "...",
                "ko-KR": "  ...",
                "pl-PL": "Tworzenie zaproszenia...",
                "pt-BR": "Criando convite...",
                "pt-PT": "Criando convite...",
                "ru-RU": " ...",
                "tr-TR": "Davet oluturuluyor...",
                "uk-UA": " ...",
                "zh-CN": "...",
                "zh-TW": "..."
            },
            "Share the invite code below to invite people to your game": {
                ar: "       ",
                "de-DE": "Teilen Sie den Einladungscode unten, um Personen zu Ihrem Spiel einzuladen",
                "es-ES": "Comparte el cdigo de invitacin a continuacin para invitar a personas a tu juego",
                "fr-FR": "Partagez le code d'invitation ci-dessous pour inviter des personnes  votre jeu",
                "it-IT": "Condividi il codice di invito qui sotto per invitare persone al tuo gioco",
                "ja-JP": "",
                "ko-KR": "      ",
                "pl-PL": "Udostpnij poniszy kod zaproszenia, aby zaprosi ludzi do swojej gry",
                "pt-BR": "Compartilhe o cdigo de convite abaixo para convidar pessoas para o seu jogo",
                "pt-PT": "Partilhe o cdigo de convite abaixo para convidar pessoas para o seu jogo",
                "ru-RU": "   ,      ",
                "tr-TR": "Aadaki davet kodunu paylaarak insanlar oyununuzda davet edin",
                "uk-UA": "   ,      ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Failed to create invite": {
                ar: "  ",
                "de-DE": "Fehler beim Erstellen der Einladung",
                "es-ES": "Error al crear la invitacin",
                "fr-FR": "chec de la cration de l'invitation",
                "it-IT": "Impossibile creare l'invito",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nie udao si utworzy zaproszenia",
                "pt-BR": "Falha ao criar convite",
                "pt-PT": "Falha ao criar convite",
                "ru-RU": "   ",
                "tr-TR": "Davet oluturulamad",
                "uk-UA": "   ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Too many hosts on this IP address": {
                ar: "       IP ",
                "de-DE": "Zu viele Hosts auf dieser IP-Adresse",
                "es-ES": "Demasiados hosts en esta direccin IP",
                "fr-FR": "Trop d'htes sur cette adresse IP",
                "it-IT": "Troppi host su questo indirizzo IP",
                "ja-JP": "IP",
                "ko-KR": " IP    ",
                "pl-PL": "Zbyt wiele hostw na tym adresie IP",
                "pt-BR": "Muitos hosts neste endereo IP",
                "pt-PT": "Muitos hosts neste endereo IP",
                "ru-RU": "     IP-",
                "tr-TR": "Bu IP adresinde ok fazla sunucu var",
                "uk-UA": "    IP-",
                "zh-CN": "IP",
                "zh-TW": "IP"
            },
            "Failed to connect to server": {
                ar: "  ",
                "de-DE": "Verbindung zum Server fehlgeschlagen",
                "es-ES": "Error al conectar con el servidor",
                "fr-FR": "chec de la connexion au serveur",
                "it-IT": "Connessione al server non riuscita",
                "ja-JP": "",
                "ko-KR": "  ",
                "pl-PL": "Nie udao si poczy z serwerem",
                "pt-BR": "Falha ao conectar ao servidor",
                "pt-PT": "Falha ao conectar ao servidor",
                "ru-RU": "    ",
                "tr-TR": "Sunucuya balanlamad",
                "uk-UA": "    ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Invite Expired": {
                ar: "  ",
                "de-DE": "Einladung abgelaufen",
                "es-ES": "Invitacin caducada",
                "fr-FR": "Invitation expire",
                "it-IT": "Invito scaduto",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Zaproszenie wygaso",
                "pt-BR": "Convite expirado",
                "pt-PT": "Convite expirado",
                "ru-RU": " ",
                "tr-TR": "Davet Sresi Doldu",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            "Expires in {0}": {
                ar: "   {0}",
                "de-DE": "Luft ab in {0}",
                "es-ES": "Expira en {0}",
                "fr-FR": "Expire dans {0}",
                "it-IT": "Scade in {0}",
                "ja-JP": "{0}",
                "ko-KR": "{0}  ",
                "pl-PL": "Wygasa za {0}",
                "pt-BR": "Expira em {0}",
                "pt-PT": "Expira em {0}",
                "ru-RU": "  {0}",
                "tr-TR": "{0} iinde sona erer",
                "uk-UA": "  {0}",
                "zh-CN": "{0}",
                "zh-TW": "{0}"
            },
            "New Code": {
                ar: " ",
                "de-DE": "Neuer Code",
                "es-ES": "Nuevo cdigo",
                "fr-FR": "Nouveau code",
                "it-IT": "Nuovo codice",
                "ja-JP": "",
                "ko-KR": " ",
                "pl-PL": "Nowy kod",
                "pt-BR": "Novo cdigo",
                "pt-PT": "Novo cdigo",
                "ru-RU": " ",
                "tr-TR": "Yeni Kod",
                "uk-UA": " ",
                "zh-CN": "",
                "zh-TW": ""
            },
            '"{0}" joined!': {
                ar: '"{0}" !',
                "de-DE": '"{0}" ist beigetreten!',
                "es-ES": '"{0}" se uni!',
                "fr-FR": '"{0}" a rejoint !',
                "it-IT": '"{0}" si  unito!',
                "ja-JP": "{0}",
                "ko-KR": '"{0}" !',
                "pl-PL": '"{0}" doczy!',
                "pt-BR": '"{0}" entrou!',
                "pt-PT": '"{0}" entrou!',
                "ru-RU": '"{0}" !',
                "tr-TR": '"{0}" katld!',
                "uk-UA": '"{0}" !',
                "zh-CN": '"{0}" ',
                "zh-TW": '"{0}" '
            },
            '"{0}" left!': {
                ar: '"{0}" !',
                "de-DE": '"{0}" hat das Spiel verlassen!',
                "es-ES": '"{0}" se fue!',
                "fr-FR": '"{0}" est parti !',
                "it-IT": '"{0}"  uscito!',
                "ja-JP": "{0}",
                "ko-KR": '"{0}" !',
                "pl-PL": '"{0}" opuci!',
                "pt-BR": '"{0}" saiu!',
                "pt-PT": '"{0}" saiu!',
                "ru-RU": '"{0}" !',
                "tr-TR": '"{0}" ayrld!',
                "uk-UA": '"{0}" !',
                "zh-CN": '"{0}" ',
                "zh-TW": '"{0}" '
            },
            '"{0}" was kicked!': {
                ar: '"{0}"  !',
                "de-DE": '"{0}" wurde gekickt!',
                "es-ES": '"{0}" fue expulsado!',
                "fr-FR": '"{0}" a t expuls !',
                "it-IT": '"{0}"  stato espulso!',
                "ja-JP": "{0}",
                "ko-KR": '"{0}"  !',
                "pl-PL": '"{0}" zosta wyrzucony!',
                "pt-BR": '"{0}" foi expulso!',
                "pt-PT": '"{0}" foi expulso!',
                "ru-RU": '"{0}"  !',
                "tr-TR": '"{0}" atld!',
                "uk-UA": '"{0}"  !',
                "zh-CN": '"{0}" ',
                "zh-TW": '"{0}" '
            }
        };
        var Ts;
        class ks {
            constructor(e) {
                Ts.set(this, void 0),
                (0,
                R.GG)(this, Ts, e, "f")
            }
            set language(e) {
                (0,
                R.GG)(this, Ts, e, "f")
            }
            get(e, t) {
                return ks.getFromLanguage((0,
                R.gn)(this, Ts, "f"), e, t)
            }
            static getFromLanguage(e, t, n) {
                let i;
                if (t in Es) {
                    const n = Es[t];
                    i = e in n ? n[e] : "en-US"in n ? n["en-US"] : t
                } else
                    i = t;
                if (null != n)
                    for (const [e,t] of n.entries())
                        i = i.replace(new RegExp("\\{" + e.toString() + "\\}","g"), t);
                return i
            }
        }
        Ts = new WeakMap;
        const Ms = ks;
        var _s, Cs, Rs, Ps, Is, Ls, Ns, zs, Us, Ds, Bs, Gs, Fs, Os, Ws, Vs, Hs, js, Ks, qs, Qs, Js, Xs, Ys, Zs, $s;
        Cs = new WeakMap,
        Rs = new WeakMap,
        Ps = new WeakMap,
        Is = new WeakMap,
        Ls = new WeakMap,
        Ns = new WeakMap,
        zs = new WeakMap,
        Us = new WeakMap,
        Ds = new WeakMap,
        Bs = new WeakMap,
        Gs = new WeakMap,
        Fs = new WeakMap,
        Os = new WeakMap,
        Ws = new WeakMap,
        Vs = new WeakMap,
        Hs = new WeakMap,
        _s = new WeakSet,
        js = function() {
            (0,
            R.gn)(this, zs, "f").className = "hidden"
        }
        ,
        Ks = function() {
            (0,
            R.gn)(this, zs, "f").className = "settings-menu-ui"
        }
        ,
        qs = function() {
            (0,
            R.GG)(this, Os, (0,
            R.gn)(this, Vs, "f").get(P.A.Language) ?? (0,
            R.gn)(this, Is, "f").getSetting(P.A.Language), "f"),
            (0,
            R.gn)(this, Ds, "f").innerHTML = '<img class="button-icon" src="images/cancel.svg"> ',
            (0,
            R.gn)(this, Ds, "f").append(document.createTextNode(Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Cancel"))),
            (0,
            R.gn)(this, Bs, "f").innerHTML = '<img class="button-icon" src="images/reset_settings.svg"> ',
            (0,
            R.gn)(this, Bs, "f").append(document.createTextNode(Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Reset"))),
            (0,
            R.gn)(this, Gs, "f").innerHTML = "",
            (0,
            R.gn)(this, Gs, "f").append(document.createTextNode(Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Apply"))),
            (0,
            R.gn)(this, Gs, "f").innerHTML += ' <img class="button-icon" src="images/apply.svg">',
            (0,
            R.gn)(this, _s, "m", Qs).call(this)
        }
        ,
        Qs = function() {
            (0,
            R.gn)(this, Us, "f").innerHTML = "",
            (0,
            R.gn)(this, _s, "m", Js).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Language")),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, null, [{
                title: "",
                value: "ar"
            }, {
                title: "Deutsch",
                value: "de-DE"
            }, {
                title: "English",
                value: "en-US"
            }, {
                title: "Espaol",
                value: "es-ES"
            }, {
                title: "Franais",
                value: "fr-FR"
            }, {
                title: "Italiano",
                value: "it-IT"
            }, {
                title: "",
                value: "ja-JP"
            }, {
                title: "",
                value: "ko-KR"
            }, {
                title: "Polski",
                value: "pl-PL"
            }, {
                title: "Portugus (BR)",
                value: "pt-BR"
            }, {
                title: "Portugus (PT)",
                value: "pt-PT"
            }, {
                title: "",
                value: "ru-RU"
            }, {
                title: "Trke",
                value: "tr-TR"
            }, {
                title: "",
                value: "uk-UA"
            }, {
                title: "",
                value: "zh-CN"
            }, {
                title: "",
                value: "zh-TW"
            }], P.A.Language, ( () => {
                (0,
                R.gn)(this, _s, "m", qs).call(this)
            }
            )),
            (0,
            R.gn)(this, _s, "m", Js).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Gameplay")),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Units"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Metric"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Imperial"),
                value: "true"
            }], P.A.ImperialUnitsEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Reset hint"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Disabled"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Enabled"),
                value: "true"
            }], P.A.ResetHintEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Ghost car"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Disabled"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Enabled"),
                value: "true"
            }], P.A.GhostCarEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Default camera"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Default"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Cockpit"),
                value: "true"
            }], P.A.DefaultCameraMode),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Cockpit camera mode"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Hold"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Toggle"),
                value: "true"
            }], P.A.CockpitCameraToggle),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Checkpoints"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "off"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Bottom"),
                value: "bottom"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Top"),
                value: "top"
            }], P.A.Checkpoints),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Timer"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "off"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Bottom"),
                value: "bottom"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Top"),
                value: "top"
            }], P.A.Timer),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Speedometer"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "off"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Bottom"),
                value: "bottom"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Top"),
                value: "top"
            }], P.A.Speedometer),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, "Custom Decimal Speedometer"),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, "Decimal places", [{
                title: "1",
                value: "1"
            }, {
                title: "2",
                value: "2"
            }, {
                title: "3",
                value: "3"
            }, {
                title: "4",
                value: "4"
            }, {
                title: "5",
                value: "5"
            }], P.A.SpeedDecimalPlaces),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, "Heads Up Splits"),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, "Size", P.A.HuSplitsSize, 0, 2),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, "Height", P.A.HuSplitsHeight, 0, .5),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, "Opacity", P.A.HuSplitsOpacity, 0, 1),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, "Show Speed Split", [{
                title: "Off",
                value: "false"
            }, {
                title: "On",
                value: "true"
            }], P.A.HuSplitsShowSpeed),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Mobile")),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Vibration"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.VibrationEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Steering control side"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Left"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Right"),
                value: "true"
            }], P.A.TouchSteeringSide),
            (0,
            R.gn)(this, _s, "m", Js).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Graphics")),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Shadows"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "0",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(0)
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Minimal"),
                value: "1",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(1)
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Low"),
                value: "2",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(2)
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Medium"),
                value: "3",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(3)
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "High"),
                value: "4",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(4)
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Ultra"),
                value: "5",
                available: (0,
                R.gn)(this, Ps, "f").isShadowQualitySupported(5)
            }], P.A.ShadowQuality, ( () => {
                (0,
                R.gn)(this, Ls, "f").generateMeshes()
            }
            )),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Clouds"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.CloudsEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Particles"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.ParticlesEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Skidmarks"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.SkidmarksEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Fog"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.FogEnabled),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Render scale"), [{
                title: "10%",
                value: "0.10"
            }, {
                title: "25%",
                value: "0.25"
            }, {
                title: "50%",
                value: "0.5"
            }, {
                title: "75%",
                value: "0.75"
            }, {
                title: "100%",
                value: "1"
            }], P.A.RenderScale),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Screen Pixel Density"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Fixed"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Auto"),
                value: "true"
            }], P.A.ScreenPixelDensity),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Anti-aliasing (requires restart)"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.Antialiasing),
            (0,
            R.gn)(this, _s, "m", Js).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Audio")),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Master volume"), P.A.MasterVolume),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Sound effect volume"), P.A.SoundEffectVolume),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Music volume"), P.A.MusicVolume),
            (0,
            R.gn)(this, _s, "m", Zs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Checkpoint volume"), P.A.CheckpointVolume),
            (0,
            R.gn)(this, _s, "m", Ys).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Ghost car sounds"), [{
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Off"),
                value: "false"
            }, {
                title: Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "On"),
                value: "true"
            }], P.A.GhostCarSoundsEnabled),
            (0,
            R.gn)(this, _s, "m", Js).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Controls")),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Vehicle")),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Accelerate"), me.A.VehicleAccelerate),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Brake"), me.A.VehicleBrake),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Turn left"), me.A.VehicleTurnLeft),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Turn right"), me.A.VehicleTurnRight),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Checkpoint reset"), me.A.VehicleCheckpointReset),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Start reset"), me.A.VehicleStartReset),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Cockpit camera"), me.A.VehicleCockpitCamera),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Editor")),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Rotate part"), me.A.EditorRotatePart),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Height modifier"), me.A.EditorHeightModifier),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Delete part"), me.A.EditorDelete),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move forwards"), me.A.EditorMoveForwards),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move backwards"), me.A.EditorMoveBackwards),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move left"), me.A.EditorMoveLeft),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move right"), me.A.EditorMoveRight),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Rotate view up"), me.A.EditorRotateViewUp),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Rotate view down"), me.A.EditorRotateViewDown),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Rotate view left"), me.A.EditorRotateViewLeft),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Rotate view right"), me.A.EditorRotateViewRight),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move down"), me.A.EditorMoveDown),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move up"), me.A.EditorMoveUp),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Test track"), me.A.EditorTest),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Pick part"), me.A.EditorPick),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Spectator")),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move forwards"), me.A.SpectatorMoveForwards),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move backwards"), me.A.SpectatorMoveBackwards),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move left"), me.A.SpectatorMoveLeft),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Move right"), me.A.SpectatorMoveRight),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Speed modifier"), me.A.SpectatorSpeedModifier),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Replay")),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Step forward"), me.A.PreviewStepForward),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Step back"), me.A.PreviewStepBack),
            (0,
            R.gn)(this, _s, "m", Xs).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Other")),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Hide UI"), me.A.ToggleUI),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Pause"), me.A.Pause),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Toggle FPS counter"), me.A.ToggleFpsCounter),
            (0,
            R.gn)(this, _s, "m", $s).call(this, Ms.getFromLanguage((0,
            R.gn)(this, Os, "f"), "Toggle spectator camera"), me.A.ToggleSpectatorCamera)
        }
        ,
        Js = function(e) {
            const t = document.createElement("h2");
            t.textContent = e,
            (0,
            R.gn)(this, Us, "f").appendChild(t)
        }
        ,
        Xs = function(e) {
            const t = document.createElement("h3");
            t.textContent = e,
            (0,
            R.gn)(this, Us, "f").appendChild(t)
        }
        ,
        Ys = function(e, t, n, i) {
            const r = (0,
            R.gn)(this, Vs, "f").get(n) ?? (0,
            R.gn)(this, Is, "f").getSetting(n)
              , a = document.createElement("div");
            if (a.className = "setting",
            null != e) {
                const t = document.createElement("p");
                t.textContent = e,
                a.appendChild(t)
            } else
                a.classList.add("wrappable");
            const s = document.createElement("div");
            s.className = "button-wrapper",
            a.appendChild(s);
            const o = [];
            for (const {title: e, value: a, available: l} of t) {
                const t = document.createElement("button");
                t.className = a == r ? "button selected" : "button",
                t.disabled = !1 === l,
                t.textContent = e,
                t.addEventListener("click", ( () => {
                    (0,
                    R.gn)(this, Rs, "f").playUIClick();
                    for (const e of o)
                        e.className = "button";
                    t.className = "button selected",
                    (0,
                    R.gn)(this, Vs, "f").set(n, a),
                    (0,
                    R.gn)(this, Is, "f").updateSettings(Array.from((0,
                    R.gn)(this, Vs, "f"))),
                    null != i && i()
                }
                )),
                s.appendChild(t),
                o.push(t)
            }
            (0,
            R.gn)(this, Us, "f").appendChild(a)
        }
        ,
        Zs = function(e, t, n=0, i=1) {
            let r = parseFloat((0,
            R.gn)(this, Vs, "f").get(t) ?? (0,
            R.gn)(this, Is, "f").getSetting(t));
            Number.isNaN(r) && (r = 0);
            const a = document.createElement("div");
            a.className = "setting";
            const s = document.createElement("p");
            s.textContent = e,
            a.appendChild(s);
            const o = document.createElement("input");
            o.type = "range",
            o.min = (20 * n).toString(),
            o.max = (20 * i).toString(),
            o.value = (20 * r).toString(),
            o.addEventListener("input", ( () => {
                const e = parseFloat(o.value) / 20;
                (0,
                R.gn)(this, Vs, "f").set(t, e.toString()),
                (0,
                R.gn)(this, Is, "f").updateSettings(Array.from((0,
                R.gn)(this, Vs, "f")))
            }
            )),
            a.appendChild(o),
            (0,
            R.gn)(this, Us, "f").appendChild(a)
        }
        ,
        $s = function(e, t) {
            const n = document.createElement("div");
            n.className = "setting key-binding";
            const i = document.createElement("p");
            i.textContent = e,
            n.appendChild(i);
            const r = document.createElement("div");
            r.className = "button-wrapper",
            n.appendChild(r);
            const a = (0,
            R.gn)(this, Hs, "f").get(t) ?? (0,
            R.gn)(this, Is, "f").getKeyBindings(t)
              , s = document.createElement("button");
            s.className = "button",
            s.textContent = ve(a[0] ?? ""),
            s.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Rs, "f").playUIClick(),
                (0,
                R.gn)(this, _s, "m", js).call(this);
                const e = t => {
                    "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || ((0,
                    R.gn)(this, Ns, "f").hide(),
                    a[0] = t.code,
                    s.textContent = ve(t.code),
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this),
                    window.removeEventListener("keydown", e),
                    t.preventDefault())
                }
                ;
                window.addEventListener("keydown", e),
                (0,
                R.gn)(this, Ns, "f").showConfirm(Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Press any key...\n\nPress [Escape] to cancel."), Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Cancel"), Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Clear"), ( () => {
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this),
                    window.removeEventListener("keydown", e)
                }
                ), ( () => {
                    s.textContent = "",
                    a[0] = null,
                    window.removeEventListener("keydown", e),
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this)
                }
                ))
            }
            )),
            r.appendChild(s);
            const o = document.createElement("button");
            o.className = "button",
            o.textContent = ve(a[1] ?? ""),
            o.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Rs, "f").playUIClick(),
                (0,
                R.gn)(this, _s, "m", js).call(this);
                const e = t => {
                    "Escape" == t.code || "Tab" == t.code || "Enter" == t.code && null != document.activeElement && document.activeElement != document.body || ((0,
                    R.gn)(this, Ns, "f").hide(),
                    a[1] = t.code,
                    o.textContent = ve(t.code),
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this),
                    window.removeEventListener("keydown", e),
                    t.preventDefault())
                }
                ;
                window.addEventListener("keydown", e),
                (0,
                R.gn)(this, Ns, "f").showConfirm(Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Press any key...\n\nPress [Escape] to cancel."), Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Cancel"), Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Clear"), ( () => {
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this),
                    window.removeEventListener("keydown", e)
                }
                ), ( () => {
                    o.textContent = "",
                    a[1] = null,
                    window.removeEventListener("keydown", e),
                    (0,
                    R.gn)(this, _s, "m", Ks).call(this)
                }
                ))
            }
            )),
            r.appendChild(o),
            (0,
            R.gn)(this, Us, "f").appendChild(n)
        }
        ;
        const eo = class {
            constructor(e, t, n, i, r, a, s, o) {
                _s.add(this),
                Cs.set(this, void 0),
                Rs.set(this, void 0),
                Ps.set(this, void 0),
                Is.set(this, void 0),
                Ls.set(this, void 0),
                Ns.set(this, void 0),
                zs.set(this, void 0),
                Us.set(this, void 0),
                Ds.set(this, void 0),
                Bs.set(this, void 0),
                Gs.set(this, void 0),
                Fs.set(this, void 0),
                Os.set(this, void 0),
                Ws.set(this, new Map),
                Vs.set(this, new Map),
                Hs.set(this, new Map),
                (0,
                R.GG)(this, Cs, e, "f"),
                (0,
                R.GG)(this, Rs, n, "f"),
                (0,
                R.GG)(this, Ps, i, "f"),
                (0,
                R.GG)(this, Is, r, "f"),
                (0,
                R.GG)(this, Ls, a, "f"),
                (0,
                R.GG)(this, Ns, s, "f"),
                (0,
                R.GG)(this, Os, r.getSetting(P.A.Language), "f"),
                (0,
                R.GG)(this, Ws, new Map(r.getSettings()), "f"),
                (0,
                R.GG)(this, zs, document.createElement("div"), "f"),
                (0,
                R.gn)(this, zs, "f").className = "settings-menu-ui",
                e.appendChild((0,
                R.gn)(this, zs, "f"));
                const l = document.createElement("h2");
                l.textContent = Ms.getFromLanguage((0,
                R.gn)(this, Os, "f"), "Settings"),
                (0,
                R.gn)(this, zs, "f").appendChild(l),
                (0,
                R.GG)(this, Us, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Us, "f").className = "container",
                (0,
                R.gn)(this, zs, "f").appendChild((0,
                R.gn)(this, Us, "f"));
                const c = document.createElement("div");
                c.className = "button-wrapper",
                (0,
                R.gn)(this, zs, "f").appendChild(c),
                (0,
                R.GG)(this, Ds, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Ds, "f").className = "button cancel",
                (0,
                R.gn)(this, Ds, "f").addEventListener("click", ( () => {
                    n.playUIClick(),
                    r.updateSettings(Array.from((0,
                    R.gn)(this, Ws, "f"))),
                    a.generateMeshes(),
                    o()
                }
                )),
                c.appendChild((0,
                R.gn)(this, Ds, "f")),
                (0,
                R.GG)(this, Bs, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Bs, "f").className = "button reset",
                (0,
                R.gn)(this, Bs, "f").addEventListener("click", ( () => {
                    n.playUIClick(),
                    (0,
                    R.GG)(this, Vs, (0,
                    R.gn)(this, Is, "f").defaultSettings(), "f"),
                    r.updateSettings(Array.from((0,
                    R.gn)(this, Vs, "f"))),
                    (0,
                    R.GG)(this, Hs, (0,
                    R.gn)(this, Is, "f").defaultKeyBindings(), "f"),
                    a.generateMeshes(),
                    (0,
                    R.gn)(this, _s, "m", qs).call(this)
                }
                )),
                c.appendChild((0,
                R.gn)(this, Bs, "f")),
                (0,
                R.GG)(this, Gs, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Gs, "f").className = "button apply",
                (0,
                R.gn)(this, Gs, "f").addEventListener("click", ( () => {
                    n.playUIClick(),
                    r.updateSettings(Array.from((0,
                    R.gn)(this, Vs, "f"))),
                    r.saveSettings(),
                    r.setKeyBindings(Array.from((0,
                    R.gn)(this, Hs, "f"))),
                    a.generateMeshes(),
                    t.language = r.getSetting(P.A.Language),
                    o()
                }
                )),
                c.appendChild((0,
                R.gn)(this, Gs, "f")),
                window.addEventListener("keydown", (0,
                R.GG)(this, Fs, (e => {
                    "Escape" == e.code && (r.updateSettings(Array.from((0,
                    R.gn)(this, Ws, "f"))),
                    a.generateMeshes(),
                    o(),
                    e.preventDefault())
                }
                ), "f")),
                (0,
                R.gn)(this, _s, "m", qs).call(this)
            }
            dispose() {
                (0,
                R.gn)(this, Cs, "f").removeChild((0,
                R.gn)(this, zs, "f")),
                window.removeEventListener("keydown", (0,
                R.gn)(this, Fs, "f"))
            }
        }
        ;
        var to = i(3025)
          , no = {};
        no.styleTagTransform = u(),
        no.setAttributes = l(),
        no.insert = s().bind(null, "head"),
        no.domAPI = r(),
        no.insertStyleElement = h();
        t()(to.A, no);
        to.A && to.A.locals && to.A.locals;
        var io = i(6252)
          , ro = {};
        ro.styleTagTransform = u(),
        ro.setAttributes = l(),
        ro.insert = s().bind(null, "head"),
        ro.domAPI = r(),
        ro.insertStyleElement = h();
        t()(io.A, ro);
        io.A && io.A.locals && io.A.locals;
        var ao = i(6005)
          , so = {};
        so.styleTagTransform = u(),
        so.setAttributes = l(),
        so.insert = s().bind(null, "head"),
        so.domAPI = r(),
        so.insertStyleElement = h();
        t()(ao.A, so);
        ao.A && ao.A.locals && ao.A.locals;
        var oo;
        !function(e) {
            e[e.Uninitialized = 0] = "Uninitialized",
            e[e.Ok = 1] = "Ok",
            e[e.TestFailed = 2] = "TestFailed",
            e[e.AssetsFailed = 3] = "AssetsFailed"
        }(oo || (oo = {}));
        var lo, co, ho, uo, po, fo, go, mo, Ao, vo, yo, wo, bo, xo, So, Eo, To, ko, Mo, _o, Co, Ro, Po, Io, Lo, No, zo, Uo, Do, Bo = i(4784);
        function Go(e) {
            let t = Math.trunc(e).toString()
              , n = "";
            for (; t.length > 3; )
                n = " " + t.slice(-3) + n,
                t = t.slice(0, -3);
            return n = t + n,
            n
        }
        function Fo() {
            return !1
        }
        function Oo() {
            let e;
            switch (Pt.aC) {
            case "kodub":
            case "electron":
            case "capacitor":
            case "jest":
            case "itch":
            case "crazygames":
                e = "../../www.crazygames.com/game/polytrack/index.html";
                break;
            case "poki":
                e = "../../../apps/polytrack/index.html"
            }
            return e
        }
        co = new WeakMap,
        ho = new WeakMap,
        uo = new WeakMap,
        po = new WeakMap,
        fo = new WeakMap,
        go = new WeakMap,
        mo = new WeakMap,
        Ao = new WeakMap,
        vo = new WeakMap,
        yo = new WeakMap,
        wo = new WeakMap,
        bo = new WeakMap,
        xo = new WeakMap,
        So = new WeakMap,
        Eo = new WeakMap,
        To = new WeakMap,
        ko = new WeakMap,
        Mo = new WeakMap,
        _o = new WeakMap,
        Co = new WeakMap,
        Ro = new WeakMap,
        Po = new WeakMap,
        Io = new WeakMap,
        Lo = new WeakMap,
        lo = new WeakSet,
        No = function(e) {
            if (null != (0,
            R.gn)(this, Io, "f"))
                if ((0,
                R.gn)(this, bo, "f").scrollTo) {
                    const t = (0,
                    R.gn)(this, bo, "f").clientHeight
                      , n = (0,
                    R.gn)(this, Io, "f").offsetTop - (0,
                    R.gn)(this, bo, "f").offsetTop - t / 2 + (0,
                    R.gn)(this, Io, "f").offsetHeight / 2;
                    (0,
                    R.gn)(this, bo, "f").scrollTo({
                        top: n,
                        behavior: e
                    })
                } else
                    (0,
                    R.gn)(this, Io, "f").scrollIntoView({
                        behavior: e,
                        block: "nearest",
                        inline: "start"
                    })
        }
        ,
        zo = function e(t) {
            (0,
            R.gn)(this, ko, "f")?.cancel();
            const n = new mr.A;
            (0,
            R.GG)(this, ko, n, "f"),
            (0,
            R.gn)(this, bo, "f").innerHTML = "",
            (0,
            R.gn)(this, bo, "f").appendChild((0,
            R.gn)(this, xo, "f")),
            (0,
            R.GG)(this, Io, null, "f"),
            setTimeout(( () => {
                if (!n.isCancelled) {
                    const i = 20
                      , r = (0,
                    R.gn)(this, Co, "f") * i;
                    (0,
                    R.gn)(this, uo, "f").getLeaderboard((0,
                    R.gn)(this, fo, "f").getCurrentUserProfile().tokenHash, (0,
                    R.gn)(this, co, "f"), r, i, (0,
                    R.gn)(this, _o, "f")).then(( ({total: a, entries: s, userEntry: o}) => {
                        if (!n.isCancelled) {
                            (0,
                            R.GG)(this, Ro, Math.ceil(a / i), "f"),
                            (0,
                            R.gn)(this, lo, "m", Do).call(this),
                            (0,
                            R.gn)(this, wo, "f").textContent = (0,
                            R.gn)(this, ho, "f").get("{0} players", [Go(a)]),
                            (0,
                            R.gn)(this, wo, "f").classList.add("fade-in");
                            for (let e = 0; e < s.length; e++) {
                                const {id: t, nickname: i, countryCode: a, time: o, carStyle: l, verifiedState: c, isSelf: h} = s[e]
                                  , d = r + e + 1;
                                (0,
                                R.gn)(this, lo, "m", Uo).call(this, d, i, a, o, l, c, h, t, n)
                            }
                            (0,
                            R.gn)(this, uo, "f").determinismState == oo.Ok && (null != o ? ((0,
                            R.GG)(this, Po, Math.floor((o.position - 1) / i), "f"),
                            (0,
                            R.gn)(this, So, "f").disabled = !1,
                            t && null != (0,
                            R.gn)(this, Io, "f") && (0,
                            R.gn)(this, lo, "m", No).call(this, "instant"),
                            (0,
                            R.gn)(this, Ao, "f").call(this, o, a)) : ((0,
                            R.GG)(this, Po, null, "f"),
                            (0,
                            R.gn)(this, So, "f").disabled = !0,
                            (0,
                            R.gn)(this, Ao, "f").call(this, null, a)),
                            (0,
                            R.gn)(this, Mo, "f") || ((0,
                            R.GG)(this, Mo, !0, "f"),
                            (0,
                            R.gn)(this, go, "f").syncRecord((0,
                            R.gn)(this, fo, "f").profileSlot, (0,
                            R.gn)(this, co, "f"), o).then((n => {
                                "Upload" == n && (0,
                                R.gn)(this, lo, "m", e).call(this, t)
                            }
                            )).catch((e => {
                                console.warn(e)
                            }
                            ))))
                        }
                    }
                    )).catch((e => {
                        if (!n.isCancelled) {
                            const e = document.createElement("p");
                            if (e.className = "error-message",
                            e.textContent = (0,
                            R.gn)(this, ho, "f").get("Error: Failed to load leaderboard"),
                            (0,
                            R.gn)(this, bo, "f").appendChild(e),
                            Fo()) {
                                const e = document.createElement("p");
                                e.className = "error-message",
                                e.textContent = (0,
                                R.gn)(this, ho, "f").get("Unofficial versions of the game cannot access the leaderboard"),
                                (0,
                                R.gn)(this, bo, "f").appendChild(e)
                            }
                        }
                        console.error(e)
                    }
                    )).finally(( () => {
                        n.isCancelled || (0,
                        R.gn)(this, bo, "f").removeChild((0,
                        R.gn)(this, xo, "f"))
                    }
                    ))
                }
            }
            ), 500)
        }
        ,
        Uo = function(e, t, n, i, r, a, s, o, l) {
            const c = document.createElement("button");
            c.className = "button main",
            s && ((0,
            R.GG)(this, Io, c, "f"),
            c.classList.add("self")),
            c.addEventListener("click", ( () => {
                (0,
                R.gn)(this, po, "f").playUIClick(),
                (0,
                R.gn)(this, Lo, "f").some((e => e.recordingId == o)) ? ((0,
                R.GG)(this, Lo, (0,
                R.gn)(this, Lo, "f").filter((e => e.recordingId != o)), "f"),
                c.classList.remove("selected"),
                (0,
                R.gn)(this, mo, "f").call(this, (0,
                R.gn)(this, Lo, "f"))) : (0,
                R.gn)(this, Lo, "f").length < 10 && ((0,
                R.GG)(this, Lo, (0,
                R.gn)(this, Lo, "f").concat([{
                    nickname: t,
                    recordingId: o,
                    isSelf: s
                }]), "f"),
                c.classList.add("selected"),
                (0,
                R.gn)(this, mo, "f").call(this, (0,
                R.gn)(this, Lo, "f")))
            }
            )),
            (0,
            R.gn)(this, bo, "f").appendChild(c),
            (0,
            R.gn)(this, Lo, "f").some((e => e.recordingId == o)) && c.classList.add("selected");
            const h = document.createElement("div");
            h.className = "image-container",
            c.appendChild(h);
            const d = document.createElement("img");
            d.className = "show",
            d.src = "images/car_thumbnail_placeholder.png",
            h.appendChild(d);
            const u = document.createElement("img");
            gr.F(r, l).then((e => {
                u.src = e,
                d.classList.remove("show"),
                u.classList.add("show")
            }
            )),
            h.appendChild(u);
            const p = document.createElement("img");
            p.className = "checkmark",
            p.src = "images/checkmark.svg",
            c.appendChild(p);
            const f = document.createElement("div");
            f.className = "left",
            c.appendChild(f);
            const g = document.createElement("p");
            g.className = "position",
            g.textContent = Qe(e),
            f.appendChild(g);
            const m = document.createElement("span");
            m.textContent = Je(e),
            g.appendChild(m);
            const A = document.createElement("p");
            A.textContent = He.A.formatTimeString(i),
            f.appendChild(A);
            const v = document.createElement("div");
            v.className = "right",
            c.appendChild(v);
            const y = document.createElement("div");
            y.className = "name-container",
            v.appendChild(y);
            const w = (0,
            On.O)()
              , b = null == n ? null : w.find((e => e.code == n));
            if (null != b) {
                const e = document.createElement("img");
                e.className = "country-flag",
                e.src = "images/countries/" + b.code + ".svg?v=0.6.0-beta1-mp21",
                e.draggable = !1,
                e.title = b.name,
                y.appendChild(e)
            }
            const x = document.createElement("span");
            if (x.className = "name",
            x.textContent = t,
            y.appendChild(x),
            s) {
                const e = document.createElement("span");
                e.className = "self",
                e.textContent = "(" + (0,
                R.gn)(this, ho, "f").get("You") + ")",
                y.appendChild(e)
            }
            const S = document.createElement("p");
            a == Bo.Y.Pending ? (S.innerHTML = '<img src="images/state_pending.svg">',
            S.prepend(document.createTextNode((0,
            R.gn)(this, ho, "f").get("Pending"))),
            S.className = "verified-state pending") : a == Bo.Y.Verified ? (S.innerHTML = '<img src="images/state_verified.svg">',
            S.prepend(document.createTextNode((0,
            R.gn)(this, ho, "f").get("Verified"))),
            S.className = "verified-state verified") : a == Bo.Y.InvalidDuplicate ? (S.innerHTML = '<img src="images/state_invalid.svg">',
            S.prepend(document.createTextNode((0,
            R.gn)(this, ho, "f").get("Duplicate"))),
            S.className = "verified-state invalid") : (S.innerHTML = '<img src="images/state_invalid.svg">',
            S.prepend(document.createTextNode((0,
            R.gn)(this, ho, "f").get("Invalid"))),
            S.className = "verified-state invalid"),
            v.appendChild(S)
        }
        ,
        Do = function e() {
            (0,
            R.gn)(this, To, "f").innerHTML = "";
            const t = document.createElement("button");
            let n;
            t.className = "button",
            t.textContent = "<",
            (0,
            R.gn)(this, Co, "f") > 0 ? t.addEventListener("click", ( () => {
                (0,
                R.gn)(this, po, "f").playUIClick(),
                (0,
                R.GG)(this, Co, (0,
                R.gn)(this, Co, "f") - 1, "f"),
                (0,
                R.gn)(this, lo, "m", e).call(this),
                (0,
                R.gn)(this, lo, "m", zo).call(this, !1)
            }
            )) : t.disabled = !0,
            (0,
            R.gn)(this, To, "f").appendChild(t),
            n = (0,
            R.gn)(this, Co, "f") < 1e3 - Math.ceil(3.5) ? 7 : (0,
            R.gn)(this, Co, "f") < 1e5 - Math.ceil(2.5) ? 5 : 3;
            const i = Math.max(0, (0,
            R.gn)(this, Co, "f") - Math.floor(n / 2));
            for (let t = i; t < i + n; ++t) {
                const n = document.createElement("button");
                n.textContent = (t + 1).toString(),
                t >= (0,
                R.gn)(this, Ro, "f") ? (n.className = "button page",
                n.disabled = !0) : t == (0,
                R.gn)(this, Co, "f") ? n.className = "button page selected" : (n.className = "button page",
                n.addEventListener("click", ( () => {
                    (0,
                    R.gn)(this, po, "f").playUIClick(),
                    (0,
                    R.GG)(this, Co, t, "f"),
                    (0,
                    R.gn)(this, lo, "m", e).call(this),
                    (0,
                    R.gn)(this, lo, "m", zo).call(this, !1)
                }
                ))),
                (0,
                R.gn)(this, To, "f").appendChild(n)
            }
            const r = document.createElement("button");
            r.className = "button",
            r.textContent = ">",
            (0,
            R.gn)(this, Co, "f") + 1 >= (0,
            R.gn)(this, Ro, "f") ? r.disabled = !0 : r.addEventListener("click", ( () => {
                (0,
                R.gn)(this, po, "f").playUIClick(),
                (0,
                R.GG)(this, Co, (0,
                R.gn)(this, Co, "f") + 1, "f"),
                (0,
                R.gn)(this, lo, "m", e).call(this),
                (0,
                R.gn)(this, lo, "m", zo).call(this, !1)
            }
            )),
            (0,
            R.gn)(this, To, "f").appendChild(r)
        }
        ;
        const Wo = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h) {
                lo.add(this),
                co.set(this, void 0),
                ho.set(this, void 0),
                uo.set(this, void 0),
                po.set(this, void 0),
                fo.set(this, void 0),
                go.set(this, void 0),
                mo.set(this, void 0),
                Ao.set(this, void 0),
                vo.set(this, void 0),
                yo.set(this, void 0),
                wo.set(this, void 0),
                bo.set(this, void 0),
                xo.set(this, void 0),
                So.set(this, void 0),
                Eo.set(this, void 0),
                To.set(this, void 0),
                ko.set(this, null),
                Mo.set(this, !1),
                _o.set(this, void 0),
                Co.set(this, 0),
                Ro.set(this, 0),
                Po.set(this, null),
                Io.set(this, null),
                Lo.set(this, []),
                (0,
                R.GG)(this, co, t, "f"),
                (0,
                R.GG)(this, ho, n, "f"),
                (0,
                R.GG)(this, uo, i, "f"),
                (0,
                R.GG)(this, po, r, "f"),
                (0,
                R.GG)(this, fo, a, "f"),
                (0,
                R.GG)(this, go, s, "f"),
                (0,
                R.GG)(this, mo, c, "f"),
                (0,
                R.GG)(this, Ao, h, "f"),
                (0,
                R.GG)(this, _o, o.isOfficialTrack(t) || o.isCommunityTrack(t), "f"),
                (0,
                R.GG)(this, vo, e, "f"),
                (0,
                R.GG)(this, yo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, yo, "f").className = "leaderboard-ui",
                e.appendChild((0,
                R.gn)(this, yo, "f"));
                const d = document.createElement("h2");
                d.textContent = n.get("Leaderboard"),
                (0,
                R.gn)(this, yo, "f").appendChild(d);
                const u = document.createElement("h3")
                  , p = Pt.rE.replace(/(\d+\.\d+)\.\d+/, "$1");
                u.textContent = n.get("Version") + " " + p,
                (0,
                R.gn)(this, yo, "f").appendChild(u),
                (0,
                R.GG)(this, wo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, wo, "f").className = "total-players",
                (0,
                R.gn)(this, yo, "f").appendChild((0,
                R.gn)(this, wo, "f")),
                (0,
                R.GG)(this, bo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, bo, "f").className = "container",
                (0,
                R.gn)(this, yo, "f").appendChild((0,
                R.gn)(this, bo, "f")),
                (0,
                R.GG)(this, xo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, xo, "f").className = "loading-spinner-container",
                (0,
                R.gn)(this, bo, "f").appendChild((0,
                R.gn)(this, xo, "f"));
                const f = document.createElement("div");
                f.className = "loading-spinner-ui",
                (0,
                R.gn)(this, xo, "f").appendChild(f),
                (0,
                R.gn)(this, lo, "m", zo).call(this, !1),
                (0,
                R.GG)(this, To, document.createElement("div"), "f"),
                (0,
                R.gn)(this, To, "f").className = "pages",
                (0,
                R.gn)(this, yo, "f").appendChild((0,
                R.gn)(this, To, "f")),
                (0,
                R.gn)(this, lo, "m", Do).call(this);
                const g = document.createElement("div");
                g.className = "button-wrapper",
                (0,
                R.gn)(this, yo, "f").appendChild(g);
                const m = document.createElement("button");
                m.className = "button back",
                m.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                m.append(document.createTextNode(n.get("Back"))),
                m.addEventListener("click", ( () => {
                    r.playUIClick(),
                    m.disabled = !0,
                    (0,
                    R.gn)(this, yo, "f").classList.add("hidden"),
                    l()
                }
                )),
                g.appendChild(m),
                (0,
                R.GG)(this, So, document.createElement("button"), "f"),
                (0,
                R.gn)(this, So, "f").className = "button icon-button first",
                (0,
                R.gn)(this, So, "f").innerHTML = '<img class="button-icon" src="images/pin.svg">',
                (0,
                R.gn)(this, So, "f").disabled = !0,
                (0,
                R.gn)(this, So, "f").addEventListener("click", ( () => {
                    r.playUIClick(),
                    null != (0,
                    R.gn)(this, Io, "f") ? (0,
                    R.gn)(this, lo, "m", No).call(this, "smooth") : null != (0,
                    R.gn)(this, Po, "f") && ((0,
                    R.GG)(this, Co, (0,
                    R.gn)(this, Po, "f"), "f"),
                    (0,
                    R.gn)(this, lo, "m", Do).call(this),
                    (0,
                    R.gn)(this, lo, "m", zo).call(this, !0))
                }
                )),
                g.appendChild((0,
                R.gn)(this, So, "f")),
                (0,
                R.GG)(this, Eo, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Eo, "f").className = "button only-verified",
                (0,
                R.gn)(this, _o, "f") || (0,
                R.gn)(this, Eo, "f").classList.add("disabled"),
                (0,
                R.gn)(this, Eo, "f").textContent = (0,
                R.gn)(this, ho, "f").get("Only verified"),
                (0,
                R.gn)(this, Eo, "f").innerHTML += '<img class="button-icon" src="images/verified.svg">',
                (0,
                R.gn)(this, Eo, "f").addEventListener("click", ( () => {
                    r.playUIClick(),
                    (0,
                    R.GG)(this, _o, !(0,
                    R.gn)(this, _o, "f"), "f"),
                    (0,
                    R.gn)(this, _o, "f") ? (0,
                    R.gn)(this, Eo, "f").classList.remove("disabled") : (0,
                    R.gn)(this, Eo, "f").classList.add("disabled"),
                    (0,
                    R.GG)(this, Co, 0, "f"),
                    (0,
                    R.GG)(this, Ro, 0, "f"),
                    (0,
                    R.gn)(this, lo, "m", Do).call(this),
                    (0,
                    R.gn)(this, lo, "m", zo).call(this, !1)
                }
                )),
                g.appendChild((0,
                R.gn)(this, Eo, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, ko, "f")?.cancel();
                const e = (0,
                R.gn)(this, yo, "f")
                  , t = (0,
                R.gn)(this, vo, "f")
                  , n = () => {
                    try {
                        t.contains(e) && t.removeChild(e)
                    } catch {}
                }
                ;
                e.classList.add("hidden"),
                "function" == typeof requestIdleCallback ? requestIdleCallback(n, {
                    timeout: 1e3
                }) : setTimeout(n, 0)
            }
        }
        ;
        var Vo, Ho, jo, Ko, qo, Qo, Jo, Xo, Yo, Zo, $o, el, tl, nl, il, rl, al, sl, ol, ll, cl = i(579), hl = i(5169);
        Ho = new WeakMap,
        jo = new WeakMap,
        Ko = new WeakMap,
        qo = new WeakMap,
        Qo = new WeakMap,
        Jo = new WeakMap,
        Xo = new WeakMap,
        Yo = new WeakMap,
        Zo = new WeakMap,
        $o = new WeakMap,
        el = new WeakMap,
        tl = new WeakMap,
        nl = new WeakMap,
        il = new WeakMap,
        rl = new WeakMap,
        al = new WeakMap,
        sl = new WeakMap,
        Vo = new WeakSet,
        ol = function(e, t) {
            (0,
            R.gn)(this, Zo, "f").innerHTML = "";
            const n = document.createElement("div");
            n.innerHTML = '<img src="images/timer.svg">';
            const i = document.createElement("span");
            null == e && (i.className = "faded"),
            i.textContent = He.A.formatTimeString(e),
            n.appendChild(i),
            (0,
            R.gn)(this, Zo, "f").appendChild(n);
            const r = document.createElement("div");
            if (r.innerHTML = '<img src="images/trophy.svg">',
            null != t) {
                r.appendChild(document.createTextNode(qe(t.position)));
                const e = t.position / t.total * 100;
                let n;
                n = e < 1e-4 ? "0.0001" : e < 10 ? e.toFixed(4) : e < 100 ? e.toFixed(3) : e.toFixed(2);
                const i = document.createElement("span");
                i.className = "faded",
                i.textContent = " (" + n + "%)",
                r.appendChild(i)
            } else {
                const e = document.createElement("span");
                e.className = "faded",
                e.textContent = "---",
                r.appendChild(e)
            }
            (0,
            R.gn)(this, Zo, "f").appendChild(r)
        }
        ,
        ll = function() {
            (0,
            R.gn)(this, rl, "f").length > 0 ? ((0,
            R.gn)(this, $o, "f").classList.remove("no-opponents"),
            1 == (0,
            R.gn)(this, rl, "f").length ? (0,
            R.gn)(this, $o, "f").textContent = (0,
            R.gn)(this, Ho, "f").get("{0} opponent selected", [(0,
            R.gn)(this, rl, "f").length.toString()]) : (0,
            R.gn)(this, $o, "f").textContent = (0,
            R.gn)(this, Ho, "f").get("{0} opponents selected", [(0,
            R.gn)(this, rl, "f").length.toString()])) : ((0,
            R.gn)(this, $o, "f").classList.add("no-opponents"),
            (0,
            R.gn)(this, $o, "f").textContent = (0,
            R.gn)(this, Ho, "f").get("Select opponents to race against from the leaderboard on the left")),
            (0,
            R.gn)(this, el, "f").disabled = 0 == (0,
            R.gn)(this, rl, "f").length && null == (0,
            R.gn)(this, Ko, "f").getRecord((0,
            R.gn)(this, qo, "f").profileSlot, (0,
            R.gn)(this, Qo, "f"))
        }
        ;
        const dl = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A) {
                Vo.add(this),
                Ho.set(this, void 0),
                jo.set(this, void 0),
                Ko.set(this, void 0),
                qo.set(this, void 0),
                Qo.set(this, void 0),
                Jo.set(this, void 0),
                Xo.set(this, void 0),
                Yo.set(this, void 0),
                Zo.set(this, void 0),
                $o.set(this, void 0),
                el.set(this, void 0),
                tl.set(this, void 0),
                nl.set(this, void 0),
                il.set(this, null),
                rl.set(this, []),
                al.set(this, !1),
                sl.set(this, []),
                (0,
                R.GG)(this, Ho, t, "f"),
                (0,
                R.GG)(this, jo, n, "f"),
                (0,
                R.GG)(this, Ko, r, "f"),
                (0,
                R.GG)(this, qo, i, "f"),
                (0,
                R.GG)(this, Qo, h, "f"),
                (0,
                R.GG)(this, Jo, e, "f"),
                (0,
                R.GG)(this, Xo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Xo, "f").className = "track-info-ui",
                e.appendChild((0,
                R.gn)(this, Xo, "f"));
                const v = r.getRecord(i.profileSlot, h);
                (0,
                R.GG)(this, tl, new Wo((0,
                R.gn)(this, Xo, "f"),h,t,n,a,i,r,u,p,(e => {
                    (0,
                    R.GG)(this, rl, e, "f"),
                    (0,
                    R.gn)(this, Vo, "m", ll).call(this)
                }
                ),( (e, t) => {
                    null == e || null != v && !e.time.lessOrEqual(v.time) ? (0,
                    R.gn)(this, Vo, "m", ol).call(this, v?.time ?? null, null) : (0,
                    R.gn)(this, Vo, "m", ol).call(this, e.time, {
                        position: e.position,
                        total: t
                    })
                }
                )), "f"),
                (0,
                R.GG)(this, Yo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Yo, "f").className = "side-panel",
                (0,
                R.gn)(this, Xo, "f").appendChild((0,
                R.gn)(this, Yo, "f"));
                const y = document.createElement("h2");
                y.textContent = o.name,
                (0,
                R.gn)(this, Yo, "f").appendChild(y);
                const w = document.createElement("div");
                if (w.className = "thumbnail",
                (0,
                R.gn)(this, Yo, "f").appendChild(w),
                d instanceof HTMLCanvasElement) {
                    const e = document.createElement("canvas");
                    e.width = d.width,
                    e.height = d.height;
                    const t = e.getContext("2d");
                    null == t ? console.error("Failed to get 2D context for thumbnail canvas") : t.drawImage(d, 0, 0),
                    w.appendChild(e)
                } else {
                    let e = null;
                    try {
                        const t = ("undefined" != typeof globalThis ? globalThis : window).__ptThumbCanvasCache;
                        e = t instanceof Map ? t.get(h) : null
                    } catch {}
                    if (e instanceof HTMLCanvasElement) {
                        const t = document.createElement("canvas");
                        t.width = e.width,
                        t.height = e.height;
                        const n = t.getContext("2d");
                        null != n && n.drawImage(e, 0, 0),
                        w.appendChild(t)
                    } else {
                        const e = document.createElement("img");
                        let n = null;
                        try {
                            n = localStorage.getItem("pt_thumb_" + Pt.rE + "_" + h)
                        } catch {}
                        e.src = null != d && "null" != d ? d : n || "images/preview.svg",
                        w.appendChild(e),
                        (null == d || "null" == d || "images/preview.svg" == d) && null == n && (async () => {
                            try {
                                let t;
                                if (t = c instanceof Function ? await c() : c,
                                null == t || "function" != typeof t.createThumbnail)
                                    return;
                                const n = t.createThumbnail();
                                if (!(n instanceof HTMLCanvasElement))
                                    return;
                                try {
                                    const e = ("undefined" != typeof globalThis ? globalThis : window);
                                    e.__ptThumbCanvasCache instanceof Map || (e.__ptThumbCanvasCache = new Map);
                                    const t = document.createElement("canvas");
                                    t.width = n.width,
                                    t.height = n.height;
                                    const i = t.getContext("2d");
                                    null != i && i.drawImage(n, 0, 0),
                                    e.__ptThumbCanvasCache.set(h, t),
                                    localStorage.setItem("pt_thumb_" + Pt.rE + "_" + h, t.toDataURL())
                                } catch {}
                                const i = document.createElement("canvas");
                                i.width = n.width,
                                i.height = n.height;
                                const r = i.getContext("2d");
                                null != r && r.drawImage(n, 0, 0),
                                w.replaceChild(i, e)
                            } catch {}
                        }
                        )()
                    }
                }
                const b = document.createElement("button");
                let x;
                switch (b.className = "button share",
                b.innerHTML = '<img src="images/share.svg">',
                b.addEventListener("click", ( () => {
                    a.playUIClick(),
                    (0,
                    R.gn)(this, Xo, "f").className = "hidden",
                    (async () => {
                        try {
                            let e;
                            if (e = c instanceof Function ? await c() : c,
                            (0,
                            R.gn)(this, al, "f"))
                                return;
                            const n = e.toExportString(o);
                            (0,
                            R.GG)(this, il, new cl.A(n,( () => {
                                (0,
                                R.gn)(this, il, "f")?.dispose(),
                                (0,
                                R.GG)(this, il, null, "f"),
                                (0,
                                R.gn)(this, Xo, "f").className = "track-info-ui"
                            }
                            ),null,t,a,u,s), "f")
                        } catch (e) {
                            if ((0,
                            R.gn)(this, al, "f"))
                                return;
                            if (!(e instanceof Tr.A))
                                throw e;
                            s.show(t.get("Failed to load track"), t.get("Ok"), ( () => {
                                (0,
                                R.gn)(this, Xo, "f").className = "track-info-ui"
                            }
                            ))
                        }
                    }
                    )()
                }
                )),
                w.appendChild(b),
                l) {
                case hl.A.Summer:
                    x = "images/summer.svg";
                    break;
                case hl.A.Winter:
                    x = "images/winter.svg";
                    break;
                case hl.A.Desert:
                    x = "images/desert.svg"
                }
                const S = document.createElement("img");
                S.className = "environment",
                S.src = x,
                w.appendChild(S);
                const E = document.createElement("div");
                E.className = "track-author",
                E.textContent = t.get("Author") + ": ";
                const T = document.createElement("span");
                T.textContent = o.author ?? t.get("Unknown"),
                E.appendChild(T),
                (0,
                R.gn)(this, Yo, "f").appendChild(E);
                const k = document.createElement("div");
                k.className = "last-modified",
                k.textContent = t.get("Created") + ": ";
                const M = document.createElement("span");
                if (null != o.lastModified) {
                    const e = new Date(o.lastModified);
                    M.textContent += e.toLocaleDateString() + " " + e.toLocaleTimeString(void 0, {
                        hour: "numeric",
                        minute: "2-digit"
                    })
                } else
                    M.textContent += t.get("Unknown");
                k.appendChild(M),
                (0,
                R.gn)(this, Yo, "f").appendChild(k);
                const _ = document.createElement("div");
                _.className = "divider",
                (0,
                R.gn)(this, Yo, "f").appendChild(_);
                const C = document.createElement("div");
                C.className = "personal-best-title",
                C.textContent = t.get("Personal best"),
                (0,
                R.gn)(this, Yo, "f").appendChild(C),
                (0,
                R.GG)(this, Zo, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Zo, "f").className = "personal-best",
                (0,
                R.gn)(this, Yo, "f").appendChild((0,
                R.gn)(this, Zo, "f")),
                (0,
                R.gn)(this, Vo, "m", ol).call(this, v?.time.clone() ?? null, null);
                const P = document.createElement("div");
                P.className = "divider",
                (0,
                R.gn)(this, Yo, "f").appendChild(P);
                const I = document.createElement("div");
                I.className = "opponents-title",
                I.textContent = t.get("Opponents"),
                (0,
                R.gn)(this, Yo, "f").appendChild(I),
                (0,
                R.GG)(this, $o, document.createElement("div"), "f"),
                (0,
                R.gn)(this, $o, "f").className = "opponents-container",
                (0,
                R.gn)(this, Yo, "f").appendChild((0,
                R.gn)(this, $o, "f")),
                (0,
                R.GG)(this, el, document.createElement("button"), "f"),
                (0,
                R.gn)(this, el, "f").className = "button watch",
                (0,
                R.gn)(this, el, "f").innerHTML = '<img src="images/preview.svg">',
                (0,
                R.gn)(this, el, "f").disabled = !0,
                (0,
                R.gn)(this, el, "f").prepend(document.createTextNode(t.get("Watch"))),
                (0,
                R.gn)(this, el, "f").addEventListener("click", ( () => {
                    a.playUIClick();
                    const e = (0,
                    R.gn)(this, rl, "f");
                    if (e.length > 0)
                        m((0,
                        R.gn)(this, jo, "f").getRecordings(e.map((e => e.recordingId))).then((t => {
                            if (t.some((e => null == e)))
                                throw new Error("Failed to load at least one recording.");
                            return t.filter((e => null != e)).map(( (t, n) => ({
                                recording: t.recording,
                                carStyle: t.carStyle,
                                nickname: e[n].nickname,
                                time: t.time,
                                isSelf: e[n].isSelf
                            })))
                        }
                        )));
                    else {
                        const e = r.getRecord(i.profileSlot, h);
                        if (null != e) {
                            const t = i.getCurrentUserProfile();
                            A([{
                                recording: e.recording,
                                carStyle: t.carStyle,
                                nickname: t.nickname,
                                time: e.time,
                                isSelf: !0
                            }])
                        }
                    }
                }
                )),
                (0,
                R.gn)(this, Yo, "f").appendChild((0,
                R.gn)(this, el, "f")),
                (0,
                R.gn)(this, Vo, "m", ll).call(this);
                const L = document.createElement("button");
                L.className = "button play",
                L.innerHTML = '<img src="images/play.svg">',
                L.prepend(document.createTextNode(t.get("Play"))),
                L.addEventListener("click", ( () => {
                    a.playUIClick();
                    const e = (0,
                    R.gn)(this, rl, "f");
                    if (e.length > 0)
                        f((0,
                        R.gn)(this, jo, "f").getRecordings(e.map((e => e.recordingId))).then((t => {
                            if (t.some((e => null == e)))
                                throw new Error("Failed to load at least one recording.");
                            return t.filter((e => null != e)).map(( (t, n) => ({
                                recording: t.recording,
                                carStyle: t.carStyle,
                                nickname: e[n].nickname,
                                time: t.time,
                                isSelf: e[n].isSelf
                            })))
                        }
                        )));
                    else {
                        const e = r.getRecord(i.profileSlot, h);
                        if (null != e) {
                            const t = i.getCurrentUserProfile();
                            g([{
                                recording: e.recording,
                                carStyle: t.carStyle,
                                nickname: t.nickname,
                                time: e.time,
                                isSelf: !0
                            }])
                        } else
                            g([])
                    }
                }
                )),
                (0,
                R.gn)(this, Yo, "f").appendChild(L),
                window.addEventListener("keydown", (0,
                R.GG)(this, nl, (e => {
                    "Escape" == e.code && null == (0,
                    R.gn)(this, il, "f") && (p(),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.GG)(this, al, !0, "f");
                const e = (0,
                R.gn)(this, Xo, "f");
                e.classList.add("hidden"),
                window.removeEventListener("keydown", (0,
                R.gn)(this, nl, "f"));
                for (const e of (0,
                R.gn)(this, sl, "f"))
                    e();
                (0,
                R.GG)(this, sl, [], "f");
                const t = (0,
                R.gn)(this, tl, "f")
                  , n = (0,
                R.gn)(this, Jo, "f")
                  , i = () => {
                    try {
                        t?.dispose()
                    } catch {}
                    try {
                        n.contains(e) && n.removeChild(e)
                    } catch {}
                }
                ;
                "function" == typeof requestIdleCallback ? requestIdleCallback(i, {
                    timeout: 1e3
                }) : setTimeout(i, 0)
            }
        }
        ;
        if (!Pt.EM)
            try {
                if (void 0 !== window.BroadcastChannel) {
                    const e = new window.BroadcastChannel("polytrack-single-instance");
                    e.addEventListener("message", (t => {
                        "new-instance" == t.data && ul && e.postMessage("conflict"),
                        "conflict" == t.data && (ul = !1)
                    }
                    )),
                    e.postMessage("new-instance"),
                    window.addEventListener("beforeunload", ( () => {
                        e.close()
                    }
                    ))
                }
            } catch (e) {
                console.error(e)
            }
        let ul = !0;
        var pl = i(6979)
          , fl = {};
        fl.styleTagTransform = u(),
        fl.setAttributes = l(),
        fl.insert = s().bind(null, "head"),
        fl.domAPI = r(),
        fl.insertStyleElement = h();
        t()(pl.A, fl);
        pl.A && pl.A.locals && pl.A.locals;
        var gl = i(8438);
        class ml extends Error {
            constructor(e="The multiplayer session is full.") {
                super(e),
                this.name = "MultiplayerSessionFullError"
            }
        }
        const Al = ml;
        class vl extends Error {
            constructor(e="The multiplayer invite has expired.") {
                super(e),
                this.name = "MultiplayerExpiredInviteError"
            }
        }
        const yl = vl;
        class wl extends Error {
            constructor(e="Kicked from the multiplayer session.") {
                super(e),
                this.name = "MultiplayerKickedError"
            }
        }
        const bl = wl;
        var xl, Sl, El, Tl, kl, Ml, _l, Cl, Rl, Pl, Il, Ll, Nl, zl, Ul, Dl, Bl, Gl, Fl, Ol, Wl, Vl, Hl, jl, Kl, ql;
        Sl = new WeakMap,
        El = new WeakMap,
        Tl = new WeakMap,
        kl = new WeakMap,
        Ml = new WeakMap,
        _l = new WeakMap,
        Cl = new WeakMap,
        Rl = new WeakMap,
        Pl = new WeakMap,
        Il = new WeakMap,
        Ll = new WeakMap,
        Nl = new WeakMap,
        zl = new WeakMap,
        Ul = new WeakMap,
        Dl = new WeakMap,
        Bl = new WeakMap,
        Gl = new WeakMap,
        Fl = new WeakMap,
        Ol = new WeakMap,
        Wl = new WeakMap,
        Vl = new WeakMap,
        Hl = new WeakMap,
        jl = new WeakMap,
        xl = new WeakSet,
        Kl = function(e) {
            const t = e.createDataChannel("reliable", {
                negotiated: !0,
                id: 0
            });
            t.binaryType = "arraybuffer",
            (0,
            R.gn)(this, xl, "m", ql).call(this, t, e, "reliable");
            const n = e.createDataChannel("unreliable", {
                negotiated: !0,
                id: 1,
                ordered: !1,
                maxRetransmits: 0
            });
            return n.binaryType = "arraybuffer",
            (0,
            R.gn)(this, xl, "m", ql).call(this, n, e, "unreliable"),
            {
                dataChannel: t,
                unreliableDataChannel: n
            }
        }
        ,
        ql = function(e, t, n) {
            e.onclose = () => {
                if (t.close(),
                "reliable" == n) {
                    for (const e of (0,
                    R.gn)(this, Rl, "f"))
                        (0,
                        R.gn)(this, Cl, "f") ? e("kicked") : e("disconnected");
                    (0,
                    R.GG)(this, Rl, [], "f")
                }
            }
            ,
            e.onmessage = t => {
                let n = "Client data channel error: ";
                if (!(t.data instanceof ArrayBuffer))
                    return console.error(n + "Received non-ArrayBuffer data"),
                    void e.close();
                const i = new Uint8Array(t.data);
                let r = 0;
                if (i.length < r + 1)
                    return console.error(n + "Received empty message"),
                    void e.close();
                const a = i[0];
                switch (r += 1,
                a) {
                case Zt.PlayerUpdate:
                    {
                        if (n += Zt[Zt.PlayerUpdate] + ": ",
                        i.length < r + 4)
                            return console.error(n + "Incomplete (id)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        i.length < r + 1)
                            return console.error(n + "Incomplete (nickname length)"),
                            void e.close();
                        const a = i[r];
                        if (r += 1,
                        i.length < r + a)
                            return console.error(n + "Incomplete (nickname)"),
                            void e.close();
                        const s = (new TextDecoder).decode(i.slice(r, r + a));
                        r += a;
                        let o, l, c = "";
                        for (; r < i.length; ) {
                            if (i.length < r + 1)
                                return console.error(n + "Incomplete (countryCode)"),
                                void e.close();
                            const t = i[r];
                            if (r += 1,
                            0 == t)
                                break;
                            c += String.fromCharCode(t),
                            c.length > 32 && console.error(n + "Too long countryCode")
                        }
                        o = 0 == c.length ? null : (0,
                        On.j)(c);
                        try {
                            l = Qt.A.deserializeBinary(i.slice(r))
                        } catch {
                            return console.error(n + "Failed to deserialize CarStyle"),
                            void e.close()
                        }
                        if (r += Qt.A.binaryLength,
                        i.length < r + 1)
                            return console.error(n + "Incomplete (hasRecord)"),
                            void e.close();
                        const h = 1 == i[r];
                        let d;
                        if (r += 1,
                        h) {
                            if (i.length < r + 3)
                                return console.error(n + "Incomplete (record)"),
                                void e.close();
                            const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16;
                            if (r += 3,
                            t <= 0 || t > re.A.maxFrames)
                                return console.error(n + "Invalid record frames"),
                                void e.close();
                            d = new wt.A(t)
                        } else
                            d = null;
                        const u = (0,
                        R.gn)(this, Fl, "f").find((e => e.id == t));
                        if (null != u)
                            u.nickname = s,
                            u.carStyle = l,
                            u.record = d;
                        else {
                            (0,
                            R.gn)(this, Fl, "f").push({
                                id: t,
                                nickname: s,
                                countryCode: o,
                                carStyle: l,
                                record: d,
                                ping: null
                            });
                            for (const e of (0,
                            R.gn)(this, Ul, "f"))
                                e((0,
                                R.gn)(this, Sl, "f").get('"{0}" joined!', [s]))
                        }
                        for (const e of (0,
                        R.gn)(this, zl, "f"))
                            e((0,
                            R.gn)(this, Dl, "f"));
                        break
                    }
                case Zt.RemovePlayer:
                    {
                        if (n += Zt[Zt.RemovePlayer] + ": ",
                        i.length < r + 4)
                            return console.error(n + "Incomplete (id)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        i.length < r + 1)
                            return console.error(n + "Incomplete (reason)"),
                            void e.close();
                        const a = i[r];
                        let s;
                        if (r += 1,
                        0 == a)
                            s = '"{0}" left!';
                        else {
                            if (1 != a)
                                return console.error(n + "Invalid reason"),
                                void e.close();
                            s = '"{0}" was kicked!'
                        }
                        for (let e = 0; e < (0,
                        R.gn)(this, Fl, "f").length; e++) {
                            const n = (0,
                            R.gn)(this, Fl, "f")[e];
                            if (n.id == t) {
                                (0,
                                R.gn)(this, Fl, "f").splice(e, 1);
                                for (const e of (0,
                                R.gn)(this, zl, "f"))
                                    e((0,
                                    R.gn)(this, Dl, "f"));
                                for (const e of (0,
                                R.gn)(this, Ul, "f"))
                                    e((0,
                                    R.gn)(this, Sl, "f").get(s, [n.nickname]));
                                break
                            }
                        }
                        break
                    }
                case Zt.CarReset:
                    {
                        if (n += Zt[Zt.CarReset] + ": ",
                        i.length < r + 4)
                            return console.error(n + "Incomplete (id)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        i.length < r + 4)
                            return console.error(n + "Incomplete (resetCounter)"),
                            void e.close();
                        const a = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        r += 4;
                        for (const e of (0,
                        R.gn)(this, Pl, "f"))
                            e((0,
                            R.gn)(this, Dl, "f"), t, a);
                        break
                    }
                case Zt.CarUpdate:
                    {
                        if (n += Zt[Zt.CarUpdate] + ": ",
                        i.length < r + 4)
                            return console.error(n + "Incomplete (sessionId)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        t == (0,
                        R.gn)(this, Dl, "f")) {
                            const t = new qt.Ay.Inflate;
                            if (t.push(i.subarray(r), !0),
                            t.err)
                                return console.error(n + "Failed to decompress data"),
                                void e.close();
                            r += i.length - r;
                            {
                                const i = t.result;
                                if (!(i instanceof Uint8Array))
                                    return console.error(n + "Failed to decompress data, incorrect type"),
                                    void e.close();
                                let r = 0;
                                for (; r < i.length; ) {
                                    if (i.length < r + 4)
                                        return console.error(n + "Incomplete (id)"),
                                        void e.close();
                                    const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                                    if (r += 4,
                                    i.length < r + 4)
                                        return console.error(n + "Incomplete (resetCounter)"),
                                        void e.close();
                                    const a = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                                    let s, o;
                                    r += 4;
                                    try {
                                        ({numberOfBytes: s, carState: o} = Jt.VO(i.slice(r)))
                                    } catch {
                                        return console.error(n + "Failed to deserialize CarState"),
                                        void e.close()
                                    }
                                    r += s;
                                    for (const e of (0,
                                    R.gn)(this, Il, "f"))
                                        e((0,
                                        R.gn)(this, Dl, "f"), t, a, o)
                                }
                            }
                        }
                        break
                    }
                case Zt.Kick:
                    (0,
                    R.GG)(this, Cl, !0, "f"),
                    e.close();
                    break;
                case Zt.TrackId:
                    {
                        if (i.length < r + 32)
                            return console.error(n + "Incomplete (trackId)"),
                            void e.close();
                        const t = Array.from(i.slice(r, r + 32)).map((e => e.toString(16).padStart(2, "0"))).join("");
                        if (r += 32,
                        null != (0,
                        R.gn)(this, Hl, "f"))
                            return console.error(n + "Received TrackId while already receiving a track"),
                            void e.close();
                        const a = (0,
                        R.gn)(this, Tl, "f").profileSlot
                          , s = (0,
                        R.gn)(this, Tl, "f").getCurrentUserProfile()
                          , o = (0,
                        R.gn)(this, kl, "f").getRecord(a, t);
                        if (null == o?.uploadId) {
                            const e = !0;
                            (0,
                            R.gn)(this, El, "f").getLeaderboardUserEntry(s.tokenHash, t, e).then((e => {
                                null != e && (0,
                                R.gn)(this, kl, "f").syncRecord(a, t, e).catch((e => {
                                    console.warn("Failed to sync multiplayer track record:", e)
                                }
                                ))
                            }
                            )).catch((e => {
                                console.warn("Failed to sync multiplayer track record:", e)
                            }
                            ))
                        }
                        (0,
                        R.GG)(this, Hl, {
                            trackId: t,
                            buffer: ""
                        }, "f");
                        break
                    }
                case Zt.TrackChunk:
                    if (null == (0,
                    R.gn)(this, Hl, "f"))
                        return console.error(n + "Received TrackChunk before TrackId"),
                        void e.close();
                    for (; r < i.length; )
                        (0,
                        R.gn)(this, Hl, "f").buffer += String.fromCharCode(i[r]),
                        r += 1;
                    break;
                case Zt.EndSession:
                    (0,
                    R.GG)(this, Bl, !0, "f");
                    for (const e of (0,
                    R.gn)(this, Ll, "f"))
                        e();
                    break;
                case Zt.NewSession:
                    {
                        if (n += Zt[Zt.NewSession] + ": ",
                        i.length < r + 4)
                            return console.error(n + "Incomplete (sessionId)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        (0,
                        R.GG)(this, Dl, t, "f"),
                        (0,
                        R.GG)(this, Bl, !1, "f"),
                        i.length < r + 1)
                            return console.error(n + "Incomplete (gameMode)"),
                            void e.close();
                        const a = i[r];
                        if (r += 1,
                        "number" != typeof a || !Number.isSafeInteger(a))
                            return console.error(n + "Invalid gameMode value"),
                            void e.close();
                        let s;
                        if (!(a in en))
                            return console.error(n + "Unknown gameMode value"),
                            void e.close();
                        if (s = a,
                        i.length < r + 1)
                            return console.error(n + "Incomplete (maxPlayers)"),
                            void e.close();
                        const o = i[r];
                        if (r += 1,
                        null == (0,
                        R.gn)(this, Hl, "f"))
                            return console.error(n + "Started new session without receiving track data"),
                            void e.close();
                        const l = gl.A.fromExportString((0,
                        R.gn)(this, Hl, "f").buffer);
                        if (null == l)
                            return console.error(n + "Received invalid track data"),
                            void e.close();
                        if (l.trackData.getId() != (0,
                        R.gn)(this, Hl, "f").trackId)
                            return console.error(n + "Received track data that doesn't match the sent track ID"),
                            void e.close();
                        (0,
                        R.GG)(this, Hl, null, "f");
                        for (const e of (0,
                        R.gn)(this, Fl, "f"))
                            e.record = null;
                        (0,
                        R.gn)(this, Gl, "f").record = null,
                        (0,
                        R.GG)(this, Ol, s, "f"),
                        (0,
                        R.GG)(this, Wl, o, "f"),
                        (0,
                        R.GG)(this, Vl, l, "f");
                        for (const e of (0,
                        R.gn)(this, Nl, "f"))
                            e(t, s, l.trackMetadata, l.trackData);
                        break
                    }
                case Zt.Ping:
                    {
                        if (n += Zt[Zt.Ping] + ": ",
                        i.length < r + 1)
                            return console.error(n + "Incomplete (pingId)"),
                            void e.close();
                        const t = i[r];
                        if (r += 1,
                        null != (0,
                        R.gn)(this, _l, "f") && "open" == (0,
                        R.gn)(this, _l, "f").readyState) {
                            const e = new Uint8Array(2);
                            e[0] = Xt.Pong,
                            e[1] = t,
                            (0,
                            R.gn)(this, _l, "f").send(e)
                        }
                        break
                    }
                case Zt.PingData:
                    for (n += Zt[Zt.PingData] + ": "; r < i.length; ) {
                        if (i.length < r + 4)
                            return console.error(n + "Incomplete (id)"),
                            void e.close();
                        const t = i[r + 0] | i[r + 1] << 8 | i[r + 2] << 16 | i[r + 3] << 24;
                        if (r += 4,
                        i.length < r + 2)
                            return console.error(n + "Incomplete (ping)"),
                            void e.close();
                        let a = i[r + 0] | i[r + 1] << 8;
                        if (r += 2,
                        65535 == a && (a = null),
                        (0,
                        R.gn)(this, Gl, "f").id == t)
                            (0,
                            R.gn)(this, Gl, "f").ping = a;
                        else {
                            const e = (0,
                            R.gn)(this, Fl, "f").find((e => e.id == t));
                            null != e && (e.ping = a)
                        }
                    }
                    break;
                case Zt.ModCustomMessage:
                    break;
                default:
                    return console.error(n + "Received unknown message type"),
                    void e.close()
                }
                return i.length != r ? (console.error(n + "Leftover data"),
                void e.close()) : void 0
            }
        }
        ;
        const Ql = class {
            constructor(e, t, n, i) {
                xl.add(this),
                Sl.set(this, void 0),
                El.set(this, void 0),
                Tl.set(this, void 0),
                kl.set(this, void 0),
                Ml.set(this, null),
                _l.set(this, null),
                Cl.set(this, !1),
                Rl.set(this, []),
                Pl.set(this, []),
                Il.set(this, []),
                Ll.set(this, []),
                Nl.set(this, []),
                zl.set(this, []),
                Ul.set(this, []),
                Dl.set(this, 0),
                Bl.set(this, !1),
                Gl.set(this, {
                    id: null,
                    record: null,
                    ping: null
                }),
                Fl.set(this, []),
                Ol.set(this, null),
                Wl.set(this, 0),
                Vl.set(this, null),
                Hl.set(this, null),
                jl.set(this, void 0),
                (0,
                R.GG)(this, Sl, e, "f"),
                (0,
                R.GG)(this, El, t, "f"),
                (0,
                R.GG)(this, Tl, n, "f"),
                (0,
                R.GG)(this, kl, i, "f"),
                window.addEventListener("pagehide", (0,
                R.GG)(this, jl, ( () => {
                    (0,
                    R.gn)(this, Ml, "f")?.close()
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.GG)(this, Rl, [], "f"),
                (0,
                R.GG)(this, Il, [], "f"),
                (0,
                R.GG)(this, Nl, [], "f"),
                (0,
                R.GG)(this, zl, [], "f"),
                window.removeEventListener("pagehide", (0,
                R.gn)(this, jl, "f")),
                (0,
                R.gn)(this, Ml, "f")?.close(),
                (0,
                R.gn)(this, _l, "f")?.close()
            }
            async joinInvite(e) {
                if (null != (0,
                R.gn)(this, Ml, "f"))
                    throw new Error("Data channel already created");
                const t = new RTCPeerConnection({
                    iceServers: await (0,
                    R.gn)(this, El, "f").getIceServers()
                })
                  , n = (0,
                R.gn)(this, xl, "m", Kl).call(this, t);
                (0,
                R.GG)(this, Ml, n.dataChannel, "f"),
                (0,
                R.GG)(this, _l, n.unreliableDataChannel, "f");
                const i = await t.createOffer();
                if (null == i.sdp)
                    throw new Error("Failed to create offer");
                const r = [];
                t.onicecandidate = e => {
                    r.push(e.candidate)
                }
                ,
                await t.setLocalDescription(i),
                await new Promise(( (a, s) => {
                    let o = !1;
                    const l = []
                      , c = (0,
                    R.gn)(this, El, "f").createMultiplayerJoinWebSocket();
                    c.addEventListener("open", ( () => {
                        const n = (0,
                        R.gn)(this, Tl, "f").getCurrentUserProfile();
                        c.send(JSON.stringify({
                            version: Pt.rE,
                            inviteCode: e,
                            offer: i.sdp,
                            mods: [],
                            isModsVanillaCompatible: !0,
                            nickname: n.nickname,
                            countryCode: n.countryCode,
                            carStyle: n.carStyle.serialize()
                        }));
                        for (const e of r)
                            c.send(JSON.stringify({
                                version: Pt.rE,
                                candidate: e
                            }));
                        r.length = 0,
                        t.onicecandidate = e => {
                            c.send(JSON.stringify({
                                version: Pt.rE,
                                candidate: e.candidate
                            }))
                        }
                    }
                    )),
                    c.addEventListener("close", ( () => {
                        s(new Error("WebSocket closed before receiving answer"))
                    }
                    )),
                    c.addEventListener("message", (e => {
                        let n, i = "Join WebSocket message error: ";
                        if ("string" != typeof e.data)
                            return s(new Error(i + "Received non-string data")),
                            void c.close();
                        try {
                            n = JSON.parse(e.data)
                        } catch {
                            return console.error(i + "Failed to parse JSON"),
                            void c.close()
                        }
                        if (null == n || "object" != typeof n)
                            return console.error(i + "JSON is not an object"),
                            void c.close();
                        if (!("type"in n) || "string" != typeof n.type)
                            return console.error(i + "Missing or invalid type"),
                            void c.close();
                        const r = n.type;
                        if ("acceptJoin" == r) {
                            if (i += "AcceptJoin: ",
                            !("answer"in n) || "string" != typeof n.answer)
                                return console.error(i + "Missing or invalid answer"),
                                void c.close();
                            const e = n.answer;
                            if (!("mods"in n) || !Array.isArray(n.mods))
                                return console.error(i + "Missing or invalid mods"),
                                void c.close();
                            const r = [];
                            for (const e of n.mods) {
                                if ("string" != typeof e)
                                    return console.error(i + "Invalid mod entry"),
                                    void c.close();
                                r.push(e)
                            }
                            if (!("isModsVanillaCompatible"in n) || "boolean" != typeof n.isModsVanillaCompatible)
                                return console.error(i + "Missing or invalid isModsVanillaCompatible"),
                                void c.close();
                            if (!n.isModsVanillaCompatible)
                                return console.error(i + "Mods are not vanilla compatible"),
                                void c.close();
                            if (!("clientId"in n) || "number" != typeof n.clientId || !Number.isSafeInteger(n.clientId) || n.clientId < 1)
                                return console.error(i + "Missing or invalid clientId"),
                                void c.close();
                            (0,
                            R.gn)(this, Gl, "f").id = n.clientId,
                            t.setRemoteDescription(new RTCSessionDescription({
                                type: "answer",
                                sdp: e
                            })).then(( () => {
                                o = !0;
                                for (const e of l)
                                    try {
                                        t.addIceCandidate(e).catch((e => {
                                            console.error("Failed to add remote ICE candidate:", e)
                                        }
                                        ))
                                    } catch (e) {
                                        console.error("Failed to create RTCIceCandidate:", e)
                                    }
                                l.length = 0
                            }
                            )).catch(s)
                        } else {
                            if ("declineJoin" == r) {
                                if (i += "DeclineJoin: ",
                                !("reason"in n) || "string" != typeof n.reason)
                                    return console.error(i + "Missing or invalid reason"),
                                    void c.close();
                                const e = n.reason;
                                switch (e) {
                                case "SessionFull":
                                    s(new Al);
                                    break;
                                case "Kicked":
                                    s(new bl);
                                    break;
                                default:
                                    s(new Error("Join declined with unknown reason: " + e))
                                }
                                return void c.close()
                            }
                            if ("iceCandidate" == r) {
                                if (i += "IceCandidate: ",
                                !("candidate"in n) || "object" != typeof n.candidate && null != n.candidate)
                                    return console.error(i + "Missing or invalid candidate"),
                                    void c.close();
                                const e = n.candidate;
                                try {
                                    let n;
                                    n = null == e ? null : new RTCIceCandidate(e),
                                    o ? t.addIceCandidate(n).catch((e => {
                                        console.error("Failed to add remote ICE candidate:", e)
                                    }
                                    )) : l.push(n)
                                } catch (e) {
                                    console.error("Failed to create RTCIceCandidate:", e)
                                }
                            } else if ("error" == r) {
                                if (i += "Error: ",
                                !("error"in n) || "string" != typeof n.error)
                                    return console.error(i + "Missing or invalid error"),
                                    void c.close();
                                const e = n.error;
                                if ("ExpiredInvite" === e)
                                    s(new yl);
                                else
                                    s(new Error("Join declined with unknown server error: " + e));
                                return void c.close()
                            }
                        }
                    }
                    )),
                    n.dataChannel.addEventListener("open", ( () => {
                        a(),
                        c.close()
                    }
                    ))
                }
                ))
            }
            addConnectionLostCallback(e) {
                null == (0,
                R.gn)(this, Ml, "f") || "closed" != (0,
                R.gn)(this, Ml, "f").readyState && "closing" != (0,
                R.gn)(this, Ml, "f").readyState ? (0,
                R.gn)(this, Rl, "f").push(e) : (0,
                R.gn)(this, Cl, "f") ? e("kicked") : e("disconnected")
            }
            removeConnectionLostCallback(e) {
                (0,
                R.GG)(this, Rl, (0,
                R.gn)(this, Rl, "f").filter((t => t != e)), "f")
            }
            addCarResetCallback(e) {
                (0,
                R.gn)(this, Pl, "f").push(e)
            }
            removeCarResetCallback(e) {
                (0,
                R.GG)(this, Pl, (0,
                R.gn)(this, Pl, "f").filter((t => t != e)), "f")
            }
            addCarUpdateCallback(e) {
                (0,
                R.gn)(this, Il, "f").push(e)
            }
            removeCarUpdateCallback(e) {
                (0,
                R.GG)(this, Il, (0,
                R.gn)(this, Il, "f").filter((t => t != e)), "f")
            }
            addEndSessionCallback(e, t) {
                (0,
                R.gn)(this, Ll, "f").push(t),
                (e != (0,
                R.gn)(this, Dl, "f") || (0,
                R.gn)(this, Bl, "f")) && t()
            }
            removeEndSessionCallback(e) {
                (0,
                R.GG)(this, Ll, (0,
                R.gn)(this, Ll, "f").filter((t => t != e)), "f")
            }
            addNewSessionCallback(e, t) {
                (0,
                R.gn)(this, Nl, "f").push(t),
                null != e && e != (0,
                R.gn)(this, Dl, "f") && null != (0,
                R.gn)(this, Ol, "f") && null != (0,
                R.gn)(this, Vl, "f") && t((0,
                R.gn)(this, Dl, "f"), (0,
                R.gn)(this, Ol, "f"), (0,
                R.gn)(this, Vl, "f").trackMetadata, (0,
                R.gn)(this, Vl, "f").trackData)
            }
            removeNewSessionCallback(e) {
                (0,
                R.GG)(this, Nl, (0,
                R.gn)(this, Nl, "f").filter((t => t != e)), "f")
            }
            addServerMessageCallback(e) {
                (0,
                R.gn)(this, Ul, "f").push(e)
            }
            removeServerMessageCallback(e) {
                (0,
                R.GG)(this, Ul, (0,
                R.gn)(this, Ul, "f").filter((t => t != e)), "f")
            }
            sendCarReset(e, t) {
                if (e == (0,
                R.gn)(this, Dl, "f") && !(0,
                R.gn)(this, Bl, "f") && null != (0,
                R.gn)(this, Ml, "f") && "open" == (0,
                R.gn)(this, Ml, "f").readyState) {
                    const n = new Uint8Array(9);
                    n[0] = Xt.CarReset,
                    n[1] = 255 & e,
                    n[2] = e >> 8 & 255,
                    n[3] = e >> 16 & 255,
                    n[4] = e >> 24 & 255,
                    n[5] = 255 & t,
                    n[6] = t >> 8 & 255,
                    n[7] = t >> 16 & 255,
                    n[8] = t >> 24 & 255,
                    (0,
                    R.gn)(this, Ml, "f").send(n)
                }
            }
            sendCarUpdate(e, t, n) {
                if (e == (0,
                R.gn)(this, Dl, "f") && !(0,
                R.gn)(this, Bl, "f") && null != (0,
                R.gn)(this, _l, "f") && "open" == (0,
                R.gn)(this, _l, "f").readyState) {
                    const i = Jt._c(n)
                      , r = new Uint8Array(9 + i.length);
                    r[0] = Xt.CarUpdate,
                    r[1] = 255 & e,
                    r[2] = e >> 8 & 255,
                    r[3] = e >> 16 & 255,
                    r[4] = e >> 24 & 255,
                    r[5] = 255 & t,
                    r[6] = t >> 8 & 255,
                    r[7] = t >> 16 & 255,
                    r[8] = t >> 24 & 255,
                    r.set(i, 9),
                    (0,
                    R.gn)(this, _l, "f").send(r)
                }
            }
            sendRecord(e, t) {
                if (e == (0,
                R.gn)(this, Dl, "f") && !(0,
                R.gn)(this, Bl, "f") && null != (0,
                R.gn)(this, Ml, "f") && "open" == (0,
                R.gn)(this, Ml, "f").readyState) {
                    (0,
                    R.gn)(this, Gl, "f").record = t.clone();
                    for (const t of (0,
                    R.gn)(this, zl, "f"))
                        t(e);
                    const n = t.numberOfFrames
                      , i = new Uint8Array(8);
                    i[0] = Xt.Record,
                    i[1] = 255 & e,
                    i[2] = e >> 8 & 255,
                    i[3] = e >> 16 & 255,
                    i[4] = e >> 24 & 255,
                    i[5] = 255 & n,
                    i[6] = n >> 8 & 255,
                    i[7] = n >> 16 & 255,
                    (0,
                    R.gn)(this, Ml, "f").send(i)
                }
            }
            getPing(e) {
                if ((0,
                R.gn)(this, Gl, "f").id == e)
                    return (0,
                    R.gn)(this, Gl, "f").ping;
                const t = (0,
                R.gn)(this, Fl, "f").find((t => t.id == e));
                return null != t ? t.ping : null
            }
            getPlayers() {
                const e = (0,
                R.gn)(this, Tl, "f").getCurrentUserProfile()
                  , t = (0,
                R.gn)(this, Fl, "f").map((e => ({
                    id: e.id,
                    nickname: e.nickname,
                    countryCode: e.countryCode,
                    carStyle: e.carStyle,
                    record: e.record?.clone() ?? null,
                    isSelf: !1
                })));
                return null != (0,
                R.gn)(this, Gl, "f").id && t.push({
                    id: (0,
                    R.gn)(this, Gl, "f").id,
                    nickname: e.nickname,
                    countryCode: e.countryCode,
                    carStyle: e.carStyle,
                    record: (0,
                    R.gn)(this, Gl, "f").record?.clone() ?? null,
                    isSelf: !0
                }),
                t
            }
            getMaxPlayers() {
                return (0,
                R.gn)(this, Wl, "f")
            }
            addPlayersChangedCallback(e) {
                (0,
                R.gn)(this, zl, "f").push(e)
            }
            removePlayersChangedCallback(e) {
                (0,
                R.GG)(this, zl, (0,
                R.gn)(this, zl, "f").filter((t => t != e)), "f")
            }
        }
        ;
        var Jl, Xl, Yl, Zl, $l, ec, tc, nc, ic, rc, ac, sc, oc, lc, cc, hc, dc, uc, pc, fc, gc, mc, Ac, vc, yc;
        Xl = new WeakMap,
        Yl = new WeakMap,
        Zl = new WeakMap,
        $l = new WeakMap,
        ec = new WeakMap,
        tc = new WeakMap,
        nc = new WeakMap,
        ic = new WeakMap,
        rc = new WeakMap,
        ac = new WeakMap,
        sc = new WeakMap,
        oc = new WeakMap,
        lc = new WeakMap,
        cc = new WeakMap,
        hc = new WeakMap,
        dc = new WeakMap,
        uc = new WeakMap,
        pc = new WeakMap,
        fc = new WeakMap,
        gc = new WeakMap,
        mc = new WeakMap,
        Jl = new WeakSet,
        Ac = function() {
            const e = document.createElement("div");
            e.className = "join",
            (0,
            R.gn)(this, oc, "f").appendChild(e);
            const t = document.createElement("div");
            t.className = "main-box",
            e.appendChild(t);
            const n = document.createElement("div");
            n.className = "error-box",
            e.appendChild(n);
            const i = document.createElement("h2");
            i.textContent = (0,
            R.gn)(this, Yl, "f").get("Join Multiplayer Game"),
            t.appendChild(i);
            const s0 = document.createElement("p");
            s0.textContent = "Multiplayer may not work on restrictive networks";
            s0.style.cssText = "margin: 20px 20px 0px; padding: 0px; font-size: 18px; font-weight: normal; text-align: center; line-height: 1.2; color: rgb(255, 77, 77);",
            t.appendChild(s0);
            const r = document.createElement("div");
            r.className = "invite-code-container",
            t.appendChild(r);
            const a = document.createElement("input");
            a.type = "text",
            a.className = "invite-code",
            a.placeholder = (0,
            R.gn)(this, Yl, "f").get("Enter invite code"),
            a.spellcheck = !1,
            a.autocomplete = "off",
            a.maxLength = 32,
            a.addEventListener("input", ( () => {
                d.disabled = 0 == a.value.trim().length
            }
            )),
            a.addEventListener("keydown", (e => {
                "Enter" != e.code && "Enter" != e.key || d.disabled || (u(),
                e.preventDefault())
            }
            )),
            r.appendChild(a),
            a.focus();
            const s = document.createElement("div");
            s.className = "connecting-text";
            const o = document.createElement("div");
            o.className = "loading-spinner-ui",
            s.appendChild(o),
            s.appendChild(document.createTextNode((0,
            R.gn)(this, Yl, "f").get("Connecting..."))),
            r.appendChild(s);
            const l = document.createElement("div");
            l.className = "buttons",
            t.appendChild(l);
            const c = document.createElement("button");
            c.className = "button",
            c.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
            c.append(document.createTextNode((0,
            R.gn)(this, Yl, "f").get("Back"))),
            c.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Xl, "f").playUIClick(),
                (0,
                R.gn)(this, Jl, "m", yc).call(this)
            }
            )),
            l.appendChild(c);
            const h = document.createElement("button");
            h.className = "button",
            h.textContent = (0,
            R.gn)(this, Yl, "f").get("Host"),
            h.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Xl, "f").playUIClick(),
                (0,
                R.gn)(this, lc, "f").classList.add("hidden"),
                (0,
                R.gn)(this, cc, "f").classList.remove("hidden"),
                (0,
                R.GG)(this, hc, !0, "f")
            }
            )),
            l.appendChild(h);
            const d = document.createElement("button");
            d.className = "button join",
            d.innerHTML = '<img class="button-icon" src="images/play.svg"> ',
            d.prepend(document.createTextNode((0,
            R.gn)(this, Yl, "f").get("Join"))),
            d.disabled = !0,
            d.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Xl, "f").playUIClick(),
                u()
            }
            )),
            l.appendChild(d);
            const u = async () => {
                n.classList.remove("show"),
                r.classList.add("connecting"),
                a.disabled = !0,
                h.disabled = !0,
                d.disabled = !0;
                const e = a.value.trim().toUpperCase()
                  , t = performance.now();
                try {
                    const t = new Ql((0,
                    R.gn)(this, Yl, "f"),(0,
                    R.gn)(this, ec, "f"),(0,
                    R.gn)(this, tc, "f"),(0,
                    R.gn)(this, $l, "f"));
                    (0,
                    R.GG)(this, fc, t, "f"),
                    await t.joinInvite(e);
                    const n = await new Promise(( (e, n) => {
                        const i = (n, a, s, o) => {
                            t.removeNewSessionCallback(i),
                            t.removeConnectionLostCallback(r),
                            e({
                                sessionId: n,
                                gameMode: a,
                                trackMetadata: s,
                                trackData: o
                            })
                        }
                          , r = () => {
                            n(new Error("Connection lost"))
                        }
                        ;
                        t.addNewSessionCallback(null, i),
                        t.addConnectionLostCallback(r)
                    }
                    ));
                    if ((0,
                    R.gn)(this, gc, "f"))
                        return void t.dispose();
                    (0,
                    R.GG)(this, fc, null, "f"),
                    this.dispose(),
                    (0,
                    R.gn)(this, ac, "f").call(this, n.trackMetadata, n.trackData, "custom", [], {
                        multiplayerConnection: t,
                        sessionId: n.sessionId,
                        gameMode: n.gameMode
                    })
                } catch (e) {
                    if (console.error(e),
                    (0,
                    R.gn)(this, gc, "f"))
                        return;
                    let i;
                    await new Promise((e => {
                        const n = performance.now() - t;
                        n < 1e3 ? setTimeout(e, 1e3 - n) : e()
                    }
                    )),
                    i = e instanceof yl ? (0,
                    R.gn)(this, Yl, "f").get("Error: The invite code has expired or is incorrect") : e instanceof Al ? (0,
                    R.gn)(this, Yl, "f").get("Error: The multiplayer server is full") : e instanceof bl ? (0,
                    R.gn)(this, Yl, "f").get("Error: You were kicked from the game") : (0,
                    R.gn)(this, Yl, "f").get("Error: Failed to connect"),
                    n.textContent = i,
                    n.classList.add("show")
                } finally {
                    (0,
                    R.GG)(this, fc, null, "f"),
                    r.classList.remove("connecting"),
                    a.disabled = !1,
                    a.focus(),
                    h.disabled = !1,
                    d.disabled = !1
                }
            }
            ;
            return e
        }
        ,
        vc = function() {
            const e = document.createElement("div");
            e.className = "host hidden",
            (0,
            R.gn)(this, oc, "f").appendChild(e);
            const t = document.createElement("div");
            t.className = "main-box",
            e.appendChild(t);
            const n = document.createElement("div");
            n.className = "error-box",
            t.appendChild(n);
            const i = document.createElement("h2");
            i.textContent = (0,
            R.gn)(this, Yl, "f").get("Host Multiplayer Game"),
            t.appendChild(i);
            let r = en.Casual;
            const a = document.createElement("div");
            a.className = "game-mode-container",
            t.appendChild(a);
            const s = document.createElement("div");
            s.className = "title",
            s.textContent = (0,
            R.gn)(this, Yl, "f").get("Game Mode"),
            a.appendChild(s);
            const o = [];
            for (const e of [en.Casual, en.Competitive]) {
                const t = document.createElement("button");
                switch (t.className = "button",
                e) {
                case en.Casual:
                    t.textContent = (0,
                    R.gn)(this, Yl, "f").get("Casual");
                    break;
                case en.Competitive:
                    t.textContent = (0,
                    R.gn)(this, Yl, "f").get("Competitive")
                }
                e == r && t.classList.add("selected"),
                t.addEventListener("click", ( () => {
                    (0,
                    R.gn)(this, Xl, "f").playUIClick(),
                    r = e,
                    l();
                    for (const e of o)
                        e.classList.remove("selected");
                    t.classList.add("selected")
                }
                )),
                a.appendChild(t),
                o.push(t)
            }
            const l = () => {
                switch (r) {
                case en.Casual:
                    c.textContent = (0,
                    R.gn)(this, Yl, "f").get("Players play to improve their personal best times.");
                    break;
                case en.Competitive:
                    c.textContent = (0,
                    R.gn)(this, Yl, "f").get("Players compete to set the best time in the session.")
                }
            }
              , c = document.createElement("div");
            c.className = "info",
            a.appendChild(c),
            l();
            const h = document.createElement("div");
            h.className = "maximum-players-container",
            t.appendChild(h);
            const d = document.createElement("div");
            d.className = "maximum-players-info",
            d.textContent = (0,
            R.gn)(this, Yl, "f").get("Maximum Players: {0}", ["8"]),
            h.appendChild(d);
            const u = document.createElement("input");
            u.className = "maximum-players",
            u.type = "range",
            u.value = "8",
            u.min = "2",
            u.max = "32",
            u.addEventListener("input", ( () => {
                d.textContent = (0,
                R.gn)(this, Yl, "f").get("Maximum Players: {0}", [u.value])
            }
            )),
            h.appendChild(u);
            let p = null;
            const f = document.createElement("button");
            f.className = "button track-button",
            f.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Xl, "f").playUIClick(),
                e.classList.add("hidden"),
                (0,
                R.GG)(this, uc, new vr.A((0,
                R.gn)(this, sc, "f"),(0,
                R.gn)(this, Yl, "f"),(0,
                R.gn)(this, Xl, "f"),(0,
                R.gn)(this, $l, "f"),(0,
                R.gn)(this, Zl, "f"),(0,
                R.gn)(this, tc, "f"),(0,
                R.gn)(this, ic, "f"),(0,
                R.gn)(this, nc, "f"),"back",!1,( () => {
                    (0,
                    R.gn)(this, uc, "f")?.dispose(),
                    (0,
                    R.GG)(this, uc, null, "f"),
                    e.classList.remove("hidden")
                }
                ),( (t, n, i, r, a, s) => {
                    (0,
                    R.gn)(this, uc, "f")?.dispose(),
                    (0,
                    R.GG)(this, uc, null, "f"),
                    e.classList.remove("hidden"),
                    A({
                        trackMetadata: t,
                        trackData: i
                    }, s)
                }
                )), "f"),
                (0,
                R.gn)(this, uc, "f").show()
            }
            )),
            t.appendChild(f);
            const g = document.createElement("img");
            g.className = "thumbnail",
            g.src = "images/empty.svg",
            f.appendChild(g);
            const m = document.createElement("div");
            m.className = "name placeholder",
            m.textContent = (0,
            R.gn)(this, Yl, "f").get("Select Track"),
            f.appendChild(m);
            const A = (e, t) => {
                if (f.innerHTML = "",
                t instanceof HTMLCanvasElement) {
                    const e = document.createElement("canvas");
                    e.className = "thumbnail",
                    e.width = t.width,
                    e.height = t.height;
                    const n = e.getContext("2d");
                    null != n && n.drawImage(t, 0, 0),
                    f.appendChild(e)
                } else if ("string" == typeof t && null != t && "null" != t && "" != t) {
                    const e = document.createElement("img");
                    e.className = "thumbnail",
                    e.src = t,
                    f.appendChild(e)
                } else {
                    let r = null
                      , a = null;
                    try {
                        a = e.trackData?.getId?.()
                    } catch {}
                    try {
                        null != a && (r = localStorage.getItem("pt_thumb_" + Pt.rE + "_" + a))
                    } catch {}
                    let s = null;
                    try {
                        const e = ("undefined" != typeof globalThis ? globalThis : window).__ptThumbCanvasCache;
                        s = e instanceof Map ? e.get(a) : null
                    } catch {}
                    if (s instanceof HTMLCanvasElement) {
                        const e = document.createElement("canvas");
                        e.className = "thumbnail",
                        e.width = s.width,
                        e.height = s.height;
                        const t = e.getContext("2d");
                        null != t && t.drawImage(s, 0, 0),
                        f.appendChild(e)
                    } else if ("string" == typeof r && r.startsWith("data:image/")) {
                        const e = document.createElement("img");
                        e.className = "thumbnail",
                        e.src = r,
                        f.appendChild(e)
                    } else {
                        const t = e.trackData.createThumbnail()
                          , n = document.createElement("canvas");
                        n.className = "thumbnail",
                        n.width = t.width,
                        n.height = t.height;
                        const i = n.getContext("2d");
                        null != i && i.drawImage(t, 0, 0),
                        f.appendChild(n);
                        try {
                            if (null != a) {
                                const e = ("undefined" != typeof globalThis ? globalThis : window);
                                e.__ptThumbCanvasCache instanceof Map || (e.__ptThumbCanvasCache = new Map);
                                const n = document.createElement("canvas");
                                n.width = t.width,
                                n.height = t.height;
                                const i = n.getContext("2d");
                                null != i && i.drawImage(t, 0, 0),
                                e.__ptThumbCanvasCache.set(a, n),
                                localStorage.setItem("pt_thumb_" + Pt.rE + "_" + a, n.toDataURL())
                            }
                        } catch {}
                    }
                }
                const n = document.createElement("div");
                n.className = "name",
                n.textContent = e.trackMetadata.name,
                f.appendChild(n),
                p = e,
                w.disabled = !1
            }
              , v = document.createElement("div");
            v.className = "buttons",
            t.appendChild(v);
            const y = document.createElement("button");
            y.className = "button",
            y.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
            y.append(document.createTextNode((0,
            R.gn)(this, Yl, "f").get("Back"))),
            y.addEventListener("click", ( () => {
                (0,
                R.gn)(this, Xl, "f").playUIClick(),
                (0,
                R.gn)(this, Jl, "m", yc).call(this)
            }
            )),
            v.appendChild(y);
            const w = document.createElement("button");
            return w.className = "button",
            w.disabled = !0,
            w.textContent = (0,
            R.gn)(this, Yl, "f").get("Host"),
            w.addEventListener("click", ( () => {
                if ((0,
                R.gn)(this, Xl, "f").playUIClick(),
                null != p) {
                    (0,
                    R.GG)(this, dc, !0, "f"),
                    (0,
                    R.gn)(this, cc, "f").classList.add("hidden");
                    const e = p.trackMetadata
                      , t = p;
                    (0,
                    R.GG)(this, pc, new kr.A(!1), "f"),
                    t.trackData().then((t => {
                        const n = parseInt(u.value);
                        if (Number.isNaN(n) || !Number.isSafeInteger(n) || n < 1)
                            throw new Error("Invalid maximum players: " + u.value);
                        const i = new Wn((0,
                        R.gn)(this, Yl, "f"),(0,
                        R.gn)(this, ec, "f"),n,(0,
                        R.gn)(this, tc, "f"))
                          , a = i.startNewSessionImmediate(r, e, t);
                        this.dispose(),
                        (0,
                        R.gn)(this, ac, "f").call(this, e, t, "custom", [], {
                            multiplayerConnection: i,
                            sessionId: a,
                            gameMode: r
                        })
                    }
                    )).catch((e => {
                        if (!(e instanceof Tr.A))
                            throw e;
                        (0,
                        R.gn)(this, ic, "f").show((0,
                        R.gn)(this, Yl, "f").get("Failed to load track"), (0,
                        R.gn)(this, Yl, "f").get("Ok"), ( () => {
                            (0,
                            R.gn)(this, cc, "f").classList.remove("hidden"),
                            (0,
                            R.GG)(this, dc, !1, "f")
                        }
                        ))
                    }
                    )).finally(( () => {
                        (0,
                        R.gn)(this, pc, "f")?.dispose(),
                        (0,
                        R.GG)(this, pc, null, "f")
                    }
                    ))
                }
            }
            )),
            v.appendChild(w),
            e
        }
        ,
        yc = function() {
            null == (0,
            R.gn)(this, uc, "f") && ((0,
            R.gn)(this, hc, "f") ? ((0,
            R.gn)(this, cc, "f").classList.add("hidden"),
            (0,
            R.gn)(this, lc, "f").classList.remove("hidden"),
            (0,
            R.GG)(this, hc, !1, "f")) : (0,
            R.gn)(this, rc, "f").call(this))
        }
        ;
        const wc = class {
            constructor(e, t, n, i, r, a, s, o, l, c) {
                Jl.add(this),
                Xl.set(this, void 0),
                Yl.set(this, void 0),
                Zl.set(this, void 0),
                $l.set(this, void 0),
                ec.set(this, void 0),
                tc.set(this, void 0),
                nc.set(this, void 0),
                ic.set(this, void 0),
                rc.set(this, void 0),
                ac.set(this, void 0),
                sc.set(this, void 0),
                oc.set(this, void 0),
                lc.set(this, void 0),
                cc.set(this, void 0),
                hc.set(this, !1),
                dc.set(this, !1),
                uc.set(this, null),
                pc.set(this, null),
                fc.set(this, null),
                gc.set(this, !1),
                mc.set(this, void 0),
                (0,
                R.GG)(this, Xl, e, "f"),
                (0,
                R.GG)(this, Yl, t, "f"),
                (0,
                R.GG)(this, Zl, n, "f"),
                (0,
                R.GG)(this, $l, i, "f"),
                (0,
                R.GG)(this, ec, r, "f"),
                (0,
                R.GG)(this, tc, a, "f"),
                (0,
                R.GG)(this, nc, s, "f"),
                (0,
                R.GG)(this, ic, o, "f"),
                (0,
                R.GG)(this, rc, l, "f"),
                (0,
                R.GG)(this, ac, c, "f");
                const h = document.getElementById("ui");
                if (null == h)
                    throw new Error("UI element not found");
                (0,
                R.GG)(this, sc, h, "f"),
                (0,
                R.GG)(this, oc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, oc, "f").className = "multiplayer-ui",
                (0,
                R.gn)(this, sc, "f").appendChild((0,
                R.gn)(this, oc, "f")),
                (0,
                R.GG)(this, lc, (0,
                R.gn)(this, Jl, "m", Ac).call(this), "f"),
                (0,
                R.GG)(this, cc, (0,
                R.gn)(this, Jl, "m", vc).call(this), "f"),
                window.addEventListener("keydown", (0,
                R.GG)(this, mc, (e => {
                    "Escape" != e.code || (0,
                    R.gn)(this, dc, "f") || ((0,
                    R.gn)(this, Jl, "m", yc).call(this),
                    e.preventDefault())
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.GG)(this, gc, !0, "f"),
                (0,
                R.gn)(this, uc, "f")?.dispose(),
                (0,
                R.GG)(this, uc, null, "f"),
                (0,
                R.gn)(this, pc, "f")?.dispose(),
                (0,
                R.GG)(this, pc, null, "f"),
                null != (0,
                R.gn)(this, fc, "f") && ((0,
                R.gn)(this, fc, "f").dispose(),
                (0,
                R.GG)(this, fc, null, "f")),
                (0,
                R.gn)(this, oc, "f").parentElement == (0,
                R.gn)(this, sc, "f") && (0,
                R.gn)(this, sc, "f").removeChild((0,
                R.gn)(this, oc, "f")),
                window.removeEventListener("keydown", (0,
                R.gn)(this, mc, "f"))
            }
        }
        ;
        var bc = i(1247)
          , xc = {};
        xc.styleTagTransform = u(),
        xc.setAttributes = l(),
        xc.insert = s().bind(null, "head"),
        xc.domAPI = r(),
        xc.insertStyleElement = h();
        t()(bc.A, xc);
        bc.A && bc.A.locals && bc.A.locals;
        var Sc, Ec, Tc, kc;
        Sc = new WeakMap,
        Ec = new WeakMap,
        Tc = new WeakMap,
        kc = new WeakMap;
        const Mc = class {
            constructor(e, t, n, i) {
                Sc.set(this, void 0),
                Ec.set(this, void 0),
                Tc.set(this, void 0),
                kc.set(this, void 0),
                (0,
                R.GG)(this, Tc, e, "f"),
                (0,
                R.GG)(this, Sc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Sc, "f").className = "news-popup-ui",
                (0,
                R.gn)(this, Tc, "f").appendChild((0,
                R.gn)(this, Sc, "f"));
                const r = document.createElement("h2");
                r.textContent = n.get("Update 0.6.0"),
                (0,
                R.gn)(this, Sc, "f").appendChild(r);
                const a = document.createElement("h3");
                a.textContent = n.get("Multiplayer & More Customization"),
                (0,
                R.gn)(this, Sc, "f").appendChild(a),
                (0,
                R.GG)(this, Ec, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ec, "f").className = "content",
                (0,
                R.gn)(this, Sc, "f").appendChild((0,
                R.gn)(this, Ec, "f"));
                const s = document.createElement("p");
                s.textContent = n.get("Welcome to PolyTrack 0.6.0! This update introduces experimental multiplayer support, more car customization, editor copy/paste, optimizations and more!"),
                (0,
                R.gn)(this, Ec, "f").appendChild(s);
                const o = document.createElement("p");
                o.className = "small",
                o.textContent = n.get("Note: As with every major PolyTrack update, physics changes mean that records from previous versions are not compatible."),
                (0,
                R.gn)(this, Ec, "f").appendChild(o);
                const l = document.createElement("div");
                l.className = "bottom-container",
                (0,
                R.gn)(this, Sc, "f").appendChild(l);
                const c = document.createElement("button");
                c.className = "button",
                c.textContent = n.get("Continue"),
                c.addEventListener("click", ( () => {
                    t.playUIClick(),
                    i()
                }
                )),
                l.appendChild(c),
                window.addEventListener("keydown", (0,
                R.GG)(this, kc, (e => {
                    "Enter" != e.code && "Escape" != e.code && "Space" != e.code || (t.playUIClick(),
                    i())
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Tc, "f").removeChild((0,
                R.gn)(this, Sc, "f")),
                window.removeEventListener("keydown", (0,
                R.gn)(this, kc, "f"))
            }
        }
        ;
        var _c, Cc, Rc, Pc, Ic, Lc, Nc, zc, Uc, Dc, Bc, Gc, Fc, Oc, Wc, Vc, Hc, jc, Kc, qc, Qc, Jc, Xc, Yc, Zc, $c, eh, th, nh, ih, rh, ah, sh, oh;
        let lh = null;
        Cc = new WeakMap,
        Rc = new WeakMap,
        Pc = new WeakMap,
        Ic = new WeakMap,
        Lc = new WeakMap,
        Nc = new WeakMap,
        zc = new WeakMap,
        Uc = new WeakMap,
        Dc = new WeakMap,
        Bc = new WeakMap,
        Gc = new WeakMap,
        Fc = new WeakMap,
        Oc = new WeakMap,
        Wc = new WeakMap,
        Vc = new WeakMap,
        Hc = new WeakMap,
        jc = new WeakMap,
        Kc = new WeakMap,
        qc = new WeakMap,
        Qc = new WeakMap,
        Jc = new WeakMap,
        Xc = new WeakMap,
        Yc = new WeakMap,
        Zc = new WeakMap,
        $c = new WeakMap,
        _c = new WeakSet,
        eh = function(e, t, n, i, r, a, s, o, l, c) {
            return new vr.A((0,
            R.gn)(this, Nc, "f"),e,t,n,i,r,a,s,"back",!1,( () => {
                (0,
                R.gn)(this, Fc, "f").hide(),
                (0,
                R.gn)(this, _c, "m", rh).call(this),
                (0,
                R.gn)(this, _c, "m", sh).call(this)
            }
            ),( (s, h, d, u, p, f) => {
                (0,
                R.gn)(this, Fc, "f").hide();
                const g = () => {
                    (0,
                    R.gn)(this, Fc, "f").show(),
                    (0,
                    R.gn)(this, Oc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Oc, null, "f")
                }
                  , m = c => {
                    (0,
                    R.gn)(this, Oc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Oc, null, "f"),
                    (0,
                    R.GG)(this, Wc, new kr.A(!1), "f"),
                    d().then((d => {
                        d.hasStartingPoint() ? l(s, d, u, c, null) : a.show(e.get("Track is missing starting point"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    )).catch((l => {
                        if (!(l instanceof Tr.A))
                            throw l;
                        a.show(e.get("Failed to load track"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    )).finally(( () => {
                        (0,
                        R.gn)(this, Wc, "f")?.dispose(),
                        (0,
                        R.GG)(this, Wc, null, "f")
                    }
                    ))
                }
                  , A = c => {
                    (0,
                    R.gn)(this, Oc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Oc, null, "f"),
                    o.determinismState != oo.Ok ? a.show(e.get("Cannot load recordings due to non-determinism"), e.get("Ok"), ( () => {
                        (0,
                        R.GG)(this, Oc, new dl((0,
                        R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                    }
                    )) : c.then((c => {
                        d().then((d => {
                            d.hasStartingPoint() ? l(s, d, u, c, null) : a.show(e.get("Track is missing starting point"), e.get("Ok"), ( () => {
                                (0,
                                R.GG)(this, Oc, new dl((0,
                                R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                            }
                            ))
                        }
                        )).catch((l => {
                            if (!(l instanceof Tr.A))
                                throw l;
                            a.show(e.get("Failed to load track"), e.get("Ok"), ( () => {
                                (0,
                                R.GG)(this, Oc, new dl((0,
                                R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                            }
                            ))
                        }
                        ))
                    }
                    )).catch(( () => {
                        a.show(e.get("Failed to load recordings"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    ))
                }
                  , v = l => {
                    (0,
                    R.gn)(this, Oc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Oc, null, "f"),
                    o.determinismState != oo.Ok ? a.show(e.get("Cannot load recordings due to non-determinism"), e.get("Ok"), ( () => {
                        (0,
                        R.GG)(this, Oc, new dl((0,
                        R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                    }
                    )) : l.then((l => {
                        d().then((d => {
                            d.hasStartingPoint() ? c(s, d, u, l) : a.show(e.get("Track is missing starting point"), e.get("Ok"), ( () => {
                                (0,
                                R.GG)(this, Oc, new dl((0,
                                R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                            }
                            ))
                        }
                        )).catch((l => {
                            if (!(l instanceof Tr.A))
                                throw l;
                            a.show(e.get("Failed to load track"), e.get("Ok"), ( () => {
                                (0,
                                R.GG)(this, Oc, new dl((0,
                                R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                            }
                            ))
                        }
                        ))
                    }
                    )).catch(( () => {
                        a.show(e.get("Failed to load recordings"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    ))
                }
                  , y = l => {
                    (0,
                    R.gn)(this, Oc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Oc, null, "f"),
                    d().then((d => {
                        d.hasStartingPoint() ? c(s, d, u, l) : a.show(e.get("Track is missing starting point"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    )).catch((l => {
                        if (!(l instanceof Tr.A))
                            throw l;
                        a.show(e.get("Failed to load track"), e.get("Ok"), ( () => {
                            (0,
                            R.GG)(this, Oc, new dl((0,
                            R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f")
                        }
                        ))
                    }
                    ))
                }
                ;
                (0,
                R.GG)(this, Oc, new dl((0,
                R.gn)(this, Nc, "f"),e,o,r,n,t,a,s,h,d,p,f,i,g,A,m,v,y), "f"),
                (0,
                R.gn)(this, _c, "m", ah).call(this)
            }
            ))
        }
        ,
        th = function e(t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A) {
            for (const e of (0,
            R.gn)(this, qc, "f"))
                (0,
                R.gn)(this, Kc, "f").removeChild(e);
            (0,
            R.GG)(this, qc, [], "f");
            for (const e of (0,
            R.gn)(this, Jc, "f"))
                (0,
                R.gn)(this, Qc, "f").removeChild(e);
            (0,
            R.GG)(this, Jc, [], "f");
            const v = document.createElement("button");
            v.className = "button button-image",
            v.innerHTML = '<img src="images/customize.svg">',
            v.addEventListener("click", ( () => {
                n.playUIClick(),
                u()
            }
            ));
            const y = document.createElement("p");
            y.textContent = t.get("Garage"),
            v.appendChild(y),
            (0,
            R.gn)(this, Kc, "f").appendChild(v),
            (0,
            R.gn)(this, qc, "f").push(v);
            const w = document.createElement("button");
            w.className = "button button-image",
            w.innerHTML = '<img src="images/editor.svg">',
            w.addEventListener("click", ( () => {
                n.playUIClick(),
                p()
            }
            ));
            const b = document.createElement("p");
            b.textContent = t.get("Editor"),
            w.appendChild(b),
            (0,
            R.gn)(this, Kc, "f").appendChild(w),
            (0,
            R.gn)(this, qc, "f").push(w);
            const x = document.createElement("button");
            x.className = "button button-image",
            x.innerHTML = '<img src="images/settings.svg">',
            x.addEventListener("click", ( () => {
                n.playUIClick(),
                (0,
                R.gn)(this, _c, "m", ih).call(this),
                (0,
                R.gn)(this, _c, "m", ah).call(this),
                (0,
                R.GG)(this, Vc, new eo((0,
                R.gn)(this, Nc, "f"),t,n,i,r,a,d,( () => {
                    (0,
                    R.gn)(this, Vc, "f")?.dispose(),
                    (0,
                    R.GG)(this, Vc, null, "f"),
                    (0,
                    R.gn)(this, Fc, "f").dispose(),
                    (0,
                    R.GG)(this, Fc, (0,
                    R.gn)(this, _c, "m", eh).call(this, t, n, l, s, o, d, c, h, f, g), "f"),
                    (0,
                    R.gn)(this, _c, "m", nh).call(this, t),
                    (0,
                    R.gn)(this, _c, "m", e).call(this, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A),
                    (0,
                    R.gn)(this, _c, "m", rh).call(this),
                    (0,
                    R.gn)(this, _c, "m", sh).call(this)
                }
                )), "f")
            }
            ));
            const S = document.createElement("p");
            S.textContent = t.get("Settings"),
            x.appendChild(S),
            (0,
            R.gn)(this, Kc, "f").appendChild(x),
            (0,
            R.gn)(this, qc, "f").push(x);
            const E = document.createElement("button");
            E.className = "button button-image",
            E.innerHTML = '<img src="images/multiplayer.svg">',
            E.addEventListener("click", ( () => {
                n.playUIClick(),
                (0,
                R.gn)(this, _c, "m", ih).call(this),
                (0,
                R.gn)(this, _c, "m", ah).call(this);
                "RTCPeerConnection"in window ? d.show(t.get("Multiplayer is experimental!") + "\n\n" + t.get("You may experience connectivity issues or other problems."), t.get("Continue"), ( () => {
                    (0,
                    R.GG)(this, Hc, new wc(n,t,s,l,h,o,c,d,( () => {
                        (0,
                        R.gn)(this, Hc, "f")?.dispose(),
                        (0,
                        R.GG)(this, Hc, null, "f"),
                        (0,
                        R.gn)(this, _c, "m", rh).call(this),
                        (0,
                        R.gn)(this, _c, "m", sh).call(this)
                    }
                    ),f), "f")
                }
                )) : d.show(t.get("WebRTC is not supported in this browser.") + "\n\n" + t.get("Please try another browser or device."), t.get("Ok"), ( () => {
                    (0,
                    R.gn)(this, _c, "m", rh).call(this),
                    (0,
                    R.gn)(this, _c, "m", sh).call(this)
                }
                ))
            }
            ));
            const T = document.createElement("p");
            T.textContent = t.get("Multiplayer"),
            E.appendChild(T),
            (0,
            R.gn)(this, Kc, "f").appendChild(E),
            (0,
            R.gn)(this, qc, "f").push(E);
            const k = document.createElement("button");
            k.className = "button button-image",
            k.innerHTML = '<img src="images/play.svg">',
            k.addEventListener("click", ( () => {
                n.playUIClick(),
                (0,
                R.gn)(this, _c, "m", ih).call(this),
                (0,
                R.gn)(this, _c, "m", ah).call(this),
                (0,
                R.gn)(this, Fc, "f").show()
            }
            ));
            const M = document.createElement("p");
            if (M.textContent = t.get("Play"),
            k.appendChild(M),
            (0,
            R.gn)(this, Kc, "f").appendChild(k),
            (0,
            R.gn)(this, qc, "f").push(k),
            window.electron) {
                const e = document.createElement("button");
                e.className = "button",
                e.innerHTML = '<img src="images/quit.svg">',
                e.appendChild(document.createTextNode(" " + t.get("Quit"))),
                e.addEventListener("click", ( () => {
                    n.playUIClick(),
                    window.electron?.quit()
                }
                )),
                (0,
                R.gn)(this, Qc, "f").appendChild(e),
                (0,
                R.gn)(this, Jc, "f").push(e)
            }
            if (Pt.Ko) {
                const e = document.createElement("button");
                e.className = "button",
                i.isFullscreen ? (e.innerHTML = '<img src="images/windowed.svg">',
                e.appendChild(document.createTextNode(" " + t.get("Windowed")))) : (e.innerHTML = '<img src="images/fullscreen.svg">',
                e.appendChild(document.createTextNode(" " + t.get("Fullscreen")))),
                null != (0,
                R.gn)(this, $c, "f") && i.removeFullscreenChangeListener((0,
                R.gn)(this, $c, "f")),
                i.addFullscreenChangeListener((0,
                R.GG)(this, $c, ( () => {
                    i.isFullscreen ? (e.innerHTML = '<img src="images/windowed.svg">',
                    e.appendChild(document.createTextNode(" " + t.get("Windowed")))) : (e.innerHTML = '<img src="images/fullscreen.svg">',
                    e.appendChild(document.createTextNode(" " + t.get("Fullscreen"))))
                }
                ), "f")),
                e.addEventListener("click", ( () => {
                    n.playUIClick(),
                    i.toggleFullscreen().catch((e => {
                        console.error(e)
                    }
                    ))
                }
                )),
                (0,
                R.gn)(this, Qc, "f").appendChild(e),
                (0,
                R.gn)(this, Jc, "f").push(e)
            }
            const _ = () => {
                (0,
                R.gn)(this, Xc, "f") ? (C.classList.remove("disabled"),
                C.innerHTML = '<img className="button-icon" src="images/music_on.svg">',
                C.appendChild(document.createTextNode(" " + t.get("Music: On")))) : (C.classList.add("disabled"),
                C.innerHTML = '<img className="button-icon" src="images/music_off.svg">',
                C.appendChild(document.createTextNode(" " + t.get("Music: Off"))))
            }
              , C = document.createElement("button");
            C.className = "button",
            C.addEventListener("click", ( () => {
                n.playUIClick(),
                (0,
                R.GG)(this, Xc, !(0,
                R.gn)(this, Xc, "f"), "f"),
                lh = (0,
                R.gn)(this, Xc, "f"),
                c.saveIsMusicEnabled((0,
                R.gn)(this, Xc, "f")),
                _()
            }
            )),
            (0,
            R.gn)(this, Qc, "f").appendChild(C),
            (0,
            R.gn)(this, Jc, "f").push(C),
            _();
            const P = o.getCurrentUserProfile();
            if (P.isVerifier) {
                const e = document.createElement("button");
                e.className = "button",
                e.textContent = "Verifier",
                e.addEventListener("click", ( () => {
                    n.playUIClick(),
                    m(P.token)
                }
                )),
                (0,
                R.gn)(this, Qc, "f").appendChild(e),
                (0,
                R.gn)(this, Jc, "f").push(e);
                const t = document.createElement("button");
                t.className = "button",
                t.textContent = "Admin",
                t.addEventListener("click", ( () => {
                    n.playUIClick(),
                    A(P.token)
                }
                )),
                (0,
                R.gn)(this, Qc, "f").appendChild(t),
                (0,
                R.gn)(this, Jc, "f").push(t)
            }
            /* Privacy Policy link removed for this build. */
        }
        ,
        nh = function(e) {
            (0,
            R.gn)(this, Dc, "f").innerHTML = "";
            const n = document.createElement("a");
            Pt.ml && (n.href = "../../opengameart.org/content/sci-fi-theme-1/index.html",
            n.target = "_blank"),
            n.textContent = 'OpenGameArt.org "Sci-fi Theme" by Maou (CC-BY 4.0)',
            (0,
            R.gn)(this, Dc, "f").appendChild(n)
        }
        ,
        ih = function() {
            (0,
            R.gn)(this, jc, "f")?.classList.add("hidden"),
            (0,
            R.gn)(this, Kc, "f").classList.add("hidden");
            for (const e of (0,
            R.gn)(this, qc, "f"))
                e.classList.remove("button-spawn");
            (0,
            R.gn)(this, Qc, "f").classList.add("hidden"),
            null != (0,
            R.gn)(this, Uc, "f") && ((0,
            R.gn)(this, Uc, "f").className = "hidden"),
            (0,
            R.gn)(this, Dc, "f").className = "hidden"
        }
        ,
        rh = function() {
            if (null != (0,
            R.gn)(this, jc, "f")) {
                (0,
                R.gn)(this, jc, "f").textContent = (0,
                R.gn)(this, Cc, "f").get("It seems like you are playing an unofficial version of {0}. For the most up-to-date version please visit the original source:", ["PolyTrack"]);
                const e = document.createElement("a");
                e.href = Oo(),
                e.textContent = Oo(),
                (0,
                R.gn)(this, jc, "f").appendChild(e),
                (0,
                R.gn)(this, jc, "f").classList.remove("hidden")
            }
            (0,
            R.gn)(this, Kc, "f").classList.remove("hidden"),
            (0,
            R.gn)(this, Qc, "f").classList.remove("hidden"),
            null != (0,
            R.gn)(this, Uc, "f") && ((0,
            R.gn)(this, Uc, "f").className = "discord-link"),
            (0,
            R.gn)(this, Dc, "f").className = "info"
        }
        ,
        ah = function() {
            (0,
            R.gn)(this, zc, "f").className = "hidden"
        }
        ,
        sh = function() {
            (0,
            R.gn)(this, zc, "f").className = "logo"
        }
        ,
        oh = function() {
            const e = (0,
            R.gn)(this, Pc, "f").getBounds()
              , t = new C.I9Y((e.min.x + (e.max.x - e.min.x) / 2) * Ti.A.partSize,(e.min.y + (e.max.y - e.min.y) / 2) * Ti.A.partSize);
            (0,
            R.gn)(this, Yc, "f").position.set(t.x + 250 * Math.cos((0,
            R.gn)(this, Zc, "f")), 100, t.y - 250 * Math.sin((0,
            R.gn)(this, Zc, "f"))),
            (0,
            R.gn)(this, Yc, "f").rotation.y = (0,
            R.gn)(this, Zc, "f") + Math.PI / 2
        }
        ;
        const ch = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A, v, y, w) {
                _c.add(this),
                Cc.set(this, void 0),
                Rc.set(this, void 0),
                Pc.set(this, void 0),
                Ic.set(this, void 0),
                Lc.set(this, void 0),
                Nc.set(this, void 0),
                zc.set(this, void 0),
                Uc.set(this, void 0),
                Dc.set(this, void 0),
                Bc.set(this, null),
                Gc.set(this, null),
                Fc.set(this, void 0),
                Oc.set(this, null),
                Wc.set(this, null),
                Vc.set(this, null),
                Hc.set(this, null),
                jc.set(this, void 0),
                Kc.set(this, void 0),
                qc.set(this, []),
                Qc.set(this, void 0),
                Jc.set(this, []),
                Xc.set(this, void 0),
                Yc.set(this, void 0),
                Zc.set(this, Math.random() * Math.PI * 2),
                $c.set(this, null),
                (0,
                R.GG)(this, Cc, e, "f"),
                (0,
                R.GG)(this, Rc, n, "f"),
                (0,
                R.GG)(this, Pc, r, "f"),
                (0,
                R.GG)(this, Ic, l, "f"),
                null == lh ? (0,
                R.GG)(this, Xc, lh = o.loadIsMusicEnabled(), "f") : (0,
                R.GG)(this, Xc, lh, "f");
                const b = document.getElementById("ui");
                if (null == b)
                    throw new Error("UI element not found");
                if ((0,
                R.GG)(this, Lc, b, "f"),
                (0,
                R.GG)(this, Nc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Nc, "f").className = "menu-ui",
                (0,
                R.gn)(this, Lc, "f").appendChild((0,
                R.gn)(this, Nc, "f")),
                (0,
                R.GG)(this, zc, document.createElement("img"), "f"),
                (0,
                R.gn)(this, zc, "f").className = "logo",
                i.hasLoaded() || ((0,
                R.gn)(this, zc, "f").classList.add("hidden"),
                (0,
                R.gn)(this, zc, "f").addEventListener("load", ( () => {
                    (0,
                    R.gn)(this, zc, "f").classList.remove("hidden")
                }
                ))),
                (0,
                R.gn)(this, zc, "f").src = "images/logo.svg",
                (0,
                R.gn)(this, Nc, "f").appendChild((0,
                R.gn)(this, zc, "f")),
                Fo() ? ((0,
                R.GG)(this, jc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, jc, "f").className = "warning-message",
                (0,
                R.gn)(this, Nc, "f").appendChild((0,
                R.gn)(this, jc, "f"))) : (0,
                R.GG)(this, jc, null, "f"),
                (0,
                R.GG)(this, Fc, (0,
                R.gn)(this, _c, "m", eh).call(this, e, t, s, h, a, u, o, c, A, v), "f"),
                !1) {
                    (0,
                    R.GG)(this, Uc, document.createElement("a"), "f"),
                    (0,
                    R.gn)(this, Uc, "f").className = "discord-link",
                    (0,
                    R.gn)(this, Uc, "f").href = "../../../discord/polytrack/index.html",
                    (0,
                    R.gn)(this, Uc, "f").target = "_blank",
                    (0,
                    R.gn)(this, Nc, "f").appendChild((0,
                    R.gn)(this, Uc, "f"));
                    const e = document.createElement("img");
                    i.hasLoaded() || (e.classList.add("hidden"),
                    e.addEventListener("load", ( () => {
                        e.classList.remove("hidden")
                    }
                    ))),
                    e.src = "images/discord.svg",
                    (0,
                    R.gn)(this, Uc, "f").appendChild(e)
                } else
                    (0,
                    R.GG)(this, Uc, null, "f");
                (0,
                R.GG)(this, Dc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Dc, "f").className = "info",
                (0,
                R.gn)(this, Nc, "f").appendChild((0,
                R.gn)(this, Dc, "f")),
                (0,
                R.gn)(this, _c, "m", nh).call(this, e),
                (0,
                R.GG)(this, Kc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Kc, "f").className = "main-buttons-container hidden",
                (0,
                R.gn)(this, Nc, "f").appendChild((0,
                R.gn)(this, Kc, "f")),
                (0,
                R.GG)(this, Qc, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Qc, "f").className = "button-bar",
                (0,
                R.gn)(this, Nc, "f").appendChild((0,
                R.gn)(this, Qc, "f")),
                (0,
                R.gn)(this, _c, "m", th).call(this, e, t, n, d, r, h, a, s, o, c, u, g, m, A, v, y, w),
                i.hasLoaded() ? (0,
                R.gn)(this, _c, "m", rh).call(this) : ((0,
                R.gn)(this, Nc, "f").classList.add("loading-screen"),
                (0,
                R.GG)(this, Bc, new bs((0,
                R.gn)(this, Nc, "f"),e,i), "f"),
                i.addCompleteListener(( () => {
                    (0,
                    R.gn)(this, Nc, "f").classList.remove("loading-screen");
                    const n = (0,
                    R.gn)(this, Bc, "f");
                    n?.fadeOut(( () => {
                        n.dispose();
                        const i = () => {
                            (0,
                            R.gn)(this, Rc, "f").isUsingSoftwareRenderer ? u.show(e.get("Hardware acceleration is disabled. Performance may be reduced.") + "\n\n" + e.get("Please make sure hardware acceleration is enabled in your browser settings."), e.get("Ok"), ( () => {
                                (0,
                                R.gn)(this, _c, "m", sh).call(this),
                                (0,
                                R.gn)(this, _c, "m", rh).call(this)
                            }
                            )) : (0,
                            R.gn)(this, Ic, "f").shouldShowUpdatePopup() ? ((0,
                            R.gn)(this, _c, "m", ih).call(this),
                            (0,
                            R.gn)(this, _c, "m", ah).call(this),
                            (0,
                            R.GG)(this, Gc, new Mc((0,
                            R.gn)(this, Nc, "f"),t,e,( () => {
                                (0,
                                R.gn)(this, Gc, "f")?.dispose(),
                                (0,
                                R.GG)(this, Gc, null, "f"),
                                (0,
                                R.gn)(this, _c, "m", sh).call(this),
                                (0,
                                R.gn)(this, _c, "m", rh).call(this)
                            }
                            )), "f")) : ((0,
                            R.gn)(this, _c, "m", sh).call(this),
                            (0,
                            R.gn)(this, _c, "m", rh).call(this))
                        }
                        ;
                        ul ? c.determinismState == oo.Ok ? i() : c.determinismState == oo.AssetsFailed ? ((0,
                        R.gn)(this, _c, "m", ah).call(this),
                        u.show(e.get("Non-deterministic game assets found.") + " " + e.get("Some leaderboard features are disabled.") + "\n\n" + e.get("Please try clearing your browser cache."), e.get("Ok"), ( () => {
                            i()
                        }
                        ))) : ((0,
                        R.gn)(this, _c, "m", ah).call(this),
                        u.show(e.get("Computer determinism check failed.") + " " + e.get("Some leaderboard features are disabled.") + "\n\n" + e.get("Please try another browser or device."), e.get("Ok"), ( () => {
                            i()
                        }
                        ))) : u.showNoButtons(e.get("You already have another instance of PolyTrack open.") + "\n\n" + e.get("Please switch to that tab or window to continue."));
                        for (let e = 0; e < (0,
                        R.gn)(this, qc, "f").length; e++) {
                            const t = (0,
                            R.gn)(this, qc, "f")[e];
                            t.classList.add("button-spawn"),
                            t.style.animationDelay = (.3 + .1 * e).toString() + "s"
                        }
                    }
                    )),
                    (0,
                    R.GG)(this, Bc, null, "f")
                }
                ))),
                null != f ? ((0,
                R.gn)(this, _c, "m", ih).call(this),
                (0,
                R.gn)(this, _c, "m", ah).call(this),
                u.show(f, e.get("Ok"), ( () => {
                    p ? (0,
                    R.gn)(this, Fc, "f").show() : ((0,
                    R.gn)(this, _c, "m", rh).call(this),
                    (0,
                    R.gn)(this, _c, "m", sh).call(this))
                }
                ))) : p && ((0,
                R.gn)(this, _c, "m", ih).call(this),
                (0,
                R.gn)(this, _c, "m", ah).call(this),
                (0,
                R.gn)(this, Fc, "f").show()),
                (0,
                R.GG)(this, Yc, new C.ubm(70,1,.5,vt.A.maxViewDistance), "f"),
                n.scene.add((0,
                R.gn)(this, Yc, "f")),
                (0,
                R.gn)(this, _c, "m", oh).call(this)
            }
            dispose() {
                (0,
                R.gn)(this, Lc, "f").removeChild((0,
                R.gn)(this, Nc, "f")),
                (0,
                R.gn)(this, Fc, "f").dispose(),
                (0,
                R.gn)(this, Oc, "f")?.dispose(),
                (0,
                R.GG)(this, Oc, null, "f"),
                (0,
                R.gn)(this, Wc, "f")?.dispose(),
                (0,
                R.GG)(this, Wc, null, "f"),
                null != (0,
                R.gn)(this, $c, "f") && (0,
                R.gn)(this, Rc, "f").removeFullscreenChangeListener((0,
                R.gn)(this, $c, "f"))
            }
            get isMusicEnabled() {
                return (0,
                R.gn)(this, Xc, "f")
            }
            get camera() {
                return (0,
                R.gn)(this, Yc, "f")
            }
            update(e) {
                (0,
                R.GG)(this, Zc, (0,
                R.gn)(this, Zc, "f") + .05 * e, "f"),
                (0,
                R.gn)(this, _c, "m", oh).call(this)
            }
        }
        ;
        var hh, dh, uh, ph, fh, gh, mh, Ah, vh, yh, wh, bh, xh, Sh;
        dh = new WeakMap,
        uh = new WeakMap,
        ph = new WeakMap,
        fh = new WeakMap,
        gh = new WeakMap,
        mh = new WeakMap,
        Ah = new WeakMap,
        vh = new WeakMap,
        yh = new WeakMap,
        wh = new WeakMap,
        bh = new WeakMap,
        xh = new WeakMap,
        hh = new WeakSet,
        Sh = function() {
            const e = (0,
            R.gn)(this, gh, "f").getRandomOfficialTrackData();
            (0,
            R.gn)(this, uh, "f").loadTrackData(e),
            (0,
            R.gn)(this, uh, "f").generateMeshes(),
            (0,
            R.gn)(this, ph, "f").generateMountains((0,
            R.gn)(this, uh, "f").getBounds());
            let t = null;
            const n = e.getId()
              , i = (0,
            R.gn)(this, mh, "f").getRecord((0,
            R.gn)(this, wh, "f").profileSlot, n);
            if (null != i && (t = i.recording),
            null != t) {
                const n = (0,
                R.gn)(this, uh, "f").getStartTransform();
                if (null == n)
                    throw new Error("Start transform is null");
                (0,
                R.GG)(this, xh, new N.A((0,
                R.gn)(this, dh, "f"),n,t,null,(0,
                R.gn)(this, vh, "f"),(0,
                R.gn)(this, yh, "f"),(0,
                R.gn)(this, ph, "f"),(0,
                R.gn)(this, uh, "f"),e,(0,
                R.gn)(this, Ah, "f"),null), "f"),
                (0,
                R.gn)(this, xh, "f").audioVolume = 0,
                (0,
                R.gn)(this, xh, "f").start()
            }
        }
        ;
        const Eh = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u, p, f, g, m, A, v, y, w, b, x, S) {
                hh.add(this),
                dh.set(this, void 0),
                uh.set(this, void 0),
                ph.set(this, void 0),
                fh.set(this, void 0),
                gh.set(this, void 0),
                mh.set(this, void 0),
                Ah.set(this, void 0),
                vh.set(this, void 0),
                yh.set(this, void 0),
                wh.set(this, void 0),
                bh.set(this, void 0),
                xh.set(this, null),
                (0,
                R.GG)(this, dh, e, "f"),
                (0,
                R.GG)(this, uh, t, "f"),
                (0,
                R.GG)(this, ph, n, "f"),
                (0,
                R.GG)(this, fh, i, "f"),
                (0,
                R.GG)(this, gh, r, "f"),
                (0,
                R.GG)(this, mh, l, "f"),
                (0,
                R.GG)(this, Ah, p, "f"),
                (0,
                R.GG)(this, vh, c, "f"),
                (0,
                R.GG)(this, yh, h, "f"),
                (0,
                R.GG)(this, wh, o, "f"),
                (0,
                R.GG)(this, bh, new ch(a,h,c,g,t,o,l,d,u,f,r,p,s,m,A,v,y,w,b,x,S), "f"),
                c.setCamera((0,
                R.gn)(this, bh, "f").camera),
                g.hasLoaded() ? (0,
                R.gn)(this, hh, "m", Sh).call(this) : g.addCompleteListener(( () => {
                    (0,
                    R.gn)(this, hh, "m", Sh).call(this)
                }
                ))
            }
            dispose() {
                (0,
                R.gn)(this, xh, "f")?.dispose(),
                (0,
                R.gn)(this, bh, "f").dispose(),
                (0,
                R.gn)(this, uh, "f").clear(),
                (0,
                R.gn)(this, ph, "f").clearMountains()
            }
            update(e) {
                (0,
                R.gn)(this, xh, "f")?.update(e),
                (0,
                R.gn)(this, bh, "f").update(e),
                (0,
                R.gn)(this, ph, "f").update((0,
                R.gn)(this, uh, "f")),
                (0,
                R.gn)(this, fh, "f").update(e, (0,
                R.gn)(this, vh, "f").camera, (0,
                R.gn)(this, uh, "f").sunDirection),
                (0,
                R.gn)(this, yh, "f").update(e, (0,
                R.gn)(this, bh, "f").isMusicEnabled, (0,
                R.gn)(this, vh, "f")),
                (0,
                R.gn)(this, vh, "f").update((0,
                R.gn)(this, uh, "f").sunDirection)
            }
        }
        ;
        var Th = i(7818)
          , kh = {};
        kh.styleTagTransform = u(),
        kh.setAttributes = l(),
        kh.insert = s().bind(null, "head"),
        kh.domAPI = r(),
        kh.insertStyleElement = h();
        t()(Th.A, kh);
        Th.A && Th.A.locals && Th.A.locals;
        var Mh, _h, Ch, Rh, Ph, Ih, Lh, Nh, zh, Uh, Dh, Bh, Gh;
        _h = new WeakMap,
        Ch = new WeakMap,
        Rh = new WeakMap,
        Ph = new WeakMap,
        Ih = new WeakMap,
        Lh = new WeakMap,
        Nh = new WeakMap,
        zh = new WeakMap,
        Uh = new WeakMap,
        Mh = new WeakSet,
        Dh = function() {
            null == (0,
            R.gn)(this, Uh, "f") && window.addEventListener("keydown", (0,
            R.GG)(this, Uh, (e => {
                this.isOpen && ("Escape" == e.code ? (null != (0,
                R.gn)(this, Nh, "f") && (0,
                R.gn)(this, Nh, "f").call(this),
                this.hide(),
                e.stopImmediatePropagation(),
                e.preventDefault()) : "Enter" == e.code && (null != (0,
                R.gn)(this, zh, "f") && (0,
                R.gn)(this, zh, "f").call(this),
                this.hide(),
                e.stopImmediatePropagation(),
                e.preventDefault()))
            }
            ), "f"))
        }
        ,
        Bh = function() {
            null != (0,
            R.gn)(this, Uh, "f") && (window.removeEventListener("keydown", (0,
            R.gn)(this, Uh, "f")),
            (0,
            R.GG)(this, Uh, null, "f"))
        }
        ,
        Gh = function() {
            const e = Math.max(.01, Math.min(window.innerWidth, 1.4375 * window.innerHeight) / 1150);
            (0,
            R.gn)(this, Rh, "f").style.transform = e < 1 ? "scale(" + e.toString() + ")" : ""
        }
        ;
        const Fh = class {
            constructor(e) {
                Mh.add(this),
                _h.set(this, null),
                Ch.set(this, void 0),
                Rh.set(this, void 0),
                Ph.set(this, void 0),
                Ih.set(this, void 0),
                Lh.set(this, void 0),
                Nh.set(this, null),
                zh.set(this, null),
                Uh.set(this, null),
                (0,
                R.GG)(this, Ch, document.createElement("dialog"), "f"),
                (0,
                R.gn)(this, Ch, "f").className = "hidden",
                document.body.appendChild((0,
                R.gn)(this, Ch, "f")),
                (0,
                R.GG)(this, Rh, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ch, "f").appendChild((0,
                R.gn)(this, Rh, "f")),
                (0,
                R.GG)(this, Ph, document.createElement("p"), "f"),
                (0,
                R.gn)(this, Rh, "f").appendChild((0,
                R.gn)(this, Ph, "f")),
                (0,
                R.GG)(this, Ih, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Ih, "f").className = "button",
                (0,
                R.gn)(this, Ih, "f").addEventListener("click", ( () => {
                    e.playUIClick();
                    const t = (0,
                    R.gn)(this, Nh, "f");
                    this.hide(),
                    null != t && t()
                }
                )),
                (0,
                R.gn)(this, Rh, "f").appendChild((0,
                R.gn)(this, Ih, "f")),
                (0,
                R.GG)(this, Lh, document.createElement("button"), "f"),
                (0,
                R.gn)(this, Lh, "f").className = "button",
                (0,
                R.gn)(this, Lh, "f").addEventListener("click", ( () => {
                    e.playUIClick();
                    const t = (0,
                    R.gn)(this, zh, "f");
                    this.hide(),
                    null != t && t()
                }
                )),
                (0,
                R.gn)(this, Rh, "f").appendChild((0,
                R.gn)(this, Lh, "f")),
                window.addEventListener("resize", ( () => {
                    (0,
                    R.gn)(this, Mh, "m", Gh).call(this)
                }
                )),
                (0,
                R.gn)(this, Mh, "m", Gh).call(this)
            }
            get isOpen() {
                return null != (0,
                R.gn)(this, _h, "f")
            }
            show(e, t, n) {
                (0,
                R.GG)(this, _h, "message", "f"),
                (0,
                R.gn)(this, Ch, "f").className = "message-box-ui message",
                (0,
                R.gn)(this, Ch, "f").showModal(),
                (0,
                R.gn)(this, Ph, "f").textContent = e,
                (0,
                R.gn)(this, Ih, "f").textContent = "",
                (0,
                R.gn)(this, Lh, "f").textContent = t,
                (0,
                R.gn)(this, Ih, "f").blur(),
                (0,
                R.gn)(this, Lh, "f").blur(),
                (0,
                R.GG)(this, Nh, n, "f"),
                (0,
                R.GG)(this, zh, n, "f"),
                (0,
                R.gn)(this, Mh, "m", Dh).call(this)
            }
            showConfirm(e, t, n, i, r) {
                (0,
                R.GG)(this, _h, "confirm", "f"),
                (0,
                R.gn)(this, Ch, "f").className = "message-box-ui confirm",
                (0,
                R.gn)(this, Ch, "f").showModal(),
                (0,
                R.gn)(this, Ph, "f").textContent = e,
                (0,
                R.gn)(this, Ih, "f").textContent = t,
                (0,
                R.gn)(this, Lh, "f").textContent = n,
                (0,
                R.gn)(this, Ih, "f").blur(),
                (0,
                R.gn)(this, Lh, "f").blur(),
                (0,
                R.GG)(this, Nh, i, "f"),
                (0,
                R.GG)(this, zh, r, "f"),
                (0,
                R.gn)(this, Mh, "m", Dh).call(this)
            }
            showNoButtons(e) {
                (0,
                R.GG)(this, _h, "no-buttons", "f"),
                (0,
                R.gn)(this, Ch, "f").className = "message-box-ui no-buttons",
                (0,
                R.gn)(this, Ch, "f").showModal(),
                (0,
                R.gn)(this, Ph, "f").textContent = e,
                (0,
                R.gn)(this, Ih, "f").textContent = "",
                (0,
                R.gn)(this, Lh, "f").textContent = "",
                (0,
                R.gn)(this, Ih, "f").blur(),
                (0,
                R.gn)(this, Lh, "f").blur(),
                (0,
                R.GG)(this, Nh, null, "f"),
                (0,
                R.GG)(this, zh, null, "f"),
                (0,
                R.gn)(this, Mh, "m", Dh).call(this)
            }
            hide() {
                (0,
                R.GG)(this, _h, null, "f"),
                (0,
                R.gn)(this, Ch, "f").className = "hidden",
                (0,
                R.gn)(this, Ch, "f").close(),
                (0,
                R.gn)(this, Ph, "f").textContent = "",
                (0,
                R.gn)(this, Ih, "f").textContent = "",
                (0,
                R.gn)(this, Lh, "f").textContent = "",
                (0,
                R.GG)(this, Nh, null, "f"),
                (0,
                R.GG)(this, zh, null, "f"),
                (0,
                R.gn)(this, Mh, "m", Bh).call(this)
            }
        }
        ;
        var Oh, Wh, Vh, Hh;
        Oh = new WeakMap,
        Wh = new WeakMap,
        Vh = new WeakMap,
        Hh = new WeakMap;
        const jh = class {
            constructor() {
                Oh.set(this, 0),
                Wh.set(this, 0),
                Vh.set(this, []),
                Hh.set(this, [])
            }
            hasLoaded() {
                return (0,
                R.gn)(this, Wh, "f") == (0,
                R.gn)(this, Oh, "f")
            }
            getProgress() {
                return (0,
                R.gn)(this, Wh, "f") / (0,
                R.gn)(this, Oh, "f")
            }
            addResource() {
                var e;
                if (0 != (0,
                R.gn)(this, Oh, "f") && this.hasLoaded())
                    throw new Error("Cannot add resources after loading is complete");
                (0,
                R.GG)(this, Oh, (e = (0,
                R.gn)(this, Oh, "f"),
                ++e), "f")
            }
            loadedResource() {
                var e;
                (0,
                R.GG)(this, Wh, (e = (0,
                R.gn)(this, Wh, "f"),
                ++e), "f");
                for (const e of (0,
                R.gn)(this, Vh, "f"))
                    e(this.getProgress());
                if (this.hasLoaded())
                    for (const e of (0,
                    R.gn)(this, Hh, "f"))
                        e()
            }
            addProgressListener(e) {
                (0,
                R.gn)(this, Vh, "f").push(e)
            }
            addCompleteListener(e) {
                (0,
                R.gn)(this, Hh, "f").push(e)
            }
            preloadImage(e) {
                this.addResource();
                const t = new Image;
                t.addEventListener("load", ( () => {
                    this.loadedResource()
                }
                )),
                t.addEventListener("error", ( () => {
                    console.error("Failed to preload image: " + e)
                }
                )),
                t.src = e
            }
        }
        ;
        var Kh, qh, Qh, Jh, Xh, Yh, Zh, $h, ed, td = i(1066);
        qh = new WeakMap,
        Qh = new WeakMap,
        Jh = new WeakMap,
        Xh = new WeakMap,
        Yh = new WeakMap,
        Zh = new WeakMap,
        Kh = new WeakSet,
        $h = async function(e, t, n, i, r) {
            if ((0,
            R.gn)(this, Jh, "f").determinismState != oo.Ok)
                return null;
            const a = (0,
            R.gn)(this, Xh, "f").getUserProfile(e);
            if (null == a)
                return null;
            const s = e.toString() + "_" + t
              , o = ((0,
            R.gn)(this, Yh, "f").get(s) ?? 0) + 1;
            (0,
            R.gn)(this, Yh, "f").set(s, o);
            const {uploadId: l, positionChange: c} = await (0,
            R.gn)(this, Jh, "f").submitLeaderboard(a.token, a.nickname, a.countryCode, a.carStyle, t, n, i, r);
            return (0,
            R.gn)(this, Yh, "f").get(s) == o && (0,
            R.gn)(this, Xh, "f").getUserProfile(e)?.token == a.token && (0,
            R.gn)(this, qh, "f").saveRecord(e, a.tokenHash, t, l, i, r, (0,
            R.gn)(this, Jh, "f").determinismState),
            c
        }
        ,
        ed = async function(e, t, n) {
            if ((0,
            R.gn)(this, Jh, "f").determinismState != oo.Ok)
                return;
            const i = (0,
            R.gn)(this, Xh, "f").getUserProfile(e);
            if (null == i)
                return;
            const r = e.toString() + "_" + t
              , a = ((0,
            R.gn)(this, Yh, "f").get(r) ?? 0) + 1;
            (0,
            R.gn)(this, Yh, "f").set(r, a);
            const s = await (0,
            R.gn)(this, Jh, "f").getRecordings([n]);
            if (s.length < 1 || null == s[0])
                throw new Error("Record not found");
            const o = s[0];
            if ((0,
            R.gn)(this, Yh, "f").get(r) == a && (0,
            R.gn)(this, Xh, "f").getUserProfile(e)?.token == i.token) {
                const r = this.getRecordTime(e, t);
                if (null == r || o.time.lessThan(r)) {
                    (0,
                    R.gn)(this, qh, "f").saveRecord(e, i.tokenHash, t, n, o.time, o.recording, (0,
                    R.gn)(this, Jh, "f").determinismState);
                    for (const e of (0,
                    R.gn)(this, Zh, "f"))
                        e()
                }
            }
        }
        ;
        const nd = class {
            constructor(e, t, n, i) {
                Kh.add(this),
                qh.set(this, void 0),
                Qh.set(this, void 0),
                Jh.set(this, void 0),
                Xh.set(this, void 0),
                Yh.set(this, new Map),
                Zh.set(this, []),
                (0,
                R.GG)(this, qh, e, "f"),
                (0,
                R.GG)(this, Qh, t, "f"),
                (0,
                R.GG)(this, Jh, n, "f"),
                (0,
                R.GG)(this, Xh, i, "f")
            }
            addRecordChangedCallback(e) {
                (0,
                R.gn)(this, Zh, "f").push(e)
            }
            removeRecordChangedCallback(e) {
                const t = (0,
                R.gn)(this, Zh, "f").indexOf(e);
                t >= 0 && (0,
                R.gn)(this, Zh, "f").splice(t, 1)
            }
            async setRecord(e, t, n, i, r) {
                const a = (0,
                R.gn)(this, Xh, "f").getUserProfile(e);
                if (null == a)
                    return null;
                (0,
                R.gn)(this, qh, "f").saveRecord(e, a.tokenHash, t, null, i, r, (0,
                R.gn)(this, Jh, "f").determinismState);
                const s = await (0,
                R.gn)(this, Kh, "m", $h).call(this, e, t, n, i, r).catch((e => (console.warn(e),
                null)));
                for (const e of (0,
                R.gn)(this, Zh, "f"))
                    e();
                return s
            }
            async syncRecord(e, t, n) {
                if ((0,
                R.gn)(this, Jh, "f").determinismState != oo.Ok)
                    return null;
                const i = this.getRecord(e, t);
                return null != i && (null == n || i.uploadId != n.id && i.time.lessThan(n.time)) ? (await (0,
                R.gn)(this, Kh, "m", $h).call(this, e, t, null, i.time, i.recording),
                "Upload") : null != n && (null == i || i.uploadId != n.id && n.time.lessThan(i.time)) ? (await (0,
                R.gn)(this, Kh, "m", ed).call(this, e, t, n.id),
                "Download") : null
            }
            cleanUpRecords() {
                const e = (0,
                R.gn)(this, qh, "f").loadRecordTracks();
                for (const t of e)
                    (0,
                    R.gn)(this, Qh, "f").isOfficialTrack(t) || (0,
                    R.gn)(this, Qh, "f").isCommunityTrack(t) || (0,
                    R.gn)(this, Qh, "f").isCustomTrack(t) || (0,
                    R.gn)(this, qh, "f").deleteAllRecordsForTrack(t)
            }
            getRecordTime(e, t) {
                const n = this.getRecord(e, t);
                return null == n ? null : n.time
            }
            getRecord(e, t) {
                const n = (0,
                R.gn)(this, Xh, "f").getUserProfile(e);
                return null == n ? null : (0,
                R.gn)(this, qh, "f").loadRecord(e, n.tokenHash, t, (0,
                R.gn)(this, Jh, "f").determinismState)
            }
        }
        ;
        var id, rd, ad, sd, od, ld, cd, hd, dd, ud, pd, fd;
        rd = new WeakMap,
        ad = new WeakMap,
        sd = new WeakMap,
        od = new WeakMap,
        ld = new WeakMap,
        cd = new WeakMap,
        id = new WeakSet,
        hd = function(e, t) {
            return (0,
            R.gn)(this, id, "m", dd).call(this, "tracks/official/" + e, t)
        }
        ,
        dd = function(e, t) {
            return t.addResource(),
            new Promise(( (n, i) => {
                const r = new XMLHttpRequest;
                r.overrideMimeType("text/plain"),
                r.onreadystatechange = () => {
                    if (4 == r.readyState)
                        if (200 == r.status) {
                            t.loadedResource();
                            const e = gl.A.fromExportString(r.responseText);
                            if (null == e)
                                throw new Error("Failed to load bundled track");
                            const {trackMetadata: i, trackData: a} = e;
                            n({
                                id: a.getId(),
                                trackMetadata: i,
                                trackData: a,
                                thumbnail: a.createThumbnail(),
                                saveTime: null
                            })
                        } else
                            i(new Error("Failed to load bundled track"))
                }
                ,
                r.open("GET", e, !0),
                r.send()
            }
            ))
        }
        ,
        ud = function(e) {
            return new Promise(( (t, n) => {
                const i = new XMLHttpRequest;
                i.overrideMimeType("text/plain"),
                i.onreadystatechange = () => {
                    if (4 == i.readyState)
                        if (200 == i.status) {
                            const e = gl.A.fromExportString(i.responseText);
                            if (null == e)
                                throw new Tr.A;
                            const {trackMetadata: n, trackData: r} = e;
                            t({
                                trackMetadata: n,
                                trackData: r
                            })
                        } else
                            n(new Tr.A)
                }
                ,
                i.open("GET", e, !0),
                i.send()
            }
            ))
        }
        ,
        pd = function(e) {
            return new Promise((t => {
                setTimeout(( () => {
                    const n = (0,
                    R.gn)(this, ld, "f").loadCustomTrack(e);
                    if (null != n) {
                        const {trackMetadata: e, trackData: i, saveTime: r} = n
                          , a = {
                            id: i.getId(),
                            trackMetadata: e,
                            trackData: i,
                            thumbnail: i.createThumbnail(),
                            saveTime: r
                        };
                        t(a)
                    } else
                        t(null)
                }
                ))
            }
            ))
        }
        ,
        fd = function() {
            for (const e of (0,
            R.gn)(this, cd, "f"))
                e()
        }
        ;
        const gd = class {
            constructor(e, t) {
                id.add(this),
                rd.set(this, []),
                ad.set(this, []),
                sd.set(this, []),
                od.set(this, new Map),
                ld.set(this, void 0),
                cd.set(this, []),
                (0,
                R.GG)(this, ld, t, "f");
                Promise.all(["summer1.track", "summer2.track", "summer3.track", "summer4.track", "summer5.track", "summer6.track", "summer7.track", "winter1.track", "winter2.track", "winter3.track", "winter4.track", "winter5.track", "desert1.track", "desert2.track", "desert3.track", "desert4.track", "desert5.track"].map((t => (0,
                R.gn)(this, id, "m", hd).call(this, t, e)))).then((e => {
                    (0,
                    R.GG)(this, rd, e, "f")
                }
                )).catch((e => {
                    console.error(e)
                }
                )),
                (0,
                R.GG)(this, ad, [{
                    id: "6f341a64070d52a00435604bfe79ee1f6d736c83511c426a1637e21d32e48c15",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Zealot",
                        author: "BonnieBeans",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/zealot.track",
                    thumbnail: null
                }, {
                    id: "8cf0dc61eeb567dd9712716cb25ff7354d79057d5d73475627978b04a73079b2",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Shrouded Oasis",
                        author: "Hiksi & BonnieBeans",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/shrouded_oasis.track",
                    thumbnail: null
                }, {
                    id: "5cb2632887d30339e5f1a0d8c153446a2bca80a01c12937dc0d873d2f8fe25d9",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Cogware",
                        author: "AZiggy",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/cogware.track",
                    thumbnail: null
                }, {
                    id: "5108622d3970e815bbb6e1879322c9c10f0f18827d6842c30de6a651b28435b0",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Land of the Rising Sun",
                        author: "2xi, imracer, KoiPoi",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/land_of_the_rising_sun.track",
                    thumbnail: null
                }, {
                    id: "a2a28e4270745b6a7cc3d53cff44dc6d9322c377cda6dd79e91dcb51d83574f4",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Midas Metropolis",
                        author: "BonnieBeans",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/midas_metropolis.track",
                    thumbnail: null
                }, {
                    id: "fde3e9eb977892f7cd73d5c91c7a0e8c45ecd08fba57ec375fac7d344fd739a8",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Frozen In Time",
                        author: "BonnieBeans",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/frozen_in_time.track",
                    thumbnail: null
                }, {
                    id: "35ae4ced2b8636d0e66bb00555c68256e2ab305086b409afc7033d426aa70f31",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Winterfell",
                        author: "Forty Shovelfish",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/winterfell.track",
                    thumbnail: null
                }, {
                    id: "1511c30262cfdb843bf2cdaa24410f206e7fc8dc2d9adc3086e76c03588c407d",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Launch Control",
                        author: "BonnieBeans",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/launch_control.track",
                    thumbnail: null
                }, {
                    id: "b78ca6b505a2b5b1918e04136386cc3e6d42a0a9445c8ad81fb284381e44cbce",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Fractured Shore",
                        author: "2xi & imracer",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/fractured_shore.track",
                    thumbnail: null
                }, {
                    id: "dd08999f8caa748f757602cfc12c6d3e8ac1098322f59d5ccaa152861c426ecd",
                    group: "0.5.2",
                    trackMetadata: {
                        name: "Starry Tropics",
                        author: "Leaf, Forty, WB",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/starry_tropics.track",
                    thumbnail: null
                }, {
                    id: "9cebf16e89693917ce7b10efd2c520336da5011550d7dbd413cfddcce79bdfd1",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "Anubis",
                        author: "paldeanp",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/anubis.track",
                    thumbnail: null
                }, {
                    id: "984bb1361ed45e000120aa0199f6f1ef21d5f6482f76c948df369758ac47f7e8",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "Flying Dreams",
                        author: "Forty, Shovelfish, Hero",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/flying_dreams.track",
                    thumbnail: null
                }, {
                    id: "18b69f54f119cfb2867abded9a1574f0799a750ef94aa744d9ec8ef6b4d565ae",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "Ghost City",
                        author: "Nexus",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/ghost_city.track",
                    thumbnail: null
                }, {
                    id: "196c21056a3fee8c5ffe4ada12a3f0a16d33653c329f8f3ee5b12bc8ab60e7bf",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "Joenail Jones",
                        author: "Tacopanda",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/joenail_jones.track",
                    thumbnail: null
                }, {
                    id: "5ea46b3ae268a0196dcc59dabe88926400b56e29814658bfed06a284f837cefd",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "MOS ESPA",
                        author: "Tacopanda, Arkangel",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/mos_espa.track",
                    thumbnail: null
                }, {
                    id: "3555bcdff2897c3efe2f4fb0274a26de6a771cab2071a23cdd46729e426169ae",
                    group: "0.5.1",
                    trackMetadata: {
                        name: "Natsuj",
                        author: " ",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/natsujo.track",
                    thumbnail: null
                }, {
                    id: "27769dfe4d9e874a4ee6ba2f9f6c073462fcaf38207902be769e1039c3fe589e",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Arabica",
                        author: "Forty",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/arabica.track",
                    thumbnail: null
                }, {
                    id: "5abca81bb3d11673df57a855dc625d4d5a36bab44c5ba254830c50499a133617",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Hyperion's Sanctuary",
                        author: "AZiggy & ChickenHotel813",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/hyperions_sanctuary.track",
                    thumbnail: null
                }, {
                    id: "3f1ba0fb066b927cc248c027e4c9441572bafc19777b96b718a79cb8352f07b4",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Winter Hollow",
                        author: "Lotus",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/winter_hollow.track",
                    thumbnail: null
                }, {
                    id: "e4fbe837eb36d12902fedbabb2e94b58e396b84112cdaafdd3dfbf8ba2792cff",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Clay temples",
                        author: "HeroHunter",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/clay_temples.track",
                    thumbnail: null
                }, {
                    id: "cf35f7dd07551566a80246b7b0d0b1a67b498f2b2961d4e97f315a50416f56f1",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Las Calles",
                        author: "Shovelfish, Tacopanda, Forty",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/las_calles.track",
                    thumbnail: null
                }, {
                    id: "e5ebb09e9dda02b2825f74bd72aa088317d71ef00eab4eb8c65daeeb365e6908",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "DESERT STALLION",
                        author: "ARKANGEL",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/desert_stallion.track",
                    thumbnail: null
                }, {
                    id: "2f63f195d9adfba060ebeb49d7c159230923a94b3ad580442e0c678cb51cbf84",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Last Remnant",
                        author: "cwcinc",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/last_remnant.track",
                    thumbnail: null
                }, {
                    id: "fbb937cb7a1a581292e3676fedcfea5e5eb49d09e2a4d154fe27542be3077b6e",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "lu muvimento",
                        author: "Noia",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/lu_muvimento.track",
                    thumbnail: null
                }, {
                    id: "948464b463691149b165b794925f3de09810d758a441546925dffc3611f1d757",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "90*RESET",
                        author: "Haru-PT",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/90_reset.track",
                    thumbnail: null
                }, {
                    id: "00d39d287da724b1c6b69eab85379f44ee4ae2fc0876343666b944cf4c3156e5",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Re : Akina",
                        author: "Marcus",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/re_akina.track",
                    thumbnail: null
                }, {
                    id: "fe72c501e18caa8e3160b3ff76cb7670cfb8845b1ec116c2e694896c44f93565",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Sandline Ultimatum",
                        author: "Haru-PT",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/sandline_ultimatum.track",
                    thumbnail: null
                }, {
                    id: "e14ecd4a2936f9188a4e260ed6535a890180a7c958c709d7a199e683d857abcc",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Malformations",
                        author: "HeroHunter, Lotus",
                        lastModified: null
                    },
                    environment: hl.A.Desert,
                    trackUrl: "tracks/community/malformations.track",
                    thumbnail: null
                }, {
                    id: "acefe12fd25200734664bf913e6da49e961f08b846bb3f8577f2a561ba979e94",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "Snow Park",
                        author: "Vlady87",
                        lastModified: null
                    },
                    environment: hl.A.Winter,
                    trackUrl: "tracks/community/snow_park.track",
                    thumbnail: null
                }, {
                    id: "d03249a253d1e6bd9098bd8ddc23439ac57c2f6ee5e592fec0e75f3a9f430380",
                    group: "0.5.0",
                    trackMetadata: {
                        name: "concrete jungle",
                        author: "HeroHunter",
                        lastModified: null
                    },
                    environment: hl.A.Summer,
                    trackUrl: "tracks/community/concrete_jungle.track",
                    thumbnail: null
                }].map((e => ({
                    id: e.id,
                    group: e.group,
                    trackMetadata: e.trackMetadata,
                    environment: e.environment,
                    trackData: async () => {
                        const t = (0,
                        R.gn)(this, od, "f").get(e.id);
                        if (null != t)
                            return t.then(( ({trackData: e}) => e));
                        const n = (0,
                        R.gn)(this, id, "m", ud).call(this, e.trackUrl);
                        (0,
                        R.gn)(this, od, "f").set(e.id, n);
                        try {
                            const {trackMetadata: i, trackData: r} = await n;
                            if (Pt.EM) {
                                const a = r.getId();
                                if (a != e.id)
                                    throw new Error("Community track ID mismatch: " + a);
                                if (i.name != e.trackMetadata.name)
                                    throw new Error("Community track name mismatch: " + i.name);
                                if (i.author != e.trackMetadata.author)
                                    throw new Error("Community track author mismatch: " + (i.author ?? "null"));
                                if (i.lastModified?.getTime() != e.trackMetadata.lastModified?.getTime())
                                    throw new Error("Community track last modified mismatch: " + (i.lastModified?.toISOString() ?? "null"));
                                if (r.environment != e.environment)
                                    throw new Error("Community track environment mismatch: " + hl.A[e.environment]);
                                function s() {
                                    const e = r.createThumbnail()
                                      , t = document.createElement("canvas");
                                    t.width = e.width,
                                    t.height = e.height;
                                    const n = t.getContext("2d");
                                    if (null == n)
                                        throw new Error("Failed to create canvas context for thumbnail verification");
                                    n.drawImage(e, 0, 0);
                                    const i = document.createElement("canvas");
                                    i.width = o.width,
                                    i.height = o.height;
                                    const a = i.getContext("2d");
                                    if (null == a)
                                        throw new Error("Failed to create canvas context for thumbnail verification");
                                    a.drawImage(o, 0, 0);
                                    try {
                                        const e = n.getImageData(0, 0, t.width, t.height).data
                                          , r = a.getImageData(0, 0, i.width, i.height).data;
                                        if (e.length != r.length)
                                            throw new Error("Community track thumbnail size mismatch");
                                        for (let t = 0; t < e.length; t++)
                                            if (e[t] != r[t])
                                                throw new Error("Community track thumbnail data mismatch")
                                    } catch (t) {
                                        throw console.log("Community track generated thumbnail: " + e.toDataURL()),
                                        t
                                    }
                                }
                                if (null == e.thumbnail || "null" == e.thumbnail)
                                    return r;
                                const o = new Image;
                                o.src = e.thumbnail,
                                o.complete ? s() : o.addEventListener("load", ( () => {
                                    s()
                                }
                                ))
                            }
                            return r
                        } catch (l) {
                            throw (0,
                            R.gn)(this, od, "f").delete(e.id),
                            l
                        }
                    }
                    ,
                    thumbnail: e.thumbnail,
                    saveTime: null
                }))), "f");
                try {
                    const e = "undefined" != typeof globalThis ? globalThis : window
                      , t = ["tracks/community/asguardia.track", "tracks/community/opal_place_ii.track", "tracks/community/Nurenburgring_GP.track", "tracks/community/alpine_descent.track", "tracks/community/japan.track", "tracks/community/natures_sanctuary.track", "tracks/community/oxygen_not_included.track", "tracks/community/pavlova_dip.track"];
                    Promise.all(t.map((t => (0,
                    R.gn)(this, id, "m", ud).call(this, t).then((n => ({
                        trackUrl: t,
                        trackMetadata: n.trackMetadata,
                        trackData: n.trackData
                    })))))).then((t => {
                        for (const n of t) {
                            const t = n.trackData.getId()
                              , i = {
                                id: t,
                                group: "0.5.2",
                                trackMetadata: n.trackMetadata,
                                environment: n.trackData.environment,
                                trackData: async () => n.trackData,
                                thumbnail: null,
                                saveTime: null
                            };
                            (0,
                            R.gn)(this, ad, "f").some((e => e.id == t)) || (0,
                            R.gn)(this, ad, "f").push(i);
                            try {
                                const t = n.trackData.createThumbnail();
                                if (t instanceof HTMLCanvasElement) {
                                    e.__ptThumbCanvasCache instanceof Map || (e.__ptThumbCanvasCache = new Map);
                                    const n = document.createElement("canvas");
                                    n.width = t.width,
                                    n.height = t.height;
                                    const r = n.getContext("2d");
                                    null != r && r.drawImage(t, 0, 0),
                                    e.__ptThumbCanvasCache.set(i.id, n),
                                    i.thumbnail = n;
                                    try {
                                        const t = n.toDataURL();
                                        "string" == typeof t && t.startsWith("data:image/") && (e.__ptThumbUrlCache instanceof Map || (e.__ptThumbUrlCache = new Map),
                                        e.__ptThumbUrlCache.set(i.id, t),
                                        localStorage.setItem("pt_thumb_" + Pt.rE + "_" + i.id, t))
                                    } catch {}
                                }
                            } catch {}
                        }
                    }
                    )).catch((e => {
                        console.error(e)
                    }
                    ))
                } catch {}
                try {
                    const e = "undefined" != typeof globalThis ? globalThis : window;
                    e.__ptCommunityPreloadStarted || (e.__ptCommunityPreloadStarted = !0,
                    ( () => {
                        const t = (0,
                        R.gn)(this, ad, "f");
                        let n = 0;
                        const i = () => {
                            if (n >= t.length)
                                return;
                            const r = t[n++];
                            if (null == r || null == r.id)
                                return void a();
                            try {
                                const t = e.__ptThumbCanvasCache;
                                if (t instanceof Map) {
                                    const n = t.get(r.id);
                                    if (n instanceof HTMLCanvasElement)
                                        return r.thumbnail = n,
                                        void a()
                                }
                            } catch {}
                            r.trackData().then((t => {
                                try {
                                    const n = t.createThumbnail();
                                    if (!(n instanceof HTMLCanvasElement))
                                        return;
                                    e.__ptThumbCanvasCache instanceof Map || (e.__ptThumbCanvasCache = new Map);
                                    const i = document.createElement("canvas");
                                    i.width = n.width,
                                    i.height = n.height;
                                    const a = i.getContext("2d");
                                    null != a && a.drawImage(n, 0, 0),
                                    e.__ptThumbCanvasCache.set(r.id, i),
                                    r.thumbnail = i;
                                    try {
                                        const t = i.toDataURL();
                                        "string" == typeof t && t.startsWith("data:image/") && (e.__ptThumbUrlCache instanceof Map || (e.__ptThumbUrlCache = new Map),
                                        e.__ptThumbUrlCache.set(r.id, t),
                                        localStorage.setItem("pt_thumb_" + Pt.rE + "_" + r.id, t))
                                    } catch {}
                                } catch {}
                            }
                            )).catch(( () => {}
                            )).finally(( () => {
                                a()
                            }
                            ))
                        }
                          , a = () => {
                            "function" == typeof requestIdleCallback ? requestIdleCallback(i, {
                                timeout: 2e3
                            }) : setTimeout(i, 0)
                        }
                        ;
                        a()
                    }
                    )())
                } catch {}
                const n = (0,
                R.gn)(this, ld, "f").getAllCustomTrackNames();
                if (null != n) {
                    const e = [];
                    for (const t of n)
                        e.push((0,
                        R.gn)(this, id, "m", pd).call(this, t));
                    Promise.all(e).then((e => {
                        (0,
                        R.GG)(this, sd, e.filter((e => null != e)).sort(( (e, t) => (t.saveTime ?? -1 / 0) - (e.saveTime ?? -1 / 0))), "f")
                    }
                    )).catch((e => {
                        console.error(e)
                    }
                    ))
                }
            }
            saveCustomTrack(e, t) {
                const n = new Date;
                if ((0,
                R.gn)(this, ld, "f").saveCustomTrack(e, t, n)) {
                    const i = {
                        id: t.getId(),
                        trackMetadata: e,
                        trackData: t,
                        thumbnail: t.createThumbnail(),
                        saveTime: n.getTime()
                    }
                      , r = (0,
                    R.gn)(this, sd, "f").findIndex((t => t.trackMetadata.name == e.name));
                    return r >= 0 ? (0,
                    R.gn)(this, sd, "f")[r] = i : (0,
                    R.gn)(this, sd, "f").unshift(i),
                    (0,
                    R.gn)(this, id, "m", fd).call(this),
                    !0
                }
                return !1
            }
            deleteCustomTrack(e) {
                if ((0,
                R.gn)(this, ld, "f").deleteCustomTrack(e)) {
                    const t = (0,
                    R.gn)(this, sd, "f").findIndex((t => t.trackMetadata.name == e));
                    if (t >= 0) {
                        const e = (0,
                        R.gn)(this, sd, "f")[t];
                        (0,
                        R.gn)(this, ld, "f").deleteAllRecordsForTrack(e.id),
                        (0,
                        R.gn)(this, sd, "f").splice(t, 1)
                    }
                    return (0,
                    R.gn)(this, id, "m", fd).call(this),
                    !0
                }
                return !1
            }
            checkCustomTrackNameExists(e) {
                return (0,
                R.gn)(this, sd, "f").some((t => t.trackMetadata.name == e))
            }
            addCustomTracksChangedListener(e) {
                (0,
                R.gn)(this, cd, "f").push(e)
            }
            removeCustomTracksChangedListener(e) {
                const t = (0,
                R.gn)(this, cd, "f").indexOf(e);
                t >= 0 && (0,
                R.gn)(this, cd, "f").splice(t, 1)
            }
            isCommunityTracksEmpty() {
                return 0 == (0,
                R.gn)(this, ad, "f").length
            }
            isCustomTracksEmpty() {
                return 0 == (0,
                R.gn)(this, sd, "f").length
            }
            forEachTrack(e) {
                this.forEachOfficialTrack(( (t, n, i, r) => {
                    e(t, n, i.environment, ( () => Promise.resolve(i)), r)
                }
                )),
                this.forEachCommunityTrack(( (t, n, i, r, a, s) => {
                    e(t, i, r, a, s)
                }
                )),
                this.forEachCustomTrack(( (t, n, i, r) => {
                    e(t, n, i.environment, ( () => Promise.resolve(i)), r)
                }
                ))
            }
            forEachOfficialTrack(e) {
                for (const t of (0,
                R.gn)(this, rd, "f"))
                    e(t.id, t.trackMetadata, t.trackData, t.thumbnail)
            }
            forEachCommunityTrack(e) {
                for (const t of (0,
                R.gn)(this, ad, "f"))
                    e(t.id, t.group, t.trackMetadata, t.environment, t.trackData, t.thumbnail)
            }
            forEachCustomTrack(e) {
                for (const t of (0,
                R.gn)(this, sd, "f"))
                    e(t.id, t.trackMetadata, t.trackData, t.thumbnail)
            }
            getNextOfficialTrack(e) {
                const t = e.getId()
                  , n = (0,
                R.gn)(this, rd, "f").findIndex((e => e.id == t));
                if (n < 0)
                    return null;
                const i = n + 1;
                if (i >= (0,
                R.gn)(this, rd, "f").length)
                    return null;
                const r = (0,
                R.gn)(this, rd, "f")[i];
                return {
                    id: r.id,
                    trackMetadata: r.trackMetadata,
                    trackData: r.trackData,
                    trackCategory: "official"
                }
            }
            getRandomOfficialTrackData() {
                return (0,
                R.gn)(this, rd, "f")[Math.floor(Math.random() * (0,
                R.gn)(this, rd, "f").length)].trackData
            }
            getTrackByName(e) {
                const t = (0,
                R.gn)(this, rd, "f").find((t => t.trackMetadata.name == e));
                if (null != t)
                    return {
                        id: t.id,
                        trackMetadata: t.trackMetadata,
                        trackData: () => Promise.resolve(t.trackData),
                        trackCategory: "official"
                    };
                const n = (0,
                R.gn)(this, ad, "f").find((t => t.trackMetadata.name == e));
                if (null != n)
                    return {
                        id: n.id,
                        trackMetadata: n.trackMetadata,
                        trackData: n.trackData,
                        trackCategory: "community"
                    };
                const i = (0,
                R.gn)(this, sd, "f").find((t => t.trackMetadata.name == e));
                return null != i ? {
                    id: i.id,
                    trackMetadata: i.trackMetadata,
                    trackData: () => Promise.resolve(i.trackData),
                    trackCategory: "custom"
                } : null
            }
            isOfficialTrack(e) {
                return (0,
                R.gn)(this, rd, "f").some((t => t.id == e))
            }
            isCommunityTrack(e) {
                return (0,
                R.gn)(this, ad, "f").some((t => t.id == e))
            }
            isCustomTrack(e) {
                return (0,
                R.gn)(this, sd, "f").some((t => t.id == e))
            }
        }
        ;
        var md, Ad, vd, yd, wd, bd = i(1728), xd = i(1566), Sd = i(2203), Ed = i(1882), Td = i(4183), kd = i(8566);
        class Md {
            constructor() {
                md.add(this),
                Ad.set(this, new Map),
                vd.set(this, new Map)
            }
            async init(e, t) {
                const n = new ie.B
                  , i = new bd.Z;
                i.setDecoderPath("lib/draco/"),
                n.setDRACOLoader(i);
                const r = (a = ["models/blocks.glb", "models/pillar.glb", "models/planes.glb", "models/road.glb", "models/road_wide.glb", "models/signs.glb", "models/wall_track.glb"],
                Promise.all(a.map((e => {
                    return t = e,
                    new Promise((e => {
                        n.load(t, (t => {
                            e(t)
                        }
                        ))
                    }
                    ));
                    var t
                }
                ))));
                var a;
                const s = new C.G_z({
                    vertexColors: !0
                });
                e.addMaterial(s);
                const o = async e => {
                    if (t.addResource(),
                    (0,
                    R.gn)(this, Ad, "f").has(e.id))
                        throw new Error("Track part types have same Id");
                    const n = {
                        configuration: e,
                        colors: new Map(e.colors.map(( ({id: e}) => [e, null]))),
                        physicsShapeVertices: null
                    };
                    (0,
                    R.gn)(this, Ad, "f").set(e.id, n);
                    const i = await r;
                    function a(e, t, n, r, a, s, l, c, h) {
                        const d = i.find((t => t.scene.name == e));
                        if (null == d)
                            throw new Error('Scene "' + e + '" does not exist');
                        const u = d.scene.getObjectByName(t);
                        if (null == u)
                            throw new Error('Mesh "' + t + '" does not exist in scene "' + e + '"');
                        let p;
                        if (0 == u.children.length) {
                            if (!(u instanceof C.eaF))
                                throw new Error("Group is not a mesh");
                            const e = u
                              , t = o(e, h);
                            e.updateMatrixWorld(!0),
                            t.applyMatrix4(e.matrix),
                            p = [t]
                        } else {
                            p = u.children.map((e => {
                                if (!(e instanceof C.eaF))
                                    throw new Error("Child is not a mesh");
                                return o(e, h)
                            }
                            )),
                            u.updateMatrixWorld(!0);
                            for (const e of p)
                                e.applyMatrix4(u.matrix)
                        }
                        let f = -1 / 0;
                        if (r)
                            for (const e of p)
                                for (let t = 0; t < e.attributes.position.array.length; t += 3)
                                    f = Math.max(f, e.attributes.position.array[t + 1]);
                        for (const e of p) {
                            if (null != l && e.scale(l.x, l.y, l.z),
                            null != c && e.applyQuaternion(c),
                            e.scale(n ? -1 : 1, r ? -1 : 1, a ? -1 : 1),
                            n || r || a) {
                                const t = e.index;
                                if (null != t)
                                    for (let e = 0; e < t.count; e += 3) {
                                        const n = t.getX(e)
                                          , i = t.getX(e + 1)
                                          , r = t.getX(e + 2);
                                        t.setXYZ(e, n, r, i)
                                    }
                                else {
                                    const t = e.attributes.position;
                                    for (let e = 0; e < t.count; e += 3) {
                                        const n = e
                                          , i = e + 1
                                          , r = e + 2
                                          , a = t.getX(n)
                                          , s = t.getY(n)
                                          , o = t.getZ(n)
                                          , l = t.getX(i)
                                          , c = t.getY(i)
                                          , h = t.getZ(i)
                                          , d = t.getX(r)
                                          , u = t.getY(r)
                                          , p = t.getZ(r);
                                        t.setXYZ(n, a, s, o),
                                        t.setXYZ(i, d, u, p),
                                        t.setXYZ(r, l, c, h)
                                    }
                                }
                            }
                            null != s ? r ? e.translate(s.x, s.y + f, s.z) : e.translate(s.x, s.y, s.z) : r && e.translate(0, f, 0)
                        }
                        return p
                    }
                    function o(e, t) {
                        const n = e.material;
                        if (!(n instanceof C._4j))
                            throw new Error("Material is not a MeshStandardMaterial");
                        let i, r, a;
                        if (Object.prototype.hasOwnProperty.call(t, n.name)) {
                            const e = new C.Q1f(t[n.name]);
                            i = e.r,
                            r = e.g,
                            a = e.b
                        } else
                            i = n.color.r,
                            r = n.color.g,
                            a = n.color.b;
                        const s = e.geometry.clone()
                          , o = new Float32Array(s.attributes.position.array.length);
                        for (let e = 0; e < o.length; e += 3)
                            o[e + 0] = i,
                            o[e + 1] = r,
                            o[e + 2] = a;
                        return s.attributes.color = new C.THS(o,3),
                        s
                    }
                    let l = null;
                    for (const t of e.colors) {
                        const i = [];
                        for (const [n,r,s] of e.models) {
                            const e = a(n, r, s?.flipX ?? !1, s?.flipY ?? !1, s?.flipZ ?? !1, s?.offset ?? null, s?.scale ?? null, s?.quaternion ?? null, t.colors);
                            for (const t of e)
                                i.push(t)
                        }
                        const r = xd.pP(i, !0).toNonIndexed();
                        r.computeVertexNormals();
                        const o = xd.ec(r)
                          , c = new C.eaF(o,s);
                        n.colors.set(t.id, c),
                        l ?? (l = r)
                    }
                    if (null == l)
                        throw new Error("Physics geometry is missing");
                    if (!(l.attributes.position instanceof C.THS))
                        throw new Error("Vertices must use BufferAttribute");
                    n.physicsShapeVertices = new Float32Array(l.attributes.position.array),
                    t.loadedResource()
                }
                  , l = await Promise.all(ki.yD.map((e => o(e)))).then((async () => await (0,
                R.gn)(this, md, "m", wd).call(this)))
                  , c = (e, t, n=null) => {
                    let i = (0,
                    R.gn)(this, vd, "f").get(e);
                    null == i && (i = new Map,
                    (0,
                    R.gn)(this, vd, "f").set(e, i)),
                    n ?? (n = (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis),
                    i.set(t, n)
                }
                ;
                c(Sd.A.BlockSlopeUp, Sd.A.SlopeUp),
                c(Sd.A.BlockSlopeUp, Sd.A.SlopeUpLeftWide),
                c(Sd.A.BlockSlopeUp, Sd.A.SlopeUpRightWide),
                c(Sd.A.BlockSlopeUp, Sd.A.PlaneSlopeUp),
                c(Sd.A.BlockSlopedUp, Sd.A.Slope),
                c(Sd.A.BlockSlopedUp, Sd.A.SlopeLeftWide),
                c(Sd.A.BlockSlopedUp, Sd.A.SlopeRightWide),
                c(Sd.A.BlockSlopedUp, Sd.A.PlaneSlope),
                c(Sd.A.BlockSlopeDown, Sd.A.SlopeDown),
                c(Sd.A.BlockSlopeDown, Sd.A.SlopeDownLeftWide),
                c(Sd.A.BlockSlopeDown, Sd.A.SlopeDownRightWide),
                c(Sd.A.BlockSlopeDown, Sd.A.PlaneSlopeDown),
                c(Sd.A.BlockSlopeDownLong, Sd.A.SlopeDownLong),
                c(Sd.A.BlockSlopeDownLong, Sd.A.SlopeDownLongLeftWide),
                c(Sd.A.BlockSlopeDownLong, Sd.A.SlopeDownLongRightWide),
                c(Sd.A.BlockSlopeDownLong, Sd.A.PlaneSlopeDownLong),
                c(Sd.A.BlockSlopeUpLong, Sd.A.SlopeUpLong),
                c(Sd.A.BlockSlopeUpLong, Sd.A.SlopeUpLongLeftWide),
                c(Sd.A.BlockSlopeUpLong, Sd.A.SlopeUpLongRightWide),
                c(Sd.A.BlockSlopeUpLong, Sd.A.PlaneSlopeUpLong),
                c(Sd.A.BlockSlopeVerticalTop, Sd.A.WallTrackTop),
                c(Sd.A.BlockSlopeVerticalInnerCornerTop, Sd.A.WallTrackTopInnerCorner),
                c(Sd.A.BlockSlopeVerticalInnerCornerBottom, Sd.A.WallTrackBottomInnerCorner),
                c(Sd.A.BlockInnerCorner, Sd.A.WallTrackMiddleCorner);
                const h = (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis || e.x == t.x && e.y == t.y + 3 && e.z == t.z && e.rotation == t.rotation && (e.rotationAxis == kd.A.YPositive && t.rotationAxis == kd.A.YNegative || e.rotationAxis == kd.A.YNegative && t.rotationAxis == kd.A.YPositive || e.rotationAxis == kd.A.XPositive && t.rotationAxis == kd.A.XNegative || e.rotationAxis == kd.A.XNegative && t.rotationAxis == kd.A.XPositive || e.rotationAxis == kd.A.ZPositive && t.rotationAxis == kd.A.ZNegative || e.rotationAxis == kd.A.ZNegative && t.rotationAxis == kd.A.ZPositive);
                return c(Sd.A.BlockSlopeVerticalBottom, Sd.A.PlaneSlopeVerticalBottom, h),
                c(Sd.A.BlockSlopeVerticalBottom, Sd.A.WallTrackBottom, h),
                c(Sd.A.BlockSlopeVerticalBottom, Sd.A.SlopeUpVertical, h),
                c(Sd.A.BlockSlopeVerticalBottom, Sd.A.SlopeUpVerticalLeftWide, h),
                c(Sd.A.BlockSlopeVerticalBottom, Sd.A.SlopeUpVerticalRightWide, h),
                c(Sd.A.BlockSlopeVerticalCornerBottom, Sd.A.WallTrackBottomCorner),
                c(Sd.A.BlockSlopeVerticalCornerTop, Sd.A.WallTrackTopCorner),
                c(Sd.A.BlockSlopeToVertical, Sd.A.SlopeToVertical),
                c(Sd.A.BlockSlopeToVertical, Sd.A.SlopeToVerticalLeftWide),
                c(Sd.A.BlockSlopeToVertical, Sd.A.SlopeToVerticalRightWide),
                c(Sd.A.BlockSlopeToVertical, Sd.A.PlaneSlopeToVertical),
                c(Sd.A.BlockSlopeToVertical, Sd.A.WallTrackSlopeToVertical),
                c(Sd.A.HalfBlock, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlock, Sd.A.HalfPlane, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlock, Sd.A.QuarterBlock, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlock, Sd.A.QuarterPlane, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.QuarterBlock, Sd.A.QuarterBlock, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.QuarterBlock, Sd.A.HalfPlane, ( (e, t) => e.rotation != t.rotation && e.rotation != (t.rotation + 1) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.QuarterBlock, Sd.A.QuarterPlane, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlane, Sd.A.HalfPlane, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlane, Sd.A.QuarterPlane, ( (e, t) => e.rotation != t.rotation && (e.rotation + 1) % 4 != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.QuarterPlane, Sd.A.QuarterPlane, ( (e, t) => e.rotation != t.rotation && e.x == t.x && e.y == t.y && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlockSlopeBottomLeft, Sd.A.HalfPlaneSlopeBottomLeft),
                c(Sd.A.HalfBlockSlopeBottomRight, Sd.A.HalfPlaneSlopeBottomRight),
                c(Sd.A.HalfBlockSlopeTopLeft, Sd.A.HalfPlaneSlopeTopLeft),
                c(Sd.A.HalfBlockSlopeTopRight, Sd.A.HalfPlaneSlopeTopRight),
                c(Sd.A.HalfBlockSlopeBottomLeft, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlockSlopeBottomRight, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 1) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlockSlopeTopLeft, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 3) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfBlockSlopeTopRight, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 0) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlaneSlopeBottomLeft, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1 || e.y == t.y - 2) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlaneSlopeBottomRight, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 1) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1 || e.y == t.y - 2) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlaneSlopeTopLeft, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 3) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1 || e.y == t.y - 2) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.HalfPlaneSlopeTopRight, Sd.A.HalfBlock, ( (e, t) => e.rotation == (t.rotation + 0) % 4 && e.x == t.x && (e.y == t.y || e.y == t.y - 1 || e.y == t.y - 2) && e.z == t.z && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.WallTrackTopInnerCorner, Sd.A.WallTrackCeilingCorner, ( (e, t) => {
                    let n;
                    switch (e.rotationAxis) {
                    case kd.A.YPositive:
                        n = new C.Pq0(0,1,0);
                        break;
                    case kd.A.YNegative:
                        n = new C.Pq0(0,-1,0);
                        break;
                    case kd.A.XPositive:
                        n = new C.Pq0(1,0,0);
                        break;
                    case kd.A.XNegative:
                        n = new C.Pq0(-1,0,0);
                        break;
                    case kd.A.ZPositive:
                        n = new C.Pq0(0,0,1);
                        break;
                    case kd.A.ZNegative:
                        n = new C.Pq0(0,0,-1);
                        break;
                    default:
                        throw new Error("Invalid rotation axis")
                    }
                    return e.rotation == t.rotation && e.x + 3 * n.x == t.x && e.y + 3 * n.y == t.y && e.z + 3 * n.z == t.z && e.rotationAxis == t.rotationAxis
                }
                )),
                c(Sd.A.WallTrackTopInnerCorner, Sd.A.WallTrackCeilingPlaneCorner, ( (e, t) => {
                    let n;
                    switch (e.rotationAxis) {
                    case kd.A.YPositive:
                        n = new C.Pq0(0,1,0);
                        break;
                    case kd.A.YNegative:
                        n = new C.Pq0(0,-1,0);
                        break;
                    case kd.A.XPositive:
                        n = new C.Pq0(1,0,0);
                        break;
                    case kd.A.XNegative:
                        n = new C.Pq0(-1,0,0);
                        break;
                    case kd.A.ZPositive:
                        n = new C.Pq0(0,0,1);
                        break;
                    case kd.A.ZNegative:
                        n = new C.Pq0(0,0,-1);
                        break;
                    default:
                        throw new Error("Invalid rotation axis")
                    }
                    return e.rotation == t.rotation && e.x + 3 * n.x == t.x && e.y + 3 * n.y == t.y && e.z + 3 * n.z == t.z && e.rotationAxis == t.rotationAxis
                }
                )),
                c(Sd.A.WallTrackBottomInnerCorner, Sd.A.WallTrackFloorCorner),
                c(Sd.A.WallTrackBottomInnerCorner, Sd.A.WallTrackFloorPlaneCorner),
                c(Sd.A.PillarTopSlope, Sd.A.Slope),
                c(Sd.A.PillarTopSlope, Sd.A.SlopeLeftWide),
                c(Sd.A.PillarTopSlope, Sd.A.SlopeRightWide),
                c(Sd.A.PillarTopSlope, Sd.A.PlaneSlope),
                c(Sd.A.PillarTopSlope, Sd.A.StraightTilted, ( (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == (t.rotation + 1) % 4 && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PillarTopSlope, Sd.A.BlockSlopedDown, ( (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == (t.rotation + 2) % 4 && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PillarTopSlope, Sd.A.BlockSlopedUp, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && (e.rotationAxis == kd.A.YPositive && t.rotationAxis == kd.A.YNegative ? e.x == t.x && e.y + 2 == t.y && e.z == t.z : e.rotationAxis == kd.A.YNegative && t.rotationAxis == kd.A.YPositive ? e.x == t.x && e.y == t.y + 2 && e.z == t.z : e.rotationAxis == kd.A.XPositive && t.rotationAxis == kd.A.XNegative ? e.x + 2 == t.x && e.y == t.y && e.z == t.z : e.rotationAxis == kd.A.XNegative && t.rotationAxis == kd.A.XPositive ? e.x == t.x + 2 && e.y == t.y && e.z == t.z : e.rotationAxis == kd.A.ZPositive && t.rotationAxis == kd.A.ZNegative ? e.x == t.x && e.y == t.y && e.z + 2 == t.z : e.rotationAxis == kd.A.ZNegative && t.rotationAxis == kd.A.ZPositive && (e.x == t.x && e.y == t.y && e.z == t.z + 2)))),
                c(Sd.A.PillarShortSlope, Sd.A.Slope),
                c(Sd.A.PillarShortSlope, Sd.A.SlopeLeftWide),
                c(Sd.A.PillarShortSlope, Sd.A.SlopeRightWide),
                c(Sd.A.PillarShortSlope, Sd.A.PlaneSlope),
                c(Sd.A.PillarShortSlope, Sd.A.StraightTilted, ( (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == (t.rotation + 1) % 4 && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PillarShortSlope, Sd.A.BlockSlopedDown, ( (e, t) => e.x == t.x && e.y == t.y && e.z == t.z && e.rotation == (t.rotation + 2) % 4 && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PillarShortSlope, Sd.A.BlockSlopedUp, ( (e, t) => e.rotation == (t.rotation + 2) % 4 && (e.rotationAxis == kd.A.YPositive && t.rotationAxis == kd.A.YNegative ? e.x == t.x && e.y + 2 == t.y && e.z == t.z : e.rotationAxis == kd.A.YNegative && t.rotationAxis == kd.A.YPositive ? e.x == t.x && e.y == t.y + 2 && e.z == t.z : e.rotationAxis == kd.A.XPositive && t.rotationAxis == kd.A.XNegative ? e.x + 2 == t.x && e.y == t.y && e.z == t.z : e.rotationAxis == kd.A.XNegative && t.rotationAxis == kd.A.XPositive ? e.x == t.x + 2 && e.y == t.y && e.z == t.z : e.rotationAxis == kd.A.ZPositive && t.rotationAxis == kd.A.ZNegative ? e.x == t.x && e.y == t.y && e.z + 2 == t.z : e.rotationAxis == kd.A.ZNegative && t.rotationAxis == kd.A.ZPositive && (e.x == t.x && e.y == t.y && e.z == t.z + 2)))),
                c(Sd.A.PlaneWallSlopeLeft, Sd.A.PlaneWallSlopeLeft, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeRight, Sd.A.PlaneWallSlopeRight, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeUpLeft, Sd.A.PlaneWallSlopeUpLeft, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeUpRight, Sd.A.PlaneWallSlopeUpRight, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeDownLeft, Sd.A.PlaneWallSlopeDownLeft, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeDownRight, Sd.A.PlaneWallSlopeDownRight, ( (e, t) => e.x == t.x && e.y == t.y + 1 && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeUpLongLeft, Sd.A.PlaneWallSlopeUpLongLeft, ( (e, t) => e.x == t.x && (e.y == t.y + 1 || e.y == t.y + 2) && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeUpLongRight, Sd.A.PlaneWallSlopeUpLongRight, ( (e, t) => e.x == t.x && (e.y == t.y + 1 || e.y == t.y + 2) && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeDownLongLeft, Sd.A.PlaneWallSlopeDownLongLeft, ( (e, t) => e.x == t.x && (e.y == t.y + 1 || e.y == t.y + 2) && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                c(Sd.A.PlaneWallSlopeDownLongRight, Sd.A.PlaneWallSlopeDownLongRight, ( (e, t) => e.x == t.x && (e.y == t.y + 1 || e.y == t.y + 2) && e.z == t.z && e.rotation == t.rotation && e.rotationAxis == t.rotationAxis)),
                i.dispose(),
                l
            }
            isPartCombinationAllowed(e, t) {
                const n = (0,
                R.gn)(this, md, "m", yd).call(this, e.id, t.id);
                if (n?.(e, t))
                    return !0;
                const i = (0,
                R.gn)(this, md, "m", yd).call(this, t.id, e.id);
                return !!i?.(t, e)
            }
            getPhysicsParts() {
                const e = [];
                for (const {configuration: t, physicsShapeVertices: n} of (0,
                R.gn)(this, Ad, "f").values()) {
                    if (null == n)
                        throw new Error("Part model has not been loaded yet");
                    e.push({
                        id: t.id,
                        vertices: n,
                        detector: t.detector,
                        startOffset: t.startOffset?.toArray() ?? null
                    })
                }
                return e
            }
            hasPart(e) {
                return (0,
                R.gn)(this, Ad, "f").has(e)
            }
            getPart(e) {
                const t = (0,
                R.gn)(this, Ad, "f").get(e);
                if (null == t)
                    throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                return t
            }
            getAllParts() {
                return Array.from((0,
                R.gn)(this, Ad, "f").values())
            }
            getPartStartOffset(e) {
                const t = (0,
                R.gn)(this, Ad, "f").get(e);
                if (null == t)
                    throw new Error('Track part with the id "' + e.toString() + '" does not exist');
                return t.configuration.startOffset?.clone() ?? null
            }
            getPartTypesWithDetector(e) {
                const t = [];
                for (const [n,i] of (0,
                R.gn)(this, Ad, "f").entries())
                    i.configuration.detector?.type == e && t.push(n);
                return t
            }
            getStartPartTypes() {
                const e = [];
                for (const [t,n] of (0,
                R.gn)(this, Ad, "f").entries())
                    null != n.configuration.startOffset && e.push(t);
                return e
            }
            getCategoryMesh(e, t) {
                let n, i;
                switch (e) {
                case Ed.A.Special:
                    n = this.getPart(Sd.A.Start);
                    break;
                case Ed.A.Road:
                    n = this.getPart(Sd.A.Straight);
                    break;
                case Ed.A.RoadTurns:
                    n = this.getPart(Sd.A.TurnShort);
                    break;
                case Ed.A.RoadWide:
                    n = this.getPart(Sd.A.OuterCornerWide);
                    break;
                case Ed.A.Plane:
                    n = this.getPart(Sd.A.Plane);
                    break;
                case Ed.A.Block:
                    n = this.getPart(Sd.A.Block);
                    break;
                case Ed.A.WallTrack:
                    n = this.getPart(Sd.A.WallTrackBottom);
                    break;
                case Ed.A.Pillar:
                    n = this.getPart(Sd.A.PillarShort);
                    break;
                case Ed.A.Sign:
                    n = this.getPart(Sd.A.SignArrowLeft)
                }
                switch (t) {
                case hl.A.Summer:
                    i = Td.A.Summer;
                    break;
                case hl.A.Winter:
                    i = Td.A.Winter;
                    break;
                case hl.A.Desert:
                    i = Td.A.Desert
                }
                const r = n.colors.get(i);
                if (null == r)
                    throw new Error("Category mesh is not loaded");
                return r
            }
        }
        Ad = new WeakMap,
        vd = new WeakMap,
        md = new WeakSet,
        yd = function(e, t) {
            const n = (0,
            R.gn)(this, vd, "f").get(e);
            return null == n ? null : n.get(t) ?? null
        }
        ,
        wd = async function() {
            const e = Object.values(Sd.A).filter((e => "string" != typeof e));
            let t = !0;
            for (const n of e) {
                const e = (0,
                R.gn)(this, Ad, "f").get(n);
                if (null == e)
                    throw new Error("Part with id " + n.toString() + " does not exist");
                const i = e.physicsShapeVertices;
                if (null == i)
                    throw new Error("Part model with id " + n.toString() + " has not been loaded yet");
                const r = await window.crypto.subtle.digest("SHA-256", i)
                  , a = Array.from(new Uint8Array(r)).map((e => e.toString(16).padStart(2, "0"))).join("");
                a != e.configuration.checksum && (console.error("Part id " + n.toString() + " " + Sd.A[n] + " checksum mismatch: " + a + " != " + e.configuration.checksum),
                t = !1)
            }
            return t
        }
        ;
        var _d = i(9207)
          , Cd = {};
        Cd.styleTagTransform = u(),
        Cd.setAttributes = l(),
        Cd.insert = s().bind(null, "head"),
        Cd.domAPI = r(),
        Cd.insertStyleElement = h();
        t()(_d.A, Cd);
        _d.A && _d.A.locals && _d.A.locals;
        var Rd, Pd, Id;
        Rd = new WeakMap,
        Pd = new WeakMap,
        Id = new WeakMap;
        const Ld = class {
            constructor(e) {
                Rd.set(this, void 0),
                Pd.set(this, document.getElementById("transition-layer")),
                Id.set(this, null),
                (0,
                R.GG)(this, Rd, e, "f")
            }
            trigger(e) {
                const t = (0,
                R.gn)(this, Pd, "f");
                if (null == t)
                    throw new Error("Failed to find transition layer");
                null == (0,
                R.gn)(this, Id, "f") && (t.style.opacity = "1",
                (0,
                R.gn)(this, Rd, "f").setInert(!0),
                setTimeout(( () => {
                    if (null != (0,
                    R.gn)(this, Id, "f")) {
                        const e = (0,
                        R.gn)(this, Id, "f").call(this);
                        null == e ? (t.style.opacity = "0",
                        (0,
                        R.gn)(this, Rd, "f").setInert(!1),
                        (0,
                        R.GG)(this, Id, null, "f")) : e.finally(( () => {
                            t.style.opacity = "0",
                            (0,
                            R.gn)(this, Rd, "f").setInert(!1),
                            (0,
                            R.GG)(this, Id, null, "f")
                        }
                        ))
                    }
                }
                ), 250)),
                (0,
                R.GG)(this, Id, e, "f")
            }
        }
        ;
        var Nd, zd, Ud, Dd;
        Nd = new WeakMap,
        zd = new WeakMap,
        Ud = new WeakMap,
        Dd = new WeakMap;
        const Bd = class {
            constructor(e, t, n) {
                Nd.set(this, void 0),
                zd.set(this, void 0),
                Ud.set(this, new C.I9Y(100 * Math.random(),100 * Math.random())),
                Dd.set(this, new C.I9Y(100 * Math.random(),100 * Math.random())),
                (0,
                R.GG)(this, Nd, t, "f"),
                n.addResource();
                const i = (new C.Tap).load("images/clouds.jpg", ( () => {
                    n.loadedResource()
                }
                ));
                i.wrapT = C.GJx,
                i.wrapS = C.GJx;
                const r = new C.Gu$(1e6,5,2,0,2 * Math.PI,0,Math.PI)
                  , a = new C.BKk({
                    defines: {
                        CLOUDS_ENABLED: t.getSettingBoolean(P.A.CloudsEnabled)
                    },
                    uniforms: {
                        scrollA: {
                            value: (0,
                            R.gn)(this, Ud, "f")
                        },
                        scrollB: {
                            value: (0,
                            R.gn)(this, Dd, "f")
                        },
                        sampler: {
                            value: i
                        },
                        cloudDensity: {
                            value: .6
                        },
                        cloudLight: {
                            value: new C.Pq0(.75,.75,.75)
                        },
                        sunPosition: {
                            value: new C.Pq0
                        }
                    },
                    vertexShader: "\n\t\t\t\tvarying vec3 fPos;\n\t\t\t\t\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewPosition;\n\t\t\t\t\tgl_Position.z = 0.0;\n\t\t\t\t\tfPos = position;\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\t\t\t\tvarying vec3 fPos;\n\n\t\t\t\tuniform vec2 offset;\n\t\t\t\tuniform vec2 scrollA;\n\t\t\t\tuniform vec2 scrollB;\n\t\t\t\tuniform sampler2D sampler;\n\n\t\t\t\tuniform float cloudDensity;\n\t\t\t\tuniform vec3 cloudLight;\n\n\t\t\t\tuniform vec3 sunPosition;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t#ifdef CLOUDS_ENABLED\n\t\t\t\t\t\tfloat c00 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 0.981, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 1.041) + scrollA).r;\n\t\t\t\t\t\tfloat c10 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.821, fPos.z / ((fPos.y + 0.06) / 0.1) - scrollB.y * 0.951) + scrollA).r;\n\t\t\t\t\t\tfloat c01 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) - scrollB.x * 1.043, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 0.899) + scrollA).r;\n\t\t\t\t\t\tfloat c11 = texture2D(sampler, vec2(fPos.x / ((fPos.y + 0.06) / 0.1) + scrollB.x * 0.901, fPos.z / ((fPos.y + 0.06) / 0.1) + scrollB.y * 1.045) + scrollA).r;\n\t\t\t\t\t\tfloat cloud = min(1.0, max(0.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 3.0);\n\n\t\t\t\t\t\tvec3 cloudColor = vec3(min(1.0, (c00 + c10 + c01 + c11) / 4.0 - (1.0 - cloudDensity)) * 4.0 + cloudDensity) * cloudLight;\n\t\t\t\t\t\tfloat cloudIntensity = cloud * min(1.0, max(0.0, fPos.y * 2.0 / 1000000.0));\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec3 cloudColor = vec3(0.0);\n\t\t\t\t\t\tfloat cloudIntensity = 0.0;\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tvec3 horizonColor = vec3(255.0 / 255.0, 255.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tvec3 zenithColor = vec3(5.0 / 255.0, 140.0 / 255.0, 255.0 / 255.0);\n\t\t\t\t\tfloat h = pow(clamp(fPos.y / 1000000.0, 0.01, 1.0), 0.2);\n\t\t\t\t\tvec3 skyColor = zenithColor * h + horizonColor * (1.0 - h);\n\n\t\t\t\t\tvec3 normal = normalize(-fPos);\n\t\t\t\t\tfloat sun = pow(max(0.0, max(0.0, dot(normal, sunPosition)) - 0.999), 4.0) * 60000000000.0;\n\t\t\t\t\tvec3 sunColor = vec3(20.0 * sun, 20.0 * sun, 19.0 * sun);\n\n\t\t\t\t\tgl_FragColor = vec4((skyColor * (1.0 - cloudIntensity) + cloudColor * cloudIntensity) * max(vec3(0.0), vec3(1.0) - sunColor) + sunColor, 1.0);\n\t\t\t\t}\n\t\t\t"
                });
                a.side = C.hsX,
                a.depthWrite = !1,
                (0,
                R.GG)(this, zd, new C.eaF(r,a), "f"),
                (0,
                R.gn)(this, zd, "f").renderOrder = -3,
                (0,
                R.gn)(this, zd, "f").matrixAutoUpdate = !1,
                (0,
                R.gn)(this, zd, "f").updateMatrix(),
                e.scene.add((0,
                R.gn)(this, zd, "f"))
            }
            update(e, t, n) {
                (0,
                R.gn)(this, Nd, "f").getSettingBoolean(P.A.CloudsEnabled) ? ((0,
                R.gn)(this, Ud, "f").x += .00226 * e,
                (0,
                R.gn)(this, Ud, "f").y += .001646 * e,
                (0,
                R.gn)(this, Dd, "f").x += .001752 * e,
                (0,
                R.gn)(this, Dd, "f").y += .001057 * e,
                1 != (0,
                R.gn)(this, zd, "f").material.defines.CLOUDS_ENABLED && ((0,
                R.gn)(this, zd, "f").material.defines.CLOUDS_ENABLED = !0,
                (0,
                R.gn)(this, zd, "f").material.needsUpdate = !0)) : 0 != (0,
                R.gn)(this, zd, "f").material.defines.CLOUDS_ENABLED && ((0,
                R.gn)(this, zd, "f").material.defines.CLOUDS_ENABLED = !1,
                (0,
                R.gn)(this, zd, "f").material.needsUpdate = !0);
                const i = n.getSunPosition();
                (0,
                R.gn)(this, zd, "f").material.uniforms.sunPosition.value.copy(i.negate()),
                (0,
                R.gn)(this, zd, "f").position.copy(t.position),
                (0,
                R.gn)(this, zd, "f").updateMatrix()
            }
        }
        ;
        class Gd {
            constructor(e) {
                this.sqlite = e,
                this._connectionDict = new Map
            }
            async initWebStore() {
                try {
                    return await this.sqlite.initWebStore(),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async saveToStore(e) {
                try {
                    return await this.sqlite.saveToStore({
                        database: e
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async saveToLocalDisk(e) {
                try {
                    return await this.sqlite.saveToLocalDisk({
                        database: e
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getFromLocalDiskToStore(e) {
                const t = null == e || e;
                try {
                    return await this.sqlite.getFromLocalDiskToStore({
                        overwrite: t
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async echo(e) {
                try {
                    const t = await this.sqlite.echo({
                        value: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isSecretStored() {
                try {
                    const e = await this.sqlite.isSecretStored();
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async setEncryptionSecret(e) {
                try {
                    return await this.sqlite.setEncryptionSecret({
                        passphrase: e
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async changeEncryptionSecret(e, t) {
                try {
                    return await this.sqlite.changeEncryptionSecret({
                        passphrase: e,
                        oldpassphrase: t
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async clearEncryptionSecret() {
                try {
                    return await this.sqlite.clearEncryptionSecret(),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async checkEncryptionSecret(e) {
                try {
                    const t = await this.sqlite.checkEncryptionSecret({
                        passphrase: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async addUpgradeStatement(e, t) {
                try {
                    return e.endsWith(".db") && (e = e.slice(0, -3)),
                    await this.sqlite.addUpgradeStatement({
                        database: e,
                        upgrade: t
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async createConnection(e, t, n, i, r) {
                try {
                    e.endsWith(".db") && (e = e.slice(0, -3)),
                    await this.sqlite.createConnection({
                        database: e,
                        encrypted: t,
                        mode: n,
                        version: i,
                        readonly: r
                    });
                    const a = new Fd(e,r,this.sqlite)
                      , s = r ? `RO_${e}` : `RW_${e}`;
                    return this._connectionDict.set(s, a),
                    Promise.resolve(a)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async closeConnection(e, t) {
                try {
                    e.endsWith(".db") && (e = e.slice(0, -3)),
                    await this.sqlite.closeConnection({
                        database: e,
                        readonly: t
                    });
                    const n = t ? `RO_${e}` : `RW_${e}`;
                    return this._connectionDict.delete(n),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isConnection(e, t) {
                const n = {};
                e.endsWith(".db") && (e = e.slice(0, -3));
                const i = t ? `RO_${e}` : `RW_${e}`;
                return n.result = this._connectionDict.has(i),
                Promise.resolve(n)
            }
            async retrieveConnection(e, t) {
                e.endsWith(".db") && (e = e.slice(0, -3));
                const n = t ? `RO_${e}` : `RW_${e}`;
                if (this._connectionDict.has(n)) {
                    const t = this._connectionDict.get(n);
                    return void 0 !== t ? Promise.resolve(t) : Promise.reject(`Connection ${e} is undefined`)
                }
                return Promise.reject(`Connection ${e} does not exist`)
            }
            async getNCDatabasePath(e, t) {
                try {
                    const n = await this.sqlite.getNCDatabasePath({
                        path: e,
                        database: t
                    });
                    return Promise.resolve(n)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async createNCConnection(e, t) {
                try {
                    await this.sqlite.createNCConnection({
                        databasePath: e,
                        version: t
                    });
                    const n = new Fd(e,!0,this.sqlite)
                      , i = `RO_${e})`;
                    return this._connectionDict.set(i, n),
                    Promise.resolve(n)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async closeNCConnection(e) {
                try {
                    await this.sqlite.closeNCConnection({
                        databasePath: e
                    });
                    const t = `RO_${e})`;
                    return this._connectionDict.delete(t),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isNCConnection(e) {
                const t = {}
                  , n = `RO_${e})`;
                return t.result = this._connectionDict.has(n),
                Promise.resolve(t)
            }
            async retrieveNCConnection(e) {
                if (this._connectionDict.has(e)) {
                    const t = `RO_${e})`
                      , n = this._connectionDict.get(t);
                    return void 0 !== n ? Promise.resolve(n) : Promise.reject(`Connection ${e} is undefined`)
                }
                return Promise.reject(`Connection ${e} does not exist`)
            }
            async isNCDatabase(e) {
                try {
                    const t = await this.sqlite.isNCDatabase({
                        databasePath: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async retrieveAllConnections() {
                return this._connectionDict
            }
            async closeAllConnections() {
                const e = new Map;
                try {
                    for (const t of this._connectionDict.keys()) {
                        const n = t.substring(3)
                          , i = "RO_" === t.substring(0, 3);
                        await this.sqlite.closeConnection({
                            database: n,
                            readonly: i
                        }),
                        e.set(t, null)
                    }
                    for (const t of e.keys())
                        this._connectionDict.delete(t);
                    return Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async checkConnectionsConsistency() {
                try {
                    const e = [...this._connectionDict.keys()]
                      , t = []
                      , n = [];
                    for (const i of e)
                        t.push(i.substring(0, 2)),
                        n.push(i.substring(3));
                    const i = await this.sqlite.checkConnectionsConsistency({
                        dbNames: n,
                        openModes: t
                    });
                    return i.result || (this._connectionDict = new Map),
                    Promise.resolve(i)
                } catch (e) {
                    return this._connectionDict = new Map,
                    Promise.reject(e)
                }
            }
            async importFromJson(e) {
                try {
                    const t = await this.sqlite.importFromJson({
                        jsonstring: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isJsonValid(e) {
                try {
                    const t = await this.sqlite.isJsonValid({
                        jsonstring: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async copyFromAssets(e) {
                const t = null == e || e;
                try {
                    return await this.sqlite.copyFromAssets({
                        overwrite: t
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getFromHTTPRequest(e, t) {
                const n = null == t || t;
                try {
                    return await this.sqlite.getFromHTTPRequest({
                        url: e,
                        overwrite: n
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isDatabaseEncrypted(e) {
                e.endsWith(".db") && (e = e.slice(0, -3));
                try {
                    const t = await this.sqlite.isDatabaseEncrypted({
                        database: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isInConfigEncryption() {
                try {
                    const e = await this.sqlite.isInConfigEncryption();
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isInConfigBiometricAuth() {
                try {
                    const e = await this.sqlite.isInConfigBiometricAuth();
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isDatabase(e) {
                e.endsWith(".db") && (e = e.slice(0, -3));
                try {
                    const t = await this.sqlite.isDatabase({
                        database: e
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getDatabaseList() {
                try {
                    const e = (await this.sqlite.getDatabaseList()).values;
                    e.sort();
                    const t = {
                        values: e
                    };
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getMigratableDbList(e) {
                const t = e || "default";
                try {
                    const e = await this.sqlite.getMigratableDbList({
                        folderPath: t
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async addSQLiteSuffix(e, t) {
                const n = e || "default"
                  , i = t || [];
                try {
                    const e = await this.sqlite.addSQLiteSuffix({
                        folderPath: n,
                        dbNameList: i
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async deleteOldDatabases(e, t) {
                const n = e || "default"
                  , i = t || [];
                try {
                    const e = await this.sqlite.deleteOldDatabases({
                        folderPath: n,
                        dbNameList: i
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async moveDatabasesAndAddSuffix(e, t) {
                const n = e || "default"
                  , i = t || [];
                return this.sqlite.moveDatabasesAndAddSuffix({
                    folderPath: n,
                    dbNameList: i
                })
            }
        }
        class Fd {
            constructor(e, t, n) {
                this.dbName = e,
                this.readonly = t,
                this.sqlite = n
            }
            getConnectionDBName() {
                return this.dbName
            }
            getConnectionReadOnly() {
                return this.readonly
            }
            async open() {
                try {
                    return await this.sqlite.open({
                        database: this.dbName,
                        readonly: this.readonly
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async close() {
                try {
                    return await this.sqlite.close({
                        database: this.dbName,
                        readonly: this.readonly
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async beginTransaction() {
                try {
                    const e = await this.sqlite.beginTransaction({
                        database: this.dbName
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async commitTransaction() {
                try {
                    const e = await this.sqlite.commitTransaction({
                        database: this.dbName
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async rollbackTransaction() {
                try {
                    const e = await this.sqlite.rollbackTransaction({
                        database: this.dbName
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isTransactionActive() {
                try {
                    const e = await this.sqlite.isTransactionActive({
                        database: this.dbName
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async loadExtension(e) {
                try {
                    return await this.sqlite.loadExtension({
                        database: this.dbName,
                        path: e,
                        readonly: this.readonly
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async enableLoadExtension(e) {
                try {
                    return await this.sqlite.enableLoadExtension({
                        database: this.dbName,
                        toggle: e,
                        readonly: this.readonly
                    }),
                    Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getUrl() {
                try {
                    const e = await this.sqlite.getUrl({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getVersion() {
                try {
                    const e = await this.sqlite.getVersion({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getTableList() {
                try {
                    const e = await this.sqlite.getTableList({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async execute(e, t=!0, n=!0) {
                try {
                    if (this.readonly)
                        return Promise.reject("not allowed in read-only mode");
                    {
                        const i = await this.sqlite.execute({
                            database: this.dbName,
                            statements: e,
                            transaction: t,
                            readonly: !1,
                            isSQL92: n
                        });
                        return Promise.resolve(i)
                    }
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async query(e, t, n=!0) {
                let i;
                try {
                    return i = t && t.length > 0 ? await this.sqlite.query({
                        database: this.dbName,
                        statement: e,
                        values: t,
                        readonly: this.readonly,
                        isSQL92: !0
                    }) : await this.sqlite.query({
                        database: this.dbName,
                        statement: e,
                        values: [],
                        readonly: this.readonly,
                        isSQL92: n
                    }),
                    i = await this.reorderRows(i),
                    Promise.resolve(i)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async run(e, t, n=!0, i="no", r=!0) {
                let a;
                try {
                    return this.readonly ? Promise.reject("not allowed in read-only mode") : (a = t && t.length > 0 ? await this.sqlite.run({
                        database: this.dbName,
                        statement: e,
                        values: t,
                        transaction: n,
                        readonly: !1,
                        returnMode: i,
                        isSQL92: !0
                    }) : await this.sqlite.run({
                        database: this.dbName,
                        statement: e,
                        values: [],
                        transaction: n,
                        readonly: !1,
                        returnMode: i,
                        isSQL92: r
                    }),
                    a.changes = await this.reorderRows(a.changes),
                    Promise.resolve(a))
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async executeSet(e, t=!0, n="no", i=!0) {
                let r;
                try {
                    return this.readonly ? Promise.reject("not allowed in read-only mode") : (r = await this.sqlite.executeSet({
                        database: this.dbName,
                        set: e,
                        transaction: t,
                        readonly: !1,
                        returnMode: n,
                        isSQL92: i
                    }),
                    r.changes = await this.reorderRows(r.changes),
                    Promise.resolve(r))
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isExists() {
                try {
                    const e = await this.sqlite.isDBExists({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isTable(e) {
                try {
                    const t = await this.sqlite.isTableExists({
                        database: this.dbName,
                        table: e,
                        readonly: this.readonly
                    });
                    return Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async isDBOpen() {
                try {
                    const e = await this.sqlite.isDBOpen({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    return Promise.resolve(e)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async delete() {
                try {
                    return this.readonly ? Promise.reject("not allowed in read-only mode") : (await this.sqlite.deleteDatabase({
                        database: this.dbName,
                        readonly: !1
                    }),
                    Promise.resolve())
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async createSyncTable() {
                try {
                    if (this.readonly)
                        return Promise.reject("not allowed in read-only mode");
                    {
                        const e = await this.sqlite.createSyncTable({
                            database: this.dbName,
                            readonly: !1
                        });
                        return Promise.resolve(e)
                    }
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async setSyncDate(e) {
                try {
                    return this.readonly ? Promise.reject("not allowed in read-only mode") : (await this.sqlite.setSyncDate({
                        database: this.dbName,
                        syncdate: e,
                        readonly: !1
                    }),
                    Promise.resolve())
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async getSyncDate() {
                try {
                    const e = await this.sqlite.getSyncDate({
                        database: this.dbName,
                        readonly: this.readonly
                    });
                    let t = "";
                    return e.syncDate > 0 && (t = new Date(1e3 * e.syncDate).toISOString()),
                    Promise.resolve(t)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async exportToJson(e, t=!1) {
                try {
                    const n = await this.sqlite.exportToJson({
                        database: this.dbName,
                        jsonexportmode: e,
                        readonly: this.readonly,
                        encrypted: t
                    });
                    return Promise.resolve(n)
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async deleteExportedRows() {
                try {
                    return this.readonly ? Promise.reject("not allowed in read-only mode") : (await this.sqlite.deleteExportedRows({
                        database: this.dbName,
                        readonly: !1
                    }),
                    Promise.resolve())
                } catch (e) {
                    return Promise.reject(e)
                }
            }
            async executeTransaction(e, t=!0) {
                let n = 0
                  , i = !1;
                if (this.readonly)
                    return Promise.reject("not allowed in read-only mode");
                if (await this.sqlite.beginTransaction({
                    database: this.dbName
                }),
                i = await this.sqlite.isTransactionActive({
                    database: this.dbName
                }),
                !i)
                    return Promise.reject("After Begin Transaction, no transaction active");
                try {
                    for (const i of e) {
                        if ("object" != typeof i || !("statement"in i))
                            throw new Error("Error a task.statement must be provided");
                        if ("values"in i && i.values && i.values.length > 0) {
                            const e = i.statement.toUpperCase().includes("RETURNING") ? "all" : "no"
                              , r = await this.sqlite.run({
                                database: this.dbName,
                                statement: i.statement,
                                values: i.values,
                                transaction: !1,
                                readonly: !1,
                                returnMode: e,
                                isSQL92: t
                            });
                            if (r.changes.changes < 0)
                                throw new Error("Error in transaction method run ");
                            n += r.changes.changes
                        } else {
                            const e = await this.sqlite.execute({
                                database: this.dbName,
                                statements: i.statement,
                                transaction: !1,
                                readonly: !1
                            });
                            if (e.changes.changes < 0)
                                throw new Error("Error in transaction method execute ");
                            n += e.changes.changes
                        }
                    }
                    n += (await this.sqlite.commitTransaction({
                        database: this.dbName
                    })).changes.changes;
                    const i = {
                        changes: {
                            changes: n
                        }
                    };
                    return Promise.resolve(i)
                } catch (e) {
                    const t = e.message ? e.message : e;
                    return await this.sqlite.rollbackTransaction({
                        database: this.dbName
                    }),
                    Promise.reject(t)
                }
            }
            async reorderRows(e) {
                const t = e;
                if (e?.values && "object" == typeof e.values[0] && Object.keys(e.values[0]).includes("ios_columns")) {
                    const n = e.values[0].ios_columns
                      , i = [];
                    for (let t = 1; t < e.values.length; t++) {
                        const r = e.values[t]
                          , a = {};
                        for (const e of n)
                            a[e] = r[e];
                        i.push(a)
                    }
                    t.values = i
                }
                return Promise.resolve(t)
            }
        }
        const Od = (0,
        g.F3)("CapacitorSQLite", {
            web: () => i.e(57).then(i.bind(i, 819)).then((e => new e.CapacitorSQLiteWeb)),
            electron: () => window.CapacitorCustomPlatform.plugins.CapacitorSQLite
        });
        var Wd, Vd, Hd, jd, Kd, qd, Qd, Jd, Xd, Yd, Zd, $d, eu, tu, nu, iu, ru, au, su, ou, lu, cu, hu, du, uu, pu = i(7980), fu = i(666), gu = i(5343), mu = i(8928), Au = i(5440), vu = i(2951), yu = i(2387);
        class wu {
            constructor() {
                Wd.add(this),
                Hd.set(this, {
                    getItem: () => {
                        throw new Error("Storage not initialized")
                    }
                    ,
                    setItem: () => {
                        throw new Error("Storage not initialized")
                    }
                    ,
                    removeItem: () => {
                        throw new Error("Storage not initialized")
                    }
                    ,
                    getAllKeys: () => {
                        throw new Error("Storage not initialized")
                    }
                })
            }
            async initialize(e) {
                if (null != e)
                    (0,
                    R.GG)(this, Hd, e, "f");
                else if ("capacitor" == Pt.aC) {
                    const t = new Map
                      , n = new Gd(Od);
                    let i = null
                      , r = null;
                    async function a(e) {
                        if (null == i)
                            throw new Error("SQLite database not opened");
                        if (null == r) {
                            const t = e();
                            r = t;
                            try {
                                await t
                            } finally {
                                r == t && (r = null)
                            }
                        } else {
                            const t = r
                              , n = new Promise((e => {
                                t.then(e).catch(e)
                            }
                            )).then(( () => e()));
                            r = n;
                            try {
                                await n
                            } finally {
                                r == n && (r = null)
                            }
                        }
                    }
                    (0,
                    R.GG)(this, Hd, {
                        getItem: e => {
                            if (null == i)
                                throw new Error("SQLite database not opened");
                            return t.has(e) ? t.get(e) ?? null : null
                        }
                        ,
                        setItem: (e, n) => {
                            if (null == i)
                                throw new Error("SQLite database not opened");
                            const r = i;
                            t.set(e, n),
                            a((async () => {
                                await r.run("INSERT OR REPLACE INTO storage (key, value) VALUES (?, ?)", [e, n])
                            }
                            )).catch((e => {
                                let t = "Failed to insert or replace key in SQLite database";
                                throw e instanceof Error && (t += ": " + e.message),
                                new Error(t)
                            }
                            ))
                        }
                        ,
                        removeItem: e => {
                            if (null == i)
                                throw new Error("SQLite database not opened");
                            const n = i;
                            t.delete(e),
                            a((async () => {
                                await n.run("DELETE FROM storage WHERE key = ?", [e])
                            }
                            )).catch((e => {
                                let t = "Failed to delete key from SQLite database";
                                throw e instanceof Error && (t += ": " + e.message),
                                new Error(t)
                            }
                            ))
                        }
                        ,
                        getAllKeys: () => Array.from(t.keys())
                    }, "f"),
                    await n.checkConnectionsConsistency();
                    const s = await n.createConnection("polytrack", !1, "no-encryption", 1, !1);
                    await s.open(),
                    await s.execute("CREATE TABLE IF NOT EXISTS storage (key TEXT PRIMARY KEY, value TEXT)");
                    const o = await s.query("SELECT key, value FROM storage");
                    if (null != o.values)
                        for (const l of o.values)
                            if (null != l && "object" == typeof l && !Array.isArray(l) && "key"in l && "value"in l) {
                                const c = l.key
                                  , h = l.value;
                                "string" == typeof c && "string" == typeof h && t.set(c, h)
                            }
                    i = s
                } else
                    (0,
                    R.GG)(this, Hd, {
                        getItem: e => window.localStorage.getItem(e),
                        setItem: (e, t) => {
                            window.localStorage.setItem(e, t)
                        }
                        ,
                        removeItem: e => {
                            window.localStorage.removeItem(e)
                        }
                        ,
                        getAllKeys: () => Object.keys(window.localStorage)
                    }, "f")
            }
            migrate() {
                const e = (0,
                R.gn)(this, Wd, "m", nu).call(this);
                (Pt.EM || Pt.Tn) && "jest" != Pt.aC || "v5" == e || ("v4" == e ? ((0,
                R.gn)(this, Wd, "m", Xd).call(this),
                (0,
                R.gn)(this, Wd, "m", tu).call(this)) : "v3" == e ? ((0,
                R.gn)(this, Wd, "m", Jd).call(this),
                (0,
                R.gn)(this, Wd, "m", Xd).call(this),
                (0,
                R.gn)(this, Wd, "m", tu).call(this)) : ((0,
                R.gn)(this, Wd, "m", Kd).call(this),
                (0,
                R.gn)(this, Wd, "m", qd).call(this),
                (0,
                R.gn)(this, Wd, "m", Qd).call(this),
                (0,
                R.gn)(this, Wd, "m", Jd).call(this),
                (0,
                R.gn)(this, Wd, "m", Xd).call(this),
                (0,
                R.gn)(this, Wd, "m", tu).call(this)))
            }
            saveStartupInfo(e) {
                try {
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", iu), JSON.stringify({
                        lastVersion: e
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadStartupInfo() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", iu));
                    if (null == e)
                        return null;
                    const t = JSON.parse(e);
                    return null == t || "object" != typeof t ? null : "lastVersion"in t && "string" == typeof t.lastVersion ? {
                        lastVersion: t.lastVersion
                    } : null
                } catch (e) {
                    return console.error(e),
                    null
                }
            }
            saveRecord(e, t, n, i, r, a, s) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    let o;
                    o = s == oo.Ok ? (0,
                    R.gn)(Vd, Vd, "f", ru) + e.toString() + "_default_" + n : (0,
                    R.gn)(Vd, Vd, "f", ru) + e.toString() + "_undeterministic_" + n,
                    (0,
                    R.gn)(this, Hd, "f").setItem(o, JSON.stringify({
                        uploadId: i,
                        tokenHash: t,
                        frames: r.numberOfFrames,
                        recording: a.serialize()
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadRecord(e, t, n, i) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    let r;
                    r = i == oo.Ok ? (0,
                    R.gn)(Vd, Vd, "f", ru) + e.toString() + "_default_" + n : (0,
                    R.gn)(Vd, Vd, "f", ru) + e.toString() + "_undeterministic_" + n;
                    const a = (0,
                    R.gn)(this, Hd, "f").getItem(r);
                    if (null == a)
                        return null;
                    const s = JSON.parse(a);
                    if (null == s || "object" != typeof s)
                        return null;
                    if (!("uploadId"in s))
                        return null;
                    let o;
                    if (null == s.uploadId)
                        o = null;
                    else {
                        if ("number" != typeof s.uploadId)
                            return null;
                        if (o = s.uploadId,
                        !Number.isSafeInteger(o))
                            return null
                    }
                    if (!("tokenHash"in s))
                        return null;
                    const l = s.tokenHash;
                    if ("string" != typeof l)
                        return null;
                    if (l != t)
                        return null;
                    if (!("frames"in s) || "number" != typeof s.frames)
                        return null;
                    const c = s.frames;
                    if (!Number.isSafeInteger(c) || c < 1)
                        return null;
                    const h = new wt.A(c);
                    if (!("recording"in s) || "string" != typeof s.recording)
                        return null;
                    const d = re.A.deserialize(s.recording);
                    return null == d ? null : {
                        uploadId: o,
                        time: h,
                        recording: d
                    }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            loadRecordTracks() {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys()
                  , t = new Set;
                for (const n of e)
                    if (n.startsWith((0,
                    R.gn)(Vd, Vd, "f", ru))) {
                        const e = n.lastIndexOf("_");
                        if (e >= 0) {
                            const i = n.substring(e + 1);
                            64 == i.length && t.add(i)
                        }
                    }
                return Array.from(t)
            }
            deleteAllRecordsForProfile(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    const t = (0,
                    R.gn)(this, Hd, "f").getAllKeys();
                    for (const n of t)
                        n.startsWith((0,
                        R.gn)(Vd, Vd, "f", ru) + e.toString() + "_") && (0,
                        R.gn)(this, Hd, "f").removeItem(n)
                } catch (e) {
                    console.error(e)
                }
            }
            deleteAllRecordsForTrack(e) {
                for (let t = 0; t < vu.A.maxNumberOfProfiles; t++)
                    try {
                        (0,
                        R.gn)(this, Hd, "f").removeItem((0,
                        R.gn)(Vd, Vd, "f", ru) + t.toString() + "_default_" + e),
                        (0,
                        R.gn)(this, Hd, "f").removeItem((0,
                        R.gn)(Vd, Vd, "f", ru) + t.toString() + "_undeterministic_" + e)
                    } catch (e) {
                        console.error(e)
                    }
            }
            saveCustomTrack(e, t, n) {
                const i = t.toExportString(e);
                try {
                    return (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", au) + e.name, JSON.stringify({
                        data: i,
                        saveTime: n.getTime()
                    })),
                    !0
                } catch (e) {
                    return console.error(e),
                    !1
                }
            }
            loadCustomTrack(e) {
                let t, n;
                try {
                    const i = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", au) + e);
                    if (null == i)
                        return null;
                    const r = JSON.parse(i);
                    if (null == r || "object" != typeof r)
                        return null;
                    if (!("data"in r) || "string" != typeof r.data)
                        return null;
                    if (!("saveTime"in r) || "number" != typeof r.saveTime)
                        return null;
                    t = r.data,
                    n = r.saveTime
                } catch (e) {
                    return console.error(e),
                    null
                }
                const i = gl.A.fromExportString(t);
                return null == i ? null : {
                    trackMetadata: i.trackMetadata,
                    trackData: i.trackData,
                    saveTime: n
                }
            }
            deleteCustomTrack(e) {
                try {
                    return (0,
                    R.gn)(this, Hd, "f").removeItem((0,
                    R.gn)(Vd, Vd, "f", au) + e),
                    !0
                } catch (e) {
                    return console.error(e),
                    !1
                }
            }
            getAllCustomTrackNames() {
                let e;
                try {
                    e = (0,
                    R.gn)(this, Hd, "f").getAllKeys()
                } catch (e) {
                    return console.error(e),
                    null
                }
                return e.filter((e => e.startsWith((0,
                R.gn)(Vd, Vd, "f", au)))).map((e => e.substring((0,
                R.gn)(Vd, Vd, "f", au).length)))
            }
            saveUserProfileSlot(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", su), JSON.stringify(e))
                } catch (e) {
                    console.error(e)
                }
            }
            loadUserProfileSlot() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", su));
                    if (null != e)
                        try {
                            const t = parseInt(e, 10);
                            if (!Number.isSafeInteger(t) || t < 0)
                                throw new Error("Profile slot is invalid");
                            return t
                        } catch (e) {
                            console.error(e)
                        }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            saveUserProfile(e, t) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", ou) + e.toString(), JSON.stringify({
                        token: t.token,
                        nickname: t.nickname,
                        countryCode: t.countryCode,
                        carStyle: t.carStyle.serialize(),
                        isVerifier: t.isVerifier
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadUserProfile(e) {
                if (!Number.isSafeInteger(e) || e < 0)
                    throw new Error("Profile slot is invalid");
                try {
                    const t = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", ou) + e.toString());
                    if (null != t) {
                        const e = JSON.parse(t);
                        if (null == e || "object" != typeof e)
                            throw new Error("User profile is not an object");
                        if (!("token"in e) || "string" != typeof e.token)
                            throw new Error("User profile token field has invalid type");
                        if (!("nickname"in e) || "string" != typeof e.nickname)
                            throw new Error("User profile nickname field has invalid type");
                        if (!("countryCode"in e) || null !== e.countryCode && "string" != typeof e.countryCode)
                            throw new Error("User profile countryCode field has invalid type");
                        let n;
                        if (n = null == e.countryCode ? null : (0,
                        On.j)(e.countryCode),
                        !("carStyle"in e) || "string" != typeof e.carStyle)
                            throw new Error("User profile carStyle field has invalid type");
                        if (!("isVerifier"in e) || "boolean" != typeof e.isVerifier)
                            throw new Error("User profile isVerifier field has invalid type");
                        return new yu.A(e.token,e.nickname,n,Qt.A.deserializeSafe(e.carStyle),e.isVerifier)
                    }
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            deleteUserProfile(e) {
                try {
                    (0,
                    R.gn)(this, Hd, "f").removeItem((0,
                    R.gn)(Vd, Vd, "f", ou) + e.toString())
                } catch (e) {
                    console.error(e)
                }
            }
            saveIsMusicEnabled(e) {
                try {
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", lu), e.toString())
                } catch (e) {
                    console.error(e)
                }
            }
            loadIsMusicEnabled() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", lu));
                    return "true" == e || "false" != e
                } catch (e) {
                    return console.error(e),
                    !0
                }
            }
            saveSettings(e) {
                try {
                    const t = [];
                    for (const [n,i] of e.entries())
                        t.push([P.A[n], i]);
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", cu), JSON.stringify(t))
                } catch (e) {
                    console.error(e)
                }
            }
            loadSettings() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", cu));
                    if (null == e)
                        return null;
                    const t = JSON.parse(e);
                    if (!Array.isArray(t))
                        return null;
                    const n = [];
                    for (const e of t) {
                        if (!Array.isArray(e))
                            continue;
                        if (2 != e.length)
                            continue;
                        if ("string" != typeof e[0])
                            continue;
                        const t = e[0];
                        if (!(t in P.A))
                            continue;
                        const i = P.A[t];
                        if ("string" != typeof e[1])
                            continue;
                        const r = e[1];
                        n.push([i, r])
                    }
                    return n
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            saveKeyBindings(e) {
                try {
                    const t = [];
                    for (const [n,i] of e.entries())
                        t.push([me.A[n], i]);
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", hu), JSON.stringify(t))
                } catch (e) {
                    console.error(e)
                }
            }
            loadKeyBindings() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", hu));
                    if (null == e)
                        return null;
                    const t = JSON.parse(e);
                    if (!Array.isArray(t))
                        return null;
                    const n = [];
                    for (const e of t) {
                        if (!Array.isArray(e))
                            continue;
                        if (2 != e.length)
                            continue;
                        if ("string" != typeof e[0])
                            continue;
                        const t = e[0];
                        if (!(t in me.A))
                            continue;
                        const i = me.A[t]
                          , r = e[1];
                        Array.isArray(r) && (2 == r.length && (null !== r[0] && "string" != typeof r[0] || null !== r[1] && "string" != typeof r[1] || n.push([i, [r[0], r[1]]])))
                    }
                    return n
                } catch (e) {
                    console.error(e)
                }
                return null
            }
            saveTrackSelectionTab(e) {
                try {
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", du), e)
                } catch (e) {
                    console.error(e)
                }
            }
            loadTrackSelectionTab() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", du));
                    if ("official" == e || "community" == e || "custom" == e)
                        return e
                } catch (e) {
                    console.error(e)
                }
                return "official"
            }
            saveUnlockedCarStyles(e, t, n) {
                try {
                    const i = e.map((e => e))
                      , r = t.map((e => e))
                      , a = n.map((e => e));
                    (0,
                    R.gn)(this, Hd, "f").setItem((0,
                    R.gn)(Vd, Vd, "f", uu), JSON.stringify({
                        patterns: i,
                        rims: r,
                        exhausts: a
                    }))
                } catch (e) {
                    console.error(e)
                }
            }
            loadUnlockedCarStyles() {
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem((0,
                    R.gn)(Vd, Vd, "f", uu));
                    if (null == e)
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    const t = JSON.parse(e);
                    if (null == t || "object" != typeof t)
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    if (!("patterns"in t))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    if (!Array.isArray(t.patterns))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    const n = [];
                    for (const e of t.patterns) {
                        const t = e;
                        if ("number" != typeof t)
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Number.isSafeInteger(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Qt.A.isValidPattern(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        n.push(t)
                    }
                    if (!("rims"in t))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    if (!Array.isArray(t.rims))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    const i = [];
                    for (const e of t.rims) {
                        const t = e;
                        if ("number" != typeof t)
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Number.isSafeInteger(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Qt.A.isValidRims(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        i.push(t)
                    }
                    if (!("exhausts"in t))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    if (!Array.isArray(t.exhausts))
                        return {
                            patterns: [],
                            rims: [],
                            exhausts: []
                        };
                    const r = [];
                    for (const e of t.exhausts) {
                        const t = e;
                        if ("number" != typeof t)
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Number.isSafeInteger(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        if (!Qt.A.isValidExhaust(t))
                            return {
                                patterns: [],
                                rims: [],
                                exhausts: []
                            };
                        r.push(t)
                    }
                    return {
                        patterns: n,
                        rims: i,
                        exhausts: r
                    }
                } catch (e) {
                    return console.error(e),
                    {
                        patterns: [],
                        rims: [],
                        exhausts: []
                    }
                }
            }
        }
        Vd = wu,
        Hd = new WeakMap,
        Wd = new WeakSet,
        Kd = function() {
            try {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys();
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("car_colors");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (!Array.isArray(t) || 4 != t.length)
                            throw new Error("Old car colors is not an array of 4 color strings");
                        const n = t[0];
                        if ("string" != typeof n)
                            throw new Error("Old car colors primary color is not a string");
                        const i = t[1];
                        if ("string" != typeof i)
                            throw new Error("Old car colors secondary color is not a string");
                        const r = t[2];
                        if ("string" != typeof r)
                            throw new Error("Old car colors frame color is not a string");
                        const a = t[3];
                        if ("string" != typeof a)
                            throw new Error("Old car colors rims color is not a string");
                        (0,
                        R.gn)(this, Wd, "m", Zd).call(this, new Qt.A(Qt.A.defaultPattern,Qt.A.defaultRims,Qt.A.defaultExhaust,new C.Q1f(n).getHex(),new C.Q1f(i).getHex(),new C.Q1f(r).getHex(),new C.Q1f(a).getHex())),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("car_colors")
                    }
                } catch (e) {
                    console.error(e)
                }
                for (const t of e) {
                    if (t.startsWith("record_"))
                        try {
                            (0,
                            R.gn)(this, Hd, "f").removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("custom_track_"))
                        try {
                            const e = (0,
                            R.gn)(this, Hd, "f").getItem(t);
                            if (null != e) {
                                const n = pu.U(e);
                                if (null != n) {
                                    const {trackMetadata: e, trackData: i} = n;
                                    this.saveCustomTrack(e, i, new Date) && (0,
                                    R.gn)(this, Hd, "f").removeItem(t)
                                }
                            }
                        } catch (e) {
                            console.error(e)
                        }
                }
            } catch (e) {
                console.error(e)
            }
        }
        ,
        qd = function() {
            try {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys();
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("v1_car");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (!Array.isArray(t) || 4 != t.length)
                            throw new Error("Old car colors is not an array of 4 color strings");
                        const n = t[0];
                        if ("string" != typeof n)
                            throw new Error("Old car colors primary color is not a string");
                        const i = t[1];
                        if ("string" != typeof i)
                            throw new Error("Old car colors secondary color is not a string");
                        const r = t[2];
                        if ("string" != typeof r)
                            throw new Error("Old car colors frame color is not a string");
                        const a = t[3];
                        if ("string" != typeof a)
                            throw new Error("Old car colors rims color is not a string");
                        (0,
                        R.gn)(this, Wd, "m", Zd).call(this, new Qt.A(Qt.A.defaultPattern,Qt.A.defaultRims,Qt.A.defaultExhaust,new C.Q1f(n).getHex(),new C.Q1f(i).getHex(),new C.Q1f(r).getHex(),new C.Q1f(a).getHex())),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("v1_car")
                    }
                } catch (e) {
                    console.error(e)
                }
                for (const t of e) {
                    if (t.startsWith("v1_record_"))
                        try {
                            (0,
                            R.gn)(this, Hd, "f").removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    if (t.startsWith("v1_track_"))
                        try {
                            const e = (0,
                            R.gn)(this, Hd, "f").getItem(t);
                            if (null != e) {
                                const n = {
                                    name: t.substring(9),
                                    author: null,
                                    lastModified: null
                                }
                                  , i = fu._(e);
                                if (null == i)
                                    throw new Error("Failed to load v1 track for migration");
                                if (!this.saveCustomTrack(n, i, new Date))
                                    throw new Error("Failed to save v1 track for migration");
                                (0,
                                R.gn)(this, Hd, "f").removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                }
            } catch (e) {
                console.error(e)
            }
        }
        ,
        Qd = function() {
            try {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys();
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("v2_user");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (null == t || "object" != typeof t)
                            throw new Error("User profile is not an object");
                        if (!("token"in t) || null !== t.token && "string" != typeof t.token)
                            throw new Error("User profile token is not a string or null");
                        const n = t.token;
                        if (!("nickname"in t) || "string" != typeof t.nickname)
                            throw new Error("User profile nickname is not a string");
                        const i = t.nickname
                          , r = null
                          , a = Qt.A.default();
                        (0,
                        R.gn)(this, Wd, "m", Yd).call(this, n, i, r, a),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("v2_user")
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("v2_car");
                    if (null != e) {
                        const t = (0,
                        R.gn)(this, Wd, "m", $d).call(this, e);
                        (0,
                        R.gn)(this, Wd, "m", Zd).call(this, t),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("v2_car")
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    (0,
                    R.gn)(this, Hd, "f").removeItem("v2_settings")
                } catch (e) {
                    console.error(e)
                }
                try {
                    (0,
                    R.gn)(this, Hd, "f").removeItem("v2_key_bindings")
                } catch (e) {
                    console.error(e)
                }
                for (const t of e)
                    if (t.startsWith("v2_record_"))
                        try {
                            (0,
                            R.gn)(this, Hd, "f").removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    else if (t.startsWith("v2_track_"))
                        try {
                            const e = (0,
                            R.gn)(this, Hd, "f").getItem(t);
                            if (null != e) {
                                const n = {
                                    name: t.substring(9),
                                    author: null,
                                    lastModified: null
                                }
                                  , i = gu._(e);
                                if (null == i)
                                    throw new Error("Failed to load v2 track for migration");
                                if (!this.saveCustomTrack(n, i, new Date))
                                    throw new Error("Failed to save v2 track for migration");
                                (0,
                                R.gn)(this, Hd, "f").removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
            } catch (e) {
                console.error(e)
            }
        }
        ,
        Jd = function() {
            try {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys();
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v3_user_slot");
                    if (null != e) {
                        const t = Number.parseInt(e, 10);
                        Number.isSafeInteger(t) && t >= 0 && t <= 2 && (this.saveUserProfileSlot(t),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("polytrack_v3_user_slot"))
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v3_settings");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (Array.isArray(t)) {
                            const e = new Map;
                            for (const n of t) {
                                if (!Array.isArray(n) || 2 != n.length)
                                    continue;
                                const t = n[0];
                                if ("string" != typeof t || !(t in P.A))
                                    continue;
                                const i = n[1];
                                "string" == typeof i && e.set(P.A[t], i)
                            }
                            this.saveSettings(e),
                            (0,
                            R.gn)(this, Hd, "f").removeItem("polytrack_v3_settings")
                        }
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v3_key_bindings");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (Array.isArray(t)) {
                            const e = new Map;
                            for (const n of t) {
                                if (!Array.isArray(n) || 2 != n.length)
                                    continue;
                                const t = n[0];
                                if ("string" != typeof t || !(t in me.A))
                                    continue;
                                const i = n[1];
                                if (!Array.isArray(i) || 2 != i.length)
                                    continue;
                                const r = i[0];
                                if (null !== r && "string" != typeof r)
                                    continue;
                                const a = i[1];
                                null !== a && "string" != typeof a || e.set(me.A[t], [r, a])
                            }
                            this.saveKeyBindings(e),
                            (0,
                            R.gn)(this, Hd, "f").removeItem("polytrack_v3_key_bindings")
                        }
                    }
                } catch (e) {
                    console.error(e)
                }
                for (const t of e)
                    if (t.startsWith("polytrack_v3_user_")) {
                        let e;
                        switch (t) {
                        case "polytrack_v3_user_0":
                            e = 0;
                            break;
                        case "polytrack_v3_user_1":
                            e = 1;
                            break;
                        case "polytrack_v3_user_2":
                            e = 2;
                            break;
                        default:
                            e = null
                        }
                        if (null != e)
                            try {
                                const n = (0,
                                R.gn)(this, Hd, "f").getItem(t);
                                if (null != n) {
                                    const i = JSON.parse(n);
                                    if (null == i || "object" != typeof i)
                                        throw new Error("User profile is not an object");
                                    if (!("token"in i) || null != i.token && "string" != typeof i.token)
                                        throw new Error("User profile token field has invalid type");
                                    if (!("nickname"in i) || "string" != typeof i.nickname)
                                        throw new Error("User profile nickname field has invalid type");
                                    if (!("carColors"in i) || "string" != typeof i.carColors)
                                        throw new Error("User profile carColors field has invalid type");
                                    const r = i.token
                                      , a = i.nickname
                                      , s = null
                                      , o = (0,
                                    R.gn)(this, Wd, "m", $d).call(this, i.carColors);
                                    this.saveUserProfile(e, new yu.A(r ?? vu.A.createToken(),a,s,o,!1)),
                                    (0,
                                    R.gn)(this, Hd, "f").removeItem(t)
                                }
                            } catch (e) {
                                console.error(e)
                            }
                    } else if (t.startsWith("polytrack_v3_record_"))
                        try {
                            (0,
                            R.gn)(this, Hd, "f").removeItem(t)
                        } catch (e) {
                            console.error(e)
                        }
                    else if (t.startsWith("polytrack_v3_track_"))
                        try {
                            const e = (0,
                            R.gn)(this, Hd, "f").getItem(t);
                            if (null != e) {
                                const n = {
                                    name: t.substring(19),
                                    author: null,
                                    lastModified: null
                                }
                                  , i = JSON.parse(e);
                                if (null == i || "object" != typeof i)
                                    throw new Error("Track data is not an object");
                                if (!("data"in i) || "string" != typeof i.data)
                                    throw new Error("Track data field is invalid");
                                if (!("saveTime"in i) || "number" != typeof i.saveTime || !Number.isSafeInteger(i.saveTime) || i.saveTime < 0)
                                    throw new Error("Track save time field is invalid");
                                const r = mu._(i.data);
                                if (null == r)
                                    throw new Error("Failed to load v3 track for migration");
                                if (!this.saveCustomTrack(n, r, new Date(i.saveTime)))
                                    throw new Error("Failed to save v3 track for migration");
                                (0,
                                R.gn)(this, Hd, "f").removeItem(t)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                try {
                    (0,
                    R.gn)(this, Hd, "f").removeItem("polytrack_v3_migrated")
                } catch (e) {
                    console.error(e)
                }
            } catch (e) {
                console.error(e)
            }
        }
        ,
        Xd = function() {
            try {
                const e = (0,
                R.gn)(this, Hd, "f").getAllKeys();
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v4_prod_user_slot");
                    if (null != e) {
                        const t = Number.parseInt(e, 10);
                        Number.isSafeInteger(t) && t >= 0 && t <= 2 && (this.saveUserProfileSlot(t),
                        (0,
                        R.gn)(this, Hd, "f").removeItem("polytrack_v4_prod_user_slot"))
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v4_prod_settings");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (Array.isArray(t)) {
                            const e = new Map;
                            for (const n of t) {
                                if (!Array.isArray(n) || 2 != n.length)
                                    continue;
                                const t = n[0];
                                if ("string" != typeof t || !(t in P.A))
                                    continue;
                                const i = n[1];
                                "string" == typeof i && e.set(P.A[t], i)
                            }
                            this.saveSettings(e),
                            (0,
                            R.gn)(this, Hd, "f").removeItem("polytrack_v4_prod_settings")
                        }
                    }
                } catch (e) {
                    console.error(e)
                }
                try {
                    const e = (0,
                    R.gn)(this, Hd, "f").getItem("polytrack_v4_prod_key_bindings");
                    if (null != e) {
                        const t = JSON.parse(e);
                        if (Array.isArray(t)) {
                            const e = new Map;
                            for (const n of t) {
                                if (!Array.isArray(n) || 2 != n.length)
                                    continue;
                                const t = n[0];
                                if ("string" != typeof t || !(t in me.A))
                                    continue;
                                const i = n[1];
                                if (!Array.isArray(i) || 2 != i.length)
                                    continue;
                                const r = i[0];
                                if (null !== r && "string" != typeof r)
                                    continue;
                                const a = i[1];
                                if (null !== a && "string" != typeof a)
                                    continue;
                                const s = me.A[t];
                                s != me.A.ToggleFpsCounter && s != me.A.ToggleSpectatorCamera && e.set(s, [r, a])
                            }
                            this.saveKeyBindings(e),
                            (0,
                            R.gn)(this, Hd, "f").removeItem("polytrack_v4_prod_key_bindings")
                        }
                    }
                } catch (e) {
                    console.error(e)
                }
                let t = !1;
                for (const n of e)
                    if (n.startsWith("polytrack_v4_prod_user_")) {
                        let e;
                        switch (n) {
                        case "polytrack_v4_prod_user_0":
                            e = 0;
                            break;
                        case "polytrack_v4_prod_user_1":
                            e = 1;
                            break;
                        case "polytrack_v4_prod_user_2":
                            e = 2;
                            break;
                        default:
                            e = null
                        }
                        if (null != e)
                            try {
                                const i = (0,
                                R.gn)(this, Hd, "f").getItem(n);
                                if (null != i) {
                                    const r = JSON.parse(i);
                                    if (null == r || "object" != typeof r)
                                        throw new Error("User profile is not an object");
                                    if (!("token"in r) || "string" != typeof r.token)
                                        throw new Error("User profile token field has invalid type");
                                    if (!("nickname"in r) || "string" != typeof r.nickname)
                                        throw new Error("User profile nickname field has invalid type");
                                    if (!("carColors"in r) || "string" != typeof r.carColors)
                                        throw new Error("User profile carColors field has invalid type");
                                    const a = r.token
                                      , s = r.nickname
                                      , o = null
                                      , l = (0,
                                    R.gn)(this, Wd, "m", $d).call(this, r.carColors);
                                    this.saveUserProfile(e, new yu.A(a,s,o,l,!1)),
                                    (0,
                                    R.gn)(this, Hd, "f").removeItem(n),
                                    t = !0
                                }
                            } catch (e) {
                                console.error(e)
                            }
                    } else if (n.startsWith("polytrack_v4_prod_record_"))
                        try {
                            (0,
                            R.gn)(this, Hd, "f").removeItem(n)
                        } catch (e) {
                            console.error(e)
                        }
                    else if (n.startsWith("polytrack_v4_prod_track_"))
                        try {
                            const e = (0,
                            R.gn)(this, Hd, "f").getItem(n);
                            if (null != e) {
                                const t = JSON.parse(e);
                                if (null == t || "object" != typeof t)
                                    throw new Error("Track data is not an object");
                                if (!("data"in t) || "string" != typeof t.data)
                                    throw new Error("Track data field is invalid");
                                if (!("saveTime"in t) || "number" != typeof t.saveTime || !Number.isSafeInteger(t.saveTime) || t.saveTime < 0)
                                    throw new Error("Track save time field is invalid");
                                const i = Au.U(t.data);
                                if (null == i)
                                    throw new Error("Failed to load p1 track for migration");
                                if (!this.saveCustomTrack(i.trackMetadata, i.trackData, new Date(t.saveTime)))
                                    throw new Error("Failed to save p1 track for migration");
                                (0,
                                R.gn)(this, Hd, "f").removeItem(n)
                            }
                        } catch (e) {
                            console.error(e)
                        }
                t && this.saveStartupInfo("0.5.2");
                try {
                    (0,
                    R.gn)(this, Hd, "f").removeItem("polytrack_v4_prod_migrated")
                } catch (e) {
                    console.error(e)
                }
            } catch (e) {
                console.error(e)
            }
        }
        ,
        Yd = function(e, t, n, i) {
            null == this.loadUserProfile(0) && this.saveUserProfile(0, new yu.A(e ?? vu.A.createToken(),t,n,i,!1))
        }
        ,
        Zd = function(e) {
            const t = this.loadUserProfile(0);
            null == t ? this.saveUserProfile(0, new yu.A(vu.A.createToken(),vu.A.defaultNickname,null,e,!1)) : this.saveUserProfile(0, new yu.A(t.token,t.nickname,t.countryCode,e,!1))
        }
        ,
        $d = function(e) {
            const t = [];
            for (let n = 0; n < 4; n++) {
                const i = e.substring(6 * n, 6 * (n + 1));
                /^[0-9a-f]{6}$/i.test(i) ? t.push(new C.Q1f("#" + i)) : t.push(new C.Q1f("#555"))
            }
            return new Qt.A(Qt.A.defaultPattern,Qt.A.defaultRims,Qt.A.defaultExhaust,t[0].getHex(),t[1].getHex(),t[2].getHex(),t[3].getHex())
        }
        ,
        tu = function() {
            try {
                (0,
                R.gn)(this, Hd, "f").setItem((0,
                R.gn)(Vd, Vd, "f", eu), "")
            } catch (e) {
                console.error(e)
            }
        }
        ,
        nu = function() {
            try {
                if (null != (0,
                R.gn)(this, Hd, "f").getItem((0,
                R.gn)(Vd, Vd, "f", eu)))
                    return "v5";
                if (null != (0,
                R.gn)(this, Hd, "f").getItem("polytrack_v4_prod_migrated"))
                    return "v4";
                if (null != (0,
                R.gn)(this, Hd, "f").getItem("polytrack_v3_migrated"))
                    return "v3"
            } catch (e) {
                console.error(e)
            }
            return null
        }
        ,
        jd = {
            value: ( () => {
                let e = "polytrack_v5_";
                return Pt.EM ? e += "dev_" : Pt.Tn ? e += "beta_" : e += "prod_",
                e
            }
            )()
        },
        eu = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "migrated"
        },
        iu = {
            value: Pt.Tn ? (0,
            R.gn)(Vd, Vd, "f", jd) + "startup_info" + Pt.GK.toString() : (0,
            R.gn)(Vd, Vd, "f", jd) + "startup_info"
        },
        ru = {
            value: Pt.Tn ? (0,
            R.gn)(Vd, Vd, "f", jd) + "record" + Pt.GK.toString() + "_" : (0,
            R.gn)(Vd, Vd, "f", jd) + "record_"
        },
        au = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "track_"
        },
        su = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "user_slot"
        },
        ou = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "user_"
        },
        lu = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "is_music_enabled"
        },
        cu = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "settings"
        },
        hu = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "key_bindings"
        },
        du = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "selected_track_tab"
        },
        uu = {
            value: (0,
            R.gn)(Vd, Vd, "f", jd) + "unlocked_car_styles"
        };
        const bu = wu;
        var xu, Su, Eu, Tu, ku, Mu, _u, Cu, Ru;
        class Pu {
            constructor() {
                xu.add(this),
                Eu.set(this, void 0),
                Tu.set(this, !1),
                ku.set(this, null),
                Mu.set(this, !1);
                const e = document.getElementById("ui");
                if (null == e)
                    throw new Error("Failed to find UI element");
                (0,
                R.GG)(this, Eu, e, "f"),
                window.addEventListener("mousemove", ( () => {
                    document.body.classList.remove("hide-cursor"),
                    (0,
                    R.GG)(this, Mu, !1, "f"),
                    (0,
                    R.gn)(this, Tu, "f") && (null != (0,
                    R.gn)(this, ku, "f") && clearTimeout((0,
                    R.gn)(this, ku, "f")),
                    (0,
                    R.GG)(this, ku, setTimeout(( () => {
                        document.body.classList.add("hide-cursor"),
                        (0,
                        R.GG)(this, Mu, !0, "f"),
                        (0,
                        R.GG)(this, ku, null, "f")
                    }
                    ), (0,
                    R.gn)(Su, Su, "f", _u)), "f"))
                }
                )),
                document.addEventListener("gesturestart", (function(e) {
                    e.preventDefault()
                }
                )),
                window.addEventListener("resize", ( () => {
                    (0,
                    R.gn)(this, xu, "m", Ru).call(this)
                }
                )),
                (0,
                R.gn)(this, xu, "m", Ru).call(this)
            }
            setCursorHiddenWhenInactive(e) {
                (0,
                R.GG)(this, Tu, e, "f"),
                e ? (0,
                R.GG)(this, ku, setTimeout(( () => {
                    document.body.classList.add("hide-cursor"),
                    (0,
                    R.GG)(this, Mu, !0, "f"),
                    (0,
                    R.GG)(this, ku, null, "f")
                }
                ), (0,
                R.gn)(Su, Su, "f", _u)), "f") : (document.body.classList.remove("hide-cursor"),
                null != (0,
                R.gn)(this, ku, "f") && (clearTimeout((0,
                R.gn)(this, ku, "f")),
                (0,
                R.GG)(this, Mu, !1, "f"),
                (0,
                R.GG)(this, ku, null, "f")))
            }
            get isCursorHidden() {
                return (0,
                R.gn)(this, Mu, "f")
            }
            setInert(e) {
                e ? (0,
                R.gn)(this, Eu, "f").setAttribute("inert", "") : (0,
                R.gn)(this, Eu, "f").removeAttribute("inert")
            }
        }
        Su = Pu,
        Eu = new WeakMap,
        Tu = new WeakMap,
        ku = new WeakMap,
        Mu = new WeakMap,
        xu = new WeakSet,
        Cu = function() {
            return Math.max(.01, Math.min(1, Math.min(window.innerWidth, 1.4375 * window.innerHeight) / 1150))
        }
        ,
        Ru = function() {
            const e = (0,
            R.gn)(this, xu, "m", Cu).call(this);
            e < 1 ? ((0,
            R.gn)(this, Eu, "f").style.width = "calc(100% / " + e.toString() + ")",
            (0,
            R.gn)(this, Eu, "f").style.height = "calc(100% / " + e.toString() + ")",
            (0,
            R.gn)(this, Eu, "f").style.transform = "scale(" + e.toString() + ")",
            document.documentElement.style.setProperty("--ui-scale-factor", e.toString())) : ((0,
            R.gn)(this, Eu, "f").style.width = "",
            (0,
            R.gn)(this, Eu, "f").style.height = "",
            (0,
            R.gn)(this, Eu, "f").style.transform = "",
            document.documentElement.style.setProperty("--ui-scale-factor", "1.0"));
            const t = window.getComputedStyle(document.documentElement).getPropertyValue("--safe-area-left-unscaled")
              , n = window.getComputedStyle(document.documentElement).getPropertyValue("--safe-area-right-unscaled");
            "0px" != t && "0.0px" != t && "0" != t || "0px" != n && "0.0px" != n && "0" != n ? (0,
            R.gn)(this, Eu, "f").classList.add("has-safe-area-horizontal") : (0,
            R.gn)(this, Eu, "f").classList.remove("has-safe-area-horizontal")
        }
        ,
        _u = {
            value: 1e3
        };
        const Iu = Pu;
        var Lu, Nu, zu, Uu, Du = i(5408);
        Lu = new WeakMap,
        Nu = new WeakMap,
        zu = new WeakMap,
        Uu = new WeakMap;
        const Bu = class {
            constructor() {
                this.determinismState = oo.Uninitialized,
                Lu.set(this, 2e4),
                Nu.set(this, 6e4),
                zu.set(this, 1e4),
                Uu.set(this, "v6/")
            }
            getLeaderboard(e, t, n, i, r) {
                let a = Pt.y0 + (0,
                R.gn)(this, Uu, "f") + "leaderboard?version=" + Pt.rE + "&trackId=" + t + "&skip=" + n.toString() + "&amount=" + i.toString() + "&onlyVerified=" + r.toString();
                return this.determinismState == oo.Ok && (a += "&userTokenHash=" + encodeURIComponent(e)),
                new Promise(( (t, n) => {
                    const i = new XMLHttpRequest;
                    i.timeout = (0,
                    R.gn)(this, Lu, "f"),
                    i.overrideMimeType("text/plain"),
                    i.onreadystatechange = () => {
                        if (i.readyState == XMLHttpRequest.DONE)
                            if (200 == i.status)
                                try {
                                    const r = JSON.parse(i.responseText);
                                    if (null == r || "object" != typeof r)
                                        return void n(new Error("JSON is not an object"));
                                    if (!("total"in r) || "number" != typeof r.total)
                                        return void n(new Error("Total is not a number"));
                                    if (!Number.isSafeInteger(r.total))
                                        return void n(new Error("Total is not a safe integer"));
                                    const a = r.total;
                                    if (!("entries"in r))
                                        return void n(new Error("Entries field does not exist"));
                                    const s = r.entries;
                                    if (!Array.isArray(s))
                                        return void n(new Error("Entries is not an array"));
                                    const o = [];
                                    for (const t of s) {
                                        if (null == t || "object" != typeof t)
                                            return void n(new Error("Entry is not an object"));
                                        if (!("id"in t))
                                            return void n(new Error('Entry is missing "id" field'));
                                        if (!("userId"in t))
                                            return void n(new Error('Entry is missing "userId" field'));
                                        if (!("nickname"in t))
                                            return void n(new Error('Entry is missing "nickname" field'));
                                        if (!("frames"in t))
                                            return void n(new Error('Entry is missing "frames" field'));
                                        if (!("carStyle"in t))
                                            return void n(new Error('Entry is missing "carStyle" field'));
                                        if (!("verifiedState"in t))
                                            return void n(new Error('Entry is missing "verifiedState" field'));
                                        if (!("countryCode"in t))
                                            return void n(new Error('Entry is missing "countryCode" field'));
                                        if ("number" != typeof t.id)
                                            return void n(new Error('"id" field has incorrect type'));
                                        if ("string" != typeof t.userId)
                                            return void n(new Error('"userId" field has incorrect type'));
                                        if ("string" != typeof t.nickname)
                                            return void n(new Error('"nickname" field has incorrect type'));
                                        if ("number" != typeof t.verifiedState)
                                            return void n(new Error('"verifiedState" field has incorrect type'));
                                        if (null != t.countryCode && "string" != typeof t.countryCode)
                                            return void n(new Error('"countryCode" field has incorrect type'));
                                        let i;
                                        if (i = null == t.countryCode ? null : (0,
                                        On.j)(t.countryCode),
                                        "number" != typeof t.frames)
                                            return void n(new Error('"frames" field has incorrect type'));
                                        if (!Number.isSafeInteger(t.frames) || t.frames <= 0 || t.frames > re.A.maxFrames)
                                            return void n(new Error('"frames" field has an invalid value'));
                                        if ("string" != typeof t.carStyle)
                                            return void n(new Error('"carStyle" field has incorrect type'));
                                        if (!Number.isSafeInteger(t.verifiedState) || t.verifiedState < 0)
                                            return void n(new Error('"verifiedState" field has an invalid value'));
                                        o.push({
                                            id: t.id,
                                            nickname: t.nickname,
                                            countryCode: i,
                                            time: new wt.A(t.frames),
                                            carStyle: Qt.A.deserializeSafe(t.carStyle),
                                            verifiedState: t.verifiedState,
                                            isSelf: t.userId == e
                                        })
                                    }
                                    if (!("userEntry"in r))
                                        return void n(new Error("User entry field does not exist"));
                                    let l = null;
                                    if (null != r.userEntry) {
                                        if ("object" != typeof r.userEntry)
                                            return void n(new Error("User entry is not an object"));
                                        if (!("position"in r.userEntry) || "number" != typeof r.userEntry.position)
                                            return void n(new Error("User position is not a number"));
                                        if (!Number.isSafeInteger(r.userEntry.position))
                                            return void n(new Error("User position is not a safe integer"));
                                        const e = r.userEntry.position;
                                        if (!("frames"in r.userEntry) || "number" != typeof r.userEntry.frames)
                                            return void n(new Error("User frames is not a number"));
                                        if (!Number.isSafeInteger(r.userEntry.frames))
                                            return void n(new Error("User frames is not a safe integer"));
                                        const t = r.userEntry.frames
                                          , i = new wt.A(t);
                                        if (!("id"in r.userEntry) || "number" != typeof r.userEntry.id)
                                            return void n(new Error("User record id is not a number"));
                                        if (!Number.isSafeInteger(r.userEntry.id))
                                            return void n(new Error("User record id is not a safe integer"));
                                        l = {
                                            position: e,
                                            time: i,
                                            id: r.userEntry.id
                                        }
                                    }
                                    t({
                                        total: a,
                                        entries: o,
                                        userEntry: l
                                    })
                                } catch (e) {
                                    n(new Error("Unknown error: " + String(e)))
                                }
                            else
                                t({
                                    total: 0,
                                    entries: [],
                                    userEntry: null
                                })
                    }
                    ,
                    i.open("GET", a, !0),
                    i.send()
                }
                ))
            }
            getLeaderboardUserEntry(e, t, n) {
                const i = Pt.y0 + (0,
                R.gn)(this, Uu, "f") + "leaderboardUserEntry?version=" + Pt.rE + "&trackId=" + t + "&userTokenHash=" + encodeURIComponent(e) + "&onlyVerified=" + n.toString();
                return new Promise(( (e, t) => {
                    const n = new XMLHttpRequest;
                    n.timeout = (0,
                    R.gn)(this, Lu, "f"),
                    n.overrideMimeType("text/plain"),
                    n.onreadystatechange = () => {
                        if (n.readyState == XMLHttpRequest.DONE)
                            if (200 == n.status)
                                try {
                                    const i = JSON.parse(n.responseText);
                                    if (null == i)
                                        return void e(null);
                                    if ("object" != typeof i)
                                        return void t(new Error("Response is not an object"));
                                    if (!("position"in i) || "number" != typeof i.position)
                                        return void t(new Error("Position is not a number"));
                                    if (!Number.isSafeInteger(i.position))
                                        return void t(new Error("Position is not a safe integer"));
                                    const r = i.position;
                                    if (!("frames"in i) || "number" != typeof i.frames)
                                        return void t(new Error("Frames is not a number"));
                                    if (!Number.isSafeInteger(i.frames))
                                        return void t(new Error("Frames is not a safe integer"));
                                    const a = i.frames
                                      , s = new wt.A(a);
                                    if (!("id"in i) || "number" != typeof i.id)
                                        return void t(new Error("Record id is not a number"));
                                    if (!Number.isSafeInteger(i.id))
                                        return void t(new Error("Record id is not a safe integer"));
                                    const o = i.id;
                                    e({
                                        position: r,
                                        time: s,
                                        id: o
                                    })
                                } catch (e) {
                                    t(new Error("Unknown error: " + String(e)))
                                }
                            else
                                t(new Error("Failed to connect to server"))
                    }
                    ,
                    n.open("GET", i, !0),
                    n.send()
                }
                ))
            }
            getRecordings(e) {
                const t = Pt.y0 + (0,
                R.gn)(this, Uu, "f") + "recordings?version=" + Pt.rE + "&ids=" + e.join(",");
                return new Promise(( (e, n) => {
                    if (this.determinismState != oo.Ok)
                        n(new Error("Getting recordings not allowed"));
                    else {
                        const i = new XMLHttpRequest;
                        i.timeout = (0,
                        R.gn)(this, Lu, "f"),
                        i.overrideMimeType("text/plain"),
                        i.onreadystatechange = () => {
                            if (i.readyState == XMLHttpRequest.DONE)
                                if (200 == i.status)
                                    try {
                                        const t = JSON.parse(i.responseText);
                                        if (!Array.isArray(t))
                                            return void n(new Error("Response is not an array"));
                                        const r = [];
                                        for (const e of t) {
                                            if (null == e) {
                                                r.push(null);
                                                continue
                                            }
                                            if ("object" != typeof e)
                                                return void n(new Error("JSON item is not an object"));
                                            if (!("recording"in e) || "string" != typeof e.recording)
                                                return void n(new Error("JSON item recording field has incorrect type"));
                                            const t = re.A.deserialize(e.recording);
                                            if (null == t)
                                                return void n(new Error("Failed to deserialize recording"));
                                            if (!("verifiedState"in e) || "number" != typeof e.verifiedState)
                                                return void n(new Error("JSON item verifiedState field has incorrect type"));
                                            const i = e.verifiedState;
                                            if (!Number.isSafeInteger(i) || i < 0)
                                                return void n(new Error("JSON item verifiedState is not a safe integer"));
                                            if (!("frames"in e) || "number" != typeof e.frames)
                                                return void n(new Error("JSON item frames field has incorrect type"));
                                            const a = e.frames;
                                            if (!Number.isSafeInteger(a) || a <= 0 || a > re.A.maxFrames)
                                                return void n(new Error("JSON item frames is not a safe integer"));
                                            const s = new wt.A(a);
                                            if (!("carStyle"in e) || "string" != typeof e.carStyle)
                                                return void n(new Error("JSON item carStyle field has incorrect type"));
                                            const o = Qt.A.deserializeSafe(e.carStyle);
                                            r.push({
                                                recording: t,
                                                time: s,
                                                verifiedState: i,
                                                carStyle: o
                                            })
                                        }
                                        e(r)
                                    } catch (e) {
                                        n(new Error("Unknown error: " + String(e)))
                                    }
                                else
                                    e([])
                        }
                        ,
                        i.open("GET", t, !0),
                        i.send()
                    }
                }
                ))
            }
            submitLeaderboard(e, t, n, i, r, a, s, o) {
                return new Promise(( (l, c) => {
                    if (this.determinismState != oo.Ok)
                        c(new Error("Submit not allowed"));
                    else {
                        const h = o.serialize();
                        if (h.length >= (0,
                        R.gn)(this, zu, "f"))
                            c(new Error("Recording is too large"));
                        else {
                            const o = Pt.y0 + (0,
                            R.gn)(this, Uu, "f") + "leaderboard";
                            let d = "version=" + Pt.rE + "&userToken=" + encodeURIComponent(e) + "&nickname=" + encodeURIComponent(t) + (null == n ? "" : "&countryCode=" + encodeURIComponent(n)) + "&carStyle=" + i.serialize() + "&trackId=" + r + "&frames=" + s.numberOfFrames.toString() + "&recording=" + h;
                            null != a && (d += "&onlyVerified=" + a.toString());
                            const u = new XMLHttpRequest;
                            u.timeout = (0,
                            R.gn)(this, Lu, "f"),
                            u.overrideMimeType("text/plain"),
                            u.onreadystatechange = () => {
                                if (4 == u.readyState)
                                    if (200 == u.status)
                                        try {
                                            const e = JSON.parse(u.responseText);
                                            if ("number" == typeof e || null === e) {
                                                const t = e;
                                                if (null !== t && "number" != typeof t)
                                                    return void c(new Error("UploadId is not a number or null"));
                                                if (!Number.isSafeInteger(t))
                                                    return void c(new Error("UploadId is not a safe integer"));
                                                l({
                                                    uploadId: t,
                                                    positionChange: null
                                                })
                                            } else {
                                                if ("object" != typeof e)
                                                    return void c(new Error("Response is not an object"));
                                                if (!("uploadId"in e))
                                                    return void c(new Error('Field "uploadId" does not exist'));
                                                if ("number" != typeof e.uploadId && null !== e.uploadId)
                                                    return void c(new Error('Field "uploadId" is not a number or null'));
                                                const t = e.uploadId;
                                                if (null !== t && "number" != typeof t)
                                                    return void c(new Error("UploadId is not a number or null"));
                                                if (!Number.isSafeInteger(t))
                                                    return void c(new Error("UploadId is not a safe integer"));
                                                if (!("previousPosition"in e))
                                                    return void c(new Error('Field "previousPosition" does not exist'));
                                                if ("number" != typeof e.previousPosition)
                                                    return void c(new Error('Field "previousPosition" is not a number'));
                                                const n = e.previousPosition;
                                                if (!Number.isSafeInteger(n) || n < 0)
                                                    return void c(new Error("PreviousPosition is not a safe positive integer"));
                                                if (!("newPosition"in e))
                                                    return void c(new Error('Field "newPosition" does not exist'));
                                                if ("number" != typeof e.newPosition)
                                                    return void c(new Error('Field "newPosition" is not a number or null'));
                                                const i = e.newPosition;
                                                if (!Number.isSafeInteger(i) || i < 0)
                                                    return void c(new Error("NewPosition is not a safe positive integer"));
                                                l({
                                                    uploadId: t,
                                                    positionChange: {
                                                        previousPosition: n,
                                                        newPosition: i
                                                    }
                                                })
                                            }
                                        } catch (e) {
                                            c(new Error("Unknown error: " + String(e)))
                                        }
                                    else
                                        c(new Error("Failed to connect to server"))
                            }
                            ,
                            u.open("POST", o, !0),
                            u.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                            u.send(d)
                        }
                    }
                }
                ))
            }
            submitUserProfile(e, t, n, i) {
                return new Promise(( (r, a) => {
                    const s = Pt.y0 + (0,
                    R.gn)(this, Uu, "f") + "user"
                      , o = "version=" + Pt.rE + "&userToken=" + encodeURIComponent(e) + "&nickname=" + encodeURIComponent(t) + (null == n ? "" : "&countryCode=" + encodeURIComponent(n)) + "&carStyle=" + i.serialize()
                      , l = new XMLHttpRequest;
                    l.timeout = (0,
                    R.gn)(this, Lu, "f"),
                    l.overrideMimeType("text/plain"),
                    l.onreadystatechange = () => {
                        4 == l.readyState && (200 == l.status ? r() : a(new Error("Failed to connect to server")))
                    }
                    ,
                    l.open("POST", s, !0),
                    l.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                    l.send(o)
                }
                ))
            }
            verifyRecordings(e, t, n, i, r) {
                return new Promise(( (a, s) => {
                    if (this.determinismState != oo.Ok)
                        s(new Error("Submit not allowed"));
                    else {
                        const o = Pt.y0 + (0,
                        R.gn)(this, Uu, "f") + "verifyRecordings"
                          , l = "version=" + Pt.rE + "&userToken=" + encodeURIComponent(e) + (null != t ? "&trackId=" + t : "") + "&maxFrames=" + n.toString() + "&getEstimatedRemaining=" + i.toString() + "&recordings=" + encodeURIComponent(JSON.stringify(r))
                          , c = new XMLHttpRequest;
                        c.timeout = (0,
                        R.gn)(this, Nu, "f"),
                        c.overrideMimeType("text/plain"),
                        c.onreadystatechange = () => {
                            if (4 == c.readyState)
                                if (200 == c.status)
                                    try {
                                        if ("" == c.responseText)
                                            return void a({
                                                unverifiedRecordings: [],
                                                exhaustive: !0,
                                                estimatedRemaining: 0
                                            });
                                        const e = JSON.parse(c.responseText);
                                        if (null == e || "object" != typeof e)
                                            return void s(new Error("Response is not an object"));
                                        if (!("exhaustive"in e))
                                            return void s(new Error('Field "exhaustive" does not exist'));
                                        const t = 1 == e.exhaustive;
                                        if (!("estimatedRemaining"in e))
                                            return void s(new Error('Field "estimatedRemaining" does not exist'));
                                        let n;
                                        if (null == e.estimatedRemaining)
                                            n = null;
                                        else {
                                            if ("number" != typeof e.estimatedRemaining)
                                                return void s(new Error("Estimated remaining is not a number"));
                                            if (n = e.estimatedRemaining,
                                            !Number.isSafeInteger(n) || n < 0)
                                                return void s(new Error("Estimated remaining is not a valid integer"))
                                        }
                                        if (!("unverifiedRecordings"in e))
                                            return void s(new Error('Field "unverifiedRecordings" does not exist'));
                                        if (!Array.isArray(e.unverifiedRecordings))
                                            return void s(new Error('Field "unverifiedRecordings" is not an array'));
                                        const i = [];
                                        for (const t of e.unverifiedRecordings) {
                                            if (null == t || "object" != typeof t)
                                                return void s(new Error("Recording is not an object"));
                                            if (!("id"in t) || "number" != typeof t.id || !Number.isSafeInteger(t.id))
                                                return void s(new Error("Recording id is not a valid integer"));
                                            if (!("recording"in t) || "string" != typeof t.recording)
                                                return void s(new Error("Recording recording is not a string"));
                                            if (!("frames"in t) || "number" != typeof t.frames || !Number.isSafeInteger(t.frames) || t.frames <= 0 || t.frames > re.A.maxFrames)
                                                return void s(new Error("Recording frames is not a valid integer"));
                                            i.push({
                                                id: t.id,
                                                recording: t.recording,
                                                frames: t.frames
                                            })
                                        }
                                        a({
                                            unverifiedRecordings: i,
                                            exhaustive: t,
                                            estimatedRemaining: n
                                        })
                                    } catch (e) {
                                        s(new Error("Unknown error: " + String(e)))
                                    }
                                else
                                    403 == c.status ? s(new Error("User is not a verifier")) : s(new Error("Failed to connect to server"))
                        }
                        ,
                        c.open("POST", o, !0),
                        c.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
                        c.send(l)
                    }
                }
                ))
            }
            getUser(e) {
                return new Promise(( (t, n) => {
                    const i = Pt.y0 + (0,
                    R.gn)(this, Uu, "f") + "user?version=" + Pt.rE + "&userToken=" + encodeURIComponent(e)
                      , r = new XMLHttpRequest;
                    r.timeout = (0,
                    R.gn)(this, Lu, "f"),
                    r.overrideMimeType("text/plain"),
                    r.onreadystatechange = () => {
                        if (r.readyState == XMLHttpRequest.DONE)
                            if (200 == r.status)
                                try {
                                    const e = JSON.parse(r.responseText);
                                    if (null == e)
                                        return void t(null);
                                    if ("object" != typeof e)
                                        return void n(new Error("Response is not an object"));
                                    if (!("nickname"in e) || "string" != typeof e.nickname)
                                        return void n(new Error("Nickname is not a string"));
                                    const i = e.nickname
                                      , a = (0,
                                    Du.k)(i);
                                    if (0 == a || a > 50)
                                        return void n(new Error("Nickname has invalid length"));
                                    if (!("countryCode"in e) || null !== e.countryCode && "string" != typeof e.countryCode)
                                        return void n(new Error("CountryCode is not a string or null"));
                                    let s;
                                    if (s = null == e.countryCode ? null : (0,
                                    On.j)(e.countryCode),
                                    !("carStyle"in e) || "string" != typeof e.carStyle)
                                        return void n(new Error("CarStyle data is not a string"));
                                    const o = Qt.A.deserializeSafe(e.carStyle);
                                    if (!("isVerifier"in e) || "boolean" != typeof e.isVerifier)
                                        return void n(new Error("IsVerifier is not a boolean"));
                                    const l = e.isVerifier;
                                    t({
                                        nickname: i,
                                        countryCode: s,
                                        carStyle: o,
                                        isVerifier: l
                                    })
                                } catch (e) {
                                    n(new Error("Unknown error: " + String(e)))
                                }
                            else
                                t(null)
                    }
                    ,
                    r.open("GET", i, !0),
                    r.send()
                }
                ))
            }
            createMultiplayerHostWebSocket() {
                if (this.determinismState != oo.Ok)
                    throw new Error("WebSocket creation not allowed with non-deterministic physics");
                return new WebSocket("wss://pt0-6-0b1-mp-backend.htmlpolytrack.workers.dev/__proxy_vps__/v6/multiplayer/host")
            }
            createMultiplayerJoinWebSocket() {
                if (this.determinismState != oo.Ok)
                    throw new Error("WebSocket creation not allowed with non-deterministic physics");
                return new WebSocket("wss://pt0-6-0b1-mp-backend.htmlpolytrack.workers.dev/__proxy_vps__/v6/multiplayer/join")
            }
            getIceServers() {
                return new Promise(( (e, t) => {
                    const n = "https://pt0-6-0b1-mp-backend.htmlpolytrack.workers.dev/__proxy_vps__/v6/iceServers?version=" + Pt.rE
                      , i = new XMLHttpRequest;
                    i.timeout = (0,
                    R.gn)(this, Lu, "f"),
                    i.overrideMimeType("text/plain"),
                    i.onreadystatechange = () => {
                        if (i.readyState == XMLHttpRequest.DONE)
                            if (200 == i.status)
                                try {
                                    const n = JSON.parse(i.responseText);
                                    if (!Array.isArray(n))
                                        return void t(new Error("Response is not an array"));
                                    const r = [];
                                    for (const e of n) {
                                        if (null == e || "object" != typeof e)
                                            return void t(new Error("Ice server item is not an object"));
                                        if (!("urls"in e))
                                            return void t(new Error("Ice server item is missing urls field"));
                                        let n;
                                        if ("string" == typeof e.urls)
                                            n = e.urls;
                                        else {
                                            if (!Array.isArray(e.urls))
                                                return void t(new Error("Ice server urls field has incorrect type"));
                                            n = [];
                                            for (const i of e.urls) {
                                                if ("string" != typeof i)
                                                    return void t(new Error("Ice server url item is not a string"));
                                                n.push(i)
                                            }
                                        }
                                        r.push({
                                            urls: n
                                        })
                                    }
                                    e(r)
                                } catch (e) {
                                    t(new Error("Unknown error: " + String(e)))
                                }
                            else
                                t(new Error("Failed to connect to server"))
                    }
                    ,
                    i.open("GET", n, !0),
                    i.send()
                }
                ))
            }
        }
        ;
        var Gu, Fu, Ou, Wu, Vu;
        Fu = new WeakMap,
        Ou = new WeakMap,
        Wu = new WeakMap,
        Gu = new WeakSet,
        Vu = function(e) {
            for (const [t,n] of e) {
                if (!(0,
                R.gn)(this, Wu, "f").has(t))
                    throw new Error("Key binding is missing");
                (0,
                R.gn)(this, Wu, "f").set(t, n)
            }
        }
        ;
        const Hu = class {
            constructor(e) {
                Gu.add(this),
                Fu.set(this, void 0),
                Ou.set(this, this.defaultSettings()),
                Wu.set(this, this.defaultKeyBindings()),
                (0,
                R.GG)(this, Fu, e, "f");
                const t = e.loadSettings();
                null != t && this.updateSettings(t);
                const n = e.loadKeyBindings();
                null != n && (0,
                R.gn)(this, Gu, "m", Vu).call(this, n)
            }
            defaultSettings() {
                return new Map([[P.A.ImperialUnitsEnabled, "false"], [P.A.ResetHintEnabled, "true"], [P.A.GhostCarEnabled, "true"], [P.A.DefaultCameraMode, "false"], [P.A.CockpitCameraToggle, "true"], [P.A.Checkpoints, "bottom"], [P.A.Timer, "bottom"], [P.A.Speedometer, "bottom"], [P.A.Language, "en-US"], [P.A.ShadowQuality, "2"], [P.A.CloudsEnabled, "true"], [P.A.ParticlesEnabled, "true"], [P.A.SkidmarksEnabled, "true"], [P.A.FogEnabled, "true"], [P.A.RenderScale, "1"], [P.A.ScreenPixelDensity, "true"], [P.A.Antialiasing, "true"], [P.A.MasterVolume, "1"], [P.A.SoundEffectVolume, "1"], [P.A.MusicVolume, "1"], [P.A.CheckpointVolume, "1"], [P.A.GhostCarSoundsEnabled, "true"], [P.A.VibrationEnabled, "false"], [P.A.TouchSteeringSide, "true"], [P.A.SpeedDecimalPlaces, "3"], [P.A.HuSplitsSize, "0.5"], [P.A.HuSplitsHeight, "0.1"], [P.A.HuSplitsOpacity, "1"], [P.A.HuSplitsShowSpeed, "true"]])
            }
            defaultKeyBindings() {
                return new Map([[me.A.VehicleAccelerate, ["KeyW", "ArrowUp"]], [me.A.VehicleTurnRight, ["KeyD", "ArrowRight"]], [me.A.VehicleBrake, ["KeyS", "ArrowDown"]], [me.A.VehicleTurnLeft, ["KeyA", "ArrowLeft"]], [me.A.VehicleCheckpointReset, ["KeyR", "Enter"]], [me.A.VehicleStartReset, ["KeyT", "Backspace"]], [me.A.VehicleCockpitCamera, ["KeyC", "KeyM"]], [me.A.ToggleUI, ["KeyH", null]], [me.A.Pause, ["KeyP", "Space"]], [me.A.EditorRotatePart, ["KeyR", "Space"]], [me.A.EditorHeightModifier, ["ShiftLeft", "ShiftRight"]], [me.A.EditorDelete, ["Delete", "KeyX"]], [me.A.EditorMoveForwards, ["KeyW", "ArrowUp"]], [me.A.EditorMoveRight, ["KeyD", "ArrowRight"]], [me.A.EditorMoveBackwards, ["KeyS", "ArrowDown"]], [me.A.EditorMoveLeft, ["KeyA", "ArrowLeft"]], [me.A.EditorRotateViewUp, ["KeyY", null]], [me.A.EditorRotateViewDown, ["KeyH", null]], [me.A.EditorRotateViewLeft, ["KeyQ", null]], [me.A.EditorRotateViewRight, ["KeyE", null]], [me.A.EditorMoveDown, ["KeyZ", null]], [me.A.EditorMoveUp, ["KeyC", null]], [me.A.EditorTest, ["KeyT", null]], [me.A.EditorPick, ["KeyG", null]], [me.A.ToggleFpsCounter, ["Equal", null]], [me.A.ToggleSpectatorCamera, ["Slash", null]], [me.A.SpectatorMoveForwards, ["KeyW", "ArrowUp"]], [me.A.SpectatorMoveRight, ["KeyD", "ArrowRight"]], [me.A.SpectatorMoveBackwards, ["KeyS", "ArrowDown"]], [me.A.SpectatorMoveLeft, ["KeyA", "ArrowLeft"]], [me.A.SpectatorSpeedModifier, ["ShiftLeft", "ShiftRight"]], [me.A.PreviewStepForward, ["Period", null]], [me.A.PreviewStepBack, ["Comma", null]]])
            }
            getSettings() {
                return Array.from((0,
                R.gn)(this, Ou, "f"))
            }
            getSetting(e) {
                const t = (0,
                R.gn)(this, Ou, "f").get(e);
                if (null == t)
                    throw new Error("Setting name is missing");
                return t
            }
            getSettingBoolean(e) {
                return "true" == this.getSetting(e)
            }
            getSettingFloat(e) {
                return parseFloat(this.getSetting(e))
            }
            getSettingInteger(e) {
                return parseInt(this.getSetting(e), 10)
            }
            updateSettings(e) {
                for (const [t,n] of e) {
                    if (!(0,
                    R.gn)(this, Ou, "f").has(t))
                        throw new Error("Setting name is missing");
                    (0,
                    R.gn)(this, Ou, "f").set(t, n)
                }
            }
            saveSettings() {
                (0,
                R.gn)(this, Fu, "f").saveSettings((0,
                R.gn)(this, Ou, "f"))
            }
            getKeyBindings(e) {
                return (0,
                R.gn)(this, Wu, "f").get(e) ?? [null, null]
            }
            setKeyBindings(e) {
                (0,
                R.gn)(this, Gu, "m", Vu).call(this, e),
                (0,
                R.gn)(this, Fu, "f").saveKeyBindings((0,
                R.gn)(this, Wu, "f"))
            }
            checkKeyBinding(e, t) {
                const n = (0,
                R.gn)(this, Wu, "f").get(t) ?? [];
                for (const t of n)
                    if (null != t && e.code == t)
                        return !0;
                return !1
            }
        }
        ;
        var ju = i(1223)
          , Ku = i(964)
          , qu = {};
        qu.styleTagTransform = u(),
        qu.setAttributes = l(),
        qu.insert = s().bind(null, "head"),
        qu.domAPI = r(),
        qu.insertStyleElement = h();
        t()(Ku.A, qu);
        Ku.A && Ku.A.locals && Ku.A.locals;
        var Qu, Ju, Xu, Yu, Zu, $u;
        Qu = new WeakMap,
        Ju = new WeakMap,
        Xu = new WeakMap,
        Yu = new WeakMap,
        Zu = new WeakMap,
        $u = new WeakMap;
        const ep = class {
            constructor(e) {
                Qu.set(this, void 0),
                Ju.set(this, void 0),
                Xu.set(this, void 0),
                Yu.set(this, void 0),
                Zu.set(this, void 0),
                $u.set(this, void 0),
                (0,
                R.GG)(this, Qu, e, "f"),
                (0,
                R.GG)(this, Ju, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Ju, "f").className = "input-visualizer-ui",
                (0,
                R.gn)(this, Qu, "f").appendChild((0,
                R.gn)(this, Ju, "f")),
                (0,
                R.GG)(this, Xu, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Xu, "f").className = "arrow-up",
                (0,
                R.gn)(this, Xu, "f").innerHTML = '<img src="images/arrow_up.svg">',
                (0,
                R.gn)(this, Ju, "f").appendChild((0,
                R.gn)(this, Xu, "f")),
                (0,
                R.GG)(this, Yu, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Yu, "f").className = "arrow-right",
                (0,
                R.gn)(this, Yu, "f").innerHTML = '<img src="images/arrow_right.svg">',
                (0,
                R.gn)(this, Ju, "f").appendChild((0,
                R.gn)(this, Yu, "f")),
                (0,
                R.GG)(this, Zu, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Zu, "f").className = "arrow-down",
                (0,
                R.gn)(this, Zu, "f").innerHTML = '<img src="images/arrow_down.svg">',
                (0,
                R.gn)(this, Ju, "f").appendChild((0,
                R.gn)(this, Zu, "f")),
                (0,
                R.GG)(this, $u, document.createElement("div"), "f"),
                (0,
                R.gn)(this, $u, "f").className = "arrow-left",
                (0,
                R.gn)(this, $u, "f").innerHTML = '<img src="images/arrow_left.svg">',
                (0,
                R.gn)(this, Ju, "f").appendChild((0,
                R.gn)(this, $u, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Qu, "f").removeChild((0,
                R.gn)(this, Ju, "f"))
            }
            update(e) {
                (0,
                R.gn)(this, Xu, "f").className = e.up ? "active arrow-up" : "arrow-up",
                (0,
                R.gn)(this, Yu, "f").className = e.right ? "active arrow-right" : "arrow-right",
                (0,
                R.gn)(this, Zu, "f").className = e.down ? "active arrow-down" : "arrow-down",
                (0,
                R.gn)(this, $u, "f").className = e.left ? "active arrow-left" : "arrow-left"
            }
        }
        ;
        var tp = i(6738)
          , np = {};
        np.styleTagTransform = u(),
        np.setAttributes = l(),
        np.insert = s().bind(null, "head"),
        np.domAPI = r(),
        np.insertStyleElement = h();
        t()(tp.A, np);
        tp.A && tp.A.locals && tp.A.locals;
        var ip, rp, ap, sp, op, lp, cp, hp, dp, up, pp, fp, gp, mp, Ap, vp, yp, wp, bp, xp, Sp, Ep, Tp, kp, Mp, _p, Cp, Rp, Pp, Ip;
        rp = new WeakMap,
        ap = new WeakMap,
        sp = new WeakMap,
        op = new WeakMap,
        lp = new WeakMap,
        cp = new WeakMap,
        hp = new WeakMap,
        dp = new WeakMap,
        up = new WeakMap,
        pp = new WeakMap,
        fp = new WeakMap,
        gp = new WeakMap,
        mp = new WeakMap,
        Ap = new WeakMap,
        vp = new WeakMap,
        yp = new WeakMap,
        wp = new WeakMap,
        bp = new WeakMap,
        xp = new WeakMap,
        Sp = new WeakMap,
        Ep = new WeakMap,
        Tp = new WeakMap,
        ip = new WeakSet,
        kp = function() {
            (0,
            R.gn)(this, fp, "f") && !(0,
            R.gn)(this, yp, "f") && (0,
            R.gn)(this, gp, "f").numberOfFrames > 0 && (0,
            R.gn)(this, ap, "f").call(this, new wt.A(Math.max(0, (0,
            R.gn)(this, gp, "f").numberOfFrames - 1)));
            let e = 0;
            const t = () => {
                (0,
                R.gn)(this, fp, "f") && !(0,
                R.gn)(this, yp, "f") && (0,
                R.gn)(this, gp, "f").numberOfFrames > 0 && (0,
                R.gn)(this, ap, "f").call(this, new wt.A(Math.max(0, (0,
                R.gn)(this, gp, "f").numberOfFrames - 1))),
                e++,
                e < 15 ? (0,
                R.GG)(this, Sp, setTimeout(t, 100), "f") : e < 100 ? (0,
                R.GG)(this, Sp, setTimeout(t, 25), "f") : (0,
                R.GG)(this, Sp, setTimeout(t, 1), "f")
            }
            ;
            (0,
            R.GG)(this, Sp, setTimeout(t, 500), "f")
        }
        ,
        Mp = function() {
            null != (0,
            R.gn)(this, Sp, "f") && (clearTimeout((0,
            R.gn)(this, Sp, "f")),
            (0,
            R.GG)(this, Sp, null, "f"))
        }
        ,
        _p = function() {
            !(0,
            R.gn)(this, fp, "f") || (0,
            R.gn)(this, yp, "f") || (0,
            R.gn)(this, mp, "f") || (0,
            R.gn)(this, ap, "f").call(this, new wt.A(Math.min((0,
            R.gn)(this, Ap, "f").numberOfFrames, (0,
            R.gn)(this, gp, "f").numberOfFrames + 1)));
            let e = 0;
            const t = () => {
                !(0,
                R.gn)(this, fp, "f") || (0,
                R.gn)(this, yp, "f") || (0,
                R.gn)(this, mp, "f") || (0,
                R.gn)(this, ap, "f").call(this, new wt.A(Math.min((0,
                R.gn)(this, Ap, "f").numberOfFrames, (0,
                R.gn)(this, gp, "f").numberOfFrames + 1))),
                e++,
                e < 15 ? (0,
                R.GG)(this, xp, setTimeout(t, 100), "f") : e < 100 ? (0,
                R.GG)(this, xp, setTimeout(t, 25), "f") : (0,
                R.GG)(this, xp, setTimeout(t, 1), "f")
            }
            ;
            (0,
            R.GG)(this, xp, setTimeout(t, 500), "f")
        }
        ,
        Cp = function() {
            null != (0,
            R.gn)(this, xp, "f") && (clearTimeout((0,
            R.gn)(this, xp, "f")),
            (0,
            R.GG)(this, xp, null, "f"))
        }
        ,
        Rp = function(e) {
            const t = (0,
            R.gn)(this, hp, "f").getBoundingClientRect()
              , n = (e.clientX - t.left) / (t.width - 8)
              , i = new wt.A(Math.max(0, Math.min((0,
            R.gn)(this, Ap, "f").numberOfFrames, Math.floor(n * (0,
            R.gn)(this, Ap, "f").numberOfFrames))));
            (0,
            R.gn)(this, ap, "f").call(this, i)
        }
        ,
        Pp = function() {
            (0,
            R.gn)(this, fp, "f") ? (0,
            R.gn)(this, mp, "f") ? ((0,
            R.gn)(this, op, "f").disabled = 0 == (0,
            R.gn)(this, gp, "f").numberOfFrames,
            (0,
            R.gn)(this, lp, "f").disabled = !0) : ((0,
            R.gn)(this, op, "f").disabled = 0 == (0,
            R.gn)(this, gp, "f").numberOfFrames,
            (0,
            R.gn)(this, lp, "f").disabled = !1) : ((0,
            R.gn)(this, op, "f").disabled = !0,
            (0,
            R.gn)(this, lp, "f").disabled = !0),
            (0,
            R.gn)(this, mp, "f") ? (0,
            R.gn)(this, cp, "f").innerHTML = '<img src="images/reset.svg">' : (0,
            R.gn)(this, fp, "f") ? (0,
            R.gn)(this, cp, "f").innerHTML = '<img src="images/play.svg">' : (0,
            R.gn)(this, cp, "f").innerHTML = '<img src="images/pause.svg">'
        }
        ,
        Ip = function() {
            if ((0,
            R.gn)(this, pp, "f").innerHTML = "",
            (0,
            R.gn)(this, Ap, "f").time < 1e4) {
                let e, t;
                (0,
                R.gn)(this, Ap, "f").time > 2e3 ? (e = 60,
                t = 600) : (0,
                R.gn)(this, Ap, "f").time > 200 ? (e = 10,
                t = 60) : (e = 1,
                t = 10);
                for (let n = e; n < (0,
                R.gn)(this, Ap, "f").time; n += e) {
                    const e = document.createElement("div");
                    e.className = n % t == 0 ? "dash long" : "dash",
                    e.style.left = "calc(" + (n / (0,
                    R.gn)(this, Ap, "f").time * 100).toString() + "% - 1px)",
                    (0,
                    R.gn)(this, pp, "f").appendChild(e)
                }
            }
            for (const e of (0,
            R.gn)(this, vp, "f")) {
                const t = document.createElement("div");
                t.className = "checkpoint-dash",
                t.style.left = "calc(" + (e.time / (0,
                R.gn)(this, Ap, "f").time * 100).toString() + "% - 1px)",
                (0,
                R.gn)(this, pp, "f").appendChild(t)
            }
        }
        ;
        const Lp = class {
            constructor(e, t, n, i, r, a, s) {
                ip.add(this),
                rp.set(this, void 0),
                ap.set(this, void 0),
                sp.set(this, void 0),
                op.set(this, void 0),
                lp.set(this, void 0),
                cp.set(this, void 0),
                hp.set(this, void 0),
                dp.set(this, void 0),
                up.set(this, void 0),
                pp.set(this, void 0),
                fp.set(this, void 0),
                gp.set(this, new wt.A(0)),
                mp.set(this, !1),
                Ap.set(this, void 0),
                vp.set(this, []),
                yp.set(this, !1),
                wp.set(this, void 0),
                bp.set(this, void 0),
                xp.set(this, null),
                Sp.set(this, null),
                Ep.set(this, void 0),
                Tp.set(this, void 0),
                (0,
                R.GG)(this, rp, e, "f"),
                (0,
                R.GG)(this, fp, s, "f"),
                (0,
                R.GG)(this, ap, a, "f"),
                (0,
                R.GG)(this, Ap, i, "f"),
                (0,
                R.GG)(this, vp, r.map((e => e.clone())), "f"),
                (0,
                R.GG)(this, sp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, sp, "f").className = "time-bar-ui",
                (0,
                R.gn)(this, rp, "f").appendChild((0,
                R.gn)(this, sp, "f")),
                (0,
                R.GG)(this, op, document.createElement("button"), "f"),
                (0,
                R.gn)(this, op, "f").className = "button",
                (0,
                R.gn)(this, op, "f").innerHTML = '<img src="images/step_back.svg">',
                (0,
                R.gn)(this, op, "f").addEventListener("pointerdown", (e => {
                    if (0 == e.button) {
                        t.playUIClick(),
                        (0,
                        R.gn)(this, ip, "m", kp).call(this);
                        const e = t => {
                            0 == t.button && ((0,
                            R.gn)(this, ip, "m", Mp).call(this),
                            window.removeEventListener("pointerup", e))
                        }
                        ;
                        window.addEventListener("pointerup", e)
                    }
                }
                )),
                (0,
                R.gn)(this, sp, "f").appendChild((0,
                R.gn)(this, op, "f")),
                (0,
                R.GG)(this, lp, document.createElement("button"), "f"),
                (0,
                R.gn)(this, lp, "f").className = "button",
                (0,
                R.gn)(this, lp, "f").innerHTML = '<img src="images/step_forward.svg">',
                (0,
                R.gn)(this, lp, "f").addEventListener("pointerdown", (e => {
                    if (0 == e.button) {
                        t.playUIClick(),
                        (0,
                        R.gn)(this, ip, "m", _p).call(this);
                        const e = t => {
                            0 == t.button && ((0,
                            R.gn)(this, ip, "m", Cp).call(this),
                            window.removeEventListener("pointerup", e))
                        }
                        ;
                        window.addEventListener("pointerup", e)
                    }
                }
                )),
                (0,
                R.gn)(this, sp, "f").appendChild((0,
                R.gn)(this, lp, "f")),
                (0,
                R.GG)(this, cp, document.createElement("button"), "f"),
                (0,
                R.gn)(this, cp, "f").className = "button",
                (0,
                R.gn)(this, cp, "f").addEventListener("click", ( () => {
                    t.playUIClick(),
                    (0,
                    R.gn)(this, mp, "f") ? ((0,
                    R.gn)(this, ap, "f").call(this, new wt.A(0)),
                    this.isPaused = !1) : this.isPaused = !this.isPaused
                }
                )),
                (0,
                R.gn)(this, sp, "f").appendChild((0,
                R.gn)(this, cp, "f")),
                (0,
                R.gn)(this, ip, "m", Pp).call(this),
                (0,
                R.GG)(this, hp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, hp, "f").className = "bar",
                (0,
                R.gn)(this, hp, "f").addEventListener("pointerdown", (e => {
                    (0,
                    R.GG)(this, yp, !0, "f"),
                    (0,
                    R.gn)(this, ip, "m", Rp).call(this, e)
                }
                )),
                window.addEventListener("pointermove", (0,
                R.GG)(this, wp, (e => {
                    (0,
                    R.gn)(this, yp, "f") && (0,
                    R.gn)(this, ip, "m", Rp).call(this, e)
                }
                ), "f")),
                window.addEventListener("pointerup", (0,
                R.GG)(this, bp, (e => {
                    (0,
                    R.gn)(this, yp, "f") && ((0,
                    R.GG)(this, yp, !1, "f"),
                    (0,
                    R.gn)(this, ip, "m", Rp).call(this, e))
                }
                ), "f")),
                (0,
                R.gn)(this, sp, "f").appendChild((0,
                R.gn)(this, hp, "f"));
                const o = document.createElement("div");
                (0,
                R.gn)(this, hp, "f").appendChild(o),
                (0,
                R.GG)(this, dp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, dp, "f").className = "unloaded-fill",
                o.appendChild((0,
                R.gn)(this, dp, "f")),
                (0,
                R.GG)(this, up, document.createElement("div"), "f"),
                (0,
                R.gn)(this, up, "f").className = "fill",
                o.appendChild((0,
                R.gn)(this, up, "f")),
                (0,
                R.GG)(this, pp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, pp, "f").className = "dash-container",
                o.appendChild((0,
                R.gn)(this, pp, "f")),
                (0,
                R.gn)(this, ip, "m", Ip).call(this),
                window.addEventListener("keydown", (0,
                R.GG)(this, Ep, (e => {
                    e.repeat || (n.checkKeyBinding(e, me.A.PreviewStepForward) ? (0,
                    R.gn)(this, ip, "m", _p).call(this) : n.checkKeyBinding(e, me.A.PreviewStepBack) && (0,
                    R.gn)(this, ip, "m", kp).call(this))
                }
                ), "f")),
                window.addEventListener("keyup", (0,
                R.GG)(this, Tp, (e => {
                    n.checkKeyBinding(e, me.A.PreviewStepForward) ? (0,
                    R.gn)(this, ip, "m", Cp).call(this) : n.checkKeyBinding(e, me.A.PreviewStepBack) && (0,
                    R.gn)(this, ip, "m", Mp).call(this)
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.gn)(this, rp, "f").removeChild((0,
                R.gn)(this, sp, "f")),
                window.removeEventListener("pointermove", (0,
                R.gn)(this, wp, "f")),
                window.removeEventListener("pointerup", (0,
                R.gn)(this, bp, "f")),
                window.removeEventListener("keydown", (0,
                R.gn)(this, Ep, "f")),
                window.removeEventListener("keyup", (0,
                R.gn)(this, Tp, "f"))
            }
            get isDragging() {
                return (0,
                R.gn)(this, yp, "f")
            }
            get isPaused() {
                return (0,
                R.gn)(this, fp, "f")
            }
            set isPaused(e) {
                (0,
                R.GG)(this, fp, e, "f"),
                (0,
                R.gn)(this, ip, "m", Pp).call(this)
            }
            set time(e) {
                (0,
                R.gn)(this, up, "f").style.width = "calc(8px + " + (e.numberOfFrames / (0,
                R.gn)(this, Ap, "f").numberOfFrames * 100).toString() + "%)",
                0 == e.numberOfFrames ? (0,
                R.gn)(this, up, "f").style.visibility = "hidden" : (0,
                R.gn)(this, up, "f").style.visibility = "visible";
                const t = e.numberOfFrames >= (0,
                R.gn)(this, Ap, "f").numberOfFrames
                  , n = (0,
                R.gn)(this, mp, "f") != t || 0 == (0,
                R.gn)(this, gp, "f").numberOfFrames && 0 != e.numberOfFrames || 0 != (0,
                R.gn)(this, gp, "f").numberOfFrames && 0 == e.numberOfFrames;
                (0,
                R.GG)(this, gp, e.clone(), "f"),
                (0,
                R.GG)(this, mp, t, "f"),
                n && (0,
                R.gn)(this, ip, "m", Pp).call(this)
            }
            set loadedTime(e) {
                (0,
                R.gn)(this, dp, "f").style.width = "calc(8px + " + (100 * (1 - e.numberOfFrames / (0,
                R.gn)(this, Ap, "f").numberOfFrames)).toString() + "%)",
                e.numberOfFrames >= (0,
                R.gn)(this, Ap, "f").numberOfFrames ? (0,
                R.gn)(this, dp, "f").style.visibility = "hidden" : (0,
                R.gn)(this, dp, "f").style.visibility = "visible"
            }
            set totalTime(e) {
                (0,
                R.gn)(this, Ap, "f").equals(e) || ((0,
                R.GG)(this, Ap, e.clone(), "f"),
                (0,
                R.gn)(this, ip, "m", Ip).call(this))
            }
            set checkpointTimes(e) {
                (0,
                R.GG)(this, vp, e.map((e => e.clone())), "f"),
                (0,
                R.gn)(this, ip, "m", Ip).call(this)
            }
        }
        ;
        var Np = i(5671)
          , zp = {};
        zp.styleTagTransform = u(),
        zp.setAttributes = l(),
        zp.insert = s().bind(null, "head"),
        zp.domAPI = r(),
        zp.insertStyleElement = h();
        t()(Np.A, zp);
        Np.A && Np.A.locals && Np.A.locals;
        var Up, Dp;
        Up = new WeakMap,
        Dp = new WeakMap;
        const Bp = class {
            constructor(e, t, n, i, r, a) {
                Up.set(this, void 0),
                Dp.set(this, void 0),
                (0,
                R.GG)(this, Up, e, "f"),
                (0,
                R.GG)(this, Dp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Dp, "f").className = "preview-toolbar-ui";
                const s = document.createElement("button");
                s.className = "button",
                s.innerHTML = '<img class="button-icon" src="images/back.svg"> ',
                s.append(document.createTextNode(n.get("Back"))),
                s.addEventListener("click", ( () => {
                    t.playUIClick(),
                    i()
                }
                )),
                (0,
                R.gn)(this, Dp, "f").appendChild(s);
                const o = document.createElement("button");
                if (o.className = "button",
                o.innerHTML = '<img class="button-icon" src="images/graph.svg"> ',
                o.append(document.createTextNode(n.get("Graphs"))),
                o.addEventListener("click", ( () => {
                    t.playUIClick(),
                    r()
                }
                )),
                (0,
                R.gn)(this, Dp, "f").appendChild(o),
                null != a) {
                    const e = document.createElement("button");
                    e.className = "button",
                    e.innerHTML = '<img class="button-icon" src="images/customize.svg"> ',
                    e.append(document.createTextNode(n.get("Switch car"))),
                    e.addEventListener("click", ( () => {
                        t.playUIClick(),
                        a()
                    }
                    )),
                    (0,
                    R.gn)(this, Dp, "f").appendChild(e)
                }
                (0,
                R.gn)(this, Up, "f").appendChild((0,
                R.gn)(this, Dp, "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Up, "f").removeChild((0,
                R.gn)(this, Dp, "f"))
            }
        }
        ;
        var Gp = i(1120)
          , Fp = {};
        Fp.styleTagTransform = u(),
        Fp.setAttributes = l(),
        Fp.insert = s().bind(null, "head"),
        Fp.domAPI = r(),
        Fp.insertStyleElement = h();
        t()(Gp.A, Fp);
        Gp.A && Gp.A.locals && Gp.A.locals;
        var Op, Wp, Vp, Hp, jp, Kp, qp, Qp, Jp, Xp, Yp, Zp, $p, ef, tf, nf, rf, af, sf, of;
        let lf = 0;
        Wp = new WeakMap,
        Vp = new WeakMap,
        Hp = new WeakMap,
        jp = new WeakMap,
        Kp = new WeakMap,
        qp = new WeakMap,
        Qp = new WeakMap,
        Jp = new WeakMap,
        Xp = new WeakMap,
        Yp = new WeakMap,
        Zp = new WeakMap,
        $p = new WeakMap,
        ef = new WeakMap,
        tf = new WeakMap,
        nf = new WeakMap,
        rf = new WeakMap,
        Op = new WeakSet,
        af = function(e) {
            e ? (0,
            R.gn)(this, Vp, "f").classList.add("type-selection-open") : (0,
            R.gn)(this, Vp, "f").classList.remove("type-selection-open"),
            (0,
            R.GG)(this, jp, e, "f")
        }
        ,
        sf = function(e, t) {
            let n, i, r;
            switch (e) {
            case 0:
                n = 210,
                i = 100,
                r = 65;
                break;
            case 1:
                n = 30,
                i = 100,
                r = 50;
                break;
            case 2:
                n = 160,
                i = 100,
                r = 30;
                break;
            case 3:
                n = 330,
                i = 100,
                r = 70;
                break;
            case 4:
                n = 0,
                i = 100,
                r = 40;
                break;
            case 5:
                n = 60,
                i = 100,
                r = 50;
                break;
            case 6:
                n = 0,
                i = 0,
                r = 60;
                break;
            case 7:
                n = 180,
                i = 100,
                r = 50;
                break;
            case 8:
                n = 30,
                i = 60,
                r = 40;
                break;
            case 9:
                n = 0,
                i = 0,
                r = 100;
                break;
            default:
                throw new Error("Index out of range")
            }
            return t && (i /= 4,
            r /= 5),
            "hsl(" + n.toString() + ", " + i.toString() + "%, " + r.toString() + "%)"
        }
        ,
        of = function(e) {
            (0,
            R.GG)(this, qp, [], "f");
            for (const {name: t, replay: n} of e) {
                const e = []
                  , i = n.getLastFrame().numberOfFrames;
                for (let t = 0; t < i; t++) {
                    const i = n.getFrame(t);
                    if (null == i)
                        throw new Error("Car Replay missing frame");
                    if (e.push((0,
                    R.gn)(this, Hp, "f").calculation(i)),
                    null != i.finishFrames)
                        break
                }
                (0,
                R.gn)(this, qp, "f").push({
                    name: t,
                    values: e
                })
            }
            (0,
            R.GG)(this, Qp, (0,
            R.gn)(this, qp, "f").flatMap((e => e.values)).reduce(( (e, t) => Math.min(e, t)), 1 / 0), "f"),
            (0,
            R.GG)(this, Jp, (0,
            R.gn)(this, qp, "f").flatMap((e => e.values)).reduce(( (e, t) => Math.max(e, t)), -1 / 0), "f"),
            (0,
            R.GG)(this, Xp, Math.max(...(0,
            R.gn)(this, qp, "f").map((e => e.values.length - 1))), "f"),
            (0,
            R.GG)(this, Xp, 1.05 * (0,
            R.gn)(this, Xp, "f"), "f"),
            (0,
            R.GG)(this, Jp, (0,
            R.gn)(this, Jp, "f") + .05 * ((0,
            R.gn)(this, Jp, "f") - (0,
            R.gn)(this, Qp, "f")), "f"),
            (0,
            R.gn)(this, ef, "f").clearRect(0, 0, (0,
            R.gn)(this, $p, "f").width, (0,
            R.gn)(this, $p, "f").height),
            (0,
            R.gn)(this, ef, "f").strokeStyle = "rgba(0, 0, 0, 0.4)",
            (0,
            R.gn)(this, ef, "f").fillStyle = "#fff",
            (0,
            R.gn)(this, ef, "f").font = "12px ForcedSquare, Arial, sans-serif";
            const t = []
              , n = Math.pow(10, Math.floor(Math.log((0,
            R.gn)(this, Xp, "f")) / Math.log(10)) - 1);
            for (let e = 0; e < (0,
            R.gn)(this, Xp, "f"); e += n)
                t.push(e);
            const i = []
              , r = Math.pow(5, Math.floor(Math.log((0,
            R.gn)(this, Jp, "f") - (0,
            R.gn)(this, Qp, "f")) / Math.log(5)) - 1);
            for (let e = Math.ceil((0,
            R.gn)(this, Qp, "f") / r) * r; e <= (0,
            R.gn)(this, Jp, "f"); e += r)
                i.push(e);
            (0,
            R.GG)(this, tf, 0, "f");
            for (const e of i) {
                const t = (0,
                R.gn)(this, ef, "f").measureText(e.toString()).width;
                (0,
                R.GG)(this, tf, Math.max((0,
                R.gn)(this, tf, "f"), t + 10), "f")
            }
            const a = 22;
            (0,
            R.gn)(this, ef, "f").textAlign = "center",
            (0,
            R.gn)(this, ef, "f").textBaseline = "top";
            let s = -1 / 0;
            for (const e of t) {
                const t = (0,
                R.gn)(this, tf, "f") + e / (0,
                R.gn)(this, Xp, "f") * ((0,
                R.gn)(this, $p, "f").width - (0,
                R.gn)(this, tf, "f"));
                (0,
                R.gn)(this, ef, "f").lineWidth = 0 == e ? 2 : 1,
                (0,
                R.gn)(this, ef, "f").beginPath(),
                (0,
                R.gn)(this, ef, "f").moveTo(Math.floor(t) + (0,
                R.gn)(this, ef, "f").lineWidth / 2, 0),
                (0,
                R.gn)(this, ef, "f").lineTo(Math.floor(t) + (0,
                R.gn)(this, ef, "f").lineWidth / 2, (0,
                R.gn)(this, $p, "f").height - a),
                (0,
                R.gn)(this, ef, "f").stroke();
                const n = Math.floor(e / 6e4)
                  , i = e / 1e3 - 60 * n;
                let r;
                r = n > 0 ? n.toString() + ":" + i.toString().padStart(2, "0") : i.toString();
                const o = (0,
                R.gn)(this, ef, "f").measureText(r)
                  , l = Math.floor(t) - o.width / 2
                  , c = Math.floor(t) + o.width / 2;
                l > s && c < (0,
                R.gn)(this, $p, "f").width && ((0,
                R.gn)(this, ef, "f").fillText(r, Math.floor(t), (0,
                R.gn)(this, $p, "f").height - a + 5),
                s = c)
            }
            (0,
            R.gn)(this, ef, "f").textAlign = "right",
            (0,
            R.gn)(this, ef, "f").textBaseline = "middle";
            for (const e of i) {
                const t = (0,
                R.gn)(this, $p, "f").height - a - (e - (0,
                R.gn)(this, Qp, "f")) / ((0,
                R.gn)(this, Jp, "f") - (0,
                R.gn)(this, Qp, "f")) * ((0,
                R.gn)(this, $p, "f").height - a);
                (0,
                R.gn)(this, ef, "f").lineWidth = 0 == e ? 2 : 1,
                (0,
                R.gn)(this, ef, "f").beginPath(),
                (0,
                R.gn)(this, ef, "f").moveTo((0,
                R.gn)(this, tf, "f"), Math.floor(t) - (0,
                R.gn)(this, ef, "f").lineWidth / 2),
                (0,
                R.gn)(this, ef, "f").lineTo((0,
                R.gn)(this, ef, "f").canvas.width, Math.floor(t) - (0,
                R.gn)(this, ef, "f").lineWidth / 2),
                (0,
                R.gn)(this, ef, "f").stroke();
                const n = e.toString()
                  , i = Math.floor(t);
                i > 0 && (0,
                R.gn)(this, ef, "f").fillText(n, (0,
                R.gn)(this, tf, "f") - 5, i)
            }
            for (let e = 0; e < (0,
            R.gn)(this, qp, "f").length; e++) {
                const t = (0,
                R.gn)(this, qp, "f")[e].values;
                (0,
                R.gn)(this, ef, "f").strokeStyle = (0,
                R.gn)(this, Op, "m", sf).call(this, e, !0),
                (0,
                R.gn)(this, ef, "f").lineWidth = 2,
                (0,
                R.gn)(this, ef, "f").beginPath();
                for (let e = 0; e < t.length; e++) {
                    const n = (0,
                    R.gn)(this, tf, "f") + e / (0,
                    R.gn)(this, Xp, "f") * ((0,
                    R.gn)(this, $p, "f").width - (0,
                    R.gn)(this, tf, "f"))
                      , i = (t[e] - (0,
                    R.gn)(this, Qp, "f")) / ((0,
                    R.gn)(this, Jp, "f") - (0,
                    R.gn)(this, Qp, "f")) * ((0,
                    R.gn)(this, $p, "f").height - a);
                    0 == e ? (0,
                    R.gn)(this, ef, "f").moveTo(n, (0,
                    R.gn)(this, $p, "f").height - a - i) : (0,
                    R.gn)(this, ef, "f").lineTo(n, (0,
                    R.gn)(this, $p, "f").height - a - i)
                }
                (0,
                R.gn)(this, ef, "f").stroke()
            }
            (0,
            R.gn)(this, rf, "f").clearRect(0, 0, (0,
            R.gn)(this, nf, "f").width, (0,
            R.gn)(this, nf, "f").height);
            for (let e = 0; e < (0,
            R.gn)(this, qp, "f").length; e++) {
                const t = (0,
                R.gn)(this, qp, "f")[e].values;
                (0,
                R.gn)(this, rf, "f").strokeStyle = (0,
                R.gn)(this, Op, "m", sf).call(this, e, !1),
                (0,
                R.gn)(this, rf, "f").lineWidth = 2,
                (0,
                R.gn)(this, rf, "f").beginPath();
                for (let e = 0; e < t.length; e++) {
                    const n = (0,
                    R.gn)(this, tf, "f") + e / (0,
                    R.gn)(this, Xp, "f") * ((0,
                    R.gn)(this, nf, "f").width - (0,
                    R.gn)(this, tf, "f"))
                      , i = (t[e] - (0,
                    R.gn)(this, Qp, "f")) / ((0,
                    R.gn)(this, Jp, "f") - (0,
                    R.gn)(this, Qp, "f")) * ((0,
                    R.gn)(this, nf, "f").height - a);
                    0 == e ? (0,
                    R.gn)(this, rf, "f").moveTo(n, (0,
                    R.gn)(this, nf, "f").height - a - i) : (0,
                    R.gn)(this, rf, "f").lineTo(n, (0,
                    R.gn)(this, nf, "f").height - a - i)
                }
                (0,
                R.gn)(this, rf, "f").stroke()
            }
        }
        ;
        const cf = class {
            constructor(e, t, n, i, r, a) {
                Op.add(this),
                Wp.set(this, void 0),
                Vp.set(this, void 0),
                Hp.set(this, void 0),
                jp.set(this, !1),
                Kp.set(this, void 0),
                qp.set(this, []),
                Qp.set(this, 0),
                Jp.set(this, 0),
                Xp.set(this, 0),
                Yp.set(this, void 0),
                Zp.set(this, void 0),
                $p.set(this, void 0),
                ef.set(this, void 0),
                tf.set(this, 0),
                nf.set(this, void 0),
                rf.set(this, void 0),
                (0,
                R.GG)(this, Wp, e, "f"),
                (0,
                R.GG)(this, Vp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Vp, "f").className = "graph-ui",
                (0,
                R.gn)(this, Wp, "f").appendChild((0,
                R.gn)(this, Vp, "f"));
                const s = document.createElement("h2");
                s.textContent = n.get("Graphs"),
                (0,
                R.gn)(this, Vp, "f").appendChild(s);
                const o = document.createElement("div");
                o.className = "content",
                (0,
                R.gn)(this, Vp, "f").appendChild(o);
                const l = document.createElement("div");
                l.className = "graph-content",
                o.appendChild(l),
                (0,
                R.GG)(this, Kp, document.createElement("div"), "f"),
                (0,
                R.gn)(this, Kp, "f").className = "side-panel",
                l.appendChild((0,
                R.gn)(this, Kp, "f")),
                (0,
                R.GG)(this, Yp, document.createElement("canvas"), "f"),
                (0,
                R.gn)(this, Yp, "f").width = 750,
                (0,
                R.gn)(this, Yp, "f").height = 500,
                l.appendChild((0,
                R.gn)(this, Yp, "f"));
                const c = (0,
                R.gn)(this, Yp, "f").getContext("2d");
                if (null == c)
                    throw new Error("Could not get 2D context");
                (0,
                R.GG)(this, Zp, c, "f"),
                (0,
                R.GG)(this, $p, document.createElement("canvas"), "f"),
                (0,
                R.gn)(this, $p, "f").width = (0,
                R.gn)(this, Yp, "f").width,
                (0,
                R.gn)(this, $p, "f").height = (0,
                R.gn)(this, Yp, "f").height,
                (0,
                R.GG)(this, nf, document.createElement("canvas"), "f"),
                (0,
                R.gn)(this, nf, "f").width = (0,
                R.gn)(this, Yp, "f").width,
                (0,
                R.gn)(this, nf, "f").height = (0,
                R.gn)(this, Yp, "f").height;
                const h = (0,
                R.gn)(this, $p, "f").getContext("2d");
                if (null == h)
                    throw new Error("Could not get 2D context");
                (0,
                R.GG)(this, ef, h, "f");
                const d = (0,
                R.gn)(this, nf, "f").getContext("2d");
                if (null == d)
                    throw new Error("Could not get 2D context");
                (0,
                R.GG)(this, rf, d, "f");
                const u = document.createElement("div");
                u.className = "type-selection-content",
                o.appendChild(u);
                const p = i.getSettingBoolean(P.A.ImperialUnitsEnabled)
                  , f = e => 180 * e / Math.PI
                  , g = [{
                    name: n.get("Speed"),
                    unit: p ? "mph" : "km/h",
                    calculation: e => p ? e.speedKmh / 1.609344 : e.speedKmh
                }, {
                    name: n.get("Speed"),
                    unit: "m/s",
                    calculation: e => e.speedKmh / 3.6
                }, {
                    name: n.get("Steering angle"),
                    unit: "",
                    calculation: e => f(e.steering)
                }, {
                    name: n.get("Grip") + " " + n.get("Average"),
                    unit: "%",
                    calculation: e => {
                        let t, n, i, r;
                        return t = e.wheelContact[0] ? e.wheelSkidInfo[0] : 0,
                        n = e.wheelContact[1] ? e.wheelSkidInfo[1] : 0,
                        i = e.wheelContact[2] ? e.wheelSkidInfo[2] : 0,
                        r = e.wheelContact[3] ? e.wheelSkidInfo[3] : 0,
                        (t + n + i + r) / 4 * 100
                    }
                }, {
                    name: n.get("Grip") + " " + n.get("Front Left"),
                    unit: "%",
                    calculation: e => e.wheelContact[0] ? 100 * e.wheelSkidInfo[0] : 0
                }, {
                    name: n.get("Grip") + " " + n.get("Front Right"),
                    unit: "%",
                    calculation: e => e.wheelContact[1] ? 100 * e.wheelSkidInfo[1] : 0
                }, {
                    name: n.get("Grip") + " " + n.get("Rear Left"),
                    unit: "%",
                    calculation: e => e.wheelContact[2] ? 100 * e.wheelSkidInfo[2] : 0
                }, {
                    name: n.get("Grip") + " " + n.get("Rear Right"),
                    unit: "%",
                    calculation: e => e.wheelContact[3] ? 100 * e.wheelSkidInfo[3] : 0
                }, {
                    name: n.get("Suspension Length") + " " + n.get("Average"),
                    unit: "cm",
                    calculation: e => (e.wheelSuspensionLength[0] + e.wheelSuspensionLength[1] + e.wheelSuspensionLength[2] + e.wheelSuspensionLength[3]) / 4 * 100
                }, {
                    name: n.get("Suspension Length") + " " + n.get("Front Left"),
                    unit: "cm",
                    calculation: e => 100 * e.wheelSuspensionLength[0]
                }, {
                    name: n.get("Suspension Length") + " " + n.get("Front Right"),
                    unit: "cm",
                    calculation: e => 100 * e.wheelSuspensionLength[1]
                }, {
                    name: n.get("Suspension Length") + " " + n.get("Rear Left"),
                    unit: "cm",
                    calculation: e => 100 * e.wheelSuspensionLength[2]
                }, {
                    name: n.get("Suspension Length") + " " + n.get("Rear Right"),
                    unit: "cm",
                    calculation: e => 100 * e.wheelSuspensionLength[3]
                }, {
                    name: n.get("Wheel Speed") + " " + n.get("Average"),
                    unit: "/s",
                    calculation: e => f(e.wheelDeltaRotation[0] + e.wheelDeltaRotation[1] + e.wheelDeltaRotation[2] + e.wheelDeltaRotation[3]) / 4 * 1e3
                }, {
                    name: n.get("Wheel Speed") + " " + n.get("Front Left"),
                    unit: "/s",
                    calculation: e => 1e3 * f(e.wheelDeltaRotation[0])
                }, {
                    name: n.get("Wheel Speed") + " " + n.get("Front Right"),
                    unit: "/s",
                    calculation: e => 1e3 * f(e.wheelDeltaRotation[1])
                }, {
                    name: n.get("Wheel Speed") + " " + n.get("Rear Left"),
                    unit: "/s",
                    calculation: e => 1e3 * f(e.wheelDeltaRotation[2])
                }, {
                    name: n.get("Wheel Speed") + " " + n.get("Rear Right"),
                    unit: "/s",
                    calculation: e => 1e3 * f(e.wheelDeltaRotation[3])
                }];
                (0,
                R.GG)(this, Hp, g[lf], "f"),
                (0,
                R.gn)(this, Op, "m", of).call(this, r);
                for (let e = 0; e < g.length; e++) {
                    const n = g[e]
                      , i = document.createElement("button");
                    i.className = "button",
                    i.textContent = n.name + " (" + n.unit + ")",
                    i.addEventListener("click", ( () => {
                        t.playUIClick(),
                        lf = e,
                        (0,
                        R.GG)(this, Hp, n, "f"),
                        v.textContent = (0,
                        R.gn)(this, Hp, "f").name + " (" + (0,
                        R.gn)(this, Hp, "f").unit + ")",
                        (0,
                        R.gn)(this, Op, "m", of).call(this, r),
                        (0,
                        R.gn)(this, Op, "m", af).call(this, !1)
                    }
                    )),
                    u.appendChild(i)
                }
                const m = document.createElement("div");
                m.className = "buttons-container",
                (0,
                R.gn)(this, Vp, "f").appendChild(m);
                const A = document.createElement("button");
                A.className = "button",
                A.innerHTML = '<img class="button-icon" src="images/cancel.svg">',
                A.appendChild(document.createTextNode(" " + n.get("Close"))),
                A.addEventListener("click", ( () => {
                    t.playUIClick(),
                    a()
                }
                )),
                m.appendChild(A);
                const v = document.createElement("button");
                v.className = "button",
                v.textContent = (0,
                R.gn)(this, Hp, "f").name + " (" + (0,
                R.gn)(this, Hp, "f").unit + ")",
                v.addEventListener("click", ( () => {
                    t.playUIClick(),
                    (0,
                    R.gn)(this, Op, "m", af).call(this, !(0,
                    R.gn)(this, jp, "f"))
                }
                )),
                m.appendChild(v)
            }
            dispose() {
                (0,
                R.gn)(this, Wp, "f").removeChild((0,
                R.gn)(this, Vp, "f"))
            }
            update(e) {
                (0,
                R.gn)(this, Kp, "f").innerHTML = "";
                for (let t = 0; t < (0,
                R.gn)(this, qp, "f").length; t++) {
                    const {name: n, values: i} = (0,
                    R.gn)(this, qp, "f")[t]
                      , r = i[Math.min(i.length - 1, e)]
                      , a = document.createElement("div");
                    a.style.color = (0,
                    R.gn)(this, Op, "m", sf).call(this, t, !1),
                    (0,
                    R.gn)(this, Kp, "f").appendChild(a);
                    const s = document.createElement("div");
                    s.textContent = n,
                    a.appendChild(s);
                    const o = document.createElement("div");
                    o.textContent = r.toFixed(2) + " " + (0,
                    R.gn)(this, Hp, "f").unit,
                    a.appendChild(o)
                }
                (0,
                R.gn)(this, Zp, "f").clearRect(0, 0, (0,
                R.gn)(this, Yp, "f").width, (0,
                R.gn)(this, Yp, "f").height),
                (0,
                R.gn)(this, Zp, "f").drawImage((0,
                R.gn)(this, $p, "f"), 0, 0);
                const t = (0,
                R.gn)(this, tf, "f") / (0,
                R.gn)(this, Yp, "f").width + (1 - (0,
                R.gn)(this, tf, "f") / (0,
                R.gn)(this, Yp, "f").width) * Math.min(1, e / (0,
                R.gn)(this, Xp, "f"));
                (0,
                R.gn)(this, Zp, "f").drawImage((0,
                R.gn)(this, nf, "f"), 0, 0, (0,
                R.gn)(this, Yp, "f").width * t, (0,
                R.gn)(this, Yp, "f").height, 0, 0, (0,
                R.gn)(this, Yp, "f").width * t, (0,
                R.gn)(this, Yp, "f").height)
            }
        }
        ;
        var hf, df, uf, pf, ff, gf, mf, Af, vf, yf, wf, bf, xf, Sf, Ef, Tf, kf, Mf, _f, Cf, Rf, Pf, If, Lf, Nf, zf, Uf, Df, Bf, Gf, Ff, Of;
        df = new WeakMap,
        uf = new WeakMap,
        pf = new WeakMap,
        ff = new WeakMap,
        gf = new WeakMap,
        mf = new WeakMap,
        Af = new WeakMap,
        vf = new WeakMap,
        yf = new WeakMap,
        wf = new WeakMap,
        bf = new WeakMap,
        xf = new WeakMap,
        Sf = new WeakMap,
        Ef = new WeakMap,
        Tf = new WeakMap,
        kf = new WeakMap,
        Mf = new WeakMap,
        _f = new WeakMap,
        Cf = new WeakMap,
        Rf = new WeakMap,
        Pf = new WeakMap,
        If = new WeakMap,
        Lf = new WeakMap,
        Nf = new WeakMap,
        zf = new WeakMap,
        Uf = new WeakMap,
        Df = new WeakMap,
        Bf = new WeakMap,
        Gf = new WeakMap,
        Ff = new WeakMap,
        hf = new WeakSet,
        Of = function(e) {
            for (const t of (0,
            R.gn)(this, Ef, "f"))
                if (t.car.getTime().numberOfFrames != e) {
                    const n = t.replay.getFrame(e);
                    null != n && t.car.setCarState(n, n.frames != t.car.getTime().numberOfFrames && n.frames != t.car.getTime().numberOfFrames + 1)
                }
        }
        ;
        const Wf = class {
            constructor(e, t, n, i, r, a, s, o, l, c, h, d, u) {
                hf.add(this),
                df.set(this, void 0),
                uf.set(this, void 0),
                pf.set(this, void 0),
                ff.set(this, void 0),
                gf.set(this, void 0),
                mf.set(this, void 0),
                Af.set(this, void 0),
                vf.set(this, void 0),
                yf.set(this, void 0),
                wf.set(this, void 0),
                bf.set(this, void 0),
                xf.set(this, void 0),
                Sf.set(this, 0),
                Ef.set(this, void 0),
                Tf.set(this, !1),
                kf.set(this, 0),
                Mf.set(this, 0),
                _f.set(this, void 0),
                Cf.set(this, void 0),
                Rf.set(this, void 0),
                Pf.set(this, void 0),
                If.set(this, void 0),
                Lf.set(this, void 0),
                Nf.set(this, void 0),
                zf.set(this, void 0),
                Uf.set(this, null),
                Df.set(this, null),
                Bf.set(this, void 0),
                Gf.set(this, void 0),
                Ff.set(this, 1e4),
                (0,
                R.GG)(this, df, e, "f"),
                (0,
                R.GG)(this, uf, t, "f"),
                (0,
                R.GG)(this, pf, n, "f"),
                (0,
                R.GG)(this, ff, i, "f"),
                (0,
                R.GG)(this, gf, r, "f"),
                (0,
                R.GG)(this, mf, a, "f"),
                (0,
                R.GG)(this, Af, s, "f"),
                (0,
                R.GG)(this, vf, o, "f"),
                (0,
                R.GG)(this, yf, l, "f"),
                (0,
                R.GG)(this, wf, c, "f"),
                (0,
                R.GG)(this, bf, h, "f"),
                (0,
                R.GG)(this, xf, u, "f"),
                t.loadTrackData(i),
                t.generateMeshes(),
                a.generateMountains(t.getBounds());
                const p = t.getStartTransform();
                if (null == p)
                    throw new Error("Track has no starting point");
                const f = new wt.A(d.reduce(( (e, t) => Math.max(e, t.time.numberOfFrames + (0,
                R.gn)(this, Ff, "f"))), 0));
                (0,
                R.GG)(this, Mf, f.time, "f"),
                (0,
                R.GG)(this, Ef, d.map(( (n, r) => {
                    const s = new N.A(null,p,n.recording,null,o,l,a,t,i,h,null);
                    s.notificationAudioEnabled = (0,
                    R.gn)(this, Sf, "f") == r,
                    s.setCarStyle(n.carStyle);
                    const c = {
                        replay: new Vt,
                        checkpointTimes: [],
                        carId: null,
                        car: s,
                        settings: n
                    }
                      , d = e.createCar(p, a.getMountainVertices(), a.getMountainOffset(), i, n.recording, (t => {
                        c.replay.push(t),
                        null != c.carId && t.frames >= f.numberOfFrames && (e.deleteCar(c.carId),
                        c.carId = null),
                        t.nextCheckpointIndex > g.nextCheckpointIndex && (c.checkpointTimes.push(new wt.A(t.frames)),
                        r == (0,
                        R.gn)(this, Sf, "f") && ((0,
                        R.gn)(this, Rf, "f").checkpointTimes = c.checkpointTimes)),
                        g = t
                    }
                    ))
                      , u = d.id;
                    let g = d.carState;
                    return c.replay.push(g),
                    e.startCar(u, f.clone()),
                    c.carId = u,
                    c
                }
                )), "f"),
                h.getSettingBoolean(P.A.DefaultCameraMode) ? o.setCamera((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.cameraCockpit) : o.setCamera((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.cameraOrbit),
                (0,
                R.GG)(this, _f, new yt(o,h), "f"),
                (0,
                R.gn)(this, _f, "f").addToggleListener((e => {
                    e ? o.setCamera((0,
                    R.gn)(this, _f, "f").camera) : (0,
                    R.gn)(this, bf, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
                    R.gn)(this, vf, "f").setCamera((0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car.cameraCockpit) : (0,
                    R.gn)(this, vf, "f").setCamera((0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car.cameraOrbit)
                }
                )),
                (0,
                R.GG)(this, Cf, new Ir, "f");
                const g = (0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")]
                  , m = g.settings.time;
                let A;
                (0,
                R.GG)(this, Rf, new Lp((0,
                R.gn)(this, Cf, "f").element,(0,
                R.gn)(this, yf, "f"),(0,
                R.gn)(this, bf, "f"),m,g.checkpointTimes,(e => {
                    let t;
                    !(0,
                    R.gn)(this, Rf, "f").isPaused || (0,
                    R.gn)(this, Rf, "f").isDragging ? t = 0 : (t = Math.max(0, e.time - (0,
                    R.gn)(this, kf, "f")),
                    t > .1 && (t = 0)),
                    (0,
                    R.GG)(this, kf, Math.max(0, Math.min((0,
                    R.gn)(this, Mf, "f"), e.time)), "f");
                    const n = Math.round(1e3 * (0,
                    R.gn)(this, kf, "f"));
                    (0,
                    R.gn)(this, hf, "m", Of).call(this, n);
                    for (const e of (0,
                    R.gn)(this, Ef, "f"))
                        e.car.update(t);
                    const i = (0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car;
                    (0,
                    R.gn)(this, Rf, "f").time = new wt.A(n),
                    (0,
                    R.gn)(this, If, "f").update(i.getControls()),
                    (0,
                    R.gn)(this, Lf, "f").update(i),
                    (0,
                    R.gn)(this, Nf, "f").update(i),
                    (0,
                    R.gn)(this, zf, "f").update(i)
                }
                ),(0,
                R.gn)(this, Tf, "f")), "f"),
                A = (0,
                R.gn)(this, Ef, "f").length > 1 ? () => {
                    (0,
                    R.GG)(this, Sf, ((0,
                    R.gn)(this, Sf, "f") + 1) % (0,
                    R.gn)(this, Ef, "f").length, "f");
                    for (let e = 0; e < (0,
                    R.gn)(this, Ef, "f").length; e++)
                        (0,
                        R.gn)(this, Ef, "f")[e].car.notificationAudioEnabled = e == (0,
                        R.gn)(this, Sf, "f");
                    (0,
                    R.gn)(this, _f, "f").isEnabled || ((0,
                    R.gn)(this, bf, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
                    R.gn)(this, vf, "f").setCamera((0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car.cameraCockpit) : (0,
                    R.gn)(this, vf, "f").setCamera((0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car.cameraOrbit)),
                    (0,
                    R.gn)(this, Rf, "f").totalTime = (0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].settings.time,
                    (0,
                    R.gn)(this, Rf, "f").checkpointTimes = (0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].checkpointTimes,
                    (0,
                    R.gn)(this, zf, "f").nickname = (0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].settings.nickname
                }
                : null,
                (0,
                R.GG)(this, Pf, new Bp((0,
                R.gn)(this, Cf, "f").element,(0,
                R.gn)(this, yf, "f"),(0,
                R.gn)(this, wf, "f"),( () => {
                    (0,
                    R.gn)(this, xf, "f").call(this, (0,
                    R.gn)(this, pf, "f"), (0,
                    R.gn)(this, ff, "f"), (0,
                    R.gn)(this, gf, "f"), (0,
                    R.gn)(this, Ef, "f").map((e => e.settings)))
                }
                ),( () => {
                    null != (0,
                    R.gn)(this, Uf, "f") ? ((0,
                    R.gn)(this, Uf, "f").dispose(),
                    (0,
                    R.GG)(this, Uf, null, "f")) : (0,
                    R.GG)(this, Uf, new cf((0,
                    R.gn)(this, Cf, "f").element,(0,
                    R.gn)(this, yf, "f"),(0,
                    R.gn)(this, wf, "f"),(0,
                    R.gn)(this, bf, "f"),(0,
                    R.gn)(this, Ef, "f").map((e => ({
                        name: e.settings.nickname,
                        replay: e.replay
                    }))),( () => {
                        (0,
                        R.gn)(this, Uf, "f")?.dispose(),
                        (0,
                        R.GG)(this, Uf, null, "f")
                    }
                    )), "f")
                }
                ),A), "f"),
                (0,
                R.GG)(this, If, new ep((0,
                R.gn)(this, Cf, "f").element), "f"),
                (0,
                R.GG)(this, Lf, new pe((0,
                R.gn)(this, Cf, "f").element,(0,
                R.gn)(this, uf, "f").getTotalNumberOfCheckpointIndices(),(0,
                R.gn)(this, bf, "f")), "f"),
                (0,
                R.gn)(this, Lf, "f").setOverridePosition(!1),
                (0,
                R.gn)(this, Lf, "f").setBottomOffset(52),
                (0,
                R.GG)(this, Nf, new Ve((0,
                R.gn)(this, Cf, "f").element,(0,
                R.gn)(this, bf, "f")), "f"),
                (0,
                R.gn)(this, Nf, "f").setOverridePosition(!1),
                (0,
                R.gn)(this, Nf, "f").setBottomOffset(52),
                (0,
                R.GG)(this, zf, new He.A((0,
                R.gn)(this, Cf, "f").element,(0,
                R.gn)(this, wf, "f"),(0,
                R.gn)(this, bf, "f"),!0), "f"),
                (0,
                R.gn)(this, zf, "f").nickname = (0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].settings.nickname,
                (0,
                R.gn)(this, zf, "f").setOverridePosition(!1),
                (0,
                R.gn)(this, zf, "f").setBottomOffset(52),
                window.addEventListener("keydown", (0,
                R.GG)(this, Bf, (e => {
                    if (!(0,
                    R.gn)(this, _f, "f").isEnabled)
                        if (h.checkKeyBinding(e, me.A.VehicleCheckpointReset) || h.checkKeyBinding(e, me.A.VehicleStartReset))
                            e.repeat || (0,
                            R.GG)(this, kf, 0, "f"),
                            e.preventDefault();
                        else if ((0,
                        R.gn)(this, bf, "f").checkKeyBinding(e, me.A.VehicleCockpitCamera)) {
                            if (!e.repeat) {
                                const e = (0,
                                R.gn)(this, Ef, "f")[(0,
                                R.gn)(this, Sf, "f")].car;
                                e.hasFinished() || ((0,
                                R.gn)(this, bf, "f").getSettingBoolean(P.A.CockpitCameraToggle) ? (0,
                                R.gn)(this, vf, "f").camera == e.cameraOrbit ? (0,
                                R.gn)(this, vf, "f").setCamera(e.cameraCockpit) : (0,
                                R.gn)(this, vf, "f").setCamera(e.cameraOrbit) : (0,
                                R.gn)(this, bf, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
                                R.gn)(this, vf, "f").setCamera(e.cameraOrbit) : (0,
                                R.gn)(this, vf, "f").setCamera(e.cameraCockpit))
                            }
                            e.preventDefault()
                        }
                    if ("Escape" == e.code && (null != (0,
                    R.gn)(this, Uf, "f") ? ((0,
                    R.gn)(this, Uf, "f").dispose(),
                    (0,
                    R.GG)(this, Uf, null, "f")) : (0,
                    R.gn)(this, _f, "f").isEnabled ? (0,
                    R.gn)(this, _f, "f").isEnabled = !1 : u(n, i, r, (0,
                    R.gn)(this, Ef, "f").map((e => e.settings))),
                    e.preventDefault()),
                    h.checkKeyBinding(e, me.A.ToggleUI) && ((0,
                    R.gn)(this, Cf, "f").isVisible = !(0,
                    R.gn)(this, Cf, "f").isVisible,
                    e.preventDefault()),
                    h.checkKeyBinding(e, me.A.ToggleSpectatorCamera)) {
                        (0,
                        R.gn)(this, _f, "f").camera.position.copy((0,
                        R.gn)(this, vf, "f").camera.position);
                        const t = new C.O9p(0,0,0,"YXZ").setFromQuaternion((0,
                        R.gn)(this, vf, "f").camera.quaternion);
                        t.z = 0,
                        (0,
                        R.gn)(this, _f, "f").camera.quaternion.setFromEuler(t),
                        (0,
                        R.gn)(this, _f, "f").toggle(),
                        e.preventDefault()
                    }
                    "Space" == e.code && ((0,
                    R.GG)(this, Tf, !(0,
                    R.gn)(this, Tf, "f"), "f"),
                    (0,
                    R.gn)(this, Rf, "f").isPaused = (0,
                    R.gn)(this, Tf, "f"),
                    e.preventDefault())
                }
                ), "f")),
                window.addEventListener("keyup", (0,
                R.GG)(this, Gf, (e => {
                    if (!(0,
                    R.gn)(this, _f, "f").isEnabled && (0,
                    R.gn)(this, bf, "f").checkKeyBinding(e, me.A.VehicleCockpitCamera)) {
                        const e = (0,
                        R.gn)(this, Ef, "f")[(0,
                        R.gn)(this, Sf, "f")].car;
                        e.hasFinished() || (0,
                        R.gn)(this, bf, "f").getSettingBoolean(P.A.CockpitCameraToggle) || ((0,
                        R.gn)(this, bf, "f").getSettingBoolean(P.A.DefaultCameraMode) ? (0,
                        R.gn)(this, vf, "f").setCamera(e.cameraCockpit) : (0,
                        R.gn)(this, vf, "f").setCamera(e.cameraOrbit))
                    }
                }
                ), "f")),
                Pt.EM && (0,
                R.GG)(this, Df, new _i(o,t), "f")
            }
            dispose() {
                (0,
                R.gn)(this, uf, "f").clear(),
                (0,
                R.gn)(this, mf, "f").clearMountains();
                for (const e of (0,
                R.gn)(this, Ef, "f"))
                    null != e.carId && ((0,
                    R.gn)(this, df, "f").deleteCar(e.carId),
                    e.carId = null),
                    e.car.dispose();
                (0,
                R.gn)(this, _f, "f").dispose(),
                (0,
                R.gn)(this, Cf, "f").dispose(),
                (0,
                R.gn)(this, Rf, "f").dispose(),
                (0,
                R.gn)(this, Pf, "f").dispose(),
                (0,
                R.gn)(this, If, "f").dispose(),
                (0,
                R.gn)(this, Lf, "f").dispose(),
                (0,
                R.gn)(this, Nf, "f").dispose(),
                (0,
                R.gn)(this, zf, "f").dispose(),
                (0,
                R.gn)(this, Uf, "f")?.dispose(),
                (0,
                R.GG)(this, Uf, null, "f"),
                window.removeEventListener("keydown", (0,
                R.gn)(this, Bf, "f")),
                window.removeEventListener("keyup", (0,
                R.gn)(this, Gf, "f")),
                (0,
                R.gn)(this, Df, "f")?.dispose()
            }
            update(e) {
                (0,
                R.GG)(this, Tf, (0,
                R.gn)(this, Rf, "f").isPaused, "f");
                let t = 1 / 0;
                for (const e of (0,
                R.gn)(this, Ef, "f"))
                    t = Math.min(t, e.replay.getLastFrame().numberOfFrames);
                const n = new wt.A(t);
                let i;
                if ((0,
                R.gn)(this, Tf, "f") || (0,
                R.gn)(this, Rf, "f").isDragging) {
                    i = 0;
                    for (const e of (0,
                    R.gn)(this, Ef, "f"))
                        e.car.audioVolume = 0
                } else {
                    const t = Math.min((0,
                    R.gn)(this, Mf, "f"), (0,
                    R.gn)(this, kf, "f") + e);
                    if (n.time >= t) {
                        (0,
                        R.GG)(this, kf, t, "f"),
                        (0,
                        R.gn)(this, kf, "f") == (0,
                        R.gn)(this, Mf, "f") && ((0,
                        R.gn)(this, Rf, "f").isPaused = !0,
                        (0,
                        R.GG)(this, Tf, !0, "f")),
                        i = e;
                        for (const e of (0,
                        R.gn)(this, Ef, "f"))
                            e.car.audioVolume = 1
                    } else {
                        i = 0;
                        for (const e of (0,
                        R.gn)(this, Ef, "f"))
                            e.car.audioVolume = 0
                    }
                }
                const r = Math.round(1e3 * (0,
                R.gn)(this, kf, "f"))
                  , a = Math.min(r, n.numberOfFrames);
                if ((0,
                R.gn)(this, Rf, "f").isDragging || a < (0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.getTime().numberOfFrames || a > (0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.getTime().numberOfFrames + 1e3)
                    (0,
                    R.gn)(this, hf, "m", Of).call(this, a);
                else {
                    for (let e = (0,
                    R.gn)(this, Ef, "f")[(0,
                    R.gn)(this, Sf, "f")].car.getTime().numberOfFrames + 1; e <= a; e++)
                        (0,
                        R.gn)(this, hf, "m", Of).call(this, e)
                }
                (0,
                R.gn)(this, Rf, "f").time = (0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.getTime(),
                (0,
                R.gn)(this, Rf, "f").loadedTime = n,
                (0,
                R.gn)(this, If, "f").update((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car.getControls()),
                (0,
                R.gn)(this, Lf, "f").update((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car),
                (0,
                R.gn)(this, Nf, "f").update((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car),
                (0,
                R.gn)(this, zf, "f").update((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car);
                for (const e of (0,
                R.gn)(this, Ef, "f"))
                    e.car.update(i),
                    e.car.updateCameras(i);
                (0,
                R.gn)(this, Df, "f")?.updateCar((0,
                R.gn)(this, Ef, "f")[(0,
                R.gn)(this, Sf, "f")].car),
                (0,
                R.gn)(this, Uf, "f")?.update(r),
                (0,
                R.gn)(this, _f, "f").update(e),
                (0,
                R.gn)(this, mf, "f").update((0,
                R.gn)(this, uf, "f")),
                (0,
                R.gn)(this, Af, "f").update(i, (0,
                R.gn)(this, vf, "f").camera, (0,
                R.gn)(this, uf, "f").sunDirection),
                (0,
                R.gn)(this, yf, "f").update(e, !1, (0,
                R.gn)(this, vf, "f")),
                (0,
                R.gn)(this, vf, "f").update((0,
                R.gn)(this, uf, "f").sunDirection)
            }
        }
        ;
        var Vf, Hf;
        Vf = new WeakMap,
        Hf = new WeakMap;
        const jf = class {
            constructor() {
                Vf.set(this, !1),
                Hf.set(this, []),
                window.addEventListener("touchstart", ( () => {
                    if (!(0,
                    R.gn)(this, Vf, "f")) {
                        (0,
                        R.GG)(this, Vf, !0, "f");
                        for (const e of (0,
                        R.gn)(this, Hf, "f"))
                            e((0,
                            R.gn)(this, Vf, "f"))
                    }
                }
                )),
                window.addEventListener("keydown", ( () => {
                    if ((0,
                    R.gn)(this, Vf, "f")) {
                        (0,
                        R.GG)(this, Vf, !1, "f");
                        for (const e of (0,
                        R.gn)(this, Hf, "f"))
                            e((0,
                            R.gn)(this, Vf, "f"))
                    }
                }
                ))
            }
            get touchEnabled() {
                return (0,
                R.gn)(this, Vf, "f")
            }
            addChangeListener(e) {
                (0,
                R.gn)(this, Hf, "f").push(e),
                e((0,
                R.gn)(this, Vf, "f"))
            }
            removeChangeListener(e) {
                const t = (0,
                R.gn)(this, Hf, "f").indexOf(e);
                t >= 0 && (0,
                R.gn)(this, Hf, "f").splice(t, 1)
            }
        }
        ;
        var Kf, qf, Qf, Jf, Xf, Yf, Zf, $f, eg, tg, ng, ig, rg = i(7024), ag = i(7680);
        qf = new WeakMap,
        Qf = new WeakMap,
        Jf = new WeakMap,
        Xf = new WeakMap,
        Yf = new WeakMap,
        Zf = new WeakMap,
        $f = new WeakMap,
        eg = new WeakMap,
        tg = new WeakMap,
        ng = new WeakMap,
        Kf = new WeakSet,
        ig = function(e, t, n) {
            if (!Number.isSafeInteger(e) || !Number.isSafeInteger(t) || !Number.isSafeInteger(n))
                throw new Error("Invalid tile position");
            for (let i = 0; i < (0,
            R.gn)(this, eg, "f").length; i++) {
                const r = (0,
                R.gn)(this, eg, "f")[i];
                if (r.x == e && r.y == t && r.z == n)
                    return (0,
                    R.gn)(this, qf, "f").scene.remove(r.mesh),
                    void (0,
                    R.gn)(this, eg, "f").splice(i, 1)
            }
            const i = new C.eaF(new C.iNn(Ti.A.partSize,Ti.A.partSize,Ti.A.partSize),new C.V9B({
                color: 65280,
                opacity: .5,
                transparent: !0
            }));
            i.position.set((e + .5) * Ti.A.partSize, (0,
            R.gn)(this, Qf, "f") + (t + .5) * Ti.A.partSize, (n + .5) * Ti.A.partSize),
            (0,
            R.gn)(this, qf, "f").scene.add(i),
            (0,
            R.gn)(this, eg, "f").push({
                x: e,
                y: t,
                z: n,
                mesh: i
            })
        }
        ;
        const sg = class {
            constructor(e, t, n, i) {
                Kf.add(this),
                qf.set(this, void 0),
                Qf.set(this, 1e4),
                Jf.set(this, void 0),
                Xf.set(this, void 0),
                Yf.set(this, void 0),
                Zf.set(this, void 0),
                $f.set(this, new C.tBo),
                eg.set(this, []),
                tg.set(this, void 0),
                ng.set(this, void 0),
                (0,
                R.GG)(this, qf, e, "f"),
                (0,
                R.GG)(this, Jf, new C.ubm(70,1,.1,vt.A.maxViewDistance), "f"),
                (0,
                R.gn)(this, Jf, "f").position.set(40, (0,
                R.gn)(this, Qf, "f") + 30, 40),
                e.scene.add((0,
                R.gn)(this, Jf, "f")),
                e.setCamera((0,
                R.gn)(this, Jf, "f")),
                (0,
                R.GG)(this, Xf, new rg.N((0,
                R.gn)(this, Jf, "f"),e.canvas), "f"),
                (0,
                R.gn)(this, Xf, "f").target.set(0, (0,
                R.gn)(this, Qf, "f"), 0),
                (0,
                R.gn)(this, Xf, "f").update(),
                (0,
                R.gn)(this, Xf, "f").mouseButtons = {
                    LEFT: null,
                    MIDDLE: C.kBv.PAN,
                    RIGHT: C.kBv.ROTATE
                },
                t.clear(),
                t.environment = hl.A.Summer;
                const r = n.getPart(i)
                  , a = r.colors.get(Td.A.Summer)?.clone();
                if (null == a)
                    throw new Error("Could not find track part mesh");
                a.position.set(0, (0,
                R.gn)(this, Qf, "f"), 0),
                e.scene.add(a),
                (0,
                R.GG)(this, Yf, a, "f"),
                (0,
                R.GG)(this, Zf, new C.eaF(new C.bdM(1e3,1e3),new C.V9B({
                    color: 0,
                    side: C.$EB
                })), "f"),
                (0,
                R.gn)(this, Zf, "f").rotation.x = -Math.PI / 2,
                (0,
                R.gn)(this, Zf, "f").position.y = (0,
                R.gn)(this, Qf, "f"),
                e.scene.add((0,
                R.gn)(this, Zf, "f")),
                window.addEventListener("click", (0,
                R.GG)(this, tg, (e => {
                    const t = new C.I9Y(e.clientX / window.innerWidth * 2 - 1,-e.clientY / window.innerHeight * 2 + 1);
                    (0,
                    R.gn)(this, $f, "f").setFromCamera(t, (0,
                    R.gn)(this, qf, "f").camera);
                    const n = (0,
                    R.gn)(this, $f, "f").intersectObjects([(0,
                    R.gn)(this, Zf, "f")]);
                    let i;
                    if (n.length > 0) {
                        const e = n[0];
                        i = e.point.distanceToSquared((0,
                        R.gn)(this, Xf, "f").target) <= 2500 ? new C.Pq0(Math.floor(e.point.x / Ti.A.partSize) + 0,Math.floor(((0,
                        R.gn)(this, Zf, "f").position.y - (0,
                        R.gn)(this, Qf, "f")) / Ti.A.partSize) + 0,Math.floor(e.point.z / Ti.A.partSize) + 0) : null
                    } else
                        i = null;
                    null != i && (0,
                    R.gn)(this, Kf, "m", ig).call(this, i.x, i.y, i.z);
                    const r = (0,
                    R.gn)(this, eg, "f").map((e => ({
                        x: e.x,
                        y: e.y,
                        z: e.z
                    }))).sort(( (e, t) => e.x != t.x ? e.x - t.x : e.y != t.y ? e.y - t.y : e.z - t.z))
                      , a = [];
                    for (; ; ) {
                        const e = r.shift();
                        if (null == e)
                            break;
                        const t = {
                            x: e.x,
                            y: e.y,
                            z: e.z
                        }
                          , n = {
                            x: e.x,
                            y: e.y,
                            z: e.z
                        };
                        let i, s, o;
                        do {
                            const e = {
                                x: n.x + 1,
                                y: n.y,
                                z: n.z
                            };
                            i = !0;
                            for (let n = t.y; n <= e.y; n++)
                                for (let a = t.z; a <= e.z; a++)
                                    r.some((t => t.x == e.x && t.y == n && t.z == a)) || (i = !1);
                            i && (n.x = e.x);
                            const a = {
                                x: n.x,
                                y: n.y,
                                z: n.z + 1
                            };
                            s = !0;
                            for (let e = t.x; e <= a.x; e++)
                                for (let n = t.y; n <= a.y; n++)
                                    r.some((t => t.x == e && t.y == n && t.z == a.z)) || (s = !1);
                            s && (n.z = a.z)
                        } while (i || s);
                        do {
                            const e = {
                                x: n.x,
                                y: n.y + 1,
                                z: n.z
                            };
                            o = !0;
                            for (let n = t.x; n <= e.x; n++)
                                for (let i = t.z; i <= e.z; i++)
                                    r.some((t => t.x == n && t.y == e.y && t.z == i)) || (o = !1);
                            o && (n.y = e.y)
                        } while (o);
                        for (let e = t.x; e <= n.x; e++)
                            for (let i = t.y; i <= n.y; i++)
                                for (let a = t.z; a <= n.z; a++) {
                                    const t = r.findIndex((t => t.x == e && t.y == i && t.z == a));
                                    t >= 0 && r.splice(t, 1)
                                }
                        a.push([[t.x, t.y, t.z], [n.x, n.y, n.z]])
                    }
                    console.log(JSON.stringify(a).replace(new RegExp(",","g"), ", "))
                }
                ), "f")),
                window.addEventListener("keydown", (0,
                R.GG)(this, ng, (e => {
                    "KeyC" == e.code && ((0,
                    R.gn)(this, Zf, "f").position.y += Ti.A.partSize,
                    (0,
                    R.gn)(this, Jf, "f").position.y += Ti.A.partSize,
                    (0,
                    R.gn)(this, Xf, "f").target.y += Ti.A.partSize),
                    "KeyZ" == e.code && ((0,
                    R.gn)(this, Zf, "f").position.y -= Ti.A.partSize,
                    (0,
                    R.gn)(this, Jf, "f").position.y -= Ti.A.partSize,
                    (0,
                    R.gn)(this, Xf, "f").target.y -= Ti.A.partSize)
                }
                ), "f"))
            }
            dispose() {
                (0,
                R.gn)(this, Xf, "f").dispose(),
                (0,
                R.gn)(this, qf, "f").scene.remove((0,
                R.gn)(this, Jf, "f")),
                (0,
                R.gn)(this, qf, "f").scene.remove((0,
                R.gn)(this, Yf, "f")),
                (0,
                R.gn)(this, qf, "f").scene.remove((0,
                R.gn)(this, Zf, "f"));
                for (const e of (0,
                R.gn)(this, eg, "f"))
                    (0,
                    R.gn)(this, qf, "f").scene.remove(e.mesh);
                (0,
                R.gn)(this, eg, "f").length = 0,
                window.removeEventListener("click", (0,
                R.gn)(this, tg, "f")),
                window.removeEventListener("keydown", (0,
                R.gn)(this, ng, "f"))
            }
            update() {
                (0,
                R.gn)(this, qf, "f").update(new ag.A)
            }
        }
        ;
        var og;
        og = new WeakMap;
        const lg = class {
            constructor(e, t) {
                og.set(this, void 0),
                (0,
                R.GG)(this, og, e.loadStartupInfo(), "f"),
                t.addCompleteListener(( () => {
                    e.saveStartupInfo(Pt.gp)
                }
                ))
            }
            shouldShowUpdatePopup() {
                return !Pt.EM && !Pt.Tn && "0.5.2" == (0,
                R.gn)(this, og, "f")?.lastVersion
            }
        }
        ;
        /**
 * @license
 * Copyright 2026 Kodub.com
 */
        C.ppV.enabled = !1,
        async function() {
            await async function() {
                const e = Uint8Array.from(atob("AGFzbQEAAAABJAZgAXwBfGACfHwBfGACf38AYAJ/fABgBH9/f38Bf2ACfH8BfAMcGwQDAQAAAAAAAAAAAQACBQIBAQAAAAAAAAAAAAUDAQARBgkBfwFBgIDAAAsHVQwGbWVtb3J5AgAEYWNvcwASBGFzaW4AEwRhdGFuABQFYXRhbjIAEANleHAAFQNsb2cAFgNwb3cAEQRzcXJ0ABcDdGFuABgEbG9nMgAZBWxvZzEwABoKsG4bqxsDHH8BfgR8IwBBwARrIgckACAHQQhqQaABEA8gB0GoAWpBoAEQDyAHQcgCakGgARAPIAdB6ANqQdAAEA9BhIDAACgCACIKIAFBf2oiC2ohBSADQX1qQRhtIgRBACAEQQBKGyIPIAtrIQQgD0ECdCABQQJ0a0GUgMAAaiEJQQAhAQNAIAdBCGogAUEDdGogBEEASAR8RAAAAAAAAAAABSAJKAIAtws5AwAgASAFSQRAIAlBBGohCSAEQQFqIQQgASABIAVJaiIBIAVNDQELCyADQWhqIQVBACEEA0AgBCALaiENIAQgCkkhBkQAAAAAAAAAACEhQQAhAQNAAkAgISAAIAFBA3RqKwMAIAdBCGogDSABa0EDdGorAwCioCEhIAEgC08NACABIAEgC0lqIgEgC00NAQsLIAdByAJqIARBA3RqICE5AwAgBCAKSQRAIAQgBmoiBCAKTQ0BCwtEAAAAAAAA8H9EAAAAAAAA4H8gBSAPQWhsIhdqIgZB/g9LIhIbRAAAAAAAAAAARAAAAAAAAGADIAZBuXBJIhMbRAAAAAAAAPA/IAZBgnhIIhQbIAZB/wdKIhUbIAZB/RcgBkH9F0gbQYJwaiAGQYF4aiASGyIYIAZB8GggBkHwaEobQZIPaiAGQckHaiATGyIZIAYgFBsgFRtB/wdqrUI0hr+iISMgB0HkA2oiECAKQQJ0aiENQRcgBmtBH3EhGkEYIAZrQR9xIRYgB0HAAmohGyAGQX9qIRwgCiEEAkADQCAHQcgCaiAEIgVBA3RqKwMAISECQCAFRQ0AIAdB6ANqIQggBSEBA0AgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhBCAhQQBB/////wcgIplEAAAAAAAA4EFjBH8gIqoFQYCAgIB4C0GAgICAeCAEGyAiRAAAwP///99BZBsgIiAiYhu3IiJEAAAAAAAAcMGioCIhRAAAAAAAAODBZiEEIAhBAEH/////BwJ/ICGZRAAAAAAAAOBBYwRAICGqDAELQYCAgIB4C0GAgICAeCAEGyAhRAAAwP///99BZBsgISAhYhs2AgAgGyABQQN0aisDACAioCEhIAFBAkkiBA0BIAhBBGohCEEBIAFBf2ogBBsiAQ0ACwsCfwJAIBVFBEAgFA0BIAYMAgsgIUQAAAAAAADgf6IiIUQAAAAAAADgf6IgISASGyEhIBgMAQsgIUQAAAAAAABgA6IiIUQAAAAAAABgA6IgISATGyEhIBkLIQECQCAhIAFB/wdqrUI0hr+iIiREAAAAAAAAwD+iIiFEAAAAAAAAAABhDQAgIb0iIEI0iKdB/w9xIgFBsghLDQACQAJAICBCAFkEQCAHICFEAAAAAAAAMEOgRAAAAAAAADDDoCAhoSIiOQO4BCABQf8HTw0BIAcrA7gEGkQAAAAAAAAAACEhDAMLIAcgIUQAAAAAAAAww6BEAAAAAAAAMEOgICGhIiI5A7gEIAFB/wdJDQELICEgIqAiIUQAAAAAAADwv6AgISAiRAAAAAAAAAAAZBshIQwBCyAHKwO4BBpEAAAAAAAA8L8hIQsgJCAhRAAAAAAAACDAoqAiIUQAAAAAAADgwWYhASAhQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggARsgIUQAAMD////fQWQbICEgIWIbIg63oSEhAn8CQAJAAkACQAJ/IAZBAEoiHUUEQCAGRQRAIBAgBUECdGooAgBBF3UMAgtBAiEMQQAgIUQAAAAAAADgP2ZFDQYaDAILIBAgBUECdGoiASABKAIAIgEgASAWdSIBIBZ0ayIENgIAIAEgDmohDiAEIBp1CyIMQQFIDQELIAUNAUEAIQgMAgsgDAwCC0EAIRFBACEIIAVBAUcEQCAFQR5xIR4gB0HoA2ohAQNAIAEoAgAhBEH///8HIQkCfwJAIAgNAEGAgIAIIQkgBA0AQQEMAQsgASAJIARrNgIAQQALIQkgAUEEaiIfKAIAIQhB////ByEEAn8CQCAJRQ0AQYCAgAghBCAIDQBBAAwBCyAfIAQgCGs2AgBBAQshCCABQQhqIQEgHiARQQJqIhFHDQALCyAFQQFxRQ0AIAdB6ANqIBFBAnRqIgkoAgAhAUH///8HIQQCQCAIDQBBgICACCEEIAENAEEAIQgMAQsgCSAEIAFrNgIAQQEhCAsCQCAdRQ0AQf///wMhAQJAAkAgHA4CAQACC0H///8BIQELIBAgBUECdGoiBCAEKAIAIAFxNgIACyAOQQFqIQ4gDCAMQQJHDQAaRAAAAAAAAPA/ICGhICNEAAAAAAAAAAAgCBuhISFBAgshDCAhRAAAAAAAAAAAYQRAIA0hASAFIQQCQCAKIAVBf2oiCEsNAEEAIQkDQAJAIAdB6ANqIAhBAnRqKAIAIAlyIQkgCiAITw0AIAogCCAKIAhJayIITQ0BCwsgBSEEIAlFDQAgBUECdCAHakHkA2ohAQNAIAVBf2ohBSAGQWhqIQYgASgCACABQXxqIQFFDQALDAMLA0AgBEEBaiEEIAEoAgAgAUF8aiEBRQ0ACyAFIARPDQEgBUEBaiEJA0AgB0EIaiAJIAtqIgVBA3RqIAkgD2pBAnRBkIDAAGooAgC3OQMAQQAhAUQAAAAAAAAAACEhA0ACQCAhIAAgAUEDdGorAwAgB0EIaiAFIAFrQQN0aisDAKKgISEgASALTw0AIAEgASALSWoiASALTQ0BCwsgB0HIAmogCUEDdGogITkDACAJIARPDQIgCSAESSAJaiIBIQkgASAETQ0ACwwBCwsCQAJAAkBBACAGayIBQf8HTARAIAFBgnhODQMgIUQAAAAAAABgA6IhISABQbhwTQ0BQckHIAZrIQEMAwsgIUQAAAAAAADgf6IhISABQf4PSw0BQYF4IAZrIQEMAgsgIUQAAAAAAABgA6IhISABQfBoIAFB8GhKG0GSD2ohAQwBCyAhRAAAAAAAAOB/oiEhIAFB/RcgAUH9F0gbQYJwaiEBCyAhIAFB/wdqrUI0hr+iIiFEAAAAAAAAcEFmBEAgIUQAAAAAAABwPqIiIkQAAAAAAADgwWYhACAhQQBB/////wcCfyAimUQAAAAAAADgQWMEQCAiqgwBC0GAgICAeAtBgICAgHggABsgIkQAAMD////fQWQbICIgImIbtyIhRAAAAAAAAHDBoqAiIkQAAAAAAADgwWYhACAHQegDaiAFQQJ0akEAQf////8HAn8gIplEAAAAAAAA4EFjBEAgIqoMAQtBgICAgHgLQYCAgIB4IAAbICJEAADA////30FkGyAiICJiGzYCACADIBdqIQYgBUEBaiEFCyAhRAAAAAAAAODBZiEAIAdB6ANqIAVBAnRqQQBB/////wcCfyAhmUQAAAAAAADgQWMEQCAhqgwBC0GAgICAeAtBgICAgHggABsgIUQAAMD////fQWQbICEgIWIbNgIACwJ8AkACQCAGQf8HTARARAAAAAAAAPA/IAZBgnhODQMaIAZBuHBNDQEgBkHJB2ohBkQAAAAAAABgAwwDCyAGQf4PSw0BIAZBgXhqIQZEAAAAAAAA4H8MAgsgBkHwaCAGQfBoShtBkg9qIQZEAAAAAAAAAAAMAQsgBkH9FyAGQf0XSBtBgnBqIQZEAAAAAAAA8H8LIAZB/wdqrUI0hr+iISEgBUEBcQR/IAUFIAdByAJqIAVBA3RqICEgB0HoA2ogBUECdGooAgC3ojkDACAhRAAAAAAAAHA+oiEhIAVBf2oLIQAgBQRAIABBA3QgB2pBwAJqIQEgAEECdCAHakHkA2ohBANAIAEgIUQAAAAAAABwPqIiIiAEKAIAt6I5AwAgAUEIaiAhIARBBGooAgC3ojkDACABQXBqIQEgBEF4aiEEICJEAAAAAAAAcD6iISEgAEEBRyAAQX5qIQANAAsLIAVBAWohBiAHQcgCaiAFQQN0aiEIIAUhAQNAAkAgCiAFIAEiAGsiAyAKIANJGyINRQRAQQAhBEQAAAAAAAAAACEhDAELIA1BAWpBfnEhCUQAAAAAAAAAACEhQQAhAUEAIQQDQCAhIAFBmILAAGorAwAgASAIaiILKwMAoqAgAUGggsAAaisDACALQQhqKwMAoqAhISABQRBqIQEgCSAEQQJqIgRHDQALCyAHQagBaiADQQN0aiANQQFxBHwgIQUgISAEQQN0QZiCwABqKwMAIAdByAJqIAAgBGpBA3RqKwMAoqALOQMAIAhBeGohCCAAQX9qIQEgAA0ACwJAIAZBA3EiAEUEQEQAAAAAAAAAACEhIAUhBAwBCyAHQagBaiAFQQN0aiEBRAAAAAAAAAAAISEgBSEEA0AgBEF/aiEEICEgASsDAKAhISABQXhqIQEgAEF/aiIADQALCyAFQQNPBEAgBEEDdCAHakGQAWohAQNAICEgAUEYaisDAKAgAUEQaisDAKAgAUEIaisDAKAgASsDAKAhISABQWBqIQEgBEEDRyAEQXxqIQQNAAsLIAIgIZogISAMGzkDACAHKwOoASAhoSEhAkAgBUUNAEEBIQEDQCAhIAdBqAFqIAFBA3RqKwMAoCEhIAEgBU8NASABIAEgBUlqIgEgBU0NAAsLIAIgIZogISAMGzkDCCAHQcAEaiQAIA5BB3ELtxIDA38BfgR8IwBBMGsiBCQAAkACQAJAAkACQCABvSIFQiCIpyIDQf////8HcSICQfvUvYAETwRAIAJBvIzxgARPBEAgBEEAQf////8HAn8CQCACQfvD5IkETwRAIAJB//+//wdLDQUgBUL/////////B4NCgICAgICAgLDBAIS/IgFEAAAAAAAA4MFmIQMgAZlEAAAAAAAA4EFjRQ0BIAGqDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwIC0GAgICAeAtBgICAgHggAxsgAUQAAMD////fQWQbIAEgAWIbtyIHOQMAIAEgB6FEAAAAAAAAcEGiIgFEAAAAAAAA4MFmIQMgBEEAQf////8HAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLQYCAgIB4IAMbIAFEAADA////30FkGyABIAFiGyIDtyIHOQMIIAQgASAHoUQAAAAAAABwQaIiATkDECAEQShqQgA3AwAgBEEgakIANwMAIARCADcDGCAEQQJBASADG0EDIAFEAAAAAAAAAABhGyAEQRhqIAJBFHZB6ndqEAAhAiAFQn9VBEAgACACNgIIIAAgBCsDIDkDECAAIAQrAxg5AwAMBwsgAEEAIAJrNgIIIAAgBCsDIJo5AxAgACAEKwMYmjkDAAwGCyACQb3714AETwRAIAJB+8PkgARGBEACQCABIAFEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiBkQAAEBU+yH5v6KgIgEgBkQxY2IaYbTQPaIiCaEiCL1CgICAgICAgPj/AINC/////////4c/Vg0AIAEgBkQAAGAaYbTQPaIiCKEiByAGRHNwAy6KGaM7oiABIAehIAihoSIJoSIIvUKAgICAgICAgP8Ag0L//////////zxWBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwHCyAFQgBZBEAgAEEENgIIIAAgAUQAAEBU+yEZwKAiAUQxY2IaYbTwvaAiBzkDACAAIAEgB6FEMWNiGmG08L2gOQMQDAcLIABBfDYCCCAAIAFEAABAVPshGUCgIgFEMWNiGmG08D2gIgc5AwAgACABIAehRDFjYhphtPA9oDkDEAwGCyACQfyyy4AERg0EIAVCAFkEQCAAQQM2AgggACABRAAAMH982RLAoCIBRMqUk6eRDum9oCIHOQMAIAAgASAHoUTKlJOnkQ7pvaA5AxAMBgsgAEF9NgIIIAAgAUQAADB/fNkSQKAiAUTKlJOnkQ7pPaAiBzkDACAAIAEgB6FEypSTp5EO6T2gOQMQDAULIANB//8/cUH7wyRGDQIgAkH9souABE8EQCAFQn9VBEAgAEECNgIIIAAgAUQAAEBU+yEJwKAiAUQxY2IaYbTgvaAiBzkDACAAIAEgB6FEMWNiGmG04L2gOQMQDAYLIABBfjYCCCAAIAFEAABAVPshCUCgIgFEMWNiGmG04D2gIgc5AwAgACABIAehRDFjYhphtOA9oDkDEAwFCyAFQn9VDQEgAEF/NgIIIAAgAUQAAEBU+yH5P6AiAUQxY2IaYbTQPaAiBzkDACAAIAEgB6FEMWNiGmG00D2gOQMQDAQLIABBADYCCCAAIAEgAaEiATkDECAAIAE5AwAMAwsgAEEBNgIIIAAgAUQAAEBU+yH5v6AiAUQxY2IaYbTQvaAiBzkDACAAIAEgB6FEMWNiGmG00L2gOQMQDAILAkAgAkEUdiICIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUI0iKdB/w9xa0ERSA0AIAIgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QjSIp0H/D3FrQTJIBEAgByEBDAELIAcgBkQAAAAuihmjO6IiCKEiASAGRMFJICWag3s5oiAHIAGhIAihoSIJoSEICyAAIAg5AwAgACABIAihIAmhOQMQIAZEAAAAAAAA4MFmIQMgAEEAQf////8HAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLQYCAgIB4IAMbIAZEAADA////30FkGyAGIAZiGzYCCAwBCwJAIAEgAUSDyMltMF/kP6JEAAAAAAAAOEOgRAAAAAAAADjDoCIGRAAAQFT7Ifm/oqAiASAGRDFjYhphtNA9oiIJoSIIvUKAgICAgICA+P8Ag0L/////////hz9WDQAgASAGRAAAYBphtNA9oiIIoSIHIAZEc3ADLooZozuiIAEgB6EgCKGhIgmhIgi9QoCAgICAgICA/wCDQv//////////PFYEQCAHIQEMAQsgByAGRAAAAC6KGaM7oiIIoSIBIAZEwUkgJZqDezmiIAcgAaEgCKGhIgmhIQgLIAAgCDkDACAAIAEgCKEgCaE5AxAgBkQAAAAAAADgwWYhAyAAQQBB/////wcCfyAGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAtBgICAgHggAxsgBkQAAMD////fQWQbIAYgBmIbNgIICyAEQTBqJAALzA8DCX8CfgV8RAAAAAAAAPA/IQ0CQAJAAkACQCABvSILQiCIpyIIQf////8HcSICIAunIgZyRQ0AIAC9IgxCIIinIQQgDKciCUVBACAEQYCAwP8DRhsNAAJAAkACQAJAAkACQCAEQf////8HcSIFQYCAwP8HSw0AAkAgBUGAgMD/B0YEQCAJIAJBgIDA/wdLcg0CDAELIAJBgYDA/wdPDQELIAJBgIDA/wdHDQEgBg0AIAVBgIDAgHxqIAlyRQ0GIAVB//+//wNLDQJEAAAAAAAAAAAgAZogC0J/VRsPCyAAIAGgDwsgDEIAUw0BIAYNAyACQYCAwP8DRw0CDAULIAFEAAAAAAAAAAAgC0J/VRsPC0ECIQMCQAJAIAJB////mQRLDQBBACEDIAJBgIDA/wNJDQAgAkEUdiEHIAJB////iQRNBEAgBg0EIAJBEyAHayIGdiIHIAZ0IAJHDQJBAiAHQQFxayEDDAILIAZBEyAHayIHdiIKIAd0IAZHDQBBAiAKQQFxayEDIAYNAwwBCyAGDQILIAJBgIDA/wNGDQMLIAhBgICA/wNHBEAgCEGAgICABEcNASAAIACiDwsgDEIAUw0AIAAQBA8LIACZIQ0CQAJAIAkNACAEQX9MBEAgBEGAgICAeEYgBEGAgMD/e0ZyDQIgBEGAgEBHDQEMAgsgBEUgBEGAgMD/A0ZyIARBgIDA/wdGcg0BC0QAAAAAAADwPyEPAkAgDEIAWQ0AAkACQCADDgIAAQILIAAgAKEiACAAow8LRAAAAAAAAPC/IQ8LAkAgAkGAgICPBE0EQCANRAAAAAAAAEBDoiIAIA0gBUGAgMAASSICGyENIAC9QiCIpyAFIAIbIgVB//8/cSIDQYCAwP8DciEEIAVBFHVBzHdBgXggAhtqIQVBACECAkAgA0GPsQ5JDQAgA0H67C5JBEBBASECDAELIANBgICA/wNyIQQgBUEBaiEFCyACQQN0IgNBqIPAAGorAwBEAAAAAAAA8D8gA0GYg8AAaisDACIAIA29Qv////8PgyAErUIghoS/IhCgoyINIBAgAKEiDiACQRJ0IARBAXZqQYCAoIACaq1CIIa/IhEgDiANoiIOvUKAgICAcIO/Ig2ioSAQIBEgAKGhIA2ioaIiACANIA2iIhBEAAAAAAAACECgIAAgDiANoKIgDiAOoiIAIACiIAAgACAAIAAgAETvTkVKKH7KP6JEZdvJk0qGzT+gokQBQR2pYHTRP6CiRE0mj1FVVdU/oKJE/6tv27Zt2z+gokQDMzMzMzPjP6CioCIRoL1CgICAgHCDvyIAoiAOIBEgAEQAAAAAAAAIwKAgEKGhoqAiDiAOIA0gAKIiDaC9QoCAgIBwg78iACANoaFE/QM63AnH7j+iIABE9QFbFOAvPr6ioKAiDSADQbiDwABqKwMAIg4gDSAARAAAAOAJx+4/oiINoKAgBbciEKC9QoCAgIBwg78iACAQoSAOoSANoaEhDgwBCwJAAkAgAkGAgMCfBE0EQCAFQf//v/8DSQ0CIAVBgIDA/wNLDQEgDUQAAAAAAADwv6AiAERE3134C65UPqIgACAAokQAAAAAAADgPyAAIABEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIg0gDSAARAAAAGBHFfc/oiINoL1CgICAgHCDvyIAIA2hoSEODAMLIAVB//+//wNNBEBEAAAAAAAA8H9EAAAAAAAAAAAgC0IAUxsPC0QAAAAAAADwf0QAAAAAAAAAACAIQQBKGw8LIAhBAEwNBQwGCyALQgBZDQQMBQsgACALQoCAgIBwg78iEKIiDSAOIAGiIAEgEKEgAKKgIgCgIgG9IgunIQICQCALQiCIpyIDQf//v4QETARAIANBgPj//wdxQf+Xw4QETQ0BIANBgOi8+wNqIAJyDQUgACABIA2hZUUNAQwFCyADQYCAwPt7aiACcg0FIABE/oIrZUcVlzygIAEgDaFkRQ0ADAULQQAhAiAPAnwgA0H/////B3FBgICA/wNLBH5BAEGAgMAAIANBFHZBAmp2IANqIgNB//8/cUGAgMAAckETIANBFHYiBGt2IgJrIAIgC0IAUxshAiAAIA1BgIBAIARBAWp1IANxrUIghr+hIg2gvQUgCwtCgICAgHCDvyIBRAAAAABDLuY/oiIOIAAgASANoaFE7zn6/kIu5j+iIAFEOWyoDGFcIL6ioCINoCIAIAAgACAAIACiIgEgASABIAEgAUTQpL5yaTdmPqJE8WvSxUG9u76gokQs3iWvalYRP6CiRJO9vhZswWa/oKJEPlVVVVVVxT+goqEiAaIgAUQAAAAAAAAAwKCjIA0gACAOoaEiASAAIAGioKGhRAAAAAAAAPA/oCIAvSILQiCIpyACQRR0aiIDQYCAwABOBEAgC0L/////D4MgA61CIIaEvwwBCyAAIAIQDguiIQ0MAQtEAAAAAAAA8D8gDaMgDSALQgBTGyENIAxCf1UNACADIAVBgIDAgHxqckUEQCANIA2hIgAgAKMPCyANmiANIANBAUYbDwsgDQ8LIAtCf1UEQCAADwtEAAAAAAAA8D8gAKMPCyAPRFnz+MIfbqUBokRZ8/jCH26lAaIPCyAPRJx1AIg85Dd+okScdQCIPOQ3fqILswcDBH8BfgN8IwBBIGsiAiQAAkACQAJ8AkACQCAAvSIFQiCIp0H/////B3EiAUH8w6T/A08EQCABQf//v/8HTQRAIAJBCGogABABIAIoAhAhAyACKwMYIQggAisDCCIHvSIFQoCAgICA/////wCDQoCAgIDwhOXyP1YiBA0CDAULIAAgAKEhAAwFCyABQYCAgPIDTwRAIAVCgICAgID/////AINCgICAgPCE5fI/ViIBDQIgAAwDCyACIABEAAAAAAAAcDiiIABEAAAAAAAAcEegIAFBgIDAAEkbOQMIIAIrAwgaDAQLRBgtRFT7Iek/IAcgB5ogBUJ/VSIBG6FEB1wUMyamgTwgCCAImiABG6GgIQdEAAAAAAAAAAAhCAwCC0QYLURU+yHpPyAAmiAAIAVCAFMboUQHXBQzJqaBPKALIgcgByAHIAeiIgaiIgBEY1VVVVVV1T+iIAYgACAGIAaiIgAgACAAIAAgAERzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgBiAAIAAgACAAIABE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCiRAAAAAAAAAAAoKJEAAAAAAAAAACgoCIGoCEAIAFFDQFEAAAAAAAA8D8gByAGIAAgAKIgAEQAAAAAAADwP6CjoaAiACAAoKEiAJogACAFQgBTGyEADAELIANBAXEhASAHIAcgByAHoiIGoiIARGNVVVVVVdU/oiAIIAYgCCAAIAYgBqIiACAAIAAgACAARHNTYNvLdfO+okSmkjegiH4UP6CiRAFl8vLYREM/oKJEKANWySJtbT+gokQ31gaE9GSWP6CiRHr+EBEREcE/oCAGIAAgACAAIAAgAETUer90cCr7PqJE6afwMg+4Ej+gokRoEI0a9yYwP6CiRBWD4P7I21c/oKJEk4Ru6eMmgj+gokT+QbMbuqGrP6CioKKgoqCgIgigIQAgBEUEQCABRQ0BRAAAAAAAAPC/IACjIgYgAL1CgICAgHCDvyIAIAa9QoCAgIBwg78iBqJEAAAAAAAA8D+gIAggACAHoaEgBqKgoiAGoCEADAELRAAAAAAAAPA/IAG3IgYgBqChIgYgByAIIAAgAKIgBiAAoKOhoCIAIACgoSIAmiAAIAVCAFMbIQALIAJBIGokACAAC9UEAgl/AX4gAL0iCkIgiKciAUGAgMD/B3FBgIDA/wdGBEAgACAAoiAAoA8LIAqnIQICfwJ/AkACQAJAAkAgAUEATARAIAFB/////wdxIAJyRQ0CIApCf1cNAQsgAUEUdSABQf//P0sNBRpBASEEIAEEQCACIQMMBAsgAiEDA0AgBEFraiEEIAMiAkEVdCEDIAJBgBBJDQALDAILIAAgAKEiACAAoyEACyAADwsgAkELdiIBIAJBAEgNARoLIAFBFCABZ0Efc2siBXQLIQEgAyAFdCECIANBACAFa3YgAXIhASAEIAVrCyABQf//P3FBgIDAAHIhA0GBeGoiCUEBcQRAIANBAXQgAkEfdnIhAyACQQF0IQILIANBAXQgAkEfdnIhBCACQQF0IQNBgICAASEBQQAhAgNAIAIgASACaiIFIAFqIAUgBEoiBhshAiAEQQAgBSAGG2tBAXQgA0EfdnIhBCADQQF0IQNBACABIAYbIAdqIQcgAUEBSyABQQF2IQENAAtBgICAgHghBUEAIQYDQCAEIAJMQQAgAiAERyADIAggBSIBaiIFSXIbRQRAIAQgAmsgAyAFSWshBCACIAVBAEggASAFaiIIQX9KcWohAiABIAZqIQYgAyAFayEDCyAEQQF0IANBH3ZyIQQgAUEBdiEFIANBAXQhAyABQQJPDQALAkAgAyAEckUNACAGQX9GBEAgB0EBaiEHQQAhBgwBCyAGQQFxIAZqIQYLIAdBH3QgBkEBdnKtIAlBE3RBgIBAcSAHQQF1akGAgID/A2qtQiCGhL8LrQUDA38BfgJ8IwBBEGshASAAvSIEQj+IpyECAkACfCAAAn8CQAJAAkACQCAEQiCIp0H/////B3EiA0GrxpiEBE8EQCAAIABiBEAgAA8LIABE7zn6/kIuhkBkDQIgAETSvHrdKyOGwGNFDQEgAUQAAAAAAACgtiAAo7Y4AgQgASoCBBogAERRMC3VEEmHwGNFDQEMBwsgA0HC3Nj+A00EQCADQYCAwPEDTQ0DQQAhASAADAYLIANBscXC/wNNDQMLIABE/oIrZUcV9z+iIAJBA3RBiIPAAGorAwCgIgVEAAAAAAAA4MFmIQJBAEH/////BwJ/IAWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C0GAgICAeCACGyAFRAAAwP///99BZBsgBSAFYhsMAwsgAEQAAAAAAADgf6IPCyABIABEAAAAAAAA4H+gOQMIIAErAwgaIABEAAAAAAAA8D+gDwsgAkEBcyACawsiAbciBUQAAOD+Qi7mv6KgIgAgBUR2PHk17znqPaIiBqELIQUgACAFIAUgBSAFoiIAIAAgACAAIABE0KS+cmk3Zj6iRPFr0sVBvbu+oKJELN4lr2pWET+gokSTvb4WbMFmv6CiRD5VVVVVVcU/oKKhIgCiRAAAAAAAAABAIAChoyAGoaBEAAAAAAAA8D+gIQUgAUUNAAJAAkACQCABQf8HTARAIAFBgnhODQMgBUQAAAAAAABgA6IhBSABQbhwTQ0BIAFByQdqIQEMAwsgBUQAAAAAAADgf6IhBSABQf4PSw0BIAFBgXhqIQEMAgsgBUQAAAAAAABgA6IhBSABQfBoIAFB8GhKG0GSD2ohAQwBCyAFRAAAAAAAAOB/oiEFIAFB/RcgAUH9F0gbQYJwaiEBCyAFIAFB/wdqrUI0hr+iIQULIAULygUDAX8BfgF8AkAgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEAgAUGAgID/A08EQCACQn9VBEBEAAAAAAAA8D8gAKFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyAAEAQiA6IgACADvUKAgICAcIO/IgAgAKKhIAMgAKCjoCAAoCIAIACgDwtEGC1EVPsh+T8gAEQAAAAAAADwP6BEAAAAAAAA4D+iIgAQBCIDIAMgACAAIAAgACAAIABECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiAAIAAgACAARIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjokQHXBQzJqaRvKCgoSIAIACgIQMMAgtEGC1EVPsh+T8hAyABQYGAgOMDSQ0BRAdcFDMmppE8IAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACioSAAoUQYLURU+yH5P6APCyACpyABQYCAwIB8anIEQEQAAAAAAAAAACAAIAChow8LRAAAAAAAAAAARBgtRFT7IQlAIAJCf1UbDwsgAwvJBAMBfwF+A3wgAL0iAkIgiKdB/////wdxIgFB//+//wNNBEACQAJ8AkAgAUGAgID/A08EQEQAAAAAAADwPyAAmaFEAAAAAAAA4D+iIgAgACAAIAAgACAARAn3/Q3hPQI/okSIsgF14O9JP6CiRDuPaLUogqS/oKJEVUSIDlXByT+gokR9b+sDEtbUv6CiRFVVVVVVVcU/oKIgACAAIAAgAESCki6xxbizP6JEWQGNG2wG5r+gokTIilmc5SoAQKCiREstihwnOgPAoKJEAAAAAAAA8D+goyEFIAAQBCEDIAFBsua8/wNLDQFEGC1EVPsh6T8gA71CgICAgHCDvyIEIASgoUQHXBQzJqaRPCAAIAQgBKKhIAMgBKCjIgAgAKChIAUgAyADoKKhoEQYLURU+yHpP6AMAgsgAUGAgEBqQYCAgPIDSQ0CIAAgAKIiAyADIAMgAyADIANECff9DeE9Aj+iRIiyAXXg70k/oKJEO49otSiCpL+gokRVRIgOVcHJP6CiRH1v6wMS1tS/oKJEVVVVVVVVxT+goiADIAMgAyADRIKSLrHFuLM/okRZAY0bbAbmv6CiRMiKWZzlKgBAoKJESy2KHCc6A8CgokQAAAAAAADwP6CjIACiIACgDwtEGC1EVPsh+T8gAyAFIAOioCIAIACgRAdcFDMmppG8oKELIgCaIAAgAkIAUxshAAsgAA8LIAKnIAFBgIDAgHxqcgRARAAAAAAAAAAAIAAgAKGjDwsgAEQYLURU+yH5P6JEAAAAAAAAcDigC48EAwJ/AX4DfCMAQRBrIQICQAJ/AkACQAJAIAC9IgNCIIinQf////8HcSIBQf//v6AETQRAIAFBgIDw/gNJDQEgAJkhACABQYCAzP8DSQ0DIAFBgICOgARJDQJEAAAAAAAA8L8gAKMhAEEDDAQLIAAgAGINBEQYLURU+yH5PyAApg8LQX8gAUGAgIDyA08NAhogAUGAgMAATw0DIAIgALY4AgwgAioCDBogAA8LIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELIAFBgICY/wNPBEAgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyAAIACgRAAAAAAAAPC/oCAARAAAAAAAAABAoKMhAEEACyECIAAgAKIiBSAFoiIEIAQgBCAEIAREL2xqLES0or+iRJr93lIt3q2/oKJEbZp0r/Kws7+gokRxFiP+xnG8v6CiRMTrmJmZmcm/oKIhBiAFIAQgBCAEIAQgBEQR2iLjOq2QP6JE6w12JEt7qT+gokRRPdCgZg2xP6CiRG4gTMXNRbc/oKJE/4MAkiRJwj+gokQNVVVVVVXVP6CiIQQgAUGAgPD+A08EQCACQQN0IgFByIPAAGorAwAgACAGIASgoiABQeiDwABqKwMAoSAAoaEiAJogACADQgBTGw8LIAAgACAGIASgoqEhAAsgAAvnAwMDfwF+BnwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyACQeK+JWoiAUEUdiADarciB0QAYJ9QE0TTP6IiCCAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAAgAEQAAAAAAADgP6KiIgWhvUKAgICAcIO/IgZEAAAgFXvL2z+iIgmgIgogCSAIIAqhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACAVe8vbP6IgB0Q2K/ER8/5ZPaIgACAGoETVrZrKOJS7PaKgoKCgDwsgACAAoUQAAAAAAAAAAKMhAAsgAAvOAwMDfwF+BXwCQAJAAkACQCAAvSIEQgBTDQAgBEIgiKciAUGAgMAASQ0AIAFB//+//wdLDQNBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAAvUL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCAFMNASAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyAEQv////8PgyACQeK+JWoiAUH//z9xQZ7Bmv8Daq1CIIaEv0QAAAAAAADwv6AiACAAIABEAAAAAAAA4D+ioiIFob1CgICAgHCDvyIGRAAAIGVHFfc/oiIHIAFBFHYgA2q3IgigIgkgByAIIAmhoCAAIAahIAWhIAAgAEQAAAAAAAAAQKCjIgAgBSAAIACiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAiAEQAACBlRxX3P6IgACAGoEQAou8u/AXnPaKgoKAPCyAAIAChRAAAAAAAAAAAoyEACyAAC6UDAgV/AX4gASABYSAAIABhcUUEQCAAIAGgDwsgAb0iB0IgiKciAkGAgMCAfGogB6ciBXJFBEAgABAIDwsgAkEedkECcSIGIAC9IgdCP4inciEDAkACQAJAIAdCIIinQf////8HcSIEIAenckUEQEQYLURU+yEJwCEBAkACQCADDgMAAAEDCyAADwtEGC1EVPshCUAPCyACQf////8HcSICIAVyRQ0CAkAgAkGAgMD/B0YEQCAEQYCAwP8HRw0BRNIhM3982QLAIQEgA0EDRg0CIANBA3RB2ILAAGorAwAPCyAEQYCAwP8HRiACQYCAgCBqIARJcg0CAnwgBgRARAAAAAAAAAAAIARBgICAIGogAkkNARoLIAAgAaOZEAgLIQECQAJAAkAgAw4DBAECAAsgAUQHXBQzJqahvKBEGC1EVPshCcCgDwsgAZoPC0QYLURU+yEJQCABRAdcFDMmpqG8oKEPC0QYLURU+yEJwCEBIANBA0YNACADQQN0QfCCwABqKwMAIQELIAEPC0QYLURU+yH5PyAApg8LRBgtRFT7Ifk/IACmC54DAwN/AX4CfAJAAkACQAJAIAC9IgRCAFMNACAEQiCIpyIBQYCAwABJDQAgAUH//7//B0sNA0GAgMD/AyECQYF4IQMgAUGAgMD/A0cEQCABIQIMAgsgBKcNAUQAAAAAAAAAAA8LIAC9Qv///////////wCDUARARAAAAAAAAPC/IAAgAKKjDwsgBEIAUw0BIABEAAAAAAAAUEOivSIEQiCIpyECQct3IQMLIAJB4r4laiIBQRR2IANqtyIFRAAA4P5CLuY/oiAEQv////8PgyABQf//P3FBnsGa/wNqrUIghoS/RAAAAAAAAPC/oCIAIAVEdjx5Ne856j2iIAAgAEQAAAAAAAAAQKCjIgUgACAARAAAAAAAAOA/oqIiBiAFIAWiIgUgBaIiACAAIABEn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiAFIAAgACAARERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoqAgBqGgoA8LIAAgAKFEAAAAAAAAAACjIQALIAALjgEBAn8gAUEQTwRAIABBACAAa0EDcSIDaiECIAMEQANAIABBADoAACAAQQFqIgAgAkkNAAsLIAIgASADayIBQXxxIgNqIQAgA0EBTgRAA0AgAkEANgIAIAJBBGoiAiAASQ0ACwsgAUEDcSEBCyABBEAgACABaiEBA0AgAEEAOgAAIABBAWoiACABSQ0ACwsLrAEAAkACQAJAIAFB/wdMBEAgAUGCeE4NAyAARAAAAAAAAGADoiEAIAFBuHBNDQEgAUHJB2ohAQwDCyAARAAAAAAAAOB/oiEAIAFB/g9LDQEgAUGBeGohAQwCCyAARAAAAAAAAGADoiEAIAFB8GggAUHwaEobQZIPaiEBDAELIABEAAAAAAAA4H+iIQAgAUH9FyABQf0XSBtBgnBqIQELIAAgAUH/B2qtQjSGv6ILCAAgACABEA0LCAAgACABEAsLCAAgACABEAILBgAgABAGCwYAIAAQBwsGACAAEAgLBgAgABAFCwYAIAAQDAsGACAAEAQLBgAgABADCwYAIAAQCgsGACAAEAkLC+YKBQBBgIDAAAvwAgMAAAAEAAAABAAAAAYAAACD+aIARE5uAPwpFQDRVycA3TT1AGLbwAA8mZUAQZBDAGNR/gC73qsAt2HFADpuJADSTUIASQbgAAnqLgAcktEA6x3+ACmxHADoPqcA9TWCAES7LgCc6YQAtCZwAEF+XwDWkTkAU4M5AJz0OQCLX4QAKPm9APgfOwDe/5cAD5gFABEv7wAKWosAbR9tAM9+NgAJyycARk+3AJ5mPwAt6l8Auid1AOXrxwA9e/EA9zkHAJJSigD7a+oAH7FfAAhdjQAwA1YAe/xGAPCrawAgvM8ANvSaAOOpHQBeYZEACBvmAIWZZQCgFF8AjUBoAIDY/wAnc00ABgYxAMpWFQDJqHMAe+JgAGuMwAAAAABA+yH5PwAAAAAtRHQ+AAAAgJhG+DwAAABgUcx4OwAAAICDG/A5AAAAQCAlejgAAACAIoLjNgAAAAAd82k1GC1EVPsh6T8YLURU+yHpv9IhM3982QJAAEH/gsAACymAGC1EVPshCUAAAAAAAADgPwAAAAAAAOC/AAAAAAAA8D8AAAAAAAD4PwBBsIPAAAsIBtDPQ+v9TD4AQcODwAALmQdAA7jiP0+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTxMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAAgCEAAqAAAAQzpcVXNlcnNcSm9uYXRoYW5cLmNhcmdvXHJlZ2lzdHJ5XHNyY1xpbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZlxvbmNlX2NlbGwtMS4yMC4yXHNyYy9saWIucnMAADwCEABiAAAACAMAABkAAAByZWVudHJhbnQgaW5pdAAAsAIQAA4AAAA8AhAAYgAAAHoCAAANAAAABAAAAAwAAAAEAAAABQAAAAYAAAAHAAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAPACEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADwAhAAKQAAAK4EAAANAAAAbWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAmAMQABUAAACtAxAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc8wDEAAYAAAAZAEAAAkAAAAEAAAADAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAACQAAAAAAAAAIAAAABAAAAAoAAAALAAAADAAAAA0AAAAOAAAAEAAAAAQAAAAPAAAAEAAAABEAAAASAAAAY2FwYWNpdHkgb3ZlcmZsb3cAAABMBBAAEQAAAGxpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnNoBBAAHAAAABkAAAAFAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAQfSKwAALAQEAfAlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuODEuMCAoZWViOTBjZGExIDIwMjQtMDktMDQpBndhbHJ1cwYwLjIzLjMMd2FzbS1iaW5kZ2VuEzAuMi4xMDAgKDI0MDVlYzJiNCkALA90YXJnZXRfZmVhdHVyZXMCKw9tdXRhYmxlLWdsb2JhbHMrCHNpZ24tZXh0"), (e => e.charCodeAt(0)))
                  , t = await WebAssembly.compile(e)
                  , n = (await WebAssembly.instantiate(t)).exports;
                Math = {
                    E: z,
                    LN10: U,
                    LN2: D,
                    LOG2E: B,
                    LOG10E: G,
                    PI: F,
                    SQRT1_2: O,
                    SQRT2: W,
                    abs: Math.abs,
                    acos: n.acos,
                    asin: n.asin,
                    atan: n.atan,
                    atan2: n.atan2,
                    ceil: Math.ceil,
                    cos: j,
                    exp: n.exp,
                    floor: Math.floor,
                    log: n.log,
                    max: Math.max,
                    min: Math.min,
                    pow: n.pow,
                    random: Math.random,
                    round: Math.round,
                    sin: H,
                    sqrt: n.sqrt,
                    tan: n.tan,
                    clz32: Math.clz32,
                    imul: Math.imul,
                    sign: Math.sign,
                    log10: n.log10,
                    log2: n.log2,
                    log1p: Math.log1p,
                    expm1: Math.expm1,
                    cosh: Math.cosh,
                    sinh: Math.sinh,
                    tanh: Math.tanh,
                    acosh: Math.acosh,
                    asinh: Math.asinh,
                    atanh: Math.atanh,
                    hypot: Math.hypot,
                    trunc: Math.trunc,
                    cbrt: Math.cbrt,
                    fround: Math.fround,
                    [Symbol.toStringTag]: "Math"
                }
            }();
            const e = new bu;
            await e.initialize(),
            e.migrate();
            const t = new jh
              , n = new lg(e,t)
              , r = new Hu(e);
            t.addResource(),
            I.n_().then(( () => {
                t.loadedResource()
            }
            )),
            t.addCompleteListener(( () => {
                if (E.cleanUpRecords(),
                I.R_(),
                Pt.EM) {
                    const e = new URLSearchParams(window.location.search)
                      , t = e.get("debug_track");
                    if (null != t) {
                        const e = w.getTrackByName(t);
                        if (null != e) {
                            const t = E.getRecord(x.profileSlot, e.id);
                            if (null != t) {
                                const n = x.getCurrentUserProfile();
                                e.trackData().then((i => {
                                    V(e.trackMetadata, i, e.trackCategory, [{
                                        recording: t.recording,
                                        carStyle: n.carStyle,
                                        nickname: n.nickname,
                                        time: t.time,
                                        isSelf: !0
                                    }], null)
                                }
                                ))
                            } else
                                e.trackData().then((t => {
                                    V(e.trackMetadata, t, e.trackCategory, [], null)
                                }
                                ))
                        }
                    }
                    const n = e.get("track_part_editor_id");
                    if (null != n) {
                        const e = parseInt(n, 10);
                        isNaN(e) || o.trigger(( () => {
                            J.dispose(),
                            J = new sg(h,y,d,e)
                        }
                        ))
                    }
                }
                if (window.electron) {
                    const e = window.electron.getArgv()
                      , t = "-verifier_token="
                      , n = e.find((e => e.startsWith(t)));
                    if (null != n) {
                        const e = n.substring(t.length);
                        q(e)
                    }
                }
            }
            ));
            const a = i(7780);
            for (const e of a.keys())
                t.preloadImage("images/" + e.substring(2));
            const s = new Iu
              , o = new Ld(s)
              , l = new L(t,r);
            l.load("music", ["audio/music.ogg", "audio/music.mp3"]),
            l.load("click", ["audio/click.ogg", "audio/click.mp3"]),
            l.load("engine", ["audio/engine.ogg", "audio/engine.mp3"]),
            l.load("suspension", ["audio/suspension.ogg", "audio/suspension.mp3"]),
            l.load("tires", ["audio/tires.ogg", "audio/tires.mp3"]),
            l.load("collision", ["audio/collision.ogg", "audio/collision.mp3"]),
            l.load("skidding", ["audio/skidding.ogg", "audio/skidding.mp3"]),
            l.load("editor_edit", ["audio/editor_edit.ogg", "audio/editor_edit.mp3"]),
            l.load("checkpoint", ["audio/checkpoint.ogg", "audio/checkpoint.mp3"]),
            l.load("record", ["audio/record.ogg", "audio/record.mp3"]),
            l.load("position_tick", ["audio/position_tick.ogg", "audio/position_tick.mp3"]),
            "capacitor" == Pt.aC && (m.addListener("appStateChange", (e => {
                l.isAppActive = e.isActive
            }
            )),
            m.addListener("backButton", ( () => {
                m.exitApp()
            }
            ))),
            td.A.initResources(t);
            const c = document.getElementById("screen");
            if (!(c instanceof HTMLCanvasElement))
                throw new Error("Screen is not a canvas element");
            const h = new vt.A(c,r)
              , d = new Md
              , u = d.init(h, t)
              , p = new ju.A(!0,d,t)
              , f = new ju.A(!1,d,t)
              , g = p.testDeterminism();
            t.addResource(),
            t.addResource(),
            t.addResource(),
            N.A.initResources().then((e => {
                t.loadedResource(),
                u.then((n => {
                    t.loadedResource(),
                    g.then((i => {
                        S.determinismState = i ? n && e ? oo.Ok : oo.AssetsFailed : oo.TestFailed,
                        t.loadedResource()
                    }
                    ))
                }
                ))
            }
            ));
            const A = new Bd(h,r,t)
              , v = new fs.A(h)
              , y = new Ti.A(h,r,d)
              , w = new gd(t,e)
              , b = new Ms(r.getSetting(P.A.Language))
              , x = new vu.A(e)
              , S = new Bu;
            x.syncUserProfile(S);
            const E = new nd(e,w,S,x)
              , T = new ne
              , k = new Fh(l)
              , M = new jf
              , _ = (i, a) => {
                o.trigger(( () => {
                    I.bQ(),
                    I.pS();
                    const oldState = J;
                    J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,i,a,C,R,V,K,q,Q),
                    I.PM(),
                    requestAnimationFrame(( () => {
                        "function" == typeof requestIdleCallback ? requestIdleCallback(( () => {
                            try {
                                oldState.dispose()
                            } catch {}
                        }
                        ), {
                            timeout: 2e3
                        }) : setTimeout(( () => {
                            try {
                                oldState.dispose()
                            } catch {}
                        }
                        ), 0)
                    }
                    ))
                }
                ))
            }
              , C = () => {
                o.trigger((async () => {
                    I.bQ(),
                    I.pS();
                    try {
                        const {default: t} = await i.e(280).then(i.bind(i, 3280));
                        await t.initResources(),
                        J.dispose(),
                        J = new t(b,y,v,A,h,l,x,r,S,k,e,( () => {
                            _(!1, null)
                        }
                        )),
                        I.PM()
                    } catch (i) {
                        // This repo is missing code-split chunks (e.g. 280.bundle.js). Fall back to the menu.
                        console.error("Failed to load customization state: ", i);
                        try {
                            _(!1, null)
                        } catch {}
                        try {
                            I.PM()
                        } catch {}
                    }
                }
                ))
            }
              , R = () => {
                o.trigger((async () => {
                    try {
                        await I.RN()
                    } finally {
                        I.pS();
                        try {
                            const {default: a} = await i.e(124).then(i.bind(i, 4124));
                            await a.initResources(),
                            J.dispose();
                            const c = J = new a(y,d,e,v,A,b,l,h,r,o,x,E,w,k,M,( () => {
                                I.bQ(),
                                I.pS(),
                                J.dispose(),
                                J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,!1,null,C,R,V,K,q,Q),
                                I.PM()
                            }
                            ),( (t, n, i) => {
                                const a = J = new ps(p,f,y,v,A,b,h,l,x,E,e,r,s,k,M,w,t,n,"custom",[],null,null,!1,( () => {
                                    throw new Error("Multiplayer connection lost should never be called from the editor")
                                }
                                ),( () => {
                                    I.tU(),
                                    a.dispose(!1),
                                    J = c,
                                    i()
                                }
                                ),null,null,( () => {
                                    throw new Error("Multiplayer new session should never be called from the editor")
                                }
                                ))
                            }
                            ));
                            I.PM(),
                            I.tU()
                        } catch (i) {
                            console.error("Failed to load editor state: ", i);
                            const a = b.get("Failed to load editor.") + "\n\n" + b.get("Check your internet connection and try again.");
                            J.dispose(),
                            J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,!1,a,C,R,V,K,q,Q),
                            I.PM()
                        }
                    }
                }
                ))
            }
              , V = (t, n, i, a, c) => {
                o.trigger(( () => I.RN().finally(( () => {
                    let o, d;
                    I.pS(),
                    J instanceof ps && null != c && J.multiplayerConnection == c.multiplayerConnection ? J.dispose(!0, !1) : J.dispose(),
                    o = "official" == i && null == c ? w.getNextOfficialTrack(n) : null,
                    d = null != o ? () => {
                        let e;
                        const t = E.getRecord(x.profileSlot, o.id);
                        if (null != t) {
                            const n = x.getCurrentUserProfile();
                            e = [{
                                recording: t.recording,
                                carStyle: n.carStyle,
                                nickname: n.nickname,
                                time: t.time,
                                isSelf: !0
                            }]
                        } else
                            e = [];
                        V(o.trackMetadata, o.trackData, o.trackCategory, e, null)
                    }
                    : null;
                    const u = "official" == i || "community" == i
                      , g = x.profileSlot
                      , m = E.getRecord(g, n.getId());
                    let T;
                    T = null != m ? {
                        time: m.time,
                        position: S.getLeaderboardUserEntry(x.getCurrentUserProfile().tokenHash, n.getId(), u).then((e => null != e && e.id == m.uploadId ? e.position : null)).catch((e => (console.warn(e),
                        null))),
                        recording: m.recording
                    } : null,
                    J = new ps(p,f,y,v,A,b,h,l,x,E,e,r,s,k,M,w,t,n,i,a,T,c,!0,(e => {
                        let t;
                        switch (e) {
                        case "kicked":
                            t = b.get("You were kicked from the game");
                            break;
                        case "disconnected":
                            t = b.get("Lost connection to server")
                        }
                        _(!1, t)
                    }
                    ),( () => {
                        _(null == c, null)
                    }
                    ),K,d,( (e, t, n, i) => {
                        if (null == c)
                            throw new Error("Tried to start new multiplayer session without a multiplayer connection");
                        V(n, i, "custom", [], {
                            multiplayerConnection: c.multiplayerConnection,
                            sessionId: e,
                            gameMode: t
                        })
                    }
                    )),
                    I.PM()
                }
                ))))
            }
              , K = (e, t, n, i) => {
                o.trigger(( () => {
                    I.pS();
                    const oldState = J;
                    J = new Wf(f,y,e,t,n,v,A,h,l,b,r,i,( (e, t, n, i) => {
                        V(e, t, n, i, null)
                    }
                    )),
                    I.PM(),
                    I.tU(),
                    requestAnimationFrame(( () => {
                        "function" == typeof requestIdleCallback ? requestIdleCallback(( () => {
                            try {
                                oldState.dispose()
                            } catch {}
                        }
                        ), {
                            timeout: 2e3
                        }) : setTimeout(( () => {
                            try {
                                oldState.dispose()
                            } catch {}
                        }
                        ), 0)
                    }
                    ))
                }
                ))
            }
              , q = a => {
                o.trigger((async () => {
                    I.pS();
                    try {
                        const {default: e} = await i.e(142).then(i.bind(i, 5142));
                        J.dispose(),
                        J = new e(l,h,S,x,w,d,t,a,( () => {
                            _(!1, null)
                        }
                        )),
                        I.PM(),
                        I.tU()
                    } catch (i) {
                        console.error("Failed to load verifier state: ", i),
                        J.dispose(),
                        J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,!1,null,C,R,V,K,q,Q),
                        I.PM()
                    }
                }
                ))
            }
              , Q = a => {
                o.trigger((async () => {
                    I.pS();
                    try {
                        const {default: e} = await i.e(982).then(i.bind(i, 9982));
                        J.dispose(),
                        J = new e(l,h,k,w,S,a,( () => {
                            _(!1, null)
                        }
                        )),
                        I.PM(),
                        I.tU()
                    } catch (i) {
                        console.error("Failed to load admin state: ", i),
                        J.dispose(),
                        J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,!1,null,C,R,V,K,q,Q),
                        I.PM()
                    }
                }
                ))
            }
            ;
            let J = new Eh(p,y,v,A,w,b,k,x,E,h,l,e,n,r,S,t,!1,null,C,R,V,K,q,Q)
              , X = 0;
            h.setAnimationLoop((function(e) {
                const t = Math.max(e - X, 0) / 1e3;
                X = e,
                J.update(t),
                T.update(t)
            }
            )),
            window.addEventListener("keyup", (e => {
                r.checkKeyBinding(e, me.A.ToggleFpsCounter) && T.toggle()
            }
            ))
        }()
    }
    )()
}
)();
